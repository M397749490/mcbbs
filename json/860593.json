{
    "title": "[Bone Studio] 简单算法入门教程 #2-2",
    "author": "107874017",
    "replyCount": 0,
    "timestamp": 1556334480,
    "txt_content": "\n更好的阅读体验\n### 0x14 并查集\n\n并查集可以让我们比较方便的维护集合的信息\n\n[并查集](<https://www.luogu.org/problemnew/show/P3367>)\n\n给出n个元素和m次操作 每次操作可以\n\n- 将两个元素所在的集合合并\n- 查询两个元素是否在一个集合内\n\n$n\\le10^4,M\\le2\\times10^5$\n\n\n\n不妨写出来一个暴力\n\n```cpp\nint col[maxn];\nint main(){\n    int n,m;cin>>n>>m;\n    for(int i=1;i<=n;i++)col[i]=i;\n    while(m--){\n        int op,x,y;cin>>op>>x>>y;\n        if(op == 1){\n            if(col[x] == col[y])continue;\n            int tmp = col[x];\n            for(int i=1;i<=n;i++)\n                if(col[i] == tmp)col[i] = col[y];\n        }else{\n            cout<<(col[x] == col[y]?\"Y\":\"N\")<<endl;\n        }\n    }\n}\n```\n\n大概思路就是选出一个元素作为集合的代表元素 并用这个元素给这个集合中的所有元素染色\n\n查询的时候直接去考虑颜色是否相同就可以了\n\n但是这么做的复杂度高达$O(nm)$ 所以我们需要一个比较优秀的做法\n\n\n\n我们实际上可以直接对每个集合建出来一棵树 这个树中所有节点就是属于这个集合的元素\n\n于是我们的代表元素就是树的根\n\n合并的时候找到一棵树的根 然后直接扔到另一棵树上作为它的儿子就好了\n\n\n\n但是这么做的复杂度不对 **情况下这棵树会退化成链 查询代表元素的根的复杂度就会达到$O(n)$\n\n所以我们有两种优化：\n\n- 路径压缩\n\n我们发现实际上这棵树的形态对我们要维护的信息没有任何影响\n\n那么我们可以直接把一个集合中的所有元素的父亲设为代表元素 这样在查询的时候就可以十分快速的得到根节点\n\n如果某个节点的父亲不是代表元素 那么我们可以直接把这个节点到代表元素的链上的所有节点的父亲设为代表节点\n\n```cpp\nint fa[maxn];//节点的父亲\nint findfa(int x){//虽然说写着是找父亲 但是找的实际上是代表元素\n    if(x == fa[x])return x;//当x=fa[x]时 说明x是代表元素\n    int tmpfa = findfa(fa[x]);\n    fa[x] = tmpfa;\n    return tmpfa;\n}\nint findfa(int x){\n    return x==fa[x]?x:fa[x]=findfa(fa[x]);//或者你使用一些技巧写成这样的一行\n}\n```\n\n- 按秩合并\n\n秩可以有很多种定义方式 在这里比较通用的定义是子树的大小 当然你也可以定义为树的深度\n\n我们发现实际上只需要在合并的时候将秩比较小树合并到秩比较小的树上就行了\n\n```cpp\nint siz[maxn];//秩\nvoid merge(int a,int b){\n    a = findfa(a),b = findfa(b);\n    if(siz[a] < siz[b]){\n        fa[a] = b;siz[b] += siz[a];\n    }else{\n        fa[b] = a;siz[a] += siz[b];\n    }\n}\n```\n\n\n\n这两种优化任何一种都可以让并查集的复杂度降低到$O(logn)$\n\n但如果你将两个一起使用可以把复杂度降低到$O(\\alpha n)$ 这里的$\\alpha$是反阿克曼函数 增长极慢\n\n### 0x14 简单平衡树\n\n平衡树是一种比较优雅的树\n\n前置知识：堆 线段树\n\n[【模板】普通平衡树](<https://www.luogu.org/problemnew/show/P3369>)\n\n题目大意：\n\n你需要支持六种操作\n\n1. 向可重集中插入一个元素x\n2. 删除集合中的一个元素x（如果有多个x 只删除一个）\n3. 查询元素x在集合中的排名\n4. 查询排名为x的数\n5. 求在集合中小于x并且最大的数\n6. 求在集合中大于x并且最小的数\n\n\n\n接下来我们会分几种不同的做法来讲\n\n#### 0x15 BST\n\nBST的中文名叫做二叉查找树（Binary Search Tree）\n\n它满足对于任意一个节点 其左儿子的权值大于本身 本身的权值大于右儿子\n\n很显然假如我们按先序遍历输出树的权值 得到的数组是从小到大有序的\n\nBST的实现在这里不再讲解 因为BST在最劣情况下（插入的数有序）构造出来的树会退化为链\n(也即每个节点只有一个儿子，构成一条链，失去树的存在意义)\n\n在链上的时间复杂度可以达到$O(n)?$ 是一种不太优美的算法\n\n当然 也不能通过本题\n\n#### 0x16 Treap\n\nTreap是所有平衡树实现中最简单 常数也比较小的一种做法\n\n我们发现BST很容易不平衡（左右儿子大小相差较大） 但是BST具有很多优美的性质\n\n所以Treap给每个节点一个随机权值$rnd$\n\n对于每个点的权值 它们构成一颗BST\n\n对于每个点的随机权值 它们构成一个**堆**（这里默认为小根堆）\n\n同时$rnd$ 是随机生成的 于是这棵树的深度会近似于$logn$ 可以说是很平衡的\n\n之后需要进行操作的时候就可以直接按照bst来操作\n\n\n\n且慢 我们怎么把随机权值维护成一个堆？\n\n我们首先定义旋转操作\n\n旋转分为两种 左旋与右旋\n\n左旋可以把一个节点变到它右儿子的位置\n\n右旋可以把一个节点变到它左儿子的位置\n\n同时左右旋都不会改变BST的性质\n\n在插入一个节点的时候 我们先把他放到某个叶子结点的后面 然后再把他不断通过旋转操作放到合适的位置\n\n删除时 \n\n如果这个节点是叶子节点 直接删除\n\n如果这个节点不是叶子结点 选择其左右儿子中随机权值比较小的旋转上来\n\n直到这个节点是叶子结点为止\n\n~~剩下的所有操作乱搞一下就好了x~~剩下的操作还是要说一下的\n\n- 查找排名\n\n这个就比较简单了 从根开始递归左儿子或者右儿子寻找这个值\n\n递归左儿子还是递归右儿子由当前节点的权值与查找的数的大小有关\n\n然后统计一下答案就可以了\n\n- 查找排名为k的数\n\n这个把查找排名倒过来就行了x\n\n假如左儿子的大小大于等于k 那就去左儿子找 不然去右儿子找\n\n- 前驱后继\n\n仅以找前驱为例 后继是相似的\n\n对于当前节点 假如它的权值小于我们要找前驱的数的权值 那么我们就可以考虑到答案应该在当前节点和它的右儿子当中\n\n假如它的权值大于要找前驱的数的权值 那么就说明答案在当前节点的左儿子中\n\n递归寻找并处理即可\n\n\n\n由于这棵树的**随机**权值满足堆的性质 其深度在$logn$左右 而绝大多数操作都与树的深度有关\n\n于是Treap维护这道题的复杂度是$O(nlogn)$\n\n#### 0x17 FHQ-Treap\n\nFHQ是范浩强的缩写\n\n这种平衡树有很多种叫法\n\n非选treap 可持久化treap之类的 不过本质上是一样的\n\n\n\n我们同样还是考虑一颗treap \n\n我们发现旋转实际上是一个十分麻烦的操作\n\n但是假如我们可以支持把一棵树拆开以及合并两棵树这两种操作\n\n支持那六种操作的难度就会低很多\n\n所以我们可以考虑fhq-treap 以下简称fhq\n\n\n\nfhq支持两种操作 split以及merge\n\nsplit又分为两种 按值分裂以及按排名分裂 这里只讲第二种\n\n按排名分裂的split可以将一颗树分成两棵树 并保证第一棵树的大小为k 还保证分裂后的两棵树都是Treap\n\n![graph (1).png](https://i.loli.net/2019/04/27/5cc3a6bcebee0.png)\n\n对于这颗树 假如我们要把它分成一颗大小为5的树和另一棵树\n\n那么很显然我们会分成这样\n\n![Snipaste_2019-04-27_08-50-18.png](https://i.loli.net/2019/04/27/5cc3a7573c543.png)\n\n\n\n我们来简单yy一个分裂的过程\n\n这里我们定义分裂后的两颗树分别叫做树1和树2\n\n同时定义每个节点的大小为以这个节点为根的数的节点数\n\n- 对于当前节点 假如它是叶子 那么此时k只能为0或1 按照规则把当前节点分入树1或树2\n- 对于当前节点 如果它不是叶子结点 那么此时考虑它的左儿子的大小\n  - 假如它的左儿子的大小大于等于k 那么就说明当前节点在树2中 于是我们把左儿子按照排名为k分裂 之后将当前节点的左儿子设置为树2的根 再令当前节点作为树2的根节点\n  - 假如它的左儿子的大小小于k 那么就说明当前节点在树1中 于是我们把右儿子按照排名为$k-leftSize()-1$(令leftsize()表示当前节点的左儿子大小)分裂 之后将当前节点的右儿子设为树1的根 再令当前节点为树1的根\n    - 仔细想想 为什么是$k-leftsize()-1$？\n- 我们发现实际上并不需要单独讨论叶子结点 因为假如我们在分裂空节点时返回两颗空的树 那么按照上面这个过程叶子结点也会被划分到正确的树中\n\n于是按照Treap的定义和fhq的分裂过程 我们先写出节点的定义\n\n```cpp\nstruct Node;         \ntypedef Node* ptr_t;//ptr_t是一个类型 这个类型是Node的指针\nstruct Node{\n    ptr_t lson;\n    ptr_t rson;\n    int size,val,rnd;\n    Node(int w){\n        val = w;rnd = rand();size = 1;\n        lson = rson = nullptr;//nullptr表示空指针\n    }\n    int leftSize(){\n        if(lson != nullptr)\n            return lson -> size;//-> 可以访问一个指针对应的元素中的变量\n        return 0;//这里需要先判断一下左儿子是不是空 不然会访问空指针\n    }\n    void maintain(){//在lson和rson变动后 我们需要更新当前节点的大小\n        size = 1;\n        if(lson != nullptr)size += lson -> size;\n        if(rson != nullptr)size += rson -> size;\n    }\n};//现在我们需要假设读者能看懂一部分C++代码了。\n```\n\n之后我们可以十分简单的写出分裂的代码\n\n```cpp\ntypedef pair<ptr_t,ptr_t> pair_t;\n//pair_t中包含了两个元素first second 类型都为ptr_t\n//在这里first表示树1 second表示树2\npair_t split(ptr_t rt,int k){//将当前节点(rt) 按排名(k)分裂\n    if(rt == nullptr)return pair_t(nullptr,nullptr);//假如当前节点为空\n    if(rt -> leftSize() >= k){//-> 也可以访问指针对应的元素的函数\n        pair_t tmpAns = split(rt -> lson,k);\n        rt -> lson = tmpAns.second;\n        rt -> maintain();\n        return pair_t(tmpAns.first,rt);\n    }else{\n        pair_t tmpAns = split(rt -> rson,k - rt -> leftSize() - 1);\n        rt -> rson = tmpAns.first;\n        rt -> maintain();\n        return pair_t(rt,tmpAns.second);\n    }\n}\n```\n\n\n\n那么 现在我们写完了分裂 只剩合并需要我们去考虑了\n\n我们发现合并的时候要同时满足BST和堆这两个性质\n\n那么我们首先删掉一个需要维护的性质 \n\n经过深思熟虑 你决定不在合并的时候维护BST\n\n这就导致我们在合并的时候需要满足树1的所有节点的权值都需要小于树2任何一个节点的权值\n\n我们从一个简单的情况入手\n\n假如需要合并的两颗树是树1和树2 其中有一棵是空的\n\n那么 很显然的 答案就是非空的那棵树\n\n之后我们可以讨论讨论比较复杂的情况\n\n比如对于这张图\n\n![img](http://luogu-ipic.oss-cn-shanghai.aliyuncs.com/isd5z.bmp)\n\n对于正在合并的两棵树\n\n我们判断一下两棵树的根的随机权值大小 然后分情况讨论\n\n- 树1的根的随机权值 小于 树2的根的随机权值\n\n这时候为了满足堆的性质 我们应当让树2作为树1的儿子\n\n然后为了满足BST的性质 我们要让树2作为树1的右儿子\n\n。。 那么树1原本的右儿子怎么办呢？\n\n这好办 把树1的右儿子和树2合并以后的新树作为树1的右儿子就好了\n\n- 树2的根的随机权值 大于等于 树2的根的随机权值\n\n和上面那种情况类似 但是这里需要让树1作为树2的儿子\n\n合并的是树1和树2的左儿子\n\n\n\n当你想要写这个函数的时候 你一定要特别注意树1和树2需要满足**树1的所有节点的权值都需要小于树2任何一个节点的权值**\n\n```cpp\nptr_t merge(ptr_t a,ptr_t b){//a b是两棵要合并的子树\n    if(a -> rnd < b -> rnd){\n        a -> rson = merge(a -> rson,b);\n        a -> maintain();\n        return a;\n    }else{\n        b -> lson = merge(a,b -> lson);\n        b -> maintain();\n        return b;\n    }\n}\n```\n\n\n\n之后我们来考虑怎么用split和merge来维护这道题的六种操作\n\n- 插入一个数\n\n在平衡树中找到当前数的排名k 之后将树分成两棵子树 第一棵的大小为k-1\n\n之后合并树1与当前插入的数的节点 再把这棵合并出来的树与树2合并\n\n```cpp\nvoid insert(int w){\n    int k = getRnk(root,w);//getRnk即查找排名的函数 这里返回的是排名-1\n    pair_t tmp = split(root,k);//root是整颗树的根\n    root = merge(tmp.first,merge(new Node(w),tmp.second));\n}\n```\n\n- 删除一个数\n\n在平衡树中找到当前数的排名k 之后将树分成三棵子树 前两棵的大小分别为k-1和1\n\n之后直接合并树1和树3就好了 如果你愿意 也可以把树2的内存释放掉\n\n```cpp\nvoid del(int w){\n    int k = getRnk(root,w);\n    pair_t tmp = split(root,k);\n    pair_t ttp = split(tmp.second,1);\n    root = merge(tmp.first,ttp.second);\n}\n```\n\n- 查找一个数的排名\n\n从根开始向左右儿子递归 顺便计算答案\n\n```cpp\nint_t getRnk(ptr_t rt,int w){\n    if(!rt)return 0;//当前节点为空时不再递归\n    if(rt -> w >= w)return getRnk(rt->lson,w);\n    return getRnk(rt->rson,w) + rt -> leftSize() + 1;\n    //当查询节点在当前节点的右儿子时 这个节点的在树中的排名还要加上当前节点的左儿子大小以及当前节点\n}\n```\n\n- 查找排名为k的数\n\n直接把树拆成k-1 1 xxx三棵树就好了 答案就是第二棵树的值\n\n当然你也可以像我一样把树拆成大小为k和xxx的两棵树 然后在树1中找最大值\n\n```cpp\nint getVal(int k){\n    pair_t tmp = split(root,k);\n    int ans = findMax(tmp.first);\n    root = merge(tmp.first,tmp.second);\n    return ans;\n}\n```\n\n- 找前驱后继\n\n仅以前驱举例\n\n首先拿到这个数的排名k 然后把树拆成两棵树k-1和xxx\n\n那么很明显的 树1中的最大值就是前驱\n\n```cpp\nint getPre(int x){\n    pair_t tmp = split(root,getRnk(root,x));\n    int ans = findMax(tmp.first);\n    root = merge(tmp.first,tmp.second);\n    return ans;\n}\n```\n\n- 最大最小值\n\n你可能会想着把整棵树都遍历一遍\n\n但是并不需要这么麻烦 \n\n查询最大值只需要一直顺着右儿子走就行了\n\n最小值同理\n\n```cpp\nint findMax(ptr_t rt){\n    while(rt -> rson)rt = rt -> rson;\n    return rt -> w;\n}\n```\n\n\n\n它的复杂度和treap的复杂度的分析方式是一样的 于是它的复杂度也是$O(nlogn)$\n\n但你需要特别注意的是 它的常数会比treap大那么一丢丢\n\n不过它比treap好写好用\n\n而且 fhq是唯一一个支持可持久化的平衡树\n\n#### 0x18 Splay\n\n是不是不想维护堆的性质了？\n\n那么splay可以满足你的需要\n\n我们发现bst不平衡的时候整棵树与链十分的像\n\n那么我们是不是可以在旋转的时候破坏掉链 把链变成树？\n\n于是就有了splay\n\nsplay的主要操作依然是旋转\n\nsplay的旋转不同于treap的只有两种方式\n\n它的旋转一共有四种情况 这被称为**双旋**\n\n在这里需要说一句 **单旋**splay是一个**假**算法 其复杂度不对\n\n\n\n我们先举一个例子        \n\n![img](https://inf.tiger0132.tk/2018/07/19/splay-notes/src.svg)\n\n假设现在我们要把2这个节点向上旋转 那么我们发现\n\n首先让6的左儿子变成2\n\n然后令4作为2的右儿子\n\n2之前的右儿子在作为4的左儿子\n\n它就像这样\n\n![img](https://inf.tiger0132.tk/2018/07/19/splay-notes/dest.svg)\n\n然后根据父节点对于爷爷节点的位置以及当前节点对于父节点的位置 一共可以搞出来四种旋转\n\n于是你用手模拟了一遍这个过程 发现旋转有以下规律：\n\n- 令k表示当前节点是父节点的左儿子还是右儿子 左儿子则$k=0$ 否则为1\n- 爷爷节点连向父节点的边会删掉 然后连向当前节点\n- 父节点将作为该节点的$(k\\text^1)$这个儿子（$k=0$时即右儿子 反之则是左儿子）\n- 该节点原本的$(k\\text^1)$这个儿子会作为父节点的k这个儿子（$k=0$则是左儿子）\n\n你发现这并不是很容易看懂 于是你可以看这段代码\n\n```cpp\nvoid rotate(int x){//这里不再写指针 而是用节点的标号来表示这个节点\n    int y = fa[x],z = fa[y],k = check(x),w = son[x][k^1];\n    //y是父节点 z是爷爷节点 k即上文的k w即x的k^1这个儿子\n    //fa数组表示节点的父亲\n    son[z][check(y)] = x; fa[x] = z;\n    son[x][k^1] = y;fa[y] = x;\n    son[y][k] = w;fa[w] = y;\n}\n```\n\n之后我们需要考虑一个问题 假如我们要把一个节点旋转到它的某个祖先 我们该怎么旋转？\n\n一直旋转它本身直到正确的位置？ 但是这依然是一个假做法\n\n你需要在旋转的过程中考虑到一个“它 它父亲 它爷爷”三点一线的问题\n\n也就是说$check(x)=check(fa[x])$\n\n这时候你要先旋转它的父亲\n\n\n\n这个操作被称为伸展 英文即$splay$\n\n事实上这个操作是splay最重要的操作\n\n具体来说 它可以把一个节点旋转到另一个节点的儿子的位置\n\n代码如下\n\n```cpp\nvoid splay(int rt,int goal=0){//goal为目标节点\n    while(fa[rt] != goal){//当前节点的父亲不是目标节点\n        int y = fa[rt],z = fa[y];\n        if(z != goal){// 如果爷爷节点是目标节点 旋转两次后rt就到了目标节点的位置 所以要判断一下\n                       if(check(rt)==check(y))rotate(y);//处理三点一线\n            else rotate(rt);\n        }\n        rotate(rt);\n    }\n    if(!goal)root=rt;//如果goal是0 则说明把rt旋转到根\n}\n```\n\n然后你就可以开始维护那六个操作了\n\n- 插入\n\n按照bst的方式插入 由于插入后平衡树可能不平衡 所以将新节点splay到根\n\n- 删除\n\n我们把比x小的那个数splay到根\n\n比x大的的那个数splay到根的儿子\n\n这样一来 根的右儿子的左儿子就是x了 直接删除\n\n具体原理可以自己简单yy一下\n\n- 查询排名\n\n在平衡树上找到最大的比x小的节点 splay到根\n\n然后简单计算一下左子树的大小就行了\n\n- 查询排名为k的数\n\n从根节点开始向下考虑 向左儿子递归时查询排名为k 向右儿子递归时查询$k-leftSize()-1$\n\n- 前驱后继\n\n把这个节点splay到根 然后在左子树右子树中找最大最小值\n\n\n\n本篇大部分代码出自Tiger0132的[splay教程](<https://tiger0132.blog.luogu.org/slay-notes>) 略有改动\n\n\n\n值得一提的是 只有splay可以维护LCT\n\n\n\n#### 0x19 平衡树练习题\n\n想不到吧 还有练习题\n\n[文艺平衡树](<https://www.luogu.org/problemnew/show/P3391>)\n\n题目大意：\n\n维护一个数列$1,2\\dots n$ 支持一种操作：\n\n- 将区间翻转 即$1,2,3,4]$翻转后即是$[4,3,2,1]$\n\n所有操作结束后求这个数列\n\n$n,m\\leq10^5$\n\n\n\n第一眼线段树对吧\n\n然后你发现线段树似乎十分难以维护区间翻转这种毒瘤一样的操作\n\n所以我们考虑一下平衡树\n\n但是区间可能是无序的 我们怎么维护bst？\n\n这好办 bst维护区间的序号就好了\n\n平衡树上翻转一个区间实际上就是把代表了这个区间的数中所有左右儿子对调\n\n比如说\n\n![Snipaste_2019-04-27_10-17-21.png](https://i.loli.net/2019/04/27/5cc3bbbd219a0.png)\n\n\n\n我们模拟一下新树的序号就可以发现\n$\n5'\\to1\\\\\n3'\\to3\\\\\n4'\\to2\\\\\n1'\\to5\\\\\n2'\\to4\n$\n翻转过来了对不对？\n\n所以我们只要在操作的时候\n\n先将$l-1$这个节点splay到根 然后再将$r+1$这个节点splay到根的右儿子\n\n那么之后直接按照上面说的方式操作根的右儿子的左儿子这棵树就好了\n\n\n\n然后你满怀希望的写了一发并且交上去 发现你超时了\n\n仔细分析一下复杂度 我们会发现一次修改的复杂度可能会达到$O(n)$\n\n这是我们所不能接受的 于是我们可以在给区间翻转时 对节点打上标记\n\n当我们需要更新一个节点的儿子的时候 把这个标记下传\n\n然后你就得到了一个复杂度比较优秀的$O(mlogn)$做法\n\n\n\n如果你不想写splay 那么你也可以用fhq来做这个过程 只需要把$[l,r]$这棵树按照相同的方法分出来就行了\n\n\n\n[维护数列](<https://www.luogu.org/problemnew/show/P2042>)\n\n题目大意：\n\n维护六种操作\n\n![img](https://cdn.luogu.org/upload/pic/1114.png)\n\n$M\\le20000,maxN\\le4000000$ 其中$maxN$指任意时刻数列中的元素个数\n\n\n\n首先 确保你已经读懂了题意 并且熟练掌握了线段树的标记\n\n然后我们来用fhq做这个题 因为fhq做这个比较方便\n\n\n\n我们发现一共有两种询问 第一是求和 第二是求最大子段和\n\n在这里不提最大子段和如何维护 如果有兴趣可以自己参考网上的博客\n\n所以我们需要维护的信息有\n\n- 这棵子树的和\n- 这棵子树的最大子段和\n  - 这棵子树的从左边开始的最大和\n  - 这棵子树的从右边开始的最大和\n  - 上面这两个是为了维护最大子段和\n\n然后我们发现有四种操作 插入和删除都很模板 来考虑修改与翻转\n\n那么我们需要维护两个标记 一是修改二是翻转\n\n记得在标记下传和打标记的时候把上面维护的信息也正确的修改掉\n\n（虽然说起来简单但是做起来极其恶心）\n\n\n\n然后你内存爆掉了\n\n你发现虽然数的个数并不太多 但是你可能会创建出大量的节点\n\n所以你还需要写一个内存池 或者使用指针写法在删除一棵树的时候递归删除释放内存\n\n\n\n当你写完这道题以后 我相信你的平衡树水平会得到**极大**的升华\n\n\n\n### 0x1A 简单可持久化数据结构\n\n这里不会讲可持久化平衡树 首先是我不会\n\n其次是 在实际开发中真的有必要写可持久化平衡树吗。。？\n\n所以这里只讲可持久化线段树\n\n前置知识： 线段树\n\n\n\n可持久化是一类特殊的操作\n\n其一般格式为\n\n- 修改某个历史版本上的信息并生成一个新的版本\n- 查询某个历史版本上的信息\n\n\n\n[可持久化数组](<https://www.luogu.org/problemnew/show/P3919>)\n\n你需要维护一个数组 需要支持\n\n- 修改某个历史版本上某位置的值\n- 查询某个历史版本上某位置的值\n\n\n\n$n,m\\le10^6?$\n\n\n\n首先 我们当然知道可以每次修改都开一个新的数组来保存这个版本的信息\n\n那么你查询的复杂度就是$O(1)$的了\n\n但是修改的复杂度是$O(n)$的 但是即使你通过某种手段将查询优化到$O(1)$\n\n你会发现空间不允许 因为你的空间复杂度是$O(nm)$的\n\n于是你想到了把数组存到文件里这个鬼点子\n\n但是这样做更慢。。。\n\n\n\n我们来思考一下为什么会有这么大的空间复杂度\n\n每次修改实际上只修改了一个位置 但是我们却不得不维护一些无用的信息 （其他位置的值）\n\n那么假如我们把这些信息和其他历史版本合并的话 是不是复杂度就会比较优秀？\n\n但是这不太好实现\n\n但是！ 如果你把眼光放得更开阔一点 你就会想到可以用线段树来维护这个数组\n\n这样的话每次修改只需要修改$logn$个节点 剩下的用原来有的就可以了\n\n所以就有了可持久化线段树\n\n![??\"???? ?2](https://cdn.luogu.org/upload/pic/46147.png)\n\n图源于洛谷某题解\n\n\n\n只要我们这么把树建出来 就可以很舒服的维护可持久化的信息了\n\n具体来讲\n\n每次修改时将所有线段树上维护的信息发生变动（左右儿子也算信息）时 建立一个新的节点为它的拷贝 然后在这个新节点上继续递归修改\n\n是不是十分简单。。。\n\n而且代码也十分短。。\n\n\n\n但是这东西有一个十分强大的应用\n\n叫做**树\n\n**树一般全称是可持久化权值线段树 但也有时候会直接指可持久化线段树\n\n假如对于一个数列中的每个数$A_i$ 我在$i$这个版本把位置为$A_i$的值加上1\n\n那么当我需要知道前$k$个数中$x$出现了几次时 就可以直接去查询$k$这个版本的$x$的值\n\n对$A_i$的值$+1$的这种特殊方法构造出来的线段树叫做权值线段树\n\n当它套上可持久化后 就被称为可持久化权值线段树 \n\n它实际上有一个十分优美的性质 当我们查询$[l,r]$中某个数的出现次数时 对$[l,r]$建出来的权值线段树实际上就是可持久化权值线段树上$r$版本的线段树和$l-1$版本的线段树的差\n\n因为这个性质是某个叫做hjt（重名）的竞赛选手提出的 所以这种算法就有了一个叫**树的名字\n\n它可以用来干什么？\n\n[**树](<https://www.luogu.org/problemnew/show/P3834>)\n\n给定数列 每次查询区间中第$K$大的数\n\n$n,m\\leq2\\times10^5$\n\n\n\n首先 $a_i$的范围比较大 我们可以通过“离散化”的技巧把它压到$n$的范围内\n\n然后对数列建一颗**树\n\n然后**树中每个节点维护这个区间的和\n\n那么当我们在区间中寻找第$K$大的时候 只需要在这个区间对应的权值线段树内像平衡树那样递归寻找就可以了\n\n代码也不长x\n\n\n\n**树实际上还有很多很难的算法\n\n比如树状数组套**树 不过这里也不讲。。 \n\n但是有一道比较有意思的可持久化线段树的题目在这里扔一下\n\n[可持久化并查集](<https://www.luogu.org/problemnew/show/P3402>)\n\n给定n个集合 三种操作\n\n- 合并两个集合\n- 回到某个版本\n- 查询两个数是否属于同一个集合\n\n$n\\le10^5,m\\le2\\times10^5$\n\n\n\n很显然我们要用可持久化来做\n\n但是你想了想发现并查集本身并不好可持久化\n\n但是并查集只需要数组就可以维护 而你又会写可持久化数组\n\n所以你选择了使用可持久化数组来实现可持久化并查集\n\n需要注意的是 这里你**只能**写按秩合并 路径压缩在这里会导致线段树上大量点的值被修改\n\n\n\n数据结构到这里就差不多结束了。。。QAQ复制代码\n\n\n\n#2-2.zip\n(10.05 KB, 下载次数: 0)\n\n\n\n2019-4-27 11:04 上传\n点击文件名下载附件\n\n\n\n\n\n\n",
    "replies": []
}