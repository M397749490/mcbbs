{
    "title": "PVPIN教程RL--使用BukkitRunnable的异步，做一个地雷",
    "author": "William_Shi",
    "replyCount": 5,
    "timestamp": 1589206980,
    "txt_content": " 本帖最后由 William_Shi 于 2020-5-12 09:41 编辑 \n\n本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\n本教程涵盖内容：\nBukkitRunnable的异步操作实例\n（本教程涉及大量函数式编程，并且看过此贴讲解之后，可能还是不一定能够理清逻辑，所以还是建议去看一下我在coding开源的代码）\n\n介绍本节实例：\n我们需要做一个地雷，它的坐标被通过某种方式记录，当玩家走近时会爆炸（创意来自PVPIN）\n\n先来学BukkitRunnable的异步操作\n\n            new BukkitRunnable() {\n                @Override\n                public void run() {\n//xxx\n                }\n            }.runTaskAsynchronously(plugin);\n复制代码\n这样就可以把任务从主线程移到Craft Scheduler Thread来执行\n具体的任务调度、线程分配，会由Bukkit来完成，更需要关心的是线程安全问题\n\n首先为了做到本节实例功能我们必须有一个对象储存世界里的地雷都被放在哪里\n这里我并不会介绍数据库/I、O读取写入，只是将这些位置全部放在内存里，并没有实现持久化，请各位读者自行实现持久化\n\n为了能够记录地雷被放下，我们需要一个BlockPlaceEvent的监听\n为了能够探测到玩家踩上地雷，我们需要一个PlayerMoveEvent的监听\n当然这里的PlayerMoveEvent也是可选的，你可以使用一个BukkitRunnable，每较短时间执行一次，遍历玩家的位置并检测是不是踩到了地雷\n在PlayerMoveEvent时传入getTo（玩家将要移动到的地方），然后判断这个位置是不是在地雷的触发区域内，如果是，爆炸\n在BlockPlaceEvent时记录好地雷的坐标\n\n那么读到这里，你肯定想到了一件事：效率问题\n是的，的确，就算是你不监听Move，而是比如每10tick遍历一次玩家列表取玩家的位置，那么至少也需要对存储的位置进行遍历，以此确定玩家有没有踩到地雷，那么如何增加效率呢？\n我的答案是：高并发、地雷位置分段存储、加锁，去掉world、只记录数字坐标\n也就是全程使用Async的BukkitRunnable完成所有操作\n\n那么问题来了，如果去掉world提高效率，会不会出现玩家走着走着就莫名踩到了其他世界的坐标相同的地雷呢？\n所以我们应该另外自己写一个对象，这个对象应当记录世界的名字，以及这个世界内所有的地雷的位置，每一个世界都应当对应一个这样的对象，后文我叫它WorldVecStore对象\n这样做就可以避免存储的时候对于每个位置对象，都重复存储一遍其所在世界了\n接下来就是最重要的位置存储了\n因为已经去掉了所有的world，而且在这里yaw、pitch这些决定朝向的量显然不参与计算\n因此我选择使用Vector，向量，来进行存储\n那么使用向量时就有一个很好用的方法，isInAABB，判断某个点是不是在一个长方体内\n这里读者要先理解，确定长方体的两个斜对角的顶点（抱歉，本人刚学数列极限未学到立体几何，名词肯定不够专业）就可以确定一个长方体\n当然这里使用自己创建的BoundingBox也是可以的\n\n那么我们知道地雷是一个方块，查阅wiki可知方块坐标本质上是方块西北下角\n（也就是方块坐标x、y、z各自加上1，可以得到方块的对角）\n地雷的有效范围显然不可以只是这1x1x1的长方体，否则玩家踩上去也不会触发（除非地雷是没有碰撞箱的方块）\n那么就应当给地雷的有效范围在地雷方块1x1x1的基础之上，扩大一圈\n\n这里我推荐预先把两个顶点坐标计算好存起来，因为地雷坐标的读取肯定比写入删除次数多得多，\n如果每次读取的时候都根据西北下角坐标重新计算碰撞箱将会出现极大性能浪费\n那么接下来应该怎么才能实现分段存储呢？\n众所周知，ConcurrentHashMap是通过分段加锁的方式去实现性能，那么我们也应当利用这一点将X、Z除以16向下取整，得到区块的X、Z坐标，这样每一个区块的地雷数据都分开存储，契合segment加锁\n那么我们就可以设计出这样的存储模块：\n使用一个WorldList，保存所有WorldVecStore对象\n每一个WorldVecStore都有一个worldName属性，记录这个对象存的所有向量的世界名\n并且还有一个map，键为区块坐标，值为这个区块所有的地雷的作用区域的列表\n每一个地雷的作用区域都是一个列表，分别存了min坐标向量和max坐标向量（长方体顶点），当然使用BoundingBox对象会更直观\n为了保证高并行线程安全性，所有的涉及到更改的list全部使用CopyOnWriteArrayList，所有的Map全部使用concurrentHashMap\n整个逻辑理顺之后，不难写出以下代码\n\n主类注册2个事件监听\n\n\n\n\nmain.png (20.85 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:19 上传\n\n\n\n\n\n\n监听玩家移动，使用自写的WorldList来判断玩家是不是触发地雷，如果是，调用createBoom方法\n\n\n\n\nmove.png (42.54 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:20 上传\n\n\n\n\n\n\n监听方块放置，如果是海绵（这里简化了），使用WorldList将其坐标存起来\n\n\n\n\nplace.png (38.07 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:21 上传\n\n\n\n\n\n\n接下来就是WorldList这个类的实现\nWorldList本质上其实是使用了List存储WorldVecStore对象，所以这个类要做的，只有根据世界名筛选对应的WorldVecStore，并且把坐标放进这个对象\n首先建立一个列表，并且把所有当前加载的世界全部新建WorldVecStore对象\n\n\n\n\nlist初始化.png (10.88 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:23 上传\n\n\n\n\n\n\n接下来，使用一个方法，判断当前有没有某个world对应的WorldVecStore对象被储存\n\n\n\n\n筛选world.png (7.01 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:25 上传\n\n\n\n\n\n\n接下来，如果需要增加一个坐标，那么就查找对应的世界WorldVecStore是否存在，如果不存在则新建，之后找到这个WorldVecStore，调用addVec方法\n\n\n\n\nworld add.png (15.37 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:27 上传\n\n\n\n\n\n\n接下来就是查找某一个WorldVecStore对象有没有包含某个坐标\n这里我的做法还是调用WorldVecStore的方法\n\n\n\n\nWorld contain.png (17.58 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:29 上传\n\n\n\n\n\n\n那么最关键的WorldVecStore是如何实现的？\n首先每个WorldVecStore肯定得有一个世界名的属性，然后还有一个Map来存储所有的坐标，这个map应当是以区块的xz作为键实现分段\n其值就是一个List，这个List储存所有的地雷作用区域，每一个区域都是一个子列表\n\n\n\n\nVec1.png (29.65 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 20:58 上传\n\n\n\n\n\n\n之后就是某个坐标是不是处于地雷作用区域的判断\n这也非常简单了，就是isInAABB方法\n\n\n\n\nct1.png (30.09 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 21:34 上传\n\n\n\n\n\n\n接下来是某个方块是不是作为地雷被记录\n需要注意，这里不能直接套用刚刚的方法，因为我们的地雷的作用范围比1x1x1大了一圈\n换句话说如果一堆地雷靠在一起，如果还按刚刚的那个做**出现，明明是不同方块但是 却被判定为包含在作用范围内，从而不被记录为一个新的地雷的情况\n那么我给出的做法就是重新将这个坐标计算成一个作用范围\n然后作用范围的min和已有的储存的min比较得到两个向量之间的距离，作用范围的max和储存的max比较得到两个向量之间的距离\n如果这两个distance都非常小（记住：double、float都是浮点数，计算机使用二进制无法完全精确表示，必定存在极小的误差，那么其distance就不一定是0，同时又有一个很重要的思想：double、float的比较，应当是两数相减，绝对值小于一个很小的数（比如0.0000001），而不是 == 0 的判断）\n那么就将其判定为是同一个方块\n\n\n\n\nct2.png (43.35 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 21:50 上传\n\n\n\n\n\n\n最后就是add的环节，也非常简单，就是存储aabb两点\n\n\n\n\nadd1.png (44.37 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 21:51 上传\n\n\n\n\n\n\n那么效果就是这样的\n\n\n\n\nmc.png (202.93 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-11 22:09 上传\n\n\n\n\n\n\n思考问题：\n1.我已经写了delVec的轮子，该怎么写拆雷？（难度※）\n这个问题很简单，无非就是设计一个工具，然后再模拟地雷掉落以及delVec\n2.如果想要实现地雷坐标的持久化，该怎么做？（难度※）\n这个也很简单，毕竟Vector就是x、y、z三个double，其他的map、list等也很方便存\n3.如果要做地雷埋下一段时间之后，做好了准备才能起爆，该怎么写？（难度※※）\n这个稍显难度，最简单的做法就是每个WorldVecStore里放上两个map，一个储存准备中的，一个储存准备好的，然后因为我的设计，给每个地雷作用区域都写了列表且仅有2项，你完全可以把第三项作为准备时间，然后每几个tick进行更新\n4.现在的这个程序，由于CopyOnWriteArrayList的原因，每次addVec，都会先把list复制一份修改后再更新回去，这样的延迟，就导致了同一个地雷，玩家走过时可能会触发n次，应该怎么解决？（注意不要给玩家做触发的CD，可能有多个玩家同时踩中了同一个地雷，给玩家做CD没有用，目标是同一个地雷只爆炸一次）（难度※※※）\n可以这样，别监听move，就几个tick循环判断玩家位置，然后如果涉及到删除地雷坐标，del操作之后，先sleep当前异步线程一会，等到列表被更新了，再让循环继续下去（注：未实际测试，欢迎一起讨论）\n\n如果全部解决，那你已经是一位优秀的BK开发者了。\n",
    "replies": [
        {
            "author": "新科",
            "timestamp": 1589217180,
            "txt_content": " 本帖最后由 新科 于 2020-5-12 01:14 编辑 \n\n话说 PVPIN 人均标配 netbeans 吗哈哈哈, 我记得是墨染最先在bbs教程上用的? (然而我也在用 bushi)\n教程很NB, 是我这种几何不好选手的福音, 但是我觉得既然是 bukkit scheduler 的入门教程, 相对的实例也应该简单点, 这个后面的实例我感觉比前面 bukkit scheduler 可难多了, 1+1开局三角函数收尾的感觉\n总之dalao加油！另外建议给个 coding 的开源地址啥的, 虽然知道你们有但是没找着\n"
        },
        {
            "author": "William_Shi",
            "timestamp": 1589242440,
            "txt_content": "新科 发表于 2020-5-12 01:13\n话说 PVPIN 人均标配 netbeans 吗哈哈哈, 我记得是墨染最先在bbs教程上用的? (然而我也在用 bushi)\n教程很N ...\n首先，海螺螺大佬评价netbeans是“儿童玩具”，所以我并没有推荐过IDE，只是nb启动速度快，idea略慢，而且我的idea背景是暗色的，截图可能看不太清楚。\n\n如果太难的话我近几天会写一篇简单点好玩点的\n\ncoding地址在索引帖，是被吞了么？"
        },
        {
            "author": "William_Shi",
            "timestamp": 1589245380,
            "txt_content": "新科 发表于 2020-5-12 01:13\n话说 PVPIN 人均标配 netbeans 吗哈哈哈, 我记得是墨染最先在bbs教程上用的? (然而我也在用 bushi)\n教程很N ...\n开源地址一直在索引贴第四页\nhttps://celestialrealm.coding.net/p/PVPINDemoRL"
        },
        {
            "author": "0x3B800001",
            "timestamp": 1589247420,
            "txt_content": "建议使用markdown做排版，然后用gitbook或者hexo做个静态页放到github/coding/gitee pages上\n\n不然的话。。本人觉得你这个着实有点劝退"
        },
        {
            "author": "William_Shi",
            "timestamp": 1589247960,
            "txt_content": "可爱的meow 发表于 2020-5-12 09:37\n建议使用markdown做排版，然后用gitbook或者hexo做个静态页放到github/coding/gitee pages上\n\n不然的话。。 ...\n我刚刚也在和yumc大佬聊这个问题\n主要是不会markdown\n我才高一，水平真的有限"
        }
    ]
}