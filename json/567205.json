{
    "title": "JAVA语言集成教程 - 基础篇4 面向对象编程",
    "author": "LiamGR",
    "replyCount": 9,
    "timestamp": 1458043140,
    "txt_content": "基础篇4 面向对象基础\n引索贴：http://www.mcbbs.net/thread-566664-1-1.html\n封装的原则\n要求使对象之外的部分不能随意存取对象的内部数据，从而有效避免了错误对它的“交叉感染”，使软件错误能局部化，降低排错难度\n\n继承\n所有的类都继承自 java.lang.Object，一些常用的方法：\n\nequals():比较两个对象引用时否相同。\n\ngetClass():返回对象运行时所对应的类的表示，从而得到相应的信息\n\ntoString():返回对象字符串表示\n\nfinalize():用于在垃圾收集前清除对象\n\nnotify(), notifyall(), wait(): 用于多线程处理中的同步\n\n子类（subclass）对父类（superclass，超类）的继承\n\n子类不能继承父类中访问权限为 private 的成员变量和方法。\n\n子类可以重写父类的方法，及命名与父类同名的成员变量。\n\nJava 不支持多重继承\n\n创建子类\n\n　　　　class SubClass extends SuperClass {\n\n　　　　　　...\n\n　　　　}\n成员的隐藏和方法的重写\n\n子类通过隐藏父类的成员变量和重写父类的方法，可以把父类的状态和行为变为自身的状态和行为。\n\n多态性\n子类继承父类后，同一个方法有不同的表现\n\n体现在两个方面：方法重载实现的静态多态性（编译时多态），方法重写实现的动态多态性（运行时多态）\n\n重写方法的调用原则：子类重写父类的方法，调用子类方法；反之，调用父类的方法\n\n一个对象可以引用子类的实例来调用子类的方法\n\neg: B 继承 A，A 的对象 a 引用 B 的实例，调用 B 的方法 callme()\n\nimport java.io.*;\nclass A {\n    void callme() {\n        System.out.println(\"Inside A's callme()) method\");\n    }\n}\n\nclass B extends A {\n    void callme() {\n        System.out.println(\"Inside B's callme() method\");\n    }\n}\n\npublic class Dispatch {\n    public static void main(String args[]) {\n        A a = new B(); // 引用子类的实例\n        a.callme(); \n    }\n}\n\n\n\n类的实现\n\n\n\n\n\n\n类声明\n\n　　　　[public][abstract|final] class className [extends superclassName] [implements interfaceNameList] {}\n　　　　　　修饰符public, abstract, final说明类的属性\n　　　　　　className为类的属性\n　　　　　　superclassName为父类的名字\n　　　　　　interfaceNameList为类所实现的接口列表\n类体\n\n　　　　class className\n　　　　{\n　　　　　　[public | protected | private] [static] [final] [transient] [volatile] type variableName; // 成员变量\n　　　　　　[public | protected | private] [static] [final | abstract] [native] [synchronized] returnType methodName(\n　　　　　　　　[paramList]) [throws exceptionList] {statements}; //成员方法\n　　　　}\n成员变量\n\n　　　　[public | protected | private] [static] [final] [transient] [volatile] type variableName; // 成员变量\n　　　　　　static: 静态变量（类变量）\n　　　　　　final: 常量\n　　　　　　transient：暂时性变量，用于对象存档\n　　　　　　volatile：共享变量，用于并发线程的共享\n成员方法\n\n　　　　[public | protected | private] [static] [final | abstract] [native] [synchronized] returnType methodName(\n　　　　[paramList]) [throws exceptionList] {statements}; //成员方法\n　　　　　　static: 类方法，可通过类名直接调用\n　　　　　　abstract: 抽象方法，没有方法体\n　　　　　　final：方法不能被重写\n　　　　　　native：集成其他语言的代码\n　　　　　　synchronized：控制多个并发线程的访问\nJava 类中的限定词：\n\nprivate：类中限定为 private 的成员，只能被这个类本身访问。如果构造方法为 private，则其他类不能实例化该类。\n\ndefault：不加任何访问权限，可以被这个类本身和同一个包中的类访问。\n\nprotected：类中限定为 protected 的成员，可以被这个类本身、它的子类和同一个包中的其他类访问。\n\npublic：类中被限定为 public 的成员，可以被所有类访问。\n\nfinal 关键字可以修饰类、类的成员变量和成员方法，但作用不同\n\n修饰成员变量：称为常量，须给出初始值\n\n修饰成员方法：该方法不能被子类重写\n\n修饰类：类不能被继承\n\nsuper: 访问父类的成员　\n\n访问父类被隐藏的成员变量，如 super.variable;\n\n调用父类中被重写的方法，如 super.Method([paramlist]);\n\n调用父类的构造函数，如 super([paramlist]);\n\neg:\n\nimport java.io.*;\nclass SuperClass {\n    int x;\n\n    SuperClass() {\n        x = 3;\n        System.out.println(\"in SuperClass: x = \" + x);\n    }\n\n    void doSomething() {\n        System.out.println(\"in SuperClass.doSomething()\");\n    }\n}\n\nclass SubClass extends SuperClass {\n    int x;\n\n    SubClass() {\n        super();\n        x = 5;\n        System.out.println(\"in SubClass: x = \" + x);\n    }\n\n    void doSomething() {\n        super.doSomething();\n        System.out.println(\"in SubClass.doSomething()\");\n        System.out.println(\"Super.x = \" + super.x + \"sub.x = \" + x);\n    }\n}\n\npublic class Inhereritance {\n\n    public static void main(String chars[]) {\n        SubClass sc = new SubClass();\n        sc.doSomething();\n    }\n}\n\n\n\n简单数据：值类型\n复合数据：引用类型\n\n\nimport java.io.*;\npublic class PassTest {\n    float ptValue;\n\n\n    public static void main(String args[]) {\n        int val;\n        PassTest pt = new PassTest();\n        val = 11;\n        System.out.println(\"Original int Value is:\"+val);\n        pt.changeInt(val);\n        System.out.println(\"Int Value after Change is:\"+val);\n        pt.ptValue = 101f;\n        System.out.println(\"Original ptValue is:\"+pt.ptValue);\n        pt.changeObjectValue(pt); // 引用类型的参数\n        System.out.println(\"ptValue after change is:\"+pt.ptValue);\n\n\n    }\n\n\n    public void changeInt(int value) {\n        value = 55;\n    }\n\n\n    public void changeObjectValue(PassTest ref) {\n        ref.ptValue = 99f;\n    }\n}\n\n\n简单数据类型作为参数传递时，为值传递；复合数据类型作为参数传递时，为地址传递\n\n方法体 方法的实现。方法体中局部变量若与成员变量同名，局部变量将屏蔽成员变量。\n\nimport java.io.*;\nclass Variable {\n    int x = 0, y = 0, z = 0; // 类的成员变量\n\n    void init(int x, int y) {\n        this.x = x;\n        this.y = y;\n        int z = 5;  // 局部变量\n        System.out.println(\"** in init**\");\n        System.out.println(\"x = \" + x + \"y = \" + y + \"z = \" + z);\n    }\n}\n\npublic class VariableTest {\n    public static void main(String args[]) {\n        Variable v = new Variable();\n        System.out.println(\"** before init **\");\n        System.out.println(\"x = \" + v.x + \"y = \" + v.y + \"z = \" + v.z);\n        v.init(20, 30);\n        System.out.println(\"** after init **\");\n        System.out.println(\"x = \" + v.x + \"y = \" + v.y + \"z = \" + v.z);\n    }\n}\n\n\n\n方法重载\n\n\n指多个方法享有相同的名字。这些方法的参数必须不同。且参数类型区分度要足够：如不能使同一简单类型的数据：int 与 long\n\n\nimport java.io.*;\n\n\nclass MethodOverloading {\n    void receive(int i) {\n        System.out.println(\"Receive in data\");\n        System.out.println(\"i = \" + i);\n    }\n\n\n    void receive(int x, int y) {\n        System.out.println(\"Receive two in datas\");\n        System.out.println(\"x = \" + x + \"y = \" + y);\n    }\n}\n\n\npublic class MethodOverloadingTest {\n    public static void main(String args[]) {\n        MethodOverloading mo = new MethodOverloading();\n        mo.receive(1);\n        mo.receive(2, 3);\n    }\n}\n\n\n构造方法\n一个特殊的方法。每个类都有构造方法，用来初始化该类的一个对象。\n\n构造方法具有和类名相同的名称，不返回任何数据类型。\n\n重载经常用于构造方法。\n\n构造方法只能由 new 运算符调用\n\n抽象类和抽象方法：\n\n用 abstract 关键字修饰类:抽象类\n\n用 abstract 关键字修饰方法：抽象方法\n\n抽象类必须被继承，抽象方法必须被重写\n\n抽象方法只需声明，无需实现\n\n抽象类不能被实例化，抽象类不一定要包含抽象方法\n\n若类中包含抽象方法，给类必须被定义为抽象类\n\n接口\n接口是抽象类的一种，只包含常量和方法的定义，没有变量和方法的实现，且其方法都是抽象方法。\n\n用处体现在：\n\n通过接口，实现不相关类的相同行为\n\n通过接口，指明多个类需要实现的方法\n\n通过接口，了解对象的交互界面，无需了解对象所对应的类\n\n接口的定义：\n\n接口声明：\n\n[public] interface interfaceName[extends listOfSuperInterface] {...}\n方法体定义：\n\nreturnType methodName([paramlist]);\n接口的实现：\n\n在类的声明中用 implements 子句来表示一个类使用某个接口\n\n类体中可以使用接口中定义的常量，必须实现接口中定义的所有方法\n\n一个类可以实现多个接口，在 implements 中用逗号隔开\n\n接口类型的使用：\n\n接口作为一种引用类型来使用\n\n任何实现该接口的类的实例，都可以存储在该接口类型的变量中，通过这些实例，访问该类接口中的方法。\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "幻灭c",
            "timestamp": 1458132060,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132120,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132240,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132240,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132300,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132300,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "幻灭c",
            "timestamp": 1458132360,
            "txt_content": "楼主我来暖贴啦！！！"
        },
        {
            "author": "as898489651",
            "timestamp": 1507828620,
            "txt_content": "冷清到没人举报- -"
        },
        {
            "author": "灵单",
            "timestamp": 1508046000,
            "txt_content": "1222222222222222"
        }
    ]
}