{
    "title": "Spigot自定义世界生成器 获取尚未生成位置Biome的问题",
    "author": "renzd2001",
    "replyCount": 11,
    "timestamp": 1590853080,
    "txt_content": "大佬们晚上好，我在尝试为 spigot1.14.4 编写一个自定义的世界生成器，但是在尝试平滑Biome连接时遇到了问题：\n\n我的逻辑是：每一个Biome有最低高度和额外高度上限。我使用了SpigotAPI的Octave生成器，就可生成高度在（0~1的随机数）*额外高度上限 + 最低高度 的地形。比如我设置沙漠的最低高度为80，额外高度上限为6，那么生成的地形即在高度80~86之间。这个高度我称之为\"当前高度\"\n\n这个方案会使相邻Biome之间的地形落差巨大，所以我需要将Biome之间的地形平整。\n我自己的方案是：对于每一个XZ坐标，收集它附近某一范围（我设定的范围是XZ坐标差之和小于等于10）的Biome信息，并且将坐标信息不重复地记录为（Biome：最短距离distance）的格式。\n\n举个例子，假如一个方块处于沙漠Biome，但其附近10格内有河流（最短距离3），平原（最短距离4），则记录为：\n沙漠：0（它距自身肯定是0格）\n河流：3\n平原：4\n\n之后，收集这些Biome的对应最低高度（我提前设定好了），并通过加权平均的算法，求出最终的\"当前高度\"\n\n问题就出在这里：如果要使用我的方法，就势必要获取此区块之外的方块的Biome信息，（因为如果当前方块处于区块边缘，获取临近方块的Biome信息就一定要跨区块）所以不能使用基于此区块的getBiome()方法，而要使用基于全地图的getBiome()方法。 然而，当我确实使用了world.getBiome(x坐标，z坐标)时，服务器开服时卡在了Preparing chunk data 0%,并且进度不再增加，也没有报错，cpu利用率接近于零。我个人判断是world.getBiome在开服阶段还不可用，导致此问题的出现。\n\n所以我想请问各位大佬：\n1、如果有可能的话，可否帮我指出一种更佳的平滑Biome的方法？我目前的方法就算能够运行，对算力也有不小的负荷，所以如果从根本逻辑上改变算法，那就谢天谢地了。\n2、如果大佬们也不清楚更好的平滑Biome方法，那么请问该如何解决现在我无法获取当前区块外的方块的Biome的信息？\n\n万分感谢！！！！！（当然如果大佬有相关教程的传送门，我也十分感谢，我只在谷歌上搜索了相关教程，但是没有找到想要的东西。）\n\n以下是我生成器的代码部分：\npackage tech.yfshadaow;\n\nimport org.bukkit.generator.ChunkGenerator;\nimport org.bukkit.Bukkit;\nimport org.bukkit.World;\nimport java.util.Random;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\nimport org.bukkit.Material;\nimport org.bukkit.block.Biome;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.lang.Math;\n\npublic class EasternCraftGenerator extends ChunkGenerator{\n        int currentHeight = 80;//初始化高度\n        @Override\n    public ChunkData generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome) {\n            SimplexOctaveGenerator generator = new SimplexOctaveGenerator(new Random(world.getSeed()), 8);//创建地形起伏生成器\n        ChunkData chunk = createChunkData(world);\n        generator.setScale(0.02D);//生成器设定参数\n\n        for (int X = 0; X < 16; X++)\n            for (int Z = 0; Z < 16; Z++) {//遍历区块的每一个X、Z坐标\n                    int baseHeight = 80;//初始化最低高度\n                    int extraHeight = 5;//初始化额外高度最大值\n                        Material surfaceBlock = Material.GRASS_BLOCK;//设置顶部方块\n                        Material subSurfaceBLock = Material.DIRT;//设置顶部下方块\n                    if (biome.getBiome(X,Z).equals(Biome.DESERT)) {baseHeight = 80; extraHeight = 5; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (biome.getBiome(X,Z).equals(Biome.DESERT_HILLS)) {baseHeight = 80; extraHeight = 40; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (biome.getBiome(X,Z).equals(Biome.RIVER)) {baseHeight = 70; extraHeight = 2; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (biome.getBiome(X,Z).equals(Biome.OCEAN)) {baseHeight = 50; extraHeight = 6; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (biome.getBiome(X,Z).equals(Biome.MOUNTAINS)) {baseHeight = 64; extraHeight = 128; surfaceBlock = Material.GRASS_BLOCK; subSurfaceBLock = Material.DIRT;}//设置biome参数的暂时性代码，以后会改\n                currentHeight = (int) (generator.noise(chunkX*16+X, chunkZ*16+Z, 0.3D, 0.3D)*((extraHeight + 1)/2)+baseHeight);//高度=生成的(0~1)随机数 * 额外高度最大值 + 最低高度\n                List<Biome> biomesInfo = new ArrayList<Biome>();//初始化平滑区块要用的区块列表\n                    List<Double> distancesInfo = new ArrayList<Double>();//初始化平滑区块要用的距离列表\n                    for (int p = 0; p < 10; p++) {\n                            for (int q = -p; q <= p; q++) {//以上两行起到的作用是，以(|x坐标差值|+|z坐标差值|)从小到大为顺序，遍历当前方块周围的 正方形范围的所有方块\n                                    if (!(biomesInfo.contains(world.getBiome(chunkX*16+X + q, chunkZ*16+Z + (p - Math.abs(q)))))) {\n                                            biomesInfo.add(world.getBiome(chunkX*16+X + q, chunkZ*16+Z + (p - Math.abs(q))));\n                                            distancesInfo.add(Math.sqrt((double)(q ^ 2 + (p - Math.abs(q)) ^ 2)));//计算直线距离\n                                    }\n                                    if (!(biomesInfo.contains(world.getBiome(chunkX*16+X + q, chunkZ*16+Z - (p - Math.abs(q)))))) {\n                                            biomesInfo.add(world.getBiome(chunkX*16+X + q, chunkZ*16+Z - (p - Math.abs(q))));\n                                            distancesInfo.add(Math.sqrt((double)(q ^ 2 + (p - Math.abs(q)) ^ 2)));//计算直线距离\n                                    }\n                            }\n                    }\n                currentHeight = getCurrentHeight(currentHeight, biomesInfo, distancesInfo);\n                //这一整段代码，会把这个方块附近一定范围内存在的biome不重复地记录下来，并且记录下该biome距离当前方块的最短距离（这个距离可能不是最短，但是离最短差不多，没有很大影响）\n                \n                \n                \n                \n                \n                chunk.setBlock(X, currentHeight, Z, surfaceBlock);\n                for (int c = 1; c < 9; c++) {\n                    chunk.setBlock(X, currentHeight-c, Z, subSurfaceBLock);\n                }\n                for (int i = currentHeight-9; i > 0; i--)\n                    chunk.setBlock(X, i, Z, Material.STONE);\n                chunk.setBlock(X, 0, Z, Material.BEDROCK);\n                if (currentHeight < 80) {\n                        for(int n = 80; n > currentHeight; n--) {\n                                chunk.setBlock(X, n, Z, Material.WATER);\n                        }\n                }//以上代码放置相应方块和水\n            }\n        return chunk;\n    }\n        public int getCurrentHeight(int currentHeight, List<Biome> biomesInfo, List<Double> distancesInfo) {\n                double weightSum = 0;\n                double numerator = 0;\n                for (int i = 0; i < biomesInfo.size(); i++) {\n                        weightSum += (10 - distancesInfo.get(i));\n                        numerator += (10 - distancesInfo.get(i)) * ((getBiomeBaseHeight(biomesInfo.get(i))) - (currentHeight));\n                }\n                return (int)(numerator / weightSum + currentHeight);\n        }\n        public int getBiomeBaseHeight(Biome biome) {//此方法用来获取biome的最低高度\n                if (biome.equals(Biome.DESERT)) {return 80;}\n                else if (biome.equals(Biome.DESERT_HILLS)) {return 80;}\n                else if (biome.equals(Biome.RIVER)) {return 70;}\n                else if (biome.equals(Biome.OCEAN)) {return 50;}\n                else if (biome.equals(Biome.MOUNTAINS)) {return 64;}\n                else {return 80;}\n        }\n        \n}\n复制代码\n\n",
    "replies": [
        {
            "author": "天辉胡萝卜",
            "timestamp": 1590860280,
            "txt_content": "最好的方法是使用GenLayer，让MC自动分配生物群系\n以1.15.2为例（不同版本略有不同）\n\npublic class CustomChunkProvider extends WorldChunkManager {\n  private final GenLayer layer;\n  \n  private static final Set<BiomeBase> e = (Set<BiomeBase>)ImmutableSet.of(Biomes.OCEAN, Biomes.PLAINS, Biomes.DESERT, Biomes.MOUNTAINS, Biomes.FOREST, Biomes.TAIGA, (Object[])new BiomeBase[] { \n        Biomes.SWAMP, Biomes.RIVER, Biomes.FROZEN_OCEAN, Biomes.FROZEN_RIVER, Biomes.SNOWY_TUNDRA, Biomes.SNOWY_MOUNTAINS, Biomes.MUSHROOM_FIELDS, Biomes.MUSHROOM_FIELD_SHORE, Biomes.BEACH, Biomes.DESERT_HILLS, \n        Biomes.WOODED_HILLS, Biomes.TAIGA_HILLS, Biomes.MOUNTAIN_EDGE, Biomes.JUNGLE, Biomes.JUNGLE_HILLS, Biomes.JUNGLE_EDGE, Biomes.DEEP_OCEAN, Biomes.STONE_SHORE, Biomes.SNOWY_BEACH, Biomes.BIRCH_FOREST, \n        Biomes.BIRCH_FOREST_HILLS, Biomes.DARK_FOREST, Biomes.SNOWY_TAIGA, Biomes.SNOWY_TAIGA_HILLS, Biomes.GIANT_TREE_TAIGA, Biomes.GIANT_TREE_TAIGA_HILLS, Biomes.WOODED_MOUNTAINS, Biomes.SAVANNA, Biomes.SAVANNA_PLATEAU, Biomes.BADLANDS, \n        Biomes.WOODED_BADLANDS_PLATEAU, Biomes.BADLANDS_PLATEAU, Biomes.WARM_OCEAN, Biomes.LUKEWARM_OCEAN, Biomes.COLD_OCEAN, Biomes.DEEP_WARM_OCEAN, Biomes.DEEP_LUKEWARM_OCEAN, Biomes.DEEP_COLD_OCEAN, Biomes.DEEP_FROZEN_OCEAN, Biomes.SUNFLOWER_PLAINS, \n        Biomes.DESERT_LAKES, Biomes.GRAVELLY_MOUNTAINS, Biomes.FLOWER_FOREST, Biomes.TAIGA_MOUNTAINS, Biomes.SWAMP_HILLS, Biomes.ICE_SPIKES, Biomes.MODIFIED_JUNGLE, Biomes.MODIFIED_JUNGLE_EDGE, Biomes.TALL_BIRCH_FOREST, Biomes.TALL_BIRCH_HILLS, \n        Biomes.DARK_FOREST_HILLS, Biomes.SNOWY_TAIGA_MOUNTAINS, Biomes.GIANT_SPRUCE_TAIGA, Biomes.GIANT_SPRUCE_TAIGA_HILLS, Biomes.MODIFIED_GRAVELLY_MOUNTAINS, Biomes.SHATTERED_SAVANNA, Biomes.SHATTERED_SAVANNA_PLATEAU, Biomes.ERODED_BADLANDS, Biomes.MODIFIED_WOODED_BADLANDS_PLATEAU, Biomes.MODIFIED_BADLANDS_PLATEAU });\n        //此处加入你想生成的群系\n  \n  public CustomChunkProvider(long seed, net.minecraft.server.v1_15_R1.WorldType worldType) {\n    super(e);\n    this.layer = GenLayers.a(seed, worldType, new GeneratorSettingsOverworld());\n  }\n  \n  public Biome getBiome(int var0, int var1, int var2) {\n    BiomeBase base = this.layer.a(var0, var2);\n    return CraftBlock.biomeBaseToBiome(base);\n  }\n}复制代码\n"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590884160,
            "txt_content": "疾风暗影 发表于 2020-5-31 01:38\n最好的方法是使用GenLayer，让MC自动分配生物群系\n以1.15.2为例（不同版本略有不同）\n\n\n十分感谢！！！"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590891960,
            "txt_content": "疾风暗影 发表于 2020-5-31 01:38\n最好的方法是使用GenLayer，让MC自动分配生物群系\n以1.15.2为例（不同版本略有不同）\n大佬你好，我仔细读了一下你提供的代码，然后对照了一下我自己的，发现我使用的是 org.bukkit.generator 包中的 ChunkGenerator 类，而你代码中好像需要用到 net.minecraft.server.v1_14_R1 包中的 ChunkGenerator 类。（org.bukkit.generator.ChunkGenerator 没有 WorldChunkManager 等相关内容）\n\n可否问一下您是建议我使用MC原版服务端完全重写一遍代码，还是保留现在的部分代码，通过某种方式调用原版当中的getBiome()方法呢？感谢！"
        },
        {
            "author": "天辉胡萝卜",
            "timestamp": 1590892140,
            "txt_content": "renzd2001 发表于 2020-5-31 10:26\n大佬你好，我仔细读了一下你提供的代码，然后对照了一下我自己的，发现我使用的是 org.bukkit.generator  ...\n这是调用nms的方法，用mc自己的层级噪声生成优化的群系分布\n\n你可以地形生成用自己的代码，群系生成用这些"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590903000,
            "txt_content": "疾风暗影 发表于 2020-5-31 10:29\n这是调用nms的方法，用mc自己的层级噪声生成优化的群系分布\n\n你可以地形生成用自己的代码，群系生成用这 ...\n大佬你好，我用了你给的代码，已经可以正常生成世界了，但是在判断生物群系时出了点小问题：\n\n我原本判断生物群系使用的是spigot自带的 BiomeGrid.getBiome()方法，因为这个方法限于当前区块，所以X和Z坐标参数都是 0~15\n\n现在我改用你给我的使用实例化的WorldChunkManager的方法，我认为这个方法应该是基于整个地图，所以我将原来的这部分判断代码\nif (biome.getBiome(X,Z).equals(Biome.DESERT)) {baseHeight = 80; extraHeight = 5; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (biome.getBiome(X,Z).equals(Biome.DESERT_HILLS)) {baseHeight = 80; extraHeight = 40; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (biome.getBiome(X,Z).equals(Biome.RIVER)) {baseHeight = 70; extraHeight = 2; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (biome.getBiome(X,Z).equals(Biome.OCEAN)) {baseHeight = 50; extraHeight = 6; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (biome.getBiome(X,Z).equals(Biome.MOUNTAINS)) {baseHeight = 64; extraHeight = 128; surfaceBlock = Material.GRASS_BLOCK; subSurfaceBLock = Material.DIRT;}复制代码改成了现在这样（getBukkitBiome()是我自己重写的方法 完整代码在后面)if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.DESERT)) {baseHeight = 83; extraHeight = 3; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.DESERT_HILLS)) {baseHeight = 100; extraHeight = 20; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.RIVER)) {baseHeight = 70; extraHeight = 1; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.OCEAN)) {baseHeight = 50; extraHeight = 3; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.MOUNTAINS)) {baseHeight = 128; extraHeight = 64; surfaceBlock = Material.GRASS_BLOCK; subSurfaceBLock = Material.DIRT;}\n                        复制代码但是出现了意料之外的结果：生物群系的高度和生物群系不对应了，我在XZ判断为河流的地方，发现了沙漠的地形特征。\n请问我该怎么解决这个问题？\n我认为我可能犯的错误：\n1、我在转换区块内坐标和世界内坐标时出错（但我记得确实应该是chunkX*16+X, chunkZ*16+Z）\n2、mc原版生成的Biome分布和spigot根本就不一样（这个不应该发生啊，spigot应该用的就是原版的生成器）（然而这个可以通过使用spigot自带的setBiome来间接解决）\n\n以下为生成器部分代码：(我暂时删掉了平整地形的部分)\npackage tech.yfshadaow;\n\nimport org.bukkit.generator.ChunkGenerator;\nimport org.bukkit.Bukkit;\nimport org.bukkit.World;\nimport java.util.Random;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\nimport org.bukkit.Material;\nimport org.bukkit.block.Biome;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.lang.Math;\nimport net.minecraft.server.v1_15_R1.WorldType;;\n\npublic class EasternCraftGenerator extends ChunkGenerator{\n        int currentHeight = 80;//Initialize currentHeight\n        @Override\n    public ChunkData generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome) {\n                EasternCraftChunkProvider provider = new EasternCraftChunkProvider(world.getSeed(),WorldType.NORMAL);\n            SimplexOctaveGenerator generator = new SimplexOctaveGenerator(new Random(world.getSeed()), 8);//instantiate the terrain generator\n        ChunkData chunk = createChunkData(world);\n        generator.setScale(0.02D);//set generator parameter\n\n        for (int X = 0; X < 16; X++)\n            for (int Z = 0; Z < 16; Z++) {\n                    int baseHeight = 83;\n                    int extraHeight = 3;\n                        Material surfaceBlock = Material.GRASS_BLOCK;\n                        Material subSurfaceBLock = Material.DIRT;\n                        if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.DESERT)) {baseHeight = 83; extraHeight = 3; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.DESERT_HILLS)) {baseHeight = 100; extraHeight = 20; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.RIVER)) {baseHeight = 70; extraHeight = 1; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.OCEAN)) {baseHeight = 50; extraHeight = 3; surfaceBlock = Material.DIRT; subSurfaceBLock = Material.DIRT;}\n                    else if (provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z).equals(Biome.MOUNTAINS)) {baseHeight = 128; extraHeight = 64; surfaceBlock = Material.GRASS_BLOCK; subSurfaceBLock = Material.DIRT;}\n                        \n                        currentHeight = (int) (generator.noise(chunkX*16+X, chunkZ*16+Z, 0.3D, 0.3D)* extraHeight + baseHeight);\n                        \n                chunk.setBlock(X, currentHeight, Z, surfaceBlock);\n                for (int c = 1; c < 9; c++) {\n                    chunk.setBlock(X, currentHeight-c, Z, subSurfaceBLock);\n                }\n                for (int i = currentHeight-9; i > 0; i--)\n                    chunk.setBlock(X, i, Z, Material.STONE);\n                chunk.setBlock(X, 0, Z, Material.BEDROCK);\n                if (currentHeight < 80) {\n                        for(int n = 80; n > currentHeight; n--) {\n                                chunk.setBlock(X, n, Z, Material.WATER);\n                        }\n                }//以上代码放置相应方块和水\n            }\n        return chunk;\n    }\n        \n}\n复制代码以下为继承了WorldChunkManager的代码部分：\npackage tech.yfshadaow;\n\nimport net.minecraft.server.v1_15_R1.WorldChunkManager;\nimport net.minecraft.server.v1_15_R1.GenLayers;\nimport net.minecraft.server.v1_15_R1.GenLayer;\nimport net.minecraft.server.v1_15_R1.Biomes;\nimport net.minecraft.server.v1_15_R1.BiomeBase;\nimport java.util.Set;\nimport com.google.common.collect.ImmutableSet; \nimport net.minecraft.server.v1_15_R1.GeneratorSettingsOverworld;\nimport org.bukkit.craftbukkit.v1_15_R1.block.CraftBlock;\nimport org.bukkit.block.Biome;\n\npublic class EasternCraftChunkProvider extends WorldChunkManager {\n          private final GenLayer layer;\n          \n          private static final Set<BiomeBase> e = (Set<BiomeBase>)ImmutableSet.of(Biomes.OCEAN, Biomes.PLAINS, Biomes.DESERT, Biomes.MOUNTAINS, Biomes.FOREST, Biomes.TAIGA, new BiomeBase[] { \n                Biomes.SWAMP, Biomes.RIVER, Biomes.FROZEN_OCEAN, Biomes.FROZEN_RIVER, Biomes.SNOWY_TUNDRA, Biomes.SNOWY_MOUNTAINS, Biomes.MUSHROOM_FIELDS, Biomes.MUSHROOM_FIELD_SHORE, Biomes.BEACH, Biomes.DESERT_HILLS, \n                Biomes.WOODED_HILLS, Biomes.TAIGA_HILLS, Biomes.MOUNTAIN_EDGE, Biomes.JUNGLE, Biomes.JUNGLE_HILLS, Biomes.JUNGLE_EDGE, Biomes.DEEP_OCEAN, Biomes.STONE_SHORE, Biomes.SNOWY_BEACH, Biomes.BIRCH_FOREST, \n                Biomes.BIRCH_FOREST_HILLS, Biomes.DARK_FOREST, Biomes.SNOWY_TAIGA, Biomes.SNOWY_TAIGA_HILLS, Biomes.GIANT_TREE_TAIGA, Biomes.GIANT_TREE_TAIGA_HILLS, Biomes.WOODED_MOUNTAINS, Biomes.SAVANNA, Biomes.SAVANNA_PLATEAU, Biomes.BADLANDS, \n                Biomes.WOODED_BADLANDS_PLATEAU, Biomes.BADLANDS_PLATEAU, Biomes.WARM_OCEAN, Biomes.LUKEWARM_OCEAN, Biomes.COLD_OCEAN, Biomes.DEEP_WARM_OCEAN, Biomes.DEEP_LUKEWARM_OCEAN, Biomes.DEEP_COLD_OCEAN, Biomes.DEEP_FROZEN_OCEAN, Biomes.SUNFLOWER_PLAINS, \n                Biomes.DESERT_LAKES, Biomes.GRAVELLY_MOUNTAINS, Biomes.FLOWER_FOREST, Biomes.TAIGA_MOUNTAINS, Biomes.SWAMP_HILLS, Biomes.ICE_SPIKES, Biomes.MODIFIED_JUNGLE, Biomes.MODIFIED_JUNGLE_EDGE, Biomes.TALL_BIRCH_FOREST, Biomes.TALL_BIRCH_HILLS, \n                Biomes.DARK_FOREST_HILLS, Biomes.SNOWY_TAIGA_MOUNTAINS, Biomes.GIANT_SPRUCE_TAIGA, Biomes.GIANT_SPRUCE_TAIGA_HILLS, Biomes.MODIFIED_GRAVELLY_MOUNTAINS, Biomes.SHATTERED_SAVANNA, Biomes.SHATTERED_SAVANNA_PLATEAU, Biomes.ERODED_BADLANDS, Biomes.MODIFIED_WOODED_BADLANDS_PLATEAU, Biomes.MODIFIED_BADLANDS_PLATEAU });\n                //此处加入你想生成的群系\n          \n          public EasternCraftChunkProvider(long seed, net.minecraft.server.v1_15_R1.WorldType worldType) {\n            super(e);\n            this.layer = GenLayers.a(seed, worldType, new GeneratorSettingsOverworld());\n          }\n          \n          public Biome getBukkitBiome(int var0, int var1) {\n            BiomeBase base = this.layer.a(var0, var1);\n            return CraftBlock.biomeBaseToBiome(base);\n          }\n          \n          public BiomeBase getBiome(int var0, int var1, int var2) {\n                    return this.layer.a(var0, var2);\n          }\n        }复制代码\n\n请问大佬是否愿意给点建议？感谢！\n\n"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590905880,
            "txt_content": "我刚刚在判断Biome的语句后添加了这段代码：\nbiome.setBiome(X, Z, provider.getBukkitBiome(chunkX*16+X, chunkZ*16+Z));复制代码\n强行将此位置的Biome设置成我用 getBukkitBiome()方法获取的Biome\n结果很明显地得到了一个缩小版的地形：\n\n\n\n\nfile_1590905849000.jpg (129.48 KB, 下载次数: 0)\n\n下载附件\n\n生成的地形\n2020-5-31 14:17 上传\n\n\n\n\n\n明显的看到河流变得非常细，然后平原biome变得很小\n所以我基本可以确定是坐标数字的问题。但是又是哪里出了问题呢...?\n"
        },
        {
            "author": "天辉胡萝卜",
            "timestamp": 1590943080,
            "txt_content": "renzd2001 发表于 2020-5-31 14:18\n我刚刚在判断Biome的语句后添加了这段代码：\n\n强行将此位置的Biome设置成我用 getBukkitBiome()方法获取的B ...\nMC在地形生成的时候群系代码为\nbiome.getBiome(x >> 2, y >> 2, z >> 2)复制代码\n\n也就是这个坐标是缩小4倍的，你需要按比例扩大"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590970740,
            "txt_content": "疾风暗影 发表于 2020-6-1 00:38\nMC在地形生成的时候群系代码为\n\n\n\n谢谢！这样问题应该就可以解决啦！"
        },
        {
            "author": "renzd2001",
            "timestamp": 1590984300,
            "txt_content": "疾风暗影 发表于 2020-6-1 00:38\nMC在地形生成的时候群系代码为\n你好大佬，抱歉再次打扰，我刚才试了一下你说的 通过>>2运算把 x和z坐标缩小到原来的四分之一，生物群系的大小确实正确了。\n但是出现了现在这个情况：\n\n\n\n\n\nfile_1590983776000.jpg (221.58 KB, 下载次数: 0)\n\n下载附件\n\n2020-6-1 11:56 上传\n\n\n\n\n\n可以很明显看到，河流宽度正常了，而且河流和沙漠的分界也是正常平滑的。\n但是图中显示，我正处在河流群系中，而地面特征却是沙漠应有的特征...\n并且可以看出，地面特征是以4x4方块为基本单位的，而不是应有的1x1\n然而，我的代码中，生物群系的生成和地面特征的设置是完全基于同一个生物群系：\nBiome b = provider.getBukkitBiome(((chunkX*16+X) >> 2), ((chunkZ*16+Z) >> 2));\n                    int baseHeight = 83;\n                    int extraHeight = 3;\n                        Material surfaceBlock = Material.GRASS_BLOCK;\n                        Material subSurfaceBLock = Material.DIRT;\nbiome.setBiome(X, Z, b);\nif (b.equals(Biome.DESERT)) {baseHeight = 83; extraHeight = 3; surfaceBlock = Material.SAND; subSurfaceBLock = Material.SAND;}复制代码以上可以看到，我用了同一个参数： b 来进行 设置biome 和 设置地面特征 这两个操作，结果biome是正确的，地面特征确实错的？？？？\n（p.s.我用1.14.4版本重新试了一下，是不会出这种错的，会不会是1.15.2的问题。。？）\n谢谢！\n"
        },
        {
            "author": "天辉胡萝卜",
            "timestamp": 1591029960,
            "txt_content": "renzd2001 发表于 2020-6-1 12:05\n你好大佬，抱歉再次打扰，我刚才试了一下你说的 通过>>2运算把 x和z坐标缩小到原来的四分之一，生物群系 ...\n疑似是客户端区块表与服务端不一致，重启客户端试试"
        },
        {
            "author": "renzd2001",
            "timestamp": 1591104840,
            "txt_content": "疾风暗影 发表于 2020-6-2 00:46\n疑似是客户端区块表与服务端不一致，重启客户端试试\n大佬晚上好，我把服务器版本换成1.14.4后就解决啦！\n不过还是谢谢大佬的建议（我在1.15.2版本也试过重启客户端，但是问题依然存在。感觉是spigot的问题，或者是什么其他小问题）\n\n现在已经可以生成比较平滑且还能看的地形了（平滑算法我找不到比较好的，所以使用的是收集附近方块高度并求平均值的笨方法）\n\n现在的情况：\n\n\n\n\nfile_1591104828000.jpg (136.97 KB, 下载次数: 0)\n\n下载附件\n\n2020-6-2 21:33 上传\n\n\n\n\n\n\n真的是非常感谢！！！！\n\n"
        }
    ]
}