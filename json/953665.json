{
    "title": "[Bukkit/Spigot]一种特别的方式加载插件",
    "author": "夏雨吖",
    "replyCount": 6,
    "timestamp": 1581006300,
    "txt_content": " 本帖最后由 M8_mve 于 2020-2-7 00:23 编辑 \n\n\n\n\n用特别的方式加载插件\n\n看这篇水贴教程之前需要\nJava基础\n反射知识\n类加载器的简单原理\n对ClassLoader的理解\n\n\n\n\n这篇教程是哪里来的\n之前写过一个UI化服务器的插件烂坑\n是用Java FX写的UI\n但是插件每次reload之后会重新实例化Plugin\n这就会重新创建FX Application然后丢异常给我\n我想能不能让插件只会实例化一次呢？\n然后就有了这个想法和这篇教程\n\n一、Loader1、HyperPlugin创建一个类做下面加载的类的父类，当然也可以直接用子类public class HyperPlugin\n{\n        public Plugin plugin;\n\n        public void onLoad() { }\n\n        public void onEnable() { }\n\n        public void onDisable() { }\n}复制代码这里的Plugin是保存每次加载时候的Plugin实例的，因为每次加载插件插件实例都会改变因为plugin实例要在调用onEnable之前更新，访问权限不公开的话要用反射改，会拉低效率当然如果你不考虑效率也可以用反射反正都能反射改，公开不公开又有什么区别呢233一会要写的Core的主类要继承这个类，重写这里的三个方法当然也可以改个名字，或者加一些别的方法2、HyperPluginClassLoader创建一个用来加载Core的类加载器，可以继承java的URLClassLoader但是要打破双亲委派的规则public class HyperPluginClassLoader extends URLClassLoader\n{\n        public static final HyperPluginClassLoader LOADER;\n        private final Map<String, Class<?>> classes = new ConcurrentHashMap<>();\n        private final JarFile jar;\n        private final HyperPlugin plugin;\n        private Map<String, Class<?>> parentClasses = new HashMap<>();\n\n        private HyperPluginClassLoader(File pluginFile) throws IOException\n        {\n                super(new URL[]{pluginFile.toURI().toURL()});\n                this.jar = new JarFile(pluginFile);\n                HyperPlugin plugin = null;\n                try\n                {\n                        Class<?> main = Class.forName(\"org.mve.hy.Main\", true, this);\n                        plugin = (HyperPlugin) main.newInstance();\n                }\n                catch (Exception e)\n                {\n                        e.printStackTrace();\n                }\n                this.plugin = plugin;\n                if (this.plugin == null)\n                        throw new IllegalStateException(\"Can not load plugin: \"+pluginFile);\n\n                this.plugin.onLoad();\n        }\n\n        public void onEnable(Plugin plugin)\n        {\n                this.parentClasses.putAll(this.classes);\n                this.plugin.plugin = plugin;\n                this.plugin.onEnable();\n        }\n\n        public void onDisable()\n        {\n                this.plugin.onDisable();\n                this.plugin.plugin = null;\n        }\n\n        @Override\n        public Class<?> findClass(String name) throws ClassNotFoundException\n        {\n                return this.loadClass(name);\n        }\n\n        @Override\n        public Class<?> loadClass(String name) throws ClassNotFoundException\n        {\n                Class<?> clazz = this.classes.get(name);\n                if (clazz != null) return clazz;\n                clazz = this.parentClasses.get(name);\n                if (clazz != null) return clazz;\n                try\n                {\n                        String path = name.replace('.', '/').concat(\".class\");\n                        JarEntry entry = jar.getJarEntry(path);\n                        if (entry != null)\n                        {\n                                InputStream in = this.jar.getInputStream(entry);\n                                byte[] bytes = HyperPluginClassLoader.toByteArray(in);\n                                in.close();\n                                clazz = this.defineClass(name, bytes, 0, bytes.length);\n                                if (clazz != null)\n                                {\n                                        this.classes.put(name, clazz);\n                                        this.parentClasses.put(name, clazz);\n                                }\n                        }\n                }\n                catch (Exception ignored) {}\n                return clazz != null ? clazz : this.getParent().loadClass(name);\n        }\n\n        private static byte[] toByteArray(InputStream in) throws IOException\n        {\n                ByteArrayOutputStream out = new ByteArrayOutputStream();\n                int len;\n                byte[] b = new byte[1024];\n                while ((len = in.read(b)) > -1)\n                {\n                        out.write(b, 0, len);\n                }\n                out.flush();\n                out.close();\n                return out.toByteArray();\n        }\n\n        static\n        {\n                HyperPluginClassLoader loader = null;\n                try\n                {\n                        File coreFile = new File(\"plugins/HyperPlugin/Core.jar\");\n                        loader = new HyperPluginClassLoader(coreFile);\n                }\n                catch (IOException e)\n                {\n                        e.printStackTrace();\n                }\n                LOADER = loader;\n        }\n}复制代码\n这里的loadClass和findClass要自己实现，我把findClass推给了loadClass我这里用了单例模式，防止反复实例化classloaderloadClass一定不能遵循双亲委派的规则，不然会出现ClassNotFoundException之类的奇怪的东西这里的parentClasses是加载插件的PluginClassLoader的classes这样可以假装自己加载过的类，父类加载器也加载过如果其他插件要连接你的插件需要这个东西在loadClass方法里加载新的类需要把加载的Class实例也put到这个parentClasses里但是自己保存的classes也是必须的，因为每次重载插件，父类加载器都会变这样这里的parentClasses也要变，在每次onEnable的时候需要把自己加载过的所有类都put进去注意: 这里的静态代码块里指定的File一定是之后插件本体的位置当然你可以改路径和名字但是别忘了改这里这里的构造方法里加载的类一定是插件本体继承之前写的HyperPlugin的类\n二、Plugin1、用来加载插件本体的BukkitPlugin现在写的类是让Bukkit来加载的public class PluginMain extends JavaPlugin\n{\n        @Override\n        public void onEnable()\n        {\n                InputStream pluginIn = this.getResource(\"HyperPlugin.class\");\n                InputStream loaderIn = this.getResource(\"HyperPluginClassLoader.class\");\n                if (pluginIn == null)\n                        throw new IllegalStateException(\n                                \"Can not load core\",\n                                new FileNotFoundException(\"HyperPlugin.class\")\n                        );\n                if (loaderIn == null)\n                        throw new IllegalStateException(\n                                \"Can not load core\",\n                                new FileNotFoundException(\"HyperPluginClassLoader.class\")\n                        );\n                try\n                {\n                        SystemClassLoader.define(IO.toByteArray(pluginIn));\n                        SystemClassLoader.define(IO.toByteArray(loaderIn));\n                }\n                catch (Throwable e)\n                {\n                        if (! (e instanceof LinkageError))\n                                throw new IllegalStateException(\"Can not load core\", e);\n                }\n                try\n                {\n                        Reflect.setFinalField(\n                                ClassLoader.class,\n                                \"parent\",\n                                HyperPluginClassLoader.LOADER,\n                                this.getClass().getClassLoader()\n                        );\n                        Reflect.setField(\n                                HyperPluginClassLoader.class,\n                                \"parentClasses\",\n                                HyperPluginClassLoader.LOADER,\n                                Reflect.reflectField(\n                                        PluginClassLoader.class,\n                                        \"classes\"\n                                )\n                        );\n                }\n                catch (NoSuchFieldException | IllegalAccessException e)\n                {\n                        e.printStackTrace();\n                }\n                HyperPluginClassLoader.LOADER.onEnable(this);\n        }\n\n        @Override\n        public void onDisable()\n        {\n                HyperPluginClassLoader.LOADER.onDisable();\n        }\n}复制代码\n2、正确的加载之前写的HyperPlugin和HyperPluginClassLoader这两个类一定不能直接丢到插件里不能让PluginClassLoader加载它，不然和普通的插件加载没什么区别了只要这两个class不在package指定的包里就可以，我直接放在缺省包里了\nSystemClassLoader.define(IO.toByteArray(pluginIn));\nSystemClassLoader.define(IO.toByteArray(loaderIn));\n然后在插件的onEnable方法里把这两个类define到AppClassLoader也就是JVM第三级类加载器也可以在onLoad方法里define，反正都一样只要别在onDisable里define就好 嗷呜~因为每次插件onEnable都会define，重复加载相同的类会报错，需要捕捉一下异常，直接忽略掉之后要改一下HyperPluginClassLoader的parent还要改一下之前说过的parentClasses，这个Map在Bukkit的PluginClassLoader里然后就可以onEnable你的插件本体啦\n三、Core现在就可以写插件的本体啦这里写的插件本体在服务器运行的过程里只会调用一次onLoad方法也就是只会加载一次类虽然不知道有什么用，但是之前写fx的时候发现的这个方法就来水一贴了哈哈哈哈本体的主类要继承之前写的HyperPlugin而不是JavaPlugin主类必须和之类加载器里指定的主类一致(全限定名)public class Main extends HyperPlugin\n{\n        @Override\n        public void onLoad()\n        {\n                System.out.println(\"Plugin load\");\n                System.out.println(this.getClass().getClassLoader());\n        }\n\n        @Override\n        public void onEnable()\n        {\n                System.out.println(\"Plugin enable\");\n                System.out.println(this.getClass().getClassLoader());\n        }\n\n        @Override\n        public void onDisable()\n        {\n                System.out.println(\"Plugin disable\");\n                System.out.println(this.getClass().getClassLoader());\n        }\n}复制代码可以输出一下类加载器看看前后的类是不是唯一\n四、测试！测试！测试！写好啦？快丢到服务器上面测试一下第二节的Plugin编译的jar放在plugins文件夹里第三节Core编译的jar放在之前类加载器指定的目录里我指定的是plugins/HyperPlugin/Core.jar 当然你也可以改但是别忘记改类加载器里的路径\n\n\n\n\n0021.png (68.94 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-7 00:01 上传\n\n\n\n\n\n\n\n\n\n0020.png (72.39 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-7 00:01 上传\n\n\n\n\n快把服务器run起来看一下\n\n\n\n\n0010.png (36.72 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-7 00:03 上传\n\n\n\n\n\n\n\n\n\n\n0011.png (18.29 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-7 00:03 上传\n\n\n\n\n\n\n\n\n\n\n0012.png (14.25 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-7 00:03 上传\n\n\n\n\n这里的顺序是onLoad->onEnable->reload->onDisable->onEnableonLoad后面的onEnable我没截图，反正都一样\n这里输出的内存地址都一样说明插件在reload前后实例没有变成功啦！嗷呜~\n\n\n插件源码\n这里IO工具和Reflect工具我也和源码一起丢出来了可以扒源码自己看\n如果有什么不明白的地方可以来问我啦 嗷呜~\n\n\n\n\nPLL.zip\n(29.91 KB, 下载次数: 4)\n\n\n\n2020-2-7 00:19 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n\n又是一篇不会有人看的没什么用的教程呢\n\n\n\n",
    "replies": [
        {
            "author": "Tds...",
            "timestamp": 1581006540,
            "txt_content": "虽然看不懂,但是留个爪！\n\n谢谢大佬的分享,收藏了,等我会了再来看！"
        },
        {
            "author": "mr2044154518",
            "timestamp": 1581006720,
            "txt_content": "支持支持支持"
        },
        {
            "author": "邓毅",
            "timestamp": 1583203620,
            "txt_content": "其实我有点看不懂"
        },
        {
            "author": "dousha0v0",
            "timestamp": 1583389380,
            "txt_content": "虽然真的看不懂 但是 楼主干巴爹！"
        },
        {
            "author": "pocketit",
            "timestamp": 1583391360,
            "txt_content": "        MCBBS有你更精彩?"
        },
        {
            "author": "KBlom",
            "timestamp": 1583473800,
            "txt_content": "顶                                  "
        }
    ]
}