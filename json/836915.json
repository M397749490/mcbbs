{
    "title": "自动旋转AxisAlignedBB－用于多方向方块",
    "author": "hnOsmium0001",
    "replyCount": 2,
    "timestamp": 1546835040,
    "txt_content": " 本帖最后由 hnOsmium0001 于 2019-1-9 08:23 编辑 \n\nMinecraft原版的台阶、漏斗都是手动计算了旋转过后的碰撞箱，非常的蛋疼+麻烦\nMinecraftForge 论坛有一个坏掉的方案，然后修改了一下（主要是在正数区域的方块碰撞箱旋转180度+会出问题）、\nhttp://www.minecraftforge.net/forum/topic/41536-1102aabbsolvedis-there-an-utility-method-to-rotate-an-aabb/\n\n适用于 MC 1.12.x 和 Java 8\n也许低版本能用，但是不保证\n\n\n\n原理\n\n其中TransformationUtils用来计算旋转矩阵（利用j avax.vecmath）虽然说有很多方法都用不上\n然后ExtendedAABB继承了原版的AxisAlignedBB，之后所有的代码里面用ExtendedAABB这个类就行了\n\nrotate方法调用后，先把自生移到origin\nthis.offset(-0.5d, -0.5d, -0.5d)复制代码\n因为大部分情况下碰撞想是在 (0, 0, 0) 到 (1, 1, 1)\n这样的话沿着origin的旋转矩阵就会把碰撞箱移到负数区域\n\n之后就是生成旋转矩阵，同时对较小顶点和较大顶点作变换\n\nVector3d min = new Vector3d(source.minX, source.minY, source.minZ);\nVector3d max = new Vector3d(source.maxX, source.maxY, source.maxZ);\ntransformation.transform(min);\ntransformation.transform(max);\n复制代码\n\n最后再\nthis.offset(0.5d, 0.5d, 0.5d)复制代码\n移动回正数区域\n\n\n\n用法在\n\nExtendedAABB#rotate(int x, int y, int z)\nExtendedAABB#rotate(Axis axis, int angle)\n复制代码\n的Javadoc里都有解释，另外提供一个基本用法:\n\n如果原来的AABB（碰撞箱）是朝上的话，\n朝下：\nbase.rotate(Axis.X, 180)复制代码\n朝东：\nbase.rotate(Axis.Z, -90)复制代码\n朝北：\nbase.rotate(Axis.X, -90)复制代码\n朝西：\nbase.rotate(Axis.Z, 90)复制代码\n朝南：\nbase.rotate(Axis.X, 90)复制代码\n\nAxis是net.minecraft.util.math.EnumFacing.Axis复制代码\n\n\n\n\nGithub Gists：https://gist.github.com/hnOsmium0001/fdc93d21e9f9e4b806d8a5bedd249ed8\n或者：\n\nimport net.minecraft.util.EnumFacing;\nimport net.minecraft.util.EnumFacing.Axis;\nimport net.minecraft.util.math.AxisAlignedBB;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.Vec3d;\n\nimport javax.vecmath.Matrix4d;\nimport javax.vecmath.Vector3d;\n\npublic class ExtendedAABB extends AxisAlignedBB {\n\n    public static ExtendedAABB from(AxisAlignedBB source) {\n        return new ExtendedAABB(source.minX, source.minY, source.minZ, source.maxX, source.maxY, source.maxZ);\n    }\n\n\n    public ExtendedAABB(double x1, double y1, double z1, double x2, double y2, double z2) {\n        super(x1, y1, z1, x2, y2, z2);\n    }\n\n    public ExtendedAABB(BlockPos pos) {\n        super(pos);\n    }\n\n    public ExtendedAABB(BlockPos pos1, BlockPos pos2) {\n        super(pos1, pos2);\n    }\n\n    public ExtendedAABB(Vec3d min, Vec3d max) {\n        super(min, max);\n    }\n\n    public ExtendedAABB(Vector3d min, Vector3d max) {\n        this(min.x, min.y, min.z, max.x, max.y, max.z);\n    }\n\n\n    /**\n     * Rotate the current ExtendedAABB on three different axis and return a new one if any of the parameters are nonzero.\n     *\n     * <p>\n     * When called, it will rotate the current ExtendedAABB on all three axis by a given degree one at a time, as <b><a\n     * >Right Hand Law in electromagnetism</a></b>:\n     * <p><q>\n     * The direction of a positive rotation is the direction of your fingers when the thumb is pointing towards the positive direction of\n     * the axis.\n     * </q></p>\n     * <p>Equivalent to apply the method {@link #rotate(EnumFacing.Axis, int)} three times on all X, Y, and Z axis.</p>\n     * </p>\n     *\n     * <h3>Example:</h3>\n     * <p>\n     * Given the current AABB describes an half box where the empty side is pointing {@link EnumFacing#UP up}<sup>1</sup>, a rotation of\n     * x=90 will make the empty side pointing to the {@link EnumFacing#SOUTH south}<sup>2</sup>.\n     * </p>\n     *\n     *\n     * <p>\n     * <hr/>\n     * <p><sup>1. {@link net.minecraft.util.EnumFacing.AxisDirection#POSITIVE positive} direction of {@link Axis#Y y axis}</sup></p>\n     * <p><sup>2. {@link net.minecraft.util.EnumFacing.AxisDirection#POSITIVE positive} direction of {@link Axis#Z z axis}</sup></p>\n     * </p>\n     *\n     * @param x The angle to rotate on x-axis, in degrees\n     * @param y The angle to rotate on y-axis, in degrees\n     * @param z The angle to rotate on z-axis, in degrees\n     * @return A new ExtendedAABB\n     */\n    public ExtendedAABB rotate(int x, int y, int z) {\n        Matrix4d rotationMat = TransformationUtils.combineTransformations(\n                TransformationUtils.getRotationMatrix(Axis.X, x),\n                TransformationUtils.getRotationMatrix(Axis.Y, y),\n                TransformationUtils.getRotationMatrix(Axis.Z, z));\n\n        return this.transformSelf(rotationMat, true);\n    }\n\n\n    /**\n     * Rotate the ExtendedAABB on the given axis at a given angle.\n     * <p>\n     * See {@link #rotate(int, int, int)} for more information and examples.\n     * </p>\n     *\n     * @param axis  The axis to rotate around\n     * @param angle The angle to rotate, in degrees.\n     * @return A new, rotated ExtendedAABB\n     * @see #rotate(int, int, int)\n     */\n    public ExtendedAABB rotate(Axis axis, int angle) {\n        if (angle == 0) {\n            return this;\n        }\n        return this.transformSelf(TransformationUtils.getRotationMatrix(axis, angle), true);\n    }\n\n\n    private ExtendedAABB transformSelf(Matrix4d transformation, boolean centralize) {\n        ExtendedAABB source = this;\n        if (centralize) {\n            source = this.offset(-0.5d, -0.5d, -0.5d);\n        }\n\n        Vector3d min = new Vector3d(source.minX, source.minY, source.minZ);\n        Vector3d max = new Vector3d(source.maxX, source.maxY, source.maxZ);\n        transformation.transform(min);\n        transformation.transform(max);\n\n        if (centralize) {\n            min.setX(min.x + 0.5d);\n            min.setY(min.y + 0.5d);\n            min.setZ(min.z + 0.5d);\n            max.setX(max.x + 0.5d);\n            max.setY(max.y + 0.5d);\n            max.setZ(max.z + 0.5d);\n        }\n        return new ExtendedAABB(min, max);\n    }\n\n\n    // =========================================================================//\n    // Override the return types of parent methods to make chain calling easier //\n    // =========================================================================//\n\n\n    @Override\n    public ExtendedAABB setMaxY(double y2) {\n        return from(super.setMaxY(y2));\n    }\n\n    @Override\n    public ExtendedAABB contract(double x, double y, double z) {\n        return from(super.contract(x, y, z));\n    }\n\n    @Override\n    public ExtendedAABB expand(double x, double y, double z) {\n        return from(super.expand(x, y, z));\n    }\n\n    @Override\n    public ExtendedAABB grow(double x, double y, double z) {\n        return from(super.grow(x, y, z));\n    }\n\n    @Override\n    public ExtendedAABB grow(double value) {\n        return from(super.grow(value));\n    }\n\n    @Override\n    public ExtendedAABB intersect(AxisAlignedBB other) {\n        return from(super.intersect(other));\n    }\n\n    @Override\n    public ExtendedAABB union(AxisAlignedBB other) {\n        return from(super.union(other));\n    }\n\n    @Override\n    public ExtendedAABB offset(double x, double y, double z) {\n        return from(super.offset(x, y, z));\n    }\n\n    @Override\n    public ExtendedAABB offset(BlockPos pos) {\n        return from(super.offset(pos));\n    }\n\n    @Override\n    public ExtendedAABB offset(Vec3d vec) {\n        return from(super.offset(vec));\n    }\n\n    @Override\n    public ExtendedAABB shrink(double value) {\n        return from(super.shrink(value));\n    }\n\n}\n复制代码\n\nimport net.minecraft.util.EnumFacing;\nimport net.minecraft.util.EnumFacing.Axis;\nimport net.minecraft.util.EnumFacing.AxisDirection;\nimport net.minecraft.util.math.Vec3i;\n\nimport javax.vecmath.AxisAngle4d;\nimport javax.vecmath.Matrix4d;\n\n\npublic class TransformationUtils {\n\n    public static Matrix4d createIdentityMatrix4d() {\n        Matrix4d identity = new Matrix4d();\n        identity.setIdentity();\n        return identity;\n    }\n\n    public static Matrix4d combineTransformations(Matrix4d... transformations) {\n        Matrix4d result = createIdentityMatrix4d();\n        for (Matrix4d transformation : transformations) {\n            result.mul(transformation);\n        }\n        return result;\n    }\n\n\n    public static Matrix4d getTranslationMatrix(double dx, double dy, double dz) {\n        Matrix4d translation = createIdentityMatrix4d();\n        // [ 1 0 0 dx ]\n        // | 0 1 0 dy |\n        // | 0 0 1 dz |\n        // [ 0 0 0 1  ]\n        translation.setM03(dx);\n        translation.setM13(dy);\n        translation.setM23(dz);\n        return translation;\n    }\n\n\n    public static Matrix4d getRotationMatrix(Axis axis, int degrees) {\n        return getRotationMatrix(axis, Math.toRadians(degrees));\n    }\n\n    public static Matrix4d getRotationMatrix(Axis axis, double radians) {\n        Matrix4d rotation = new Matrix4d();\n\n        Vec3i direction = EnumFacing.getFacingFromAxis(AxisDirection.POSITIVE, axis).getDirectionVec();\n        // Rotation matrix calculation is done in Matrix4d#set(AxisAngle4d), the object is just used\n        // to pass in parameters\n        rotation.set(new AxisAngle4d(direction.getX(), direction.getY(), direction.getZ(), radians));\n        return rotation;\n    }\n\n\n    public static Matrix4d getScalingMatrix(double scale) {\n        return getScalingMatrix(scale, scale, scale);\n    }\n\n    public static Matrix4d getScalingMatrix(double xs, double ys, double zs) {\n        Matrix4d scaling = createIdentityMatrix4d();\n        // [ xs 0  0  0 ]\n        // | 0  ys 0  0 |\n        // | 0  0  zs 0 |\n        // [ 0  0  0  1 ]\n        scaling.setM00(xs);\n        scaling.setM11(ys);\n        scaling.setM22(zs);\n        return scaling;\n    }\n\n}\n复制代码",
    "replies": [
        {
            "author": "1850343382",
            "timestamp": 1546835460,
            "txt_content": "貌似帖子贴出的代码中混入了一些莫名其妙的东西。"
        },
        {
            "author": "hnOsmium0001",
            "timestamp": 1546835760,
            "txt_content": "1850343382 发表于 2019-1-7 12:31\n貌似帖子贴出的代码中混入了一些莫名其妙的东西。\nhmmmmm\nIntelliJ复制过来的时候把一些神奇的东西也复制过来啦\n\nhttps://gist.github.com/hnOsmium0001/fdc93d21e9f9e4b806d8a5bedd249ed8\n"
        }
    ]
}