{
    "title": "当风过时的Block-GUI教程（2）-为方块添加它的功能",
    "author": "当风过时",
    "replyCount": 4,
    "timestamp": 1357452540,
    "txt_content": " 本帖最后由 当风过时 于 2013-6-22 20:53 编辑 \n\n由于一直在更新我的mod，所以一直没抽得出时间来写教程，现在终于有些时间来写了。上一个教程：http://www.mcbbs.net/thread-59702-1-1.html下一篇教程：http://www.mcbbs.net/thread-78145-1-1.html\n这次的教程是为方块增加新功能（自定义TileEntity的行为）。\n\n先进行TileEntity库存物品部分进行配置。\n库存的物品一般是存放在TileEntity。\n在rtTileEntityRepairTable引入IInventory接口，并自动修正，这时会新增了10个方法。\nIInventory是普通GUI显示的核心（合成表这种是奇葩），它是用于给Container识别的关键，之后会慢慢道来。\n把isUseableByPlayer的返回参数修改成true，使它的gui默认能被任何人打开。\n在rtTileEntityRepairTable里新增一个ItemStack的私有数组。这个数组将成为存放GUI中的物品的容器。\nprivate ItemStack stack[] = new ItemStack[3];\n修改decrStackSize方法，这个方法看注释是玩家取走物品时返回取走物品的参数，这个地方直接复制熔炉的就好了。\n将熔炉的代码复制过来并稍稍修改后我们就得到下面的代码。@Override\n        public ItemStack decrStackSize(int par1, int par2) {\n                // TODO Auto-generated method stub\n                if (this.stack[par1] != null)\n        {\n            ItemStack var3;\n\n            if (this.stack[par1].stackSize <= par2)\n            {\n                var3 = this.stack[par1];\n                this.stack[par1] = null;\n                return var3;\n            }\n            else\n            {\n                var3 = this.stack[par1].splitStack(par2);\n\n                if (this.stack[par1].stackSize == 0)\n                {\n                    this.stack[par1] = null;\n                }\n\n                return var3;\n            }\n        }\n        else\n        {\n            return null;\n        }\n        }复制代码\ngetInvName是库存的名称，一般没什么大作用，我们跳过。\ngetInventoryStackLimit获取库存中单个物品栈最大数量，这里先设置成64，虽然之后我们可以手动设定- -\ngetSizeInventory获取最大库存，我们返回之前的stack的最大数量。\ngetStackInSlot取得槽（库存）中的物品栈，这个是在定义TileEntity行为的关键之一，我们在update中药经常调整库存的物品，一般就通过这个。参数是槽的编号。\nreturn stack[var1];\ngetStackInSlotOnClosing在关闭GUI时的动作，这个我们用不到，像合成台就用到了，关闭时抛出没用到的物品。\nsetInventorySlotContents设置槽（库存）中的内容（物品栈），这个也是在定义TileEntity行为的关键之一。参数1是槽的编号，参数2是要设置的物品栈\n同样，直接复制熔炉的XD\n                       this.stack[var1] = var2;\n        if (var2 != null && var2.stackSize > this.getInventoryStackLimit())\n        {\n                var2.stackSize = this.getInventoryStackLimit();\n        }复制代码现在基础的TileEntity配置完了\n\n之后是配置Container\n在Container的构造函数中加入\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 0, 49, 19));\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 1, 112, 19));\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 2, 80, 54));\n              int var3;\n              for (var3 = 0; var3 < 3; ++var3)\n              {\n                  for (int var4 = 0; var4 < 9; ++var4)\n                  {\n                      this.addSlotToContainer(new Slot(par1InventoryPlayer, var4 + var3 * 9 + 9, 8 + var4 * 18, 84 + var3 * 18));\n                  }\n              }\n\n              for (var3 = 0; var3 < 9; ++var3)\n              {\n                  this.addSlotToContainer(new Slot(par1InventoryPlayer, var3, 8 + var3 * 18, 142));\n              }复制代码Slot，槽（暂时这么翻译吧。。。），用于存放物品栈最基本的类，它需要输入IInventory作为显示的内容，第一个参数是IInventory，第二个参数是ID，对应第一个参数，即取得第一个参数对应ID的内容，第三个参数是显示的X坐标，第四个是参数是显示的Y坐标。\n在之前的TileEntity中引入了IInventory就是为这个槽做准备的，在加入的代码中引入玩家的Inventory是为了显示玩家的库存。\naddSlotToContainer是给Container添加入槽。前三个是对应TileEntity的物品槽，后面那些是玩家的物品槽。\n\n加入这个后，我们就可以往GUI中放置物品了，效果如下：\n\n\n\n\n\n2013-01-06_12.21.27.png (108.77 KB, 下载次数: 8)\n\n下载附件\n\n2013-1-6 13:57 上传\n\n\n\n\n\n\n接下来是定义TileEntity的动作。\n修复台mod定义的功能是将损坏的物品用高温修复，在程序中就是用燃料来修复物品（虽然感觉挺bug的。。。），有这个设定后我们就开始制作这个功能了。\n首先要有记录燃烧时间、最大燃烧时间的变量\npublic int tableBurnTime = 0;\npublic int maxBurnTime = 0;复制代码然后对这个方块的数据的读取\\保存的方法进行覆写，对readFromNBT和writeToNBT进行覆写。我们需要保存燃烧时间，最大燃烧时间以及存放着的物品。\n同样，直接复制熔炉的复制过来修改一下就好了。\npublic void readFromNBT(NBTTagCompound par1NBTTagCompound)\n    {\n        super.readFromNBT(par1NBTTagCompound);\n        NBTTagList var2 = par1NBTTagCompound.getTagList(\"Items\");\n        this.stack = new ItemStack[this.getSizeInventory()];\n        for (int var3 = 0; var3 < var2.tagCount(); ++var3)\n        {\n            NBTTagCompound var4 = (NBTTagCompound)var2.tagAt(var3);\n            byte var5 = var4.getByte(\"Slot\");\n            if (var5 >= 0 && var5 < this.stack.length)\n            {\n                this.stack[var5] = ItemStack.loadItemStackFromNBT(var4);\n            }\n        }\n        this.tableBurnTime = par1NBTTagCompound.getShort(\"tableBurnTime\");\n        this.maxBurnTime = par1NBTTagCompound.getShort(\"maxBurnTime\");\n    }\n\n    public void writeToNBT(NBTTagCompound par1NBTTagCompound)\n    {\n        super.writeToNBT(par1NBTTagCompound);\n        par1NBTTagCompound.setShort(\"tableBurnTime\", (short)this.tableBurnTime);\n        par1NBTTagCompound.setShort(\"maxBurnTime\", (short)this.maxBurnTime);\n        NBTTagList var2 = new NBTTagList();\n        for (int var3 = 0; var3 < this.stack.length; ++var3)\n        {\n            if (this.stack[var3] != null)\n            {\n                NBTTagCompound var4 = new NBTTagCompound();\n                var4.setByte(\"Slot\", (byte)var3);\n                this.stack[var3].writeToNBT(var4);\n                var2.appendTag(var4);\n            }\n        }\n        par1NBTTagCompound.setTag(\"Items\", var2);\n    }复制代码然后是准备取得各种燃料的热值的方法，复制熔炉XD\npublic static int getItemBurnTime(ItemStack par0ItemStack)\n    {\n        if (par0ItemStack == null)\n        {\n            return 0;\n        }\n        else\n        {\n            int var1 = par0ItemStack.getItem().shiftedIndex;\n            Item var2 = par0ItemStack.getItem();\n\n            if (par0ItemStack.getItem() instanceof ItemBlock && Block.blocksList[var1] != null)\n            {\n                Block var3 = Block.blocksList[var1];\n\n                if (var3 == Block.woodSingleSlab)\n                {\n                    return 150;\n                }\n\n                if (var3.blockMaterial == Material.wood)\n                {\n                    return 300;\n                }\n            }\n            if (var2 instanceof ItemTool && ((ItemTool) var2).getToolMaterialName().equals(\"WOOD\")) return 200;\n            if (var2 instanceof ItemSword && ((ItemSword) var2).func_77825_f().equals(\"WOOD\")) return 200;\n            if (var2 instanceof ItemHoe && ((ItemHoe) var2).func_77842_f().equals(\"WOOD\")) return 200;\n            if (var1 == Item.stick.shiftedIndex) return 100;\n            if (var1 == Item.coal.shiftedIndex) return 1600;\n            if (var1 == Item.bucketLava.shiftedIndex) return 20000;\n            if (var1 == Block.sapling.blockID) return 100;\n            if (var1 == Item.blazeRod.shiftedIndex) return 2400;\n            return GameRegistry.getFuelValue(par0ItemStack);\n        }\n    }复制代码有了上面各种方法之后，我们就可以开始对updateEntity进行重写了。\n// 判断燃烧时间\n            if(tableBurnTime > 0)\n            {\n                    // 取得修复的物品\n                    ItemStack repairItem = getStackInSlot(0);\n                    // 取得修复好的物品\n                    ItemStack outputItem = getStackInSlot(1);\n                    // 确定开始修复的条件之一：修复物品槽不为空，已修复物品槽为空\n                    if(repairItem != null && outputItem == null)\n                    {\n                            // 判断被修复的物品是否为工具或武器\n                            if(repairItem.getItem() instanceof ItemTool || repairItem.getItem() instanceof ItemArmor)\n                            {\n                                    // 判断物品是否要修理\n                                    if(repairItem.getItemDamage() > 0)\n                                    {\n                                            // 修复物品\n                                            repairItem.setItemDamage(repairItem.getItemDamage() - 1);\n                                    }\n                            }\n                    }\n                    // 减少燃烧时间\n                    tableBurnTime -= 1;\n            }\n            else // 没有燃料的情况下\n            {\n                    // 如果有被修复的物品\n                    if(getStackInSlot(0) != null)\n                    {\n                            // 取得燃料槽的物品\n                            ItemStack burnItem = getStackInSlot(2);\n                            // 取得物品的燃烧值\n                        int getBurnTime = getItemBurnTime(burnItem);\n                        // 判断物品是否能燃烧\n                        if(getBurnTime > 0)\n                        {\n                                maxBurnTime = getBurnTime;\n                                tableBurnTime = getBurnTime;\n                                // 如果燃烧物品为岩浆桶\n                                if(burnItem.getItem().shiftedIndex == Item.bucketLava.shiftedIndex)\n                                {\n                                        // 取得空桶\n                                        setInventorySlotContents(2, new ItemStack(Item.bucketEmpty, 1));\n                                }\n                                else\n                                {\n                                        // 其他物品就减少\n                                        if(burnItem.stackSize - 1 > 0)\n                                        {\n                                                burnItem.stackSize--;\n                                                setInventorySlotContents(2, burnItem);\n                                        }\n                                        else\n                                        {\n                                                setInventorySlotContents(2, null);\n                                        }\n                                }\n                        }\n                    }\n            }复制代码完成这步后就可以测试看到我们的修复台对装备和武器的修复了。\n完成这步后的源码，因为这次只更新了两个文件，所以就只贴出这两个的文件的源码了（其实我很懒- -）rtTileEntityRepairTable.java\n\npackage net.minecraft.src;\n\nimport cpw.mods.fml.common.registry.GameRegistry;\n \npublic class rtTileEntityRepairTable extends TileEntity implements IInventory{\n        private ItemStack stack[] = new ItemStack[3];\n        public int tableBurnTime = 0;\n    public int maxBurnTime = 0;\n    @Override\n    public void updateEntity() {\n            // TODO Auto-generated method stub\n            // 判断燃烧时间\n            if(tableBurnTime > 0)\n            {\n                    // 取得修复的物品\n                    ItemStack repairItem = getStackInSlot(0);\n                    // 取得修复好的物品\n                    ItemStack outputItem = getStackInSlot(1);\n                    // 确定开始修复的条件之一：修复物品槽不为空，已修复物品槽为空\n                    if(repairItem != null && outputItem == null)\n                    {\n                            // 判断被修复的物品是否为工具或武器\n                            if(repairItem.getItem() instanceof ItemTool || repairItem.getItem() instanceof ItemArmor)\n                            {\n                                    // 判断物品是否要修理\n                                    if(repairItem.getItemDamage() > 0)\n                                    {\n                                            // 修复物品\n                                            repairItem.setItemDamage(repairItem.getItemDamage() - 1);\n                                    }\n                            }\n                    }\n                    // 减少燃烧时间\n                    tableBurnTime -= 1;\n            }\n            else // 没有燃料的情况下\n            {\n                    // 如果有被修复的物品\n                    if(getStackInSlot(0) != null)\n                    {\n                            // 取得燃料槽的物品\n                            ItemStack burnItem = getStackInSlot(2);\n                            // 取得物品的燃烧值\n                        int getBurnTime = getItemBurnTime(burnItem);\n                        // 判断物品是否能燃烧\n                        if(getBurnTime > 0)\n                        {\n                                maxBurnTime = getBurnTime;\n                                tableBurnTime = getBurnTime;\n                                // 如果燃烧物品为岩浆桶\n                                if(burnItem.getItem().shiftedIndex == Item.bucketLava.shiftedIndex)\n                                {\n                                        // 取得空桶\n                                        setInventorySlotContents(2, new ItemStack(Item.bucketEmpty, 1));\n                                }\n                                else\n                                {\n                                        // 其他物品就减少\n                                        if(burnItem.stackSize - 1 > 0)\n                                        {\n                                                burnItem.stackSize--;\n                                                setInventorySlotContents(2, burnItem);\n                                        }\n                                        else\n                                        {\n                                                setInventorySlotContents(2, null);\n                                        }\n                                }\n                        }\n                    }\n            }\n    }\n    public static int getItemBurnTime(ItemStack par0ItemStack)\n    {\n        if (par0ItemStack == null)\n        {\n            return 0;\n        }\n        else\n        {\n            int var1 = par0ItemStack.getItem().shiftedIndex;\n            Item var2 = par0ItemStack.getItem();\n\n            if (par0ItemStack.getItem() instanceof ItemBlock && Block.blocksList[var1] != null)\n            {\n                Block var3 = Block.blocksList[var1];\n\n                if (var3 == Block.woodSingleSlab)\n                {\n                    return 150;\n                }\n\n                if (var3.blockMaterial == Material.wood)\n                {\n                    return 300;\n                }\n            }\n            if (var2 instanceof ItemTool && ((ItemTool) var2).getToolMaterialName().equals(\"WOOD\")) return 200;\n            if (var2 instanceof ItemSword && ((ItemSword) var2).func_77825_f().equals(\"WOOD\")) return 200;\n            if (var2 instanceof ItemHoe && ((ItemHoe) var2).func_77842_f().equals(\"WOOD\")) return 200;\n            if (var1 == Item.stick.shiftedIndex) return 100;\n            if (var1 == Item.coal.shiftedIndex) return 1600;\n            if (var1 == Item.bucketLava.shiftedIndex) return 20000;\n            if (var1 == Block.sapling.blockID) return 100;\n            if (var1 == Item.blazeRod.shiftedIndex) return 2400;\n            return GameRegistry.getFuelValue(par0ItemStack);\n        }\n    }\n    public void readFromNBT(NBTTagCompound par1NBTTagCompound)\n    {\n        super.readFromNBT(par1NBTTagCompound);\n        NBTTagList var2 = par1NBTTagCompound.getTagList(\"Items\");\n        this.stack = new ItemStack[this.getSizeInventory()];\n        for (int var3 = 0; var3 < var2.tagCount(); ++var3)\n        {\n            NBTTagCompound var4 = (NBTTagCompound)var2.tagAt(var3);\n            byte var5 = var4.getByte(\"Slot\");\n\n            if (var5 >= 0 && var5 < this.stack.length)\n            {\n                this.stack[var5] = ItemStack.loadItemStackFromNBT(var4);\n            }\n        }\n        this.tableBurnTime = par1NBTTagCompound.getShort(\"tableBurnTime\");\n        this.maxBurnTime = par1NBTTagCompound.getShort(\"maxBurnTime\");\n    }\n    \n    public void writeToNBT(NBTTagCompound par1NBTTagCompound)\n    {\n        super.writeToNBT(par1NBTTagCompound);\n        par1NBTTagCompound.setShort(\"tableBurnTime\", (short)this.tableBurnTime);\n        par1NBTTagCompound.setShort(\"maxBurnTime\", (short)this.maxBurnTime);\n        NBTTagList var2 = new NBTTagList();\n        for (int var3 = 0; var3 < this.stack.length; ++var3)\n        {\n            if (this.stack[var3] != null)\n            {\n                NBTTagCompound var4 = new NBTTagCompound();\n                var4.setByte(\"Slot\", (byte)var3);\n                this.stack[var3].writeToNBT(var4);\n                var2.appendTag(var4);\n            }\n        }\n        par1NBTTagCompound.setTag(\"Items\", var2);\n    }\n        @Override\n        public void closeChest() {\n                // TODO Auto-generated method stub\n                \n        }\n\n        @Override\n        public ItemStack decrStackSize(int par1, int par2) {\n                // TODO Auto-generated method stub\n                if (this.stack[par1] != null)\n        {\n            ItemStack var3;\n\n            if (this.stack[par1].stackSize <= par2)\n            {\n                var3 = this.stack[par1];\n                this.stack[par1] = null;\n                return var3;\n            }\n            else\n            {\n                var3 = this.stack[par1].splitStack(par2);\n\n                if (this.stack[par1].stackSize == 0)\n                {\n                    this.stack[par1] = null;\n                }\n\n                return var3;\n            }\n        }\n        else\n        {\n            return null;\n        }\n        }\n\n        @Override\n        public String getInvName() {\n                // TODO Auto-generated method stub\n                return \"Repair Table\";\n        }\n\n        @Override\n        public int getInventoryStackLimit() {\n                // TODO Auto-generated method stub\n                return 64;\n        }\n\n        @Override\n        public int getSizeInventory() {\n                // TODO Auto-generated method stub\n                return stack.length;\n        }\n\n        @Override\n        public ItemStack getStackInSlot(int var1) {\n                // TODO Auto-generated method stub\n                return stack[var1];\n        }\n\n        @Override\n        public ItemStack getStackInSlotOnClosing(int var1) {\n                // TODO Auto-generated method stub\n                return null;\n        }\n\n        @Override\n        public boolean isUseableByPlayer(EntityPlayer var1) {\n                // TODO Auto-generated method stub\n                return true;\n        }\n\n        @Override\n        public void openChest() {\n                // TODO Auto-generated method stub\n                \n        }\n\n        @Override\n        public void setInventorySlotContents(int var1, ItemStack var2) {\n                // TODO Auto-generated method stub\n                this.stack[var1] = var2;\n\n        if (var2 != null && var2.stackSize > this.getInventoryStackLimit())\n        {\n                var2.stackSize = this.getInventoryStackLimit();\n        }\n        }\n \n}复制代码\n\nrtContainerRepairTable.java\npackage net.minecraft.src;\n \npublic class rtContainerRepairTable extends Container{\n       private rtTileEntityRepairTable tile;\n       public rtContainerRepairTable(InventoryPlayer par1InventoryPlayer, rtTileEntityRepairTable par2TileEntityRepairTable)\n       {\n              tile = par2TileEntityRepairTable;\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 0, 49, 19));\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 1, 112, 19));\n              this.addSlotToContainer(new Slot(par2TileEntityRepairTable, 2, 80, 54));\n              int var3;\n              for (var3 = 0; var3 < 3; ++var3)\n              {\n                  for (int var4 = 0; var4 < 9; ++var4)\n                  {\n                      this.addSlotToContainer(new Slot(par1InventoryPlayer, var4 + var3 * 9 + 9, 8 + var4 * 18, 84 + var3 * 18));\n                  }\n              }\n\n              for (var3 = 0; var3 < 9; ++var3)\n              {\n                  this.addSlotToContainer(new Slot(par1InventoryPlayer, var3, 8 + var3 * 18, 142));\n              }\n       }\n       @Override\n       public boolean canInteractWith(EntityPlayer var1) {\n              // TODO Auto-generated method stub\n              return true;\n       }\n \n}复制代码\n不过现在还不算完成，只是实现了它的基本功能，还有后续的辅助功能需要做，比如：数据同步，进度条的描绘。下一个教程就会说明。\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "zesty",
            "timestamp": 1357453380,
            "txt_content": "非常不错的原创教程，支持！"
        },
        {
            "author": "hendyzone",
            "timestamp": 1357457220,
            "txt_content": "路过帮顶{:10_512:}"
        },
        {
            "author": "52Dora",
            "timestamp": 1357469520,
            "txt_content": "看到标题我还以为是已经过时的Mod教程..."
        },
        {
            "author": "wanghh",
            "timestamp": 1357475160,
            "txt_content": " 本帖最后由 wanghh 于 2013-1-6 20:26 编辑 \n52Dora 发表于 2013-1-6 18:52 \n看到标题我还以为是已经过时的Mod教程...\n严重同意啊！我当时以为lz叫做当风"
        }
    ]
}