{
    "title": "[搬运+翻译][从零学编程]Python3Ⅳ：异常 & 文件",
    "author": "45gfg9",
    "replyCount": 3,
    "timestamp": 1584582060,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-20 09:40 编辑 \n\n索引贴\n答案帖\nPrev: Python3Ⅲ：函数 & 模块\nNext: Python3Ⅴ：更多类型\n\n\n1 异常\n\n1.1 异常（一）\n\n你之前已经见过[ruby=exceptions]异常[/ruby]了。如果你的代码出事，例如运行不正确的代码或处理不正确的输入时，就会产生异常，程序立即停止。\n下面的代码通过尝试计算7 / 0来产生一个ZeroDivisionError。\nnum1 = 7\nnum2 = 0\nprint(num1/num2)\n输出：\n>>>\nZeroDivisionError: division by zero\n>>>\n\nPart题：\n异常是什么？\nA. 变量\nB. 程序出错时产生的事件\nC. 函数\n\n1.2 异常（二）\n\n由于不同的出错原因，会产生不同的异常。\n常见的异常有：\nImportError：导入失败\nIndexError：访问列表时索引越界\nNameError：使用了未知的变量名\nSyntaxError：代码不能被正确解析\nTypeError：调用函数时传递了不恰当类型的值\nValueError：调用函数时传递了恰当类型但有不恰当的值的值\nPython还有一些内置异常，例如ZeroDivisionError和OSError。第三方库也常常定义自己的异常。\nPart题：\n下面代码会跑出什么异常？\nprint(\"7\" + 4)\nA. ValueError\nB. TypeError\nC. ZeroDivisionError\n\n\n2 异常处理\n\n2.1 异常处理（一）\n\n若要处理异常，或在发生异常时执行特定代码，你可以用try/except语句。\ntry语句块包含着可能会抛出某种异常的代码。如果那种异常发生了，try代码块停止执行，转而执行except代码块。如果异常没有发生，那么except代码块不会运行。\n举例：\ntry:\n   num1 = 7\n   num2 = 0\n   print (num1 / num2)\n   print(\"Done calculation\")\nexcept ZeroDivisionError:\n   print(\"An error occurred\")\n   print(\"due to zero division\")\n结果：\n>>>\nAn error occurred\ndue to zero division\n>>>\n上面的代码中，except语句标明了要处理的异常类型（本例中是ZeroDivisionError）。\nPart题：\n下面代码的输出是？\ntry:\n  variable = 10\n  print (10 / 2)\nexcept ZeroDivisionError:\n  print(\"Error\")\nprint(\"Finished\")\nA.\nError\nFinished\nB.\n5.0\nC.\n5.0\nFinished\n\n\n2.2 异常处理（二）\n\n一个try语句可以有几个except语句来处理不同的异常。\n一个except语句也可以处理多种异常，通过将异常列表写进括号内。\ntry:\n   variable = 10\n   print(variable + \"hello\")\n   print(variable / 2)\nexcept ZeroDivisionError:\n   print(\"Divided by zero\")\nexcept (ValueError, TypeError):\n   print(\"Error occurred\")\n结果：\n>>>\nError occurred\n>>>\n\nPart题：\n下面代码的输出是？\ntry:\n  meaning = 42\n  print(meaning / 0)\n  print(\"the meaning of life\")\nexcept (ValueError, TypeError):\n  print(\"ValueError or TypeError occurred\")\nexcept ZeroDivisionError:\n  print(\"Divided by zero\")\nA.\nDivided by zero\nValueError or TypeError occurred\nB.\nValueError or TypeError occurred\nC.\nDivided by zero\n\n\n2.3 异常处理（三）\n\n一个不标注异常类型的except语句会处理所有异常。应该少用这种语法，因为有时这会捕获未预料到的异常并掩盖出现的错误。\n举例：\ntry:\n   word = \"spam\"\n   print(word / 0)\nexcept:\n   print(\"An error occurred\")\n输出：\n>>>\nAn error occurred\n>>>\n异常处理在与用户输入打交道时往往会很有用。\nPart题：\n填空以处理所有可能的异常。\n____\n  num1 = input(\":\")\n  num2 = input(\":\")\n  print(float(num1)/float(num2))\n_______\n  print(\"Invalid input\")\n\n\n\n3 finally\n\n3.1 finally（一）\n\n如果要保证某些代码不管有没有异常都要运行，可以使用finally语句。finally语句置于try/except语句的最后。finally代码块会在try代码块或except代码块执行后执行。\ntry:\n   print(\"Hello\")\n   print(1 / 0)\nexcept ZeroDivisionError:\n   print(\"Divided by zero\")\nfinally:\n   print(\"This code will run no matter what\")\n输出：\n>>>\nHello\nDivided by zero\nThis code will run no matter what\n>>>\n\nPart题：\n下面代码的输出是？\ntry:\n  print(1)\nexcept:\n  print(2)\nfinally:\n  print(3)\nA.\n3\nB.\n1\n3\nC.\n1\n2\n3\nD.\n1\n\n\n3.2 finally（二）\n\n即使之前有一个未被捕获的异常发生，finally代码块也会运行。\ntry:\n   print(1)\n   print(10 / 0)\nexcept ZeroDivisionError:\n   print(unknown_var)\nfinally:\n   print(\"This is executed last\")\n结果\n>>>\n1\nThis is executed last\n\nZeroDivisionError: division by zero\nDuring handling of the above exception, another exception occurred:\nNameError: name 'unknown_var' is not defined\n>>>\n\nPart题：\n用选项填空，组成一个完整的try/except/finally块。\n______\n  print(1)\n______\n  print(2)\n______\n  print(42)\ntry:        finally:        except:\n\n\n4 抛出异常\n\n4.1 抛出异常（一）\n\n用raise语句抛出异常。\nprint(1)\nraise ValueError\nprint(2)\n输出\n>>>\n1\nValueError\n>>>\n你必须指出要抛出的异常类型。\nPart题：\n下面的代码会产生什么错误？\ntry:\n  print(1 / 0)\nexcept ZeroDivisionError:\n  raise ValueError\nA. 没有\nB. ValueError\nC. ZeroDivisionError\nD. ZeroDivisionError和ValueError\n\n4.2 抛出异常（二）\n\n异常可以带着一些描述信息被抛出。例\nname = \"123\"\nraise NameError(\"Invalid name!\")\n输出\n>>>\nNameError: Invalid name!\n>>>\n\nPart题：\n填空，如果输入是负数，就抛出一个ValueError异常。\nnum = input(\":\")\nif float(num) _ 0:\n  _____ ValueError(\"Negative!\")\n\n\n4.3 抛出异常（三）\n\n在except块中，可以不加参数的使用raise语句来重抛出任意它捕获的异常。\n举例：\ntry:\n   num = 5 / 0\nexcept:\n   print(\"An error occurred\")\n   raise\n结果：\n>>>\nAn error occurred\n\nZeroDivisionError: division by zero\n>>>\n\nPart题：\n在except块之外能使用raise语句么？\n\n\n5 断言\n\n5.1 断言（一）\n\n[ruby=assertion]断言[/ruby]是一种合理性检查，你可以在测试完程序后启用或关闭。\n先测试一个表达式，如果结果为假，就抛出异常。\n断言用assert语句来执行。\nprint(1)\nassert 2 + 2 == 4\nprint(2)\nassert 1 + 1 == 3\nprint(3)\n结果：\n>>>\n1\n2\nAssertionError\n>>>\n程序员常在函数起始放置断言检验输入是否有效，并在调用函数后检测输出是否有效。\nPart题：\n下面代码输出的最大数是？\nprint(0)\nassert \"h\" != \"w\"\nprint(1)\nassert False\nprint(2)\nassert True\nprint(3)\n\n\n5.2 断言（二）\n\nassert可以有第二个参数，当断言失败时作为实参传递给AssertionError。\ntemp = -10\nassert (temp >= 0), \"Colder than absolute zero!\"\n输出\n>>>\nAssertionError: Colder than absolute zero!\n>>>\nAssertionError与任何其他异常一样可以用try-except语句捕获，但如果不处理的话，它会中止程序执行。\nPart题：\n填空定义一个有一个参数的函数。断言这个参数必须是正数。\n___ my_func(x):\n  ______ x > 0, \"Error!\"\n  print(x)\n\n\n\n6 打开文件\n\n6.1 打开文件（一）\n\n你可以用Python读写文件内容。\n文本文件是最容易操作的。但在编辑文件之前，我们必须先用open函数打开一个文件。\nmyfile = open(\"filename.txt\")\nopen函数的参数是文件的路径。如果文件在当前程序路径下，你可以只写文件名。\nPart题：\n哪个函数用来访问文件？\n\n6.2 打开文件（二）\n\n你可以在open函数的第二个参数中指定打开文件的模式。\n\n传入\"r\"代表将文件以读取方式打开。这是默认值。\n传入\"w\"代表将文件以写入模式打开，这会覆写文件。\n传入\"a\"代表追加模式，在文件末尾加入新内容。\n\n模式后加\"b\"将文件以二进制模式打开，用来操作非文本文件（例如图像或音频文件）。\n举例：\n# 写模式\nopen(\"filename.txt\", \"w\")\n\n# 读模式\nopen(\"filename.txt\", \"r\")\nopen(\"filename.txt\")\n\n# 二进制写模式\nopen(\"filename.txt\", \"wb\")\n在上面的模式中用+号会赋予对文件额外的操作权限。例如，r+将文件以读写模式打开。\nPart题：\n用选项填空，以二进制读模式打开\"test.bin\"文件。\nfile = open(______, ______)\n\"w\"        \"r\"        \"b\"        \"rb\"        \"test.bin\"        \"test.txt\"\n\n6.3 打开文件（三）\n\n打开并操作文件后，你应该记得关闭它。\n用文件对象的close方法这么做。\nfile = open(\"filename.txt\", \"w\")\n# do stuff to the file\nfile.close()\n之后会讲如何读写文件内容。\nPart题：\n如何关闭文件对象text_file？\nA. text_file.close()\nB. close(text_file)\nC. close(\"text_file\")\n\n\n7 读取文件\n\n7.1 读取文件（一）\n\n以读模式打开的文件的内容可以用read方法读取。\nfile = open(\"filename.txt\", \"r\")\ncont = file.read()\nprint(cont)\nfile.close()\n这会输出\"filename.txt\"文件的内容。\nPart题：\n重排下列代码，打开文件，读取并输出文件内容，之后关闭文件。\n1. file = open(\"test.txt\")\n2. cont = file.read()\n3. file.close()\n4. print(cont)\n\n\n7.2 读取文件（二）\n\n 若要定量读取文件，你可以给read方法提供一个数作为参数。这会决定要读取的字节数。\n你可以对同一个文件对象调用很多次read来逐字节读取文件。不加参数时，read返回所有剩余的文件内容。\nfile = open(\"filename.txt\", \"r\")\nprint(file.read(16))\nprint(file.read(4))\nprint(file.read(4))\nprint(file.read())\nfile.close()\n传递负数参数与不传递参数一样，返回剩余的所有内容。\nPart题：\n如果每个字符为一字节，下面的代码每一行会输出几个字符？\nfile = open(\"filename.txt\", \"r\")\nfor i in range(21):\n  print(file.read(4))\nfile.close()\n\n\n7.3 读取文件（三）\n\n如果所有的文件内容都读取完了，任何继续尝试从文件读取的行为会返回空字符串，因为你尝试从文件末读内容。\nfile = open(\"filename.txt\", \"r\")\nfile.read()\nprint(\"Re-reading\")\nprint(file.read())\nprint(\"Finished\")\nfile.close()\n结果：\n>>>\nRe-reading\n\nFinished\n>>>\n与不传参一样，负参数返回所有内容。\nPart题：\n填空打开文件，读取其内容并输出内容长度。\nfile = ____ (\"filename.txt\", \"r\")\nstr = file.____()\nprint(len(str))\nfile.close()\n\n\n7.4 读取文件（四）\n\n若要读取文件的每一行，可以用readlines方法返回一个列表，列表元素是文件的每一行内容。\n举例：\nfile = open(\"filename.txt\", \"r\")\nprint(file.readlines())\nfile.close()\n结果：\n>>>\n['Line 1 text \\n', 'Line 2 text \\n', 'Line 3 text']\n>>>\n你也可以用一个for循环迭代文件每行的内容。\nfile = open(\"filename.txt\", \"r\")\n\nfor line in file:\n    print(line)\n\nfile.close()\n结果：\n>>>\nLine 1 text\n\nLine 2 text\n\nLine 3 text\n>>>\n在输出中，每一行又被一个空行所隔开，因为print函数在输出后又会添加一个换行。\nPart题：\n如果file.txt文件有7行，那么下面的表达式返回什么？\nlen(open(\"test.txt\").readlines())\n\n\n\n8 写入文件\n\n8.1 写入文件（一）\n\n用write方法可以将一个字符串写入文件。\n例：\nfile = open(\"newfile.txt\", \"w\")\nfile.write(\"This has been written to a file\")\nfile.close()\n\nfile = open(\"newfile.txt\", \"r\")\nprint(file.read())\nfile.close()\n结果：\n>>>\nThis has been written to a file\n>>>\n如果文件不存在，\"w\"模式会创建它。\nPart题：\n哪一行会将\"Hello world!\"写入文件？\nA. write(file, \"Hello world!\")\nB. file.write(\"Hello world!\")\nC. write(\"Hello world!\", file)\n\n8.2 写入文件（二）\n\n当文件以写模式打开时，现有文件的内容会被删除。\nfile = open(\"newfile.txt\", \"r\")\nprint(\"Reading initial contents\")\nprint(file.read())\nprint(\"Finished\")\nfile.close()\n\nfile = open(\"newfile.txt\", \"w\")\nfile.write(\"Some new text\")\nfile.close()\n\nfile = open(\"newfile.txt\", \"r\")\nprint(\"Reading new contents\")\nprint(file.read())\nprint(\"Finished\")\nfile.close()\n输出\n>>>\nReading initial contents\nsome initial text\nFinished\nReading new contents\nSome new text\nFinished\n>>>\n如你所见，文件内容被覆写了。\nPart题：\n如果将一个文件以读模式打开后立即关闭会怎么样？\nA. 文件被写入一个空行\nB. 文件内容被删除\nC. 无事发生\n\n8.3 写入文件（三）\n\nwrite方法调用成功时返回实际写入的字节数。\nmsg = \"Hello world!\"\nfile = open(\"newfile.txt\", \"w\")\namount_written = file.write(msg)\nprint(amount_written)\nfile.close()\n输出：\n>>>\n12\n>>>\n若要写入非字符串对象，你需要先将其转换为字符串。\nPart题：\n如果一次文件写入操作成功，下面哪个语句会计算为真？\nA. file.write(msg) == True\nB. file.write(msg) == msg\nC. file.write(msg) == len(msg)\n\n\n9 运用文件\n\n9.1 运用文件（一）\n\n使用文件后永远关闭文件以防止资源浪费是好习惯。一种方法是用try和finally。\ntry:\n   f = open(\"filename.txt\")\n   print(f.read())\nfinally:\n   f.close()\n这会保证即使有错误发生，文件也会被关闭。\nPart题：\n下面代码中会调用close()方法吗？\ntry:\n  f = open(\"filename.txt\")\n  print(f.read())\n  print(1 / 0)\nfinally:\n  f.close()\n\n\n9.2 运用文件（二）\n\n另一种方法使用with语句。这会创建一个临时变量（通常叫f），只在with语句块内能访问。\nwith open(\"filename.txt\") as f:\n   print(f.read())\n在with块执行结束后，即使出错，文件也会被自动关闭。\nPart题：\n填空创建一个有效的with语句块，并读取文件内容。\n____ open(\"test.txt\") __ f:\n  print(f.____())\n\n\n期末考试\n\n1. 下面代码不会输出哪个数字？\ntry:\n  print(1)\n  print(20 / 0)\n  print(2)\nexcept ZeroDivisionError:\n  print(3)\nfinally:\n  print(4)\nA. 2\nB. 3\nC. 4\n\n2. 将文件以二进制读模式打开。\nopen(\"test.txt\", \"w_\")\n\n3. 填空尝试打开并读取文件。若有异常产生，输出错误信息。\ntry:\n  ____ open(\"test.txt\") as _:\n    print(f.read())\n_______\n  print(\"Error\")\n\n4. 下面代码输出的最大数是？\ntry:\n  print(1)\n  assert 2 + 2 == 5\nexcept AssertionError:\n  print(3)\nexcept:\n  print(4)\n\n\n",
    "replies": [
        {
            "author": "qq295920624",
            "timestamp": 1584584040,
            "txt_content": "这还是mcbbs嘛 编程都有昂"
        },
        {
            "author": "xiaojiajiawww",
            "timestamp": 1594788900,
            "txt_content": "谢谢大佬指点"
        },
        {
            "author": "QWERTY770",
            "timestamp": 1594816020,
            "txt_content": "唉看到except就想起了一段不好的回忆\n\n有一天我从网上下载了一个库\n\n结果一调用报错了……\nexcept Exception,err:\nSyntaxError: invalid syntax\n附加一堆路径和During handling of the above exception, another exception occurred:\n我寻思着我也没有干出这种事啊……\n\n结果按pycharm给的路径一查……坏大了……\n\n这个作者把所有的except Exception as err:都写成了except Exception,err:\n\n我翻源码和路径改了一下午才好了"
        }
    ]
}