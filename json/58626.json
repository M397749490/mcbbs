{
    "title": "【填坑向】【1.4.2】TechGuy开发教程翻译+自己的理解【mcbbs开发小组】",
    "author": "hendyzone",
    "replyCount": 9,
    "timestamp": 1350568740,
    "txt_content": " 本帖最后由 hendyzone 于 2012-11-9 20:32 编辑 \n\n前篇：http://www.mcbbs.net/thread-38101-1-1.html\n\n卡比君的翻译坑，我来义务填坑啦（其实是突然发现自己翻译过这个教程然后忘了发了=。=我会乱说？）\n                              \n声明\n凡是前面带[slimeball]都为lz自己的补充不是翻译自教程\n                                食物篇\n常见的食物\nmod_Food（新建mod的主文件）package net.minecraft.src;\npublic class \nmod_Food extends BaseMod\n{\npublic static \nfinal Item nameHere = new ItemFood(5001, 4, 1F, false).setItemName(\"anyNameHere\");\n\npublic void \nload()\n{\nnameHere.iconIndex = \nModLoader.addOverride(\"/gui/items.png\", \"/image.png\");\nModLoader.addName(nameHere, \"In-Game Name Here\");\nModLoader.addRecipe(new ItemStack(nameHere, 1), new Object [] {\"#\", Character.valueOf('#'), \nBlock.dirt});\n}\n\npublic String \ngetVersion()\n{\nreturn \"1.4.2\";\n}\n}复制代码\n代码解析\n\n通常食物只是与其他物品只有一点小小不同的物品的不同。那就是它能够回复饱食度！它的实现是通过建立一个继承于ItemFood类的类。ItemFood有3个int参数和一个boolean参数。第一个参数为物品的id第二个参数表示你可以恢复多少个半鸡腿。4代表你会恢复的2个鸡腿饱食度。第三个表示的是食物饱和度。食物饱和度是一个隐藏的属性，它决定你消耗饱食度的速度。当你的食物饱和度为0时，饱食度就会快速下降。最后的boolean值代表这样东西是否能否被狼食用。当这项数值为true时这样就可以喂狼。[slimeball]另外ItemFood还提供了另一个构造函数 ItemFood(int par1, int par2, boolean par3) 它和上一个的区别为第三个参数即食物饱食度为默认值：0.6F\n\n有特殊效果的食物\n想要通过食用食物来获得一个状态是非常简单的的。首先像上例那样创建一个一般的食物然后加入一小段代码：\n.setPotionEffect(Potion.hunger.id, \n15, 0, 1F)复制代码\n最终它会是这样：\npublic static final Item \nnameHere = new \nItemFood(5001, 4, 1F, false).setPotionEffect(Potion.hunger.id, 15, 0, 1F).setItemName(\"anyNameHere\");复制代码\n记住.setPotionEffect 必须在.setItemName 之前否则会引起编译错误。我在例子中使用的是饥饿（hunger），即在腐肉中被用到的那个。\n你可以在这个地方加入任何一样状态。所有的状态信息都可以在Potion.java中找到。15是那个状态将会持续的时间。你可以用其他的数字来代替0.它的效果是放大状态的程/和时间。1代表放大1倍，时间变为30秒。“1F”是状态成功的几率，腐肉的几率为0.8F即代表有80%的几率获得食物上的状态。使用1F就表示100%。\n有多种特殊效果的食物（本篇重点）   \nmod_Foodpackage net.minecraft.src;\npublic class mod_Food extends BaseMod\n{\npublic static final Item nameHere = new ItemFoodNameHere(5001, 4, 1F, false).setItemName(\"anyNameHere\");\n\npublic void load()\n{\nnameHere.iconIndex = ModLoader.addOverride(\"/gui/items.png\", \"/image.png\");\nModLoader.addName(nameHere, \"In-Game Name Here\");\nModLoader.addRecipe(new ItemStack(nameHere, 1), new Object [] {\"#\", Character.valueOf('#'), Block.dirt});\n}\n\npublic String getVersion()\n{\nreturn \"1.4.2\";\n}\n}复制代码ItemFoodNameHerepackage net.minecraft.src;\npublic class ItemFoodNameHere extends ItemFood\n{\npublic ItemFoodNameHere(int i, int j, boolean B)\n{\nsuper(i, j, B);\n}\npublic ItemStack onFoodEaten(ItemStack itemStack, World world, EntityPlayer entityPlayer)\n{\nentityPlayer.getFoodStats().addStats(this);\nworld.playSoundAtEntity(entityPlayer, \"random.burp\", 0.5F, world.rand.nextFloat() * 0.1F + 0.9F);\nitemStack.stackSize--;\n\nentityPlayer.addPotionEffect(new PotionEffect(Potion.blindness.id, 10 * 20, 6));\nentityPlayer.addPotionEffect(new PotionEffect(Potion.nightVision.id, 10 * 20, 6));\n\nreturn itemStack;\n}\n}复制代码代码解析mod_Food先像上面那样创建一个食物，但是创建一个你自己的食物类，基础于ItemFood类。\nItemFoodNameHereonFoodEaten method当食物被食用之后会自动调用。它的参数为ItemStack，World和Player/EntityPlayer。[slimeball]onItemRightClick method会在拿着物品右击之后，onFoodEaten被调用前调用\nentityPlayer.getFoodStats().addStats(this);复制代码这行代码的数据会从mod_***文件里的'public static final'代码行获得，并将它应用于玩家。\nworld.playSoundAtEntity(entityPlayer, \"random.burp\", \n0.5F, \nworld.rand.nextFloat() * 0.1F + 0.9F);复制代码这行代码应用了一般的食物被吃的声音。\nitemStack.stackSize--;复制代码使用简单的代码使堆叠数减少1（吃掉一个）。\n\n然后我们就可以添加所需的状态了\nentityPlayer.addPotionEffect(new PotionEffect(Potion.blindness.id, 10 * 20, 6));复制代码这就是给玩家添加状态的method。这部分就是这段的主要代码：\n(Potion.blindness.id, 10 * 20, 6)复制代码这个method的第一个参数是添加给玩家的状态。它们都能相当容易的在Potion.java文件里找到。确保你输入的在状态后的id为int型，否则会返回错误。第三个参数为状态所持续的时间，1tick为1/20秒所以10*20为10秒。第四个参数只是一个效果增幅值，如果你想的话你也可以将它设为0.你可以加入尽可能多的“状态”，来达到你要求的目的。\n\n                                                特殊方块篇\n\n花（基础版本）\n\nmod_Flowerpackage net.minecraft.src;\n\nimport java.util.Random;\n\npublic class \nmod_Flower extends BaseMod\n{\npublic static \nfinal Block nameHere= new BlockFlower(165, 0).setBlockName(\"anyNameHere\");\n\npublic void \nload()\n{\nnameHere.blockIndexInTexture = \nModLoader.addOverride(\"/terrain.png\", \"/image.png\");\nModLoader.registerBlock(nameHere);\nModLoader.addName(nameHere, \n\"In-Game Name Here\");\nModLoader.addRecipe(new ItemStack(nameHere, 1), new Object [] {\"##\", \"##\", \nCharacter.valueOf('#'), \nBlock.dirt});\n}\n\n\npublic void generateSurface(World world, Random random, \nint i, int \nj)\n{\nfor(int k = 0; k < 7; k++)\n{\nint randPosX = i + random.nextInt(16);\nint randPosY = \nrandom.nextInt(128);\nint randPosZ = j + random.nextInt(16);\n(new \nWorldGenFlowers(nameHere.blockID)).generate(world, random, randPosX, randPosY, \nrandPosZ);\n}\n\n}\n\npublic String \ngetVersion()\n{\nreturn \"1.4.2\";\n}\n}复制代码\n代码解析它和一般的方块有一些小区别。它继承于BlockFlower。BlockFlower有一些特殊的方法。它们之中最重要的是：\npublic boolean \nisOpaqueCube()\n{\nreturn \nfalse;\n}\n\npublic boolean renderAsNormalBlock()\n{\nreturn false;\n}\n\npublic int \ngetRenderType()\n{\nreturn 1;\n}复制代码\nisOpaqueCube允许我们使用透明/可见方块，来决定是否能看到下方的东西。renderAsNormalBlock,是一个很容易明白的选项，返回false意味着它看起来不会是一个普通的方块（block）。\npublic int getRenderType()\n{\nreturn 1;\n}复制代码这是使你的方块更像花的关键的一个。它会复制一次你的图片，然后会生成一个X型的形状（从上往下看）。\ngenerateSurface 方法允许你在世界生成花（flower）。在矿物生成的那章中会有更详细的介绍。\n\n\n花（详细版）\n\nmod_Flowerpackage \nnet.minecraft.src;\n\nimport \njava.util.Random;\n\npublic class mod_Flower extends BaseMod\n{\npublic static \nfinal Block nameHere= new \nBlockNamehereFlower(165, 0).setBlockName(\"anyNameHere\");\n\npublic void \nload()\n{\nnameHere.blockIndexInTexture = \nModLoader.addOverride(\"/terrain.png\", \"/image.png\");\nModLoader.registerBlock(nameHere);\nModLoader.addName(nameHere, \n\"In-Game Name Here\");\nModLoader.addRecipe(new ItemStack(nameHere, 1), new Object [] {\"##\", \"##\", \nCharacter.valueOf('#'), \nBlock.dirt});\n}\n\n\npublic void generateSurface(World world, Random random, \nint i, int \nj)\n{\nfor(int k = 0; k < 7; k++)\n{\nint randPosX = i + random.nextInt(16);\nint randPosY = \nrandom.nextInt(128);\nint randPosZ = j + random.nextInt(16);\n(new \nWorldGenFlowers(nameHere.blockID)).generate(world, random, randPosX, randPosY, \nrandPosZ);\n}\n\n}\n\npublic String \ngetVersion()\n{\nreturn \"1.4.2\";\n}\n}复制代码\n\nBlockNamehereFlower\npackage net.minecraft.src;\n\nimport java.util.Random;\n\npublic class \nBlockNamehereFlower extends \nBlock\n{\nprotected \nBlockNamehereFlower(int i, int j)\n{\nsuper(i, Material.plants);\nblockIndexInTexture \n= j;\nsetTickRandomly(true);\nfloat f = 0.2F;\nsetBlockBounds(0.5F - f, 0.0F, 0.5F - f, 0.5F + f, f * 3F, 0.5F + f);\n}\n\npublic \nboolean canPlaceBlockAt(World world, int i, int j, \nint k)\n{\nreturn super.canPlaceBlockAt(world, i, j, k) && \ncanThisPlantGrowOnThisBlockID(world.getBlockId(i, j - \n1, k));\n}\n\nprotected boolean \ncanThisPlantGrowOnThisBlockID(int \ni)\n{\nreturn i == Block.grass.blockID || i == Block.dirt.blockID || i == Block.tilledField.blockID;\n}\n\npublic void \nonNeighborBlockChange(World world, int i, int j, int k, int l)\n{\nsuper.onNeighborBlockChange(world, i, j, k, l);\ncheckFlowerChange(world, i, j, k);\n}\n\npublic void \nupdateTick(World world, int i, int j, int k, Random random)\n{\ncheckFlowerChange(world, i, j, k);\n}\n\nprotected final \nvoid checkFlowerChange(World world, int i, int j, \nint k)\n{\nif (!canBlockStay(world, \ni, j, k))\n{\ndropBlockAsItem(world, i, j, k, world.getBlockMetadata(i, j, k), 0);\nworld.setBlockWithNotify(i, j, k, 0);\n}\n}\n\npublic boolean \ncanBlockStay(World world, int i, int j, int \nk)\n{\nreturn \n(world.getFullBlockLightValue(i, j, k) >= 8 || world.canBlockSeeTheSky(i, j, k)) && \ncanThisPlantGrowOnThisBlockID(world.getBlockId(i, j - 1, k));\n}\n\npublic AxisAlignedBB \ngetCollisionBoundingBoxFromPool(World world, int i, int j, \nint k)\n{\nreturn null;\n}\n\npublic boolean \nisOpaqueCube()\n{\nreturn \nfalse;\n}\n\npublic boolean renderAsNormalBlock()\n{\nreturn false;\n}\n\npublic int \ngetRenderType()\n{\nreturn 1;\n}\n}复制代码\n代码解析 它看起来和之前的简单版一样，但是可以给你的花添加更多特性。我不会在这解析所有的代码，但是我会解析你希望改变的重要的代码。\nsetBlockBounds是用来描方块的边界线的。每一个float值都有它们各自不同的功能，你可以一个个修改它们来搞清楚它们各自的作用。//0.0这个东西蛮复杂的，，，一般不要去修改比较好=。=canPlaceBlockAt 和 canThisPlantGrowOnThisBlockID 只是说明了你可以在那些方块上放置你的方块。isOpaqueCube, renderAsNormalBlock 和getRenderType 与前面的介绍的内容是一样的。\n\n\n透明方块\n\n在需要使它透明的方块的Block类中添加method\n\npublic boolean isOpaqueCube()\n{\nreturn false;\n}复制代码\n就可以了。。。就这么简单\n\n\n\n楼梯\n\nmod_Stairs\n\npackage net.minecraft.src;\npublic class mod_Stairs extends BaseMod\n{\n         public static final Block nameHere= new BlockNameHereStairs(170, 0).setBlockName(\"stairsNameHere\").setHardness(3F).setResistance(4F);\n                        \n         public void load()\n         {\n                         nameHere.blockIndexInTexture = ModLoader.addOverride(\"/terrain.png\", \"/imageblock.png\");\n                         ModLoader.registerBlock(nameHere);\n                         ModLoader.addName(nameHere, \"In-Game Name Here\");\n                         ModLoader.addRecipe(new ItemStack(nameHere, 1), new Object [] {\"# \", \"## \", \"###\", Character.valueOf('#'), Block.dirt});\n         }\n         public String getVersion()\n         {\n                         return \"1.4.2\";\n         }\n}复制代码\n\n\nBlockNamehereStairs\n\npackage net.minecraft.src;\nimport java.util.List;\nimport java.util.Random;\npublic class BlockNameHereStairs extends Block\n{\nprivate static final int[][] field_72159_a = new int[][] {{2, 6}, {3, 7}, {2, 3}, {6, 7}, {0, 4}, {1, 5}, {0, 1}, {4, 5}};\nprivate boolean field_72156_cr = false;\nprivate int field_72160_cs = 0;\nprotected BlockNameHereStairs(int i, int j)\n{\n         super(i, j, Material.rock);\n         this.setLightOpacity(255);\n         this.setCreativeTab(CreativeTabs.tabBlock);\n}\n/**\n         * 根据block的当前状态来更新block的边界参数：world,x,y,z\n         */\npublic void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)\n{\n         if (this.field_72156_cr)\n         {\n                 this.setBlockBounds(0.5F * (float)(this.field_72160_cs % 2), 0.5F * (float)(this.field_72160_cs / 2 % 2), 0.5F * (float)(this.field_72160_cs / 4 % 2), 0.5F + 0.5F * (float)(this.field_72160_cs % 2), 0.5F + 0.5F * (float)(this.field_72160_cs / 2 % 2), 0.5F + 0.5F * (float)(this.field_72160_cs / 4 % 2));\n         }\n         else\n         {\n                 this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);\n         }\n}\n/**\n         *  这是否是不透明方块，是否为完全填满一格空间的方块？这觉得对这个方块的渲染方式以及玩家是否可以将火把，红石粉等一些方块放置在它的上面\n         */\npublic boolean isOpaqueCube()\n{\n         return false;\n}\n/**\n         * 如果这个方块不是像一般的方块那样被渲染，它就会返回false（例如：牌子，按钮，阶梯等）\n         */\npublic boolean renderAsNormalBlock()\n{\n         return false;\n}\n/**\n         * 描绘（render）的方法\n         */\npublic int getRenderType()\n{\n         return 10;\n}\n/**\n         *  如果特殊方块石在给定的长方形范围（given AABB）内，则将CollidingBlock添加到列里\n         */\npublic void addCollidingBlockToList(World par1World, int par2, int par3, int par4, AxisAlignedBB par5AxisAlignedBB, List par6List, Entity par7Entity)\n{\n         int var8 = par1World.getBlockMetadata(par2, par3, par4);\n         int var9 = var8 & 3;\n         float var10 = 0.0F;\n         float var11 = 0.5F;\n         float var12 = 0.5F;\n         float var13 = 1.0F;\n         if ((var8 & 4) != 0)\n         {\n                 var10 = 0.5F;\n                 var11 = 1.0F;\n                 var12 = 0.0F;\n                 var13 = 0.5F;\n         }\n         this.setBlockBounds(0.0F, var10, 0.0F, 1.0F, var11, 1.0F);\n         super.addCollidingBlockToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);\n         if (var9 == 0)\n         {\n                 this.setBlockBounds(0.5F, var12, 0.0F, 1.0F, var13, 1.0F);\n                 super.addCollidingBlockToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);\n         }\n         else if (var9 == 1)\n         {\n                 this.setBlockBounds(0.0F, var12, 0.0F, 0.5F, var13, 1.0F);\n                 super.addCollidingBlockToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);\n         }\n         else if (var9 == 2)\n         {\n                 this.setBlockBounds(0.0F, var12, 0.5F, 1.0F, var13, 1.0F);\n                 super.addCollidingBlockToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);\n         }\n         else if (var9 == 3)\n         {\n                 this.setBlockBounds(0.0F, var12, 0.0F, 1.0F, var13, 0.5F);\n                 super.addCollidingBlockToList(par1World, par2, par3, par4, par5AxisAlignedBB, par6List, par7Entity);\n         }\n         this.setBlockBounds(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);\n}\n/**\n         * 当方块被放置出来时被调用\n         */\npublic void onBlockPlacedBy(World par1World, int par2, int par3, int par4, EntityLiving par5EntityLiving)\n{\n         int var6 = MathHelper.floor_double((double)(par5EntityLiving.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;\n         int var7 = par1World.getBlockMetadata(par2, par3, par4) & 4;\n         if (var6 == 0)\n         {\n                 par1World.setBlockMetadataWithNotify(par2, par3, par4, 2 | var7);\n         }\n         if (var6 == 1)\n         {\n                 par1World.setBlockMetadataWithNotify(par2, par3, par4, 1 | var7);\n         }\n         if (var6 == 2)\n         {\n                 par1World.setBlockMetadataWithNotify(par2, par3, par4, 3 | var7);\n         }\n         if (var6 == 3)\n         {\n                 par1World.setBlockMetadataWithNotify(par2, par3, par4, 0 | var7);\n         }\n}\n/**\n         * 在onBlockPlacedBy 被调用前被调用\n         */\npublic void updateBlockMetadata(World par1World, int par2, int par3, int par4, int par5, float par6, float par7, float par8)\n{\n         if (par5 == 0 || par5 != 1 && (double)par7 > 0.5D)\n         {\n                 int var9 = par1World.getBlockMetadata(par2, par3, par4);\n                 par1World.setBlockMetadataWithNotify(par2, par3, par4, var9 | 4);\n         }\n}\n/**\n         * Ray traces through the blocks collision from start vector to end vector returning a ray trace hit. Args: world,\n         * x, y, z, startVec, endVec\n         */\npublic MovingObjectPosition collisionRayTrace(World par1World, int par2, int par3, int par4, Vec3 par5Vec3, Vec3 par6Vec3)\n{\n         MovingObjectPosition[] var7 = new MovingObjectPosition[8];\n         int var8 = par1World.getBlockMetadata(par2, par3, par4);\n         int var9 = var8 & 3;\n         boolean var10 = (var8 & 4) == 4;\n         int[] var11 = field_72159_a[var9 + (var10 ? 4 : 0)];\n         this.field_72156_cr = true;\n         int var14;\n         int var15;\n         int var16;\n         for (int var12 = 0; var12 < 8; ++var12)\n         {\n                 this.field_72160_cs = var12;\n                 int[] var13 = var11;\n                 var14 = var11.length;\n                 for (var15 = 0; var15 < var14; ++var15)\n                 {\n                         var16 = var13[var15];\n                         if (var16 == var12)\n                         {\n                                 ;\n                         }\n                 }\n                 var7[var12] = super.collisionRayTrace(par1World, par2, par3, par4, par5Vec3, par6Vec3);\n         }\n         int[] var21 = var11;\n         int var24 = var11.length;\n         for (var14 = 0; var14 < var24; ++var14)\n         {\n                 var15 = var21[var14];\n                 var7[var15] = null;\n         }\n         MovingObjectPosition var23 = null;\n         double var22 = 0.0D;\n         MovingObjectPosition[] var25 = var7;\n         var16 = var7.length;\n         for (int var17 = 0; var17 < var16; ++var17)\n         {\n                 MovingObjectPosition var18 = var25[var17];\n                 if (var18 != null)\n                 {\n                         double var19 = var18.hitVec.squareDistanceTo(par6Vec3);\n                         if (var19 > var22)\n                         {\n                                 var23 = var18;\n                                 var22 = var19;\n                         }\n                 }\n         }\n         return var23;\n}\n}\n复制代码\n\n代码解析\nmod_Stairs\n\n与一般的方块类没什么区别\n\nBlockNamehereStairs\n\naddCollidingBlockToList 将方块的collision box添加到列中。通过“else if”这个命令行来修正方块的朝向。\n在 onBlockPlacedBy中的if命令行被用来使方块的朝向为正对着玩家.\n\n\n\n\n\n\n以及欢迎各种提问，这种东西讨论比自己死钻效率高=w=\n\n广告\n============================================\n另外mcbbsmod开发小组的qq群：255579164 欢迎各种mod爱好者 材质爱好者 以及有想法的少年[diamond_gem]",
    "replies": [
        {
            "author": "sylqiuyifeng",
            "timestamp": 1350568800,
            "txt_content": "我一直想知道想做mod需要JAVA水平去到哪里……"
        },
        {
            "author": "kaho",
            "timestamp": 1350569280,
            "txt_content": "表示很难的路过..."
        },
        {
            "author": "geludan",
            "timestamp": 1350573660,
            "txt_content": "这类东西我一般直接跳过"
        },
        {
            "author": "qw4wer",
            "timestamp": 1350620760,
            "txt_content": "又见开坑的，有树木生成"
        },
        {
            "author": "当风过时",
            "timestamp": 1350976980,
            "txt_content": "源码党表示在ItemFood里有一个构造函数的第四个布尓值参数的名字是“狼是否能吃”，虽然我没试过- -(逃...)"
        },
        {
            "author": "kingdomheart",
            "timestamp": 1381459080,
            "txt_content": "那请问我想弄一个方块 站在方块上就能获得一些效果 如回血 中毒 加速\n还有方块叠在一起效果加倍要怎么写?\n教学里都好像没这一类的\n\n我主要想弄一个跟ThaumCraft3中的魔法升降机一模一样的方块\n但是ThaumCraft3 好像没有开放源码 只有API"
        },
        {
            "author": "hendyzone",
            "timestamp": 1381465860,
            "txt_content": "kingdomheart 发表于 2013-10-11 10:38 \n那请问我想弄一个方块 站在方块上就能获得一些效果 如回血 中毒 加速\n还有方块叠在一起效果加倍要怎么写?\n ...\n魔法升降机没用过。。。\n要实现站在上面获得buff的效果可以用block的onentitywalk（有个了类似的方法不过具体名字不记得的【。）那样的方法 不过这样会有误差、\n最好是为block单独建立一个tileentity实时监测正上一格的位置，"
        },
        {
            "author": "halfcigarette",
            "timestamp": 1381560000,
            "txt_content": "回帖是美德。。。"
        },
        {
            "author": "JYJY",
            "timestamp": 1396322880,
            "txt_content": "{:10_512:}{:10_523:}{:10_523:}"
        }
    ]
}