{
    "title": "ItemStack序列化为String[已解决]",
    "author": "沫苍",
    "replyCount": 4,
    "timestamp": 1560573000,
    "txt_content": " 本帖最后由 沫苍 于 2019-6-16 16:50 编辑 \n\n如题 怎么将ItemStack序列化为String\nProtocolLib的StreamSerializer 好像不是很行 比如序列化一把原版钻石剑是\nARQB******AAAAAAAAA\\r\\\n  \\n******AAAAAAAAAAAAA\\r\\\n  \\n******AAAAAAAAAAAAA\\r\\\n  \\n******AAAAAAAAAAAAA\\r\\\n  \\n**AAAAAAAAAAAAAAAAA==\\r\\n\n但是无法反序列化",
    "replies": [
        {
            "author": "海螺螺",
            "timestamp": 1560576000,
            "txt_content": "ItemStack实现了ConfigurationSerializable类，所以可以用serialize方法将ItemStack序列化成一个Map\nMap变成String方法就多了"
        },
        {
            "author": "lgou2w",
            "timestamp": 1560616620,
            "txt_content": "倒不如读取物品栈的 NBT 存储方便。比如：\n第一种方法：读取物品栈NBT流 -> 进行Base64编码。这种方式适合存储\n第二种方法：读取物品栈NBT流 -> 转换为Mojangson格式的JSON字符串。这种方式适合阅读和修改"
        },
        {
            "author": "wshycaa",
            "timestamp": 1560623100,
            "txt_content": "String反序列化为ItemStack：\n\n        public static ItemStack getItemStack(String data)\n        {\n            StreamSerializer ss=new StreamSerializer();\n            try\n            {\n                return ss.deserializeItemStack(data);\n            }catch(Exception e){e.printStackTrace();}\n            return null;\n        }"
        },
        {
            "author": "沫苍",
            "timestamp": 1560675000,
            "txt_content": "wshycaa 发表于 2019-6-16 02:25\nString反序列化为ItemStack：\n\n        public static ItemStack getItemStack(String data)\n这个不行的 我问题里已经注明无法使用ProtocolLib自带的序列化工具 因为会序列化出很长的A\n"
        }
    ]
}