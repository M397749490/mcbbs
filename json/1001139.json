{
    "title": "关于多个掉落物实体的问题",
    "author": "阡喏",
    "replyCount": 17,
    "timestamp": 1585468680,
    "txt_content": " 本帖最后由 阡喏 于 2020-3-29 16:00 编辑 \n\n如果地上有多个掉落物，那么这些掉落物就会叠到一起，这个是常识，但这些堆叠的掉落物判定为一个实体\nkill @e[type=item,limit=1] 就把这些堆叠的东西都清理了，有没有办法能解决这个问题，让一个掉落物判定为一个实体?\n这样我就可以给每个掉落物分别计分了",
    "replies": [
        {
            "author": "⊙u⊙",
            "timestamp": 1585468680,
            "txt_content": "阡喏 发表于 2020-3-28 22:10\n不对啊，我试着在地上丢一组土豆，然后kill @e[type=item,limit=1] 然后一组土豆都没了，同理，我炼药锅 ...\n你这cooking标签是实体标签吗？此标签非彼标签。\n\ntag add @e[type=item] label\n^ ^ ^ 这个是给实体标签。实体标签并不能阻止物品叠堆。\n\nexecute as @e[type=item] store result entity @s Item.tag.custom byte 1 run scoreboard players get $rng dummy\n这个是给掉落物添加一个标签并赐值，你只要保证每次虚拟玩家$rng的dummy记分板是不一样的。掉落物就会有不同的物品标签，也就不会互相叠堆了\n\n另外相同的物品标签是允许叠堆的。"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585468800,
            "txt_content": "掉落物数据不同时就不会合并了，可以给每一个刚\"出生\"的掉落物不同的物品标签\n计分？计什么分？计分干啥?"
        },
        {
            "author": "阡喏",
            "timestamp": 1585469100,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 16:00\n掉落物数据不同时就不会合并了，可以给每一个刚\"出生\"的掉落物不同的物品标签\n计分？计什么分？计分干啥?\n ...\n比如说一个土豆，丢到炼药锅里就给这个土豆一个cooking标签，然后有cooking标签的土豆就每tick把scb的cooking_time 加一，当出现cooking_time为400的土豆时在原地生成一个烤土豆,然后把这个原先那个生土豆kill了,后来我发现每次只能烹煮一个土豆，土豆多了也只能获得一个烤土豆"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585469220,
            "txt_content": " 本帖最后由 ⊙u⊙ 于 2020-3-28 22:08 编辑 \n后来我发现每次只能烹煮一个土豆，土豆多了也只能获得一个烤土豆\n是你命令写得不对emmm我想想"
        },
        {
            "author": "阡喏",
            "timestamp": 1585469400,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 16:07\n是你命令写得不对\n不对啊，我试着在地上丢一组土豆，然后kill @e[type=item,limit=1] 然后一组土豆都没了，同理，我炼药锅里的土豆都是有cooking标签的，先丢一个，3s后再丢一个，然后他们堆叠到一起，成为了一个实体，然后最先到达400tick的那个土豆被检测到，然后kill，然后一整个实体都被kill了(两个都没了),最后就出来一个土豆，不能实现分别计时"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585469520,
            "txt_content": "修改每一个丢在地上且位于炼药锅里的生土豆的物品标签（非实体标签）使其不予任何其他组叠堆，并修改其PickupDelay:32767s防止玩家立刻捡起。计分/时\n\n时间到达后清除并替换"
        },
        {
            "author": "阡喏",
            "timestamp": 1585469640,
            "txt_content": " 本帖最后由 阡喏 于 2020-3-29 16:24 编辑 \n⊙u⊙ 发表于 2020-3-29 16:12\n修改每一个丢在地上且位于炼药锅里的生土豆的物品标签（非实体标签）使其不予任何其他组叠堆，并修改其Pick ...\n那两个土豆都在锅里，岂不是标签都设为一样了，那这样不能堆叠吗\n还有，我不会data指令\n"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585470720,
            "txt_content": "长话短说...\n\n实体标签，记分板  >  保存于实体\n\n物品标签  >  保存于实体内的物品数据\n\n物品数据不同的物品不能叠堆"
        },
        {
            "author": "阡喏",
            "timestamp": 1585472640,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 16:32\n长话短说...\n\n实体标签，记分板  >  保存于实体\nemmm，出现问题了，好像现存实体大于2时就会堆叠了"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585478880,
            "txt_content": "阡喏 发表于 2020-3-28 23:04\nemmm，出现问题了，好像现存实体大于2时就会堆叠了\n把命令发上来，你可能没处理好..."
        },
        {
            "author": "阡喏",
            "timestamp": 1585479240,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 18:48\n把命令发上来，你可能没处理好...execute as @e[type=minecraft:item,nbt={Item:{id:\"minecraft:stone\"}},limit=1] store result entity @s Item.tag.custom byte 1 run scoreboard players get $rng dummy复制代码scoreboard players add $rng dummy 1复制代码\n"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585479660,
            "txt_content": "阡喏 发表于 2020-3-29 00:54\n这里不过是一段\n\n处理时的执行顺序呢？\n或者更早一点，整个东西是怎么开始的，选择器是怎么选的？"
        },
        {
            "author": "阡喏",
            "timestamp": 1585480200,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 19:01\n这里不过是一段\n\n处理时的执行顺序呢？\n我就循环了这俩，然后如果现存实体超过2个就会开始叠加"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585481340,
            "txt_content": " 本帖最后由 ⊙u⊙ 于 2020-3-29 01:38 编辑 \n阡喏 发表于 2020-3-29 01:10\n我就循环了这俩，然后如果现存实体超过2个就会开始叠加\n那我大概清楚是什么情况了，我还原/分析一下\n\n#循环命令\nexecute as @e[type=item,limit=1] store result ... run ... get $rng dummy\n\n#连锁命令\n... players add $rng dummy 1复制代码\n\n\n假设目前有两个掉落物实体，A和B（其中有一个表格，A排在表中的第一位，而B则排在第二位）\n\n第一轮执行，会选取一个实体A并走一轮处理(添加物品标签与值，$rng分数+1)\n\n第二轮执行，会选取一个实体A并走一轮处理(添加物品标签与值，$rng分数+1)\n\n...\n\n第n轮执行，会选取一个实体A并走一轮处理(添加物品标签与值，$rng分数+1)\n\n\n\n问题已经很明显了，每次都只处理和修改A，而B并没有被修改过。那么若此时存在C，由于B和C的物品标签一致，B和C会叠堆。\n"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585481760,
            "txt_content": "选择器选取对象的流程是先列一个表，然后在表中做匹配，最终获得满足参数的对象\n而这个表中的对象按sort的顺序排列，@e的默认顺序为arbitrary，虽然列表的顺序很奇怪，但是在外部条件不变的情况下，每次表中对象的顺序都是一致的。\n\n在加上limit=1后，就很有可能出现你现在这样的情况，永远都只选中表中的第一个适格对象。"
        },
        {
            "author": "阡喏",
            "timestamp": 1585481940,
            "txt_content": "⊙u⊙ 发表于 2020-3-29 19:36\n选择器选取对象的流程是先列一个表，然后在表中做匹配，最终获得满足参数的对象\n而这个表中的对象按sort的 ...\n那能不能在选择器中加一个只选择未被处理过的物品？怎么加？"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1585482060,
            "txt_content": "阡喏 发表于 2020-3-29 01:39\n那能不能在选择器中加一个只选择未被处理过的物品？怎么加？\n把第一条命令的选择器加上  @e[type=item,tag=!marked,nbt={...},limit=1]\n\n在每一次处理时给处理中的掉落物实体加上实体标签，比如 tag @s add marked"
        }
    ]
}