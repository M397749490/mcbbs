{
    "title": "关于大量实体占用消耗计算机算力的问题",
    "author": "cyt",
    "replyCount": 3,
    "timestamp": 1576326060,
    "txt_content": " 本帖最后由 cyt 于 2020-1-6 20:46 编辑 \n\n如果是大量生物或者是大规模红石电路这种涉及复杂计算的实体就算了，可是仅仅是几千个告示牌、展示框、头颅、旗帜这种不涉及复杂计算的实体方块，也会导致严重的性能下降（下面贴两张图，12000个头颅实体和12000个活版门方块，左上角有fps显示，可以明显看到12000个头颅相比活版门性能下降近75%）\n\n\n\n\nfile_1576324891000.jpg (260.42 KB, 下载次数: 0)\n\n下载附件\n\n12000个头颅实体，帧数只有30帧\n2019-12-14 20:01 上传\n\n\n\n\n\n\n\n\nfile_1576324898000.jpg (219.59 KB, 下载次数: 0)\n\n下载附件\n\n同样复杂度的非实体方块，左上角帧数达到上限\n2019-12-14 20:01 上传\n\n\n\n\n\n\n如果看任务管理器的话会发现，当视野里存在庞大数量的实体时，cpu其中一个核心使用率接近100%，所以大量实体导致的卡顿应该是逻辑计算的问题，和显卡负责的部分没有关系。\n\n除此之外，我也尝试过用fabric环境下的mixin修改minecraft的源码，直接将实体方块每tick的更新完全禁掉（直接导致所有实体方块不再渲染动画），但对大量实体的性能没有任何提升。\n我怀疑是游戏本身一个隐藏很深的bug，可能是某些本来应该由显卡渲染的工作交给了cpu去做，也有可能是别的原因。因为包括optifine在内的现有主流优化插件和mod都没有针对此问题进行优化。所以发出此贴，希望能交流讨论一下，看看能不能有一些别的发现。\n对更新内容的补充：下列内容所提到的帧数测试仅供参考，因为在不同的环境下，帧数会有比较剧烈的波动，而且帧数本质上和代码执行时间成反比关系，而我在进行测试时经常会各种注释代码，导致有时候帧数波动会变得很玄学，比如明明禁掉同一段代码，有时帧数变化很大，有时却微乎其微。。。大概就这样子=w=\n\n\n\n\n2019.12.15更新\n基本确认大量实体存在时卡顿的原因之一，就是实体交给opengl渲染前的一系列预处理太过复杂。用optfine调试分析器就可以看出当视野存在大量实体时，渲染进程的占用比例会大幅提高。具体到代码方面，用minecraft1.14官方反混淆的jar包来说，在net.minecraft.client.renderer.blockentity下的BlockEntityRenderDispather类开始，其render方法向下一层层调用，消耗掉大量的cpu资源。\n还是以12000个头颅的场景举例，上面提到的BlockEntityRenderDispather类，其中的render方法有一行获取实体亮度的代码，仅仅注释掉这一行，帧数就提升了15-20帧左右。emmmm真不明白为什么仅仅一个数据获取的代码就占用那么多cpu资源=.=\n\n\n\n\ntmp.png (50.31 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-15 22:41 上传\n\n\n\n\n\n\n\n2019.12.17更新\n重新统计blockEntityRenderDispather下render方法，各行代码的耗时（用了System.nanoTime()进行统计，可能有40%左右的误差），最终平均耗时如下图\n\n\n\n\ntmp.png (38.08 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-17 18:44 上传\n\n\n\n\n很意外的第二行代码Lighting.turnOn()居然需要那么长时间运行，我现在暂时也不清楚此行代码的作用，因为注释掉这行后运行游戏，似乎并没有对实体方块的渲染造成影响。\n然后我直接将turnOn()方法给复写为空了，才知道这是一个渲染暗面效果的开关。至于为什么在BlockEntityRenderDispather下面注释掉代码没有影响，是因为在调用render方法之前就已经有其他代码调用了turnOn()了，所以这里属于重复调用。\n去掉这行没有意义的代码后，帧数提高了5帧左右。\n\n2019.12.19更新\n发现用System.nanoTime()统计依然会有极大的误差，不同的环境下会严重影响所得值，所以考虑接下来不使用纳秒进行耗时统计，而改用百分比的方式进行统计。\n为了更加精确地进行统计，我重新创了一个空白世界，以确保实验时只有一个实体在进行渲染。以BlockEntityRenderDispather下的render()耗时为总集100%，统计其调用的下级代码耗时占用百分比。\n考虑到不同实体之间的差异性，不同类型的实体将分别进行统计。\n经过一段简单的统计后，我应该是找到了导致实体渲染卡顿的地方。。。。\n在net.minecraft.client.model.geom.ModelPart类型下的render方法，其中调用GlStateManager.callList(int)方法是卡顿之源。此代码耗时占了总渲染耗时的的70%左右(+-10%)\n                \n2019.12.25更新\n重新研究了一下方块的渲染和实体渲染的区别，我现在有新的猜测：关于方块渲染，从源码上看 是先在cpu端按照区块进行预处理，然后再将顶点信息等发送到gpu，也就是每帧cpu与gpu的通信次数应是处于渲染状态的区块数(比如16视距区块，每帧通信次数应小于256次)。然而实体的渲染分了很多层级进行，最底的一层modelPart最终执行将信息发往gpu进行渲染的操作，而每个modelPart对象是相互独立的，也就是每个modelPart都会进行一次通信。而基本上一个实体就会有一个以上的modelPart对象，也就是说如果有成千上万个实体的话，游戏就会在每帧渲染间进行成千上万次通信。最终结果就是导致严重的性能下降。\n如果我没弄错的话，cpu与gpu的通信速度是非常非常慢的，也就是在用openGL时要尽量避免频繁的通信，最好将需要渲染的顶点信息一次性发送。如果确实如此的话，那问题的关键也应该就在这里。让存在于世界的实体一次性发送到gpu进行渲染，能显著提高实体渲染的性能。\n2019.12.28更新\n基本弄清实体渲染的流程，超级简化伪代码如下：renderEntities() {\n    for (entity : entities) {\n        glBindTexture(entity.getTexture());\n        Light i = entity.getLightMap().getSkyLight();\n        Light j = entity.getLightMap().getAmbientLight();\n        glMultiTexCoord(i,j);\n        if (notComplied(entity)) complied(entity);\n        glCallList();\n    }\n}\n\ncomplied(entity) {\n    glNewList();\n    for (polygon : entity.getPolygons()) {\n         BufferBuilder.put(polygon);\n         glDrawArray(BufferBuilder.buffer);\n         BufferBuilder.clear();\n    }\n    glEndList();\n}复制代码\nglMultiTexCoord()方法是设定一张静态光度图的UV坐标，其设定的UV坐标信息对应一个亮度值，在GPU渲染时参与纹理的光照渲染。\nglBindTexture则是在每个实体渲染前让openGL绑定相应贴图，而不是像方块渲染那样把所有方块纹理合成一张贴图进行渲染。\nglNewList()和glEndList()是向openGL声明一段显示列表，该显示列表先进行一次编译后，再通过glCallList()调用此列表，以执行其中的代码。\nBufferBuilder是底层缓冲类，所有实体渲染都要将所需信息输入该缓冲，然后发送到gpu渲染，从伪代码上看，每次循环缓冲只会存储一个面的顶点信息，因为glDrawArray是执行向gpu发送顶点信息的方法，所以理论上每次gpu通信也都只发送一个正方形的信息，然后该缓冲就会被清空。\n本来我认为glDrawArray就是卡顿之源，所以试着把complied()里for循环中的glDrawArray提到循环之外（因为每个模型方块至少有六个面，意味着glDrawArray执行次数将减少5/6以上）然而实际测试并没有带来丝毫帧数提升。。。。只能猜测在执行显示列表时，无论glDrawArray执行多少次，都只会在列表执行结束后进行一次gpu通信。\n另外，如果不使用glCallList方法，直接执行的话，渲染耗时能再增加5.6倍。（然而如果在直接执行的情况下按上述方式减少glDrawArray的调用次数，渲染耗时依然增加2.6倍左右）\n\n2020.1.2更新\nemmmm到目前为止，我所理解的整个渲染流程还有一些问题，首先是glDrawArray，其实是指定某一块内存区域为下一次gpu通信传输时访问读取的区域，也就是说，callList才应该是向gpu传输信息的方法。另外，由于calllist执行显示列表是执行事先编译完成的指令块，里面所涉及到的所有东西，包括可能调用的外部变量指针，全都是静态的，只有在下一次编译时才会发生改变，所以minecraft每个实体的坐标变换是在显示列表外部完成，并且直接传输到openGL的模型变换矩阵中，直到将这个矩阵发送往gpu，再根据一同传来的顶点信息进行变换操作。\n传输之前存放顶点信息的缓冲也是静态的，也是因为显示列表的上述特性，不进行编译根本不会改变缓冲的变量地址。\n我之前傻傻地想要不把模型变换矩阵传入显示列表，直接在cpu变换顶点信息，然而因为模型变换矩阵是动态的，所以根本不可行，只会渲染出各种奇怪的形状出来。。\n因为显示列表的这种特性，所以处理起来很麻烦，本来想着一次性发送所有实体顶点信息到gpu，在这种情况下，我想不出实现的方法。。。\n2020.1.6更新\n这几天考试，所以没什么时间研究。今天重新导入一个LWJGL包，自己建个项目研究openGL。\n之前查别人关于显示列表的信息，也一直没弄清楚其特性，网上wiki和其他教程也讲的不清不楚，现在知道了=.=。如果我没弄错的话，显示列表编译时，会直接执行其中的非openGL指令，openGL指令则根据新建显示列表指定模式，选择是只编译还是编译后执行。这里我弄不清楚的是，显示列表涉及多级调用时会怎么处理？比如显示列表调用某个对象里的某个方法，方法里面有openGL指令，那么编译结果是不是只剩下那么一条openGL指令？\n举个伪代码：Object o = new Object();\n\nvoid compile() {\n        glNewList();\n        o.method();\n        glEndList();\n}\n\nclass Object {\n        Buffer buffer\n        object variable;\n        \n        method() {\n                int x= [expression]\n                int y= variable.getValue();\n                variable.operation();\n                glDrawArray(this.buffer);\n        }\n}复制代码\n[expression]指的是不涉及客户端存储的表达式，getValue()是一个返回某个整数的函数，changeValue()方法是改变对象variable内部存储信息的操作，glDrawArray()是openGL指令。\n编译过程应该会把处理openGL指令以外的代码执行一遍，但是编译结果似乎会变成://编译时执行的代码\nfinal const1=[expression]\nfinal const2=variable.getValue();\nfinal const_Buffer=this.buffer;\n\n//编译后显示列表会执行的指令\nint x=const1;\nint y=const2;\nglDrawArray(const_Buffer);复制代码\n也就是说，里面所有临时变量会变成一个常量，openGL可以调用的对象也会变成完全静态的，对客户端的数据操作将不会存在于显示列表中。带有返回值的函数将只剩下一个编译时的返回值\n那么，涉及if,for之类的操作又会如何？switch/case操作呢？还有在内部创建新对象的操作呢？这些代码在显示列表里会变成什么样？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "unexisted",
            "timestamp": 1583999160,
            "txt_content": "期待更新结果"
        },
        {
            "author": "chasing6",
            "timestamp": 1584074160,
            "txt_content": "奈何本人没文化一句牛逼走天下"
        },
        {
            "author": "Flow_Sea",
            "timestamp": 1585190460,
            "txt_content": "aaaaaaaaaaaaaaaa"
        }
    ]
}