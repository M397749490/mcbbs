{
    "title": "[前置API]Atlas —— 全新API|自定义监听|超多工具包[1.7-1.14]",
    "author": "Iverins",
    "replyCount": 0,
    "timestamp": 1567142640,
    "txt_content": " 本帖最后由 ShareFO 于 2019-9-1 09:12 编辑 \n\n\n\n\n\n\n精搬良运.png (21.57 KB, 下载次数: 0)\n\n下载附件\n\n2019-8-30 12:37 上传\n\n\n\n\n\n\n\n\n\n42019459536ea206380714d1facff5f38c39f425.png (20.83 KB, 下载次数: 0)\n\n下载附件\n\n2019-8-30 12:38 上传\n\n\n\n\n舆图 是一个致力于为开发者改进Bukkit插件和升级那无聊的反作弊的而制作的API！\n原作者：funkemunky更多关于Atlas的资料优点：\n1.先进且极少BUG的自定义数据包的检测系统，具有单独的包装系统\n2.自定义事件系统，以异步方式运行，因此使用此API的插件将不会对你的服务器造成一定的卡顿\n3.完善的数学程序能够让你忘记那令人头疼的数学计算\n4.超多细节方法，譬如：给后台的一些信息分色\n5.最准确，最简便的公用搜索\n6.众多反射方法和超好用的程序，并且包括NMS的抓取\n介绍一个出名的插件\n它也是使用AtlasAPI的！\nIris Anticheat\n站外链接\n更新日志：\n\n- 修复内存错误\n- 修复了ArraysOutOfBoundsException错误\n如何使用API&Wiki查看\n\nMaven：\n<repositories>\n        <repository>\n            <id>funkemunky-releases</id>\n            <url>http://nexus.funkemunky.cc/content/repositories/releases/</url>\n        </repository>\n    </repositories>\n\n    <dependencies>\n        <dependency>\n            <groupId>cc.funkemunky.plugins</groupId>\n            <artifactId>Atlas</artifactId>\n            <version>1.5</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>复制代码自定义事件系统\n创建一个事件\npackage cc.funkemunky.anticheat.api.event;\n\nimport cc.funkemunky.api.events.AtlasEvent;\nimport cc.funkemunky.api.events.Cancellable;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n\npublic class TickEvent extends AtlasEvent implements Cancellable {\n    private int currentTick;\n\n    public TickEvent(int currentTick) {\n        this.currentTick = currentTick;\n    }\n\n    public int getCurrentTick() {\n        return currentTick;\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return false;\n    }\n\n    @Override\n    public void setCancelled(boolean b) {\n\n    }\n}复制代码使用该事件（Calling an Event）\nnew BukkitRunnable() {\n            public void run() {\n                TickEvent tickEvent = new TickEvent(currentTicks++);\n\n                Atlas.getInstance().getEventManager().callEvent(tickEvent);\n       }\n}.runTaskTimerAsynchronously(this, 1L, 1L);复制代码监听示例：\npackage cc.funkemunky.anticheat.impl.listeners;\n\nimport cc.funkemunky.anticheat.Rock;\nimport cc.funkemunky.anticheat.api.data.PlayerData;\nimport cc.funkemunky.anticheat.api.event.TickEvent;\nimport cc.funkemunky.api.Atlas;\nimport cc.funkemunky.api.events.AtlasListener;\nimport cc.funkemunky.api.events.Listen;\nimport cc.funkemunky.api.utils.Init;\n\n@Init\npublic class FunkeListeners implements AtlasListener {\n\n    @Listen\n    public void onTickEvent(TickEvent event) {\n        Atlas.getInstance().executeTask(() -> Rock.getInstance().getDataManager().getDataObjects().keySet().forEach(key -> {\n            PlayerData data = Rock.getInstance().getDataManager().getDataObjects().get(key);\n\n            data.getActionProcessor().update(data);\n        }));\n    }\n}复制代码注册监听器\npublic void onEnable() {\n        Atlas.getInstance().getEventManager().registerListeners(new FunkeListeners(), this);\n}复制代码自定义数据包系统\n发送数据包\nTinyProtocolHandler.sendPacket(e.getPlayer(), new WrappedOutKeepAlivePacket(233 + e.getPlayer().getEntityId() + 935));复制代码监听数据包\n@Listen\n    public void onEvent(PacketRecieveEvent e) {\n        if(e.getType().equals(Packet.Client.ENTITY_ACTION)) {\n            WrappedInEntityActionPacket packet = new WrappedInEntityActionPacket(e.getPacket(), e.getPlayer());\n\n            switch(packet.getAction()) {\n                case START_SNEAKING:\n                    data.skiderino.sneak = true;\n                    break;\n                case STOP_SNEAKING:\n                    data.skiderino.sneak = false;\n                    break;\n                case START_SPRINTING:\n                    data.skiderino.sprint = true;\n                    break;\n                case STOP_SPRINTING:\n                    data.skiderino.sprint = false;\n                    break;\n            }\n        }\n    }\n 复制代码监听已发送的数据包\n        if (data != null) {\n            switch (e.getType()) {\n                case Packet.Server.KEEP_ALIVE:\n                    data.lastServerKeepAlive = System.currentTimeMillis();\n                    break;\n                case Packet.Server.ENTITY_METADATA:\n                    WrappedOutEntityMetadata wrapper = new WrappedOutEntityMetadata(e.getPacket(), e.getPlayer());\n\n                    if(wrapper.getObjects().size() > 0) {\n                        if(wrapper.getObjects().get(0).getObject() instanceof Byte && (data.isUsingItem = ((Byte) wrapper.getObjects().get(0).getObject()) % 0x5 == 1)) {\n                            data.lastUseItem.reset();\n                        }\n                    }\n                break;\n            }\n        }\n    }复制代码碰撞箱\n获取特殊方块的碰撞箱\n@EventHandler(priority = EventPriority.HIGHEST)\n    public void onEvent(PlayerInteractEvent event) {\n        if (event.getAction() == Action.RIGHT_CLICK_BLOCK) {\n            if (event.getItem() != null\n                    && event.getItem().getType().equals(Material.BLAZE_ROD)\n                    && event.getItem().getItemMeta().getDisplayName().equalsIgnoreCase(Color.Red + \"Magic Box Wand\")) {\n                Block block = event.getClickedBlock();\n\n                event.getPlayer().sendMessage(block.getType().name() + \"'s Data: \" + block.getData());\n                for (BoundingBox box : Atlas.getInstance().getBlockBoxManager().getBlockBox().getSpecificBox(block.getLocation())) {\n                    for (float x = box.minX; x < box.maxX; x += 0.2f) {\n                        for (float y = box.minY; y < box.maxY; y += 0.2f) {\n                            for (float z = box.minZ; z < box.maxZ; z += 0.2f) {\n                                WrappedPacketPlayOutWorldParticle packet = new WrappedPacketPlayOutWorldParticle(WrappedEnumParticle.FLAME, true, x, y, z, 0f, 0f, 0f, 0f, 1, null);\n                                packet.sendPacket(event.getPlayer());\n                            }\n                        }\n                    }\n                    event.getPlayer().sendMessage(ReflectionsUtil.getVanillaBlock(event.getClickedBlock()).getClass().getSimpleName() + \": \" + box.toString());\n                }\n            }\n        }\n    }复制代码获取所有接触的玩意的碰撞箱\nList<BoundingBox> box = Atlas.getInstance().getBlockBoxManager().getBlockBox().getCollidingBoxes(to.getWorld(), data.boundingBox.grow(0.5f, 0.1f, 0.5f).subtract(0, 0.5f, 0, 0, 0, 0));\n\n        CollisionAssessment assessment = new CollisionAssessment(data.boundingBox, data);\n        box.forEach(bb -> assessment.assessBox(bb, to.getWorld()));\n 复制代码获取实体碰撞箱（hitbox是碰撞箱..）\nMiscUtils.getEntityBoundingBox(e.getPlayer());复制代码\n\nWiKi\n如果你对此有任何问题，欢迎查阅Wiki\n（WiKi正在翻译中）\n\nWiki:\n欢迎来到舆图的维基百科，在这里，你可以学习到如何使用该API及其文档。\n不过仍在编写中，所以请耐心等待成品\n数据包：\n使用舆图API，让使用数据包变得前所未有的简单。该系统基于aadnk的TinyProtocol。兼容大多数版本（1.7.10-1.14），而且还是自动处理数据包，所以你每次处理这些数据包的时候，都不需要谷歌的那些玩意\n事件：\npackage cc.funkemunky.anticheat.impl.listeners;\n\nimport cc.funkemunky.api.events.AtlasListener;\nimport cc.funkemunky.api.events.Listen;\nimport cc.funkemunky.api.events.impl.PacketReceiveEvent;\nimport cc.funkemunky.api.events.impl.PacketSendEvent;\nimport cc.funkemunky.api.utils.Init;\n\n@Init\npublic class MyListener implements AtlasListener {\n    \n    //Listening for packets from the player.\n    @Listen\n    public void onEvent(PacketReceiveEvent event) {\n        \n    }\n    \n    //Listening for packets from the server.\n    @Listen\n    public void onEvent(PacketSendEvent event) {\n        \n    }\n    \n}复制代码数据包的接收事件\n方法名称返回值说明 getPlayer() Player 获取收到该数据包的玩家ID getPacket() Object 返回从netty连接接收到的vanilla类 isCancelled() boolean 判断该事件是否被取消 getType() String 返回已解析的数据包的名称 getTimeStamp() long返回收到该数据包的确切时间setPacket(Object)void修改vanilla类setCancelled(boolean)void设置事件是否取消数据包的发送事件\n以上同样\nAnnotations\n对于从事大型项目开发的人员来说，使用注释可以获得更加高效和简洁的体验，这是关于如何使用舆图来实现注释技术的文档\n参数的用法（未翻译）\n\n\n\n\n",
    "replies": []
}