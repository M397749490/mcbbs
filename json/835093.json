{
    "title": "[Tutorial][Bone Studio]从零开始的MC特效 (三 | 向量的旋转)",
    "author": "602723113",
    "replyCount": 5,
    "timestamp": 1547354460,
    "txt_content": " 本帖最后由 602723113 于 2019-1-19 21:51 编辑 \n\n目录:\n\n导读Yaw，Pitch，Roll与向量的旋转利用向量旋转一个圆\n\n\n导读\n\n导读 本教程需要读者有一定的空间想象能力(因为我也懒得画图了233) 本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心 在阅读之前请确保你具有高中数学必修4和选修4-4坐标系与参数方程和Java基础的知识 (没有我不会解释的)\n\n高三时间有限，我就不解释了，请读者见谅! —— 作者 2019/1/12\n<To初中生>: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧...)\n<To高中生>: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾\n<To大学生>: 没什么好说的...\n\nYaw，Pitch，Roll与向量的旋转\n\n这次我们来讲讲一些概念上的东西，在Minecraft中除了X, Y, Z之外Location还有两个量一个是Yaw一个是Pitch，这两个东西在学术上被称为欧拉角(飞机姿态角) 怎么理解这三个内容呢？\n\nYaw: 我们 水平旋转 我们的头，也就是左右转头，这就是一次Yaw转动\n\nPitch: 我们 上下旋转 我们的头，也就是上下点头，这就是一次Pitch转动\n\nRoll: 这个东西在Minecraft里面没有，但是我也讲一下，大家都玩过绝地求生吧，里面的人物QE摇头时就是一次Roll转动\n\n看不懂我说的可以看别的有图的\n\n那么它们跟我们的向量旋转有什么关系呢？其实在Minecraft中，我们利用Yaw和Pitch就可以描述出一个Vector向量，如我们看如下的图\n\n\n在Minecraft当中，Yaw为0时，它表示的就是Z轴正半轴的方向，为-90°时则表示X轴正半轴的方向\n\nPitch就是你的Steve上下看时的方向，看向天空时最大值是-90，看向地板时最大值是90，正视时就是0\n\n\n概念的东西都讲完了，我们来谈谈向量的旋转，那么在数学上的话，平面向量的旋转是有直接的公式套用，或者利用矩阵也可以达到目的，点我看相关资料\n\n那么通过上面的资料，我们就可以得到三个方法\n\n    /**\n     * 将一个向量围绕X轴旋转angle个角度\n     *\n     * @param v     向量\n     * @param angle 角度\n     * @return {@link Vector}\n     */\n    public static Vector rotateAroundAxisX(Vector v, double angle) {\n        angle = Math.toRadians(angle);\n        double y, z, cos, sin;\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        y = v.getY() * cos - v.getZ() * sin;\n        z = v.getY() * sin + v.getZ() * cos;\n        return v.setY(y).setZ(z);\n    }\n\n    /**\n     * 将一个向量围绕Y轴旋转angle个角度\n     *\n     * @param v     向量\n     * @param angle 角度\n     * @return {@link Vector}\n     */\n    public static Vector rotateAroundAxisY(Vector v, double angle) {\n        angle = -angle;\n        angle = Math.toRadians(angle);\n        double x, z, cos, sin;\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        x = v.getX() * cos + v.getZ() * sin;\n        z = v.getX() * -sin + v.getZ() * cos;\n        return v.setX(x).setZ(z);\n    }\n\n    /**\n     * 将一个向量围绕Z轴旋转angle个角度\n     *\n     * @param v     向量\n     * @param angle 角度\n     * @return {@link Vector}\n     */\n    public static Vector rotateAroundAxisZ(Vector v, double angle) {\n        angle = Math.toRadians(angle);\n        double x, y, cos, sin;\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        x = v.getX() * cos - v.getY() * sin;\n        y = v.getX() * sin + v.getY() * cos;\n        return v.setX(x).setY(y);\n    }复制代码\n那么如果我们想用Yaw和Pitch来旋转向量应该怎么做呢？这里我直接给出方法，来自开源项目EffectLib里的VectorUtils.java\n\n    /**\n     * This handles non-unit vectors, with yaw and pitch instead of X,Y,Z angles.\n     * <p>\n     * Thanks to SexyToad!\n     * <p>\n     * 将一个非单位向量使用yaw和pitch来代替X, Y, Z的角旋转方式\n     *\n     * @param v            向量\n     * @param yawDegrees   yaw的角度\n     * @param pitchDegrees pitch的角度\n     * @return\n     */\n    public static final Vector rotateVector(Vector v, float yawDegrees, float pitchDegrees) {\n        double yaw = Math.toRadians(-1 * (yawDegrees + 90));\n        double pitch = Math.toRadians(-pitchDegrees);\n\n        double cosYaw = Math.cos(yaw);\n        double cosPitch = Math.cos(pitch);\n        double sinYaw = Math.sin(yaw);\n        double sinPitch = Math.sin(pitch);\n\n        double initialX, initialY, initialZ;\n        double x, y, z;\n\n        // Z_Axis rotation (Pitch)\n        initialX = v.getX();\n        initialY = v.getY();\n        x = initialX * cosPitch - initialY * sinPitch;\n        y = initialX * sinPitch + initialY * cosPitch;\n\n        // Y_Axis rotation (Yaw)\n        initialZ = v.getZ();\n        initialX = x;\n        z = initialZ * cosYaw - initialX * sinYaw;\n        x = initialZ * sinYaw + initialX * cosYaw;\n\n        return new Vector(x, y, z);\n    }复制代码\n具体的证明过程我这里就不阐述了，请读者自行解决吧...\n\n那么有了上面的基础我们就可以来做一个简单向量旋转的特效\n\n利用向量旋转一个圆\n\n首先我们需要做个分析 如果我们要用向量制作一个围绕Y轴的圆可以怎么做呢？ 我们看下方的代码\n\npublic void createACircleWithVector(Location loc) {\n    double radius = 1D;\n    // 我们直接在X轴正半轴上加一个单位, 用来制作我们的第一个向量\n    Vector originalVector = getVector(loc, loc.clone().add(1, 0, 0));\n    originalVector.multiply(radius); // 圆的半径长度\n    for (int degree = 0; degree < 360; degree++) {\n        // 我们将向量进行旋转\n        Vector vector = VectorUtils.rotateAroundAxisY(originalVector, degree);\n        loc.add(vector);\n        loc.getWorld().spawnParticle(Particle.FLAME, loc, 0);\n        loc.subtract(vector);\n    }\n}\n\n/**\n * 取第一个坐标到第二个坐标的向量\n *\n * @param firstLocation  坐标1\n * @param secondLocation 坐标2\n * @return {@link Vector}\n */\npublic static Vector getVector(Location firstLocation, Location secondLocation) {\n    return secondLocation.clone().subtract(firstLocation).toVector();\n}复制代码\n首先我们看这行代码 Vector originalVector = getVector(loc, loc.clone().add(1, 0, 0)); 这行要怎么理解呢？我们看下方的图来理解一下\n\n首先我们在loc的X轴上增加了一个单位也就是图中的A点，那么我们利用终点减起点来得到向量OA(看不懂的去复习MC特效二)，那么这个向量OA我们将做为我们的待旋转向量\n\n之后我们进入循环，我们假设degree是2 Vector vector = VectorUtils.rotateAroundAxisY(originalVector, 2); 那么我们调用该方法即可得到绕Y轴逆时针旋转2个角度后的向量\n\n之后就是坐标加向量，绘制粒子，坐标减去向量保持坐标不变等一系列通法 最终的效果就是这样啦\n\n\n那么我们如果想制作一个类似物品掉落时，然后物品围绕Y轴旋转的那种效果，我们又要怎么做呢？这里我们就要利用到Yaw和Pitch\n\n首先我们这里新建一个类用于旋转圆特效的实现，并且让它继承BukkitRunnable，当然Runnable也是可以的\n\npublic class RotatableCircle extends BukkitRunnable {\n\n    // 原点\n    private Location location;\n    // X轴上的单位向量\n    private Vector originalVector;\n\n    private float yaw = 0;\n    private double radius = 1D;\n\n    public RotatableCircle(Location location) {\n        this.location = location.clone();\n        // getVector() 方法是上面已经发过的一个方法，目的是构造一个向量OA\n        originalVector = getVector(location, location.clone().add(1, 0, 0));\n    }\n\n    @Override\n    public void run() {\n\n    }\n    /**\n     * 取第一个坐标到第二个坐标的向量\n     *\n     * @param firstLocation  坐标1\n     * @param secondLocation 坐标2\n     * @return {@link Vector}\n     */\n    public static Vector getVector(Location firstLocation, Location secondLocation) {\n        return secondLocation.clone().subtract(firstLocation).toVector();\n    }\n}复制代码\n从上方的代码我们先简单的需要几个基本量，待旋转向量和原点即可，之后yaw和radius分别是yaw和圆的半径\n\n在构造函数里，我们将传入的location参数进行克隆以防原location的变动 之后我们依然做一个向量OA，当作待旋转向量\n\n之后我们进行几何分析，看下图\n\n首先这是一个向量OA，如果我们想让它旋转1个yaw单位可以使用以下方法 \nVector vector = VectorUtils.rotateVector(originalVector, 1, 0) \n \n那么这就是旋转一个θ yaw角，那么pitch角要怎么旋转呢？\n \n根据上方的图我们将向量OA旋转θ个角之后得到了向量OB，那么我们就可以这么写我们的代码\n\n// 请注意第三个参数 θ 是角度\nVector vector = VectorUtils.rotateVector(originalVector, 0, θ)复制代码\n那么有了上面的铺垫我们可以这么写我们的RotatableCircle\n\npublic class RotatableCircle extends BukkitRunnable {\n\n    // 原点\n    private Location location;\n    // X轴上的单位向量\n    private Vector originalVector;\n\n    private float yaw = 0;\n    private double radius = 1D;\n\n    public RotatableCircle(Location location) {\n        this.location = location.clone();\n        originalVector = VectorUtils.getVector(location, location.clone().add(1, 0, 0));\n    }\n\n    @Override\n    public void run() {\n        // 我们假设是第一次yaw旋转, 那么是0, 所以我们先将originalVector旋转yaw个单位\n        Vector vectorYaw = VectorUtils.rotateVector(originalVector, yaw, 0);\n        // 之后我们将pitch进行 90 ~ -90 的一个循环用于将向量进行上下翻转\n        for (float pitch = 90; pitch > -90; pitch--) {\n            Vector vector = VectorUtils.rotateVector(vectorYaw, 0, pitch);\n            // 这样得出来的vector只有一个半圆, 那么另外一个向量我们可以通过得到相反向量来制造出\n            Vector reverseVector = vector.clone().multiply(-1);\n\n            // 在正方向上绘制粒子\n            location.add(vector);\n            location.getWorld().spawnParticle(Particle.FLAME, location, 0);\n            location.subtract(vector);\n\n            // 在反方向上绘制粒子\n            location.add(reverseVector);\n            location.getWorld().spawnParticle(Particle.FLAME, location, 0);\n            location.subtract(reverseVector);\n        }\n\n        // 将yaw设定在0~360之间进行循环\n        if (yaw >= 360) {\n            yaw = 0;\n        } else {\n            yaw++;\n        }\n    }\n}复制代码\n我们在代码中像下方一样调用\n\nRotatableCircle rotatableCircle = new RotatableCircle(location);\nrotatableCircle.runTaskTimer(你插件的主类实例, 0L, 3L);复制代码\n最终的效果 \n\n\n\n结语\n高三不易，望读者谅解! —— 撰写: 一个来自普高文科的学生\n\n[groupid=1306]Bone Studio[/groupid]",
    "replies": [
        {
            "author": "Hueihuea",
            "timestamp": 1547363580,
            "txt_content": "写得真好\n但是我按不动评分\n没办法 下次再评分XD"
        },
        {
            "author": "南外丶仓鼠",
            "timestamp": 1553930820,
            "txt_content": "请问大佬，怎么求一个向量经过一个平面反弹后的向量？\n比如说向量v碰到了[0,0,0]的泥土块，反弹变成v'，求这个v'"
        },
        {
            "author": "602723113",
            "timestamp": 1553948640,
            "txt_content": "动态规划DFS 发表于 2019-3-30 15:27\n请问大佬，怎么求一个向量经过一个平面反弹后的向量？\n比如说向量v碰到了[0,0,0]的泥土块，反弹变成v'，求 ...\n经过这个平面的代码我就不写了手机\n\nv2 = v1.mutiply(-1);\n即可得到这个向量的相反向量"
        },
        {
            "author": "南外丶仓鼠",
            "timestamp": 1554085560,
            "txt_content": " 本帖最后由 动态规划DFS 于 2019-4-1 10:34 编辑 \n602723113 发表于 2019-3-30 20:24\n经过这个平面的代码我就不写了手机\n\nv2 = v1.mutiply(-1);\n谢谢大佬\n乘以-1表示的是反向量\n我想知道一个向量接触平面后遵循物理的反射原理的新向量\n请问是它自乘吗？v2=v1.mutiply(v1)吗？（我试了这个卓有成效）如图\n\n\n\n\n\nQQ截图20190401103356.png\n(21.08 KB, 下载次数: 0)\n\n\n\n\n下载附件\n\n\n2019-4-1 10:34 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "author": "602723113",
            "timestamp": 1554463140,
            "txt_content": "动态规划DFS 发表于 2019-4-1 10:26\n谢谢大佬\n乘以-1表示的是反向量\n我想知道一个向量接触平面后遵循物理的反射原理的新向量\n我觉得你可以使用一下射影的计算，下面是资料\n\nhttps://baike.so.com/doc/6215677-6428950.html\n\n或者你可以用旋转也可以"
        }
    ]
}