{
    "title": "没什么用的教程：挖掘基岩！",
    "author": "Sssss...",
    "replyCount": 2,
    "timestamp": 1584882540,
    "txt_content": " 本帖最后由 Sssss... 于 2020-3-23 12:05 编辑 \n\n本教程的代码部分测试于Bukkit 1.13，理论上所有版本通用\n\n一、思路整理\n几天前打算写一个关于基岩的插件（即将发布），但由于基岩在生存模式无法破坏，所以需要通过一些特殊的方式“挖掘”\n不久后翻阅Bukkit API文档时看到了一个没用过的事件：PlayerAnimationEvent，文档内的介绍是“玩家动作事件”，只能检测摆臂\n\n于是因为我闲的没事干（可能），就简单测试了一下，得出以下结论：\nPlayerAnimationEvent在玩家对着方块按住鼠标时，每tick触发一次PlayerInteractEvent仅在玩家按下鼠标的那一刻触发一次，刚好可以用于防止连点器挖掘PlayerInteractEvent在Animation之前触发\n\n现在可以通过计数器实现基岩挖掘。经过简单的思考，得出以下过程：记录在两次PlayerInteractEvent之间的PlayerAnimationEvent触发次数当次数达到规定次数（也就是基岩挖掘所需的刻数）时破坏方块并刷新进度\n\n考虑到挖掘的方块变化、手中物品变化时需要清零挖掘进度得到以下较为详细的过程（以下[I]代表Interact事件监听器，[A]代表Animation）：\n以下所有的变量（isMining，animationCount，lastInteractLocation，lastInteractTool）实际应用时应改为Map监听器的各种判断，如是否点击方块、方块种类等省略，此处列举的为思路，并非实际代码实现设挖掘时间为5秒，即100ticks\n[I] 将isMining设置为true // 声明玩家正在挖掘基岩，使Animation监听器工作[I] 将animationCount设为0 // 重置进度[I] 向lastInteractLocation写入点击的方块位置 // 防止鼠标移动挖掘其他方块[I] 向lastInteractTool写入手中的物品 // 防止切换到其他物品\n也许有人会好奇为什么没有一个100t之后刷新进度的定时器？因为实际上不刷新进度不会有影响，玩家松开鼠标以后再次点击必将触发PlayerInteractEvent，所以是否刷新无关紧要\n[A] 若isMining为false（玩家不在挖掘基岩），则跳出监听器[A] 若lastInteractLocation或lastInteractTool不匹配（前者使用getTargetBlock方法），则将isMining设置为false并跳出监听器[A] animationCount的值增加1 // 计数[A] 若animationCount的值为100（即挖掘结束），将isMining设置为false，触发方块破坏\n\n\n深究一下，会发现isMining变量实际上并没有作用\n因为挖掉方块后会因为lastInteractLocation不符而不再执行[A]监听器，若下方为虚空则不会继续触发[A]\n于是删除I.1与A.1两步\n\n\n二、代码实现（由于MCBBS自带的代码显示会出现内容消失等bug，故直接使用文本形式）\n        public static final int TICKS = 100; // 挖掘所需时间\n        static int animationCount = 0;        static Location lastInteractLocation;\n        static ItemStack lastInteractTool;\n        \n        @EventHandler\n        public void onInteract(PlayerInteractEvent event) {\n                if (!event.getAction != Action.LEFT_CLICK_BLOCK) {\n                        return;\n                }\n                // 一堆判断\n                // 下面的判断铁镐是我懒得写null判断（毕竟也不能让玩家随意挖掘基岩）\n                if (!event.hasBlock()) {\n                        return;\n                }\n                // 此处特意写出来并注释\n                // 为什么？\n                // 因为如果这么写，可以通过挖掘其他方块并切换到另一个之前挖掘过的方块\n                // 导致程序错乱（实际上应该也没有什么大问题）\n                // if (event.getClickedBlock().getType() != Material.BEDROCK) {\n                //         return;\n                // }\n                if (!event.hasItem()) {\n                        return;\n                }\n                if (event.getItem().getType() != Material.IRON_PICKAXE) {\n                        return;\n                }\n                animationCount = 0;\n                lastInteractLocation = event.getClickedBlock().getLocation();\n                lastInteractTool = event.getPlayer().getInventory().getItemInMainHand();\n        }\n        \n        @EventHandler\n        public void onAnimation(PlayerAnimationEvent event) {\n                if (!lastInteractLocation.equals(event.getPlayer().getTargetBlock(10).getLocation())) {\n                        return; // 正在挖掘的方块位置与第一次触发不符\n                }\n                if (!lastInteractTool.equals(event.getPlayer().getInventory().getItemInMainHand())) {\n                        return; // 手中的物品不符\n                }\n                animationCount++; // 计数\n                if (animationCount == TICKS) {\n                        toBreak(event.getPlayer().getTargetBlock(10)); // 破坏方块\n                }\n        }\n        \n        private void toBreak(Block block) {\n                block.setType(Material.AIR);\n                block.getWorld().dropItemNaturally(block.getLocation(), new ItemStack(Material.BEDROCK));\n        }\n然后就可以正常运行了，手持铁镐对着基岩按住五秒后基岩就掉落为物品\n\n是不是觉得少了什么？\n没有粒子效果使破坏过程过于突兀，于是加上粒子效果：游戏卡顿的时候可以观察到破坏方块的粒子实际上是从4x4x4的64个点创建的因为基岩无法显示挖掘进度，所以可以加一条ActionBar而且挖基岩需要大量时间与精力（才5秒？），可以让它掉落经验球\n\n于是toBreak方法改为：\n        private void toBreak(Block block) {\n\n                for (double dx = -0.5; dx <= 0.5; dx += 0.333) {\n                        for (double dy = -0.5; dy <= 0.5; dy += 0.333) {\n                                for (double dz = -0.5; dz <= 0.5; dz += 0.333) {\n                                        Location location = block.getLocation().toCenterLocation().add(dx, dy, dz);\n                                        block.getWorld().spawnParticle(Particle.BLOCK_DUST, location, 3, block.getBlockData());\n                                }\n                        }\n                }\n                block.setType(Material.AIR);\n                block.getWorld().dropItemNaturally(block.getLocation().toCenterLocation(), new ItemStack(Material.BEDROCK));\n                ExperienceOrb orb = (ExperienceOrb) block.getWorld().spawnEntity(block.getLocation(), EntityType.EXPERIENCE_ORB);\n                orb.setExperience(new Random().nextInt(120) + 60);\n        }\nonAnimation下方加一行：\nevent.getPlayer().sendActionBar(\"§7基岩挖掘中... §f\" + Math.round((double) animationCount / TICKS * 1000) / 10 + \"%\");\n\n三、最终效果\n完美实现破坏基岩：\n（我截完这张图以后发现粒子太多了，于是把那边的8改成了3）\n\n\n\n由于最后一张图片的链接有敏感词（D.J），请手动输入链接查看（去掉链接中的中括号）\nhttps://i.loli.net/2020/03/22/xRD[]JydQ9q4mG8Ck.png\n\n",
    "replies": [
        {
            "author": "602723113",
            "timestamp": 1584886560,
            "txt_content": "如果挖掘基岩的效果可以配合上NMS的Block Break Animation, 那就会更好了，这里是包的信息\nhttps://wiki.vg/Protocol#Block_Break_Animation"
        },
        {
            "author": "洞穴夜莺",
            "timestamp": 1584887640,
            "txt_content": "为什么不直接使用原版的挖掘动画？"
        }
    ]
}