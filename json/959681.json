{
    "title": "创建了实体但是无法看见.",
    "author": "隔壁老吕",
    "replyCount": 3,
    "timestamp": 1581650400,
    "txt_content": " 本帖最后由 隔壁老吕 于 2020-2-14 11:21 编辑 \n\n生成后无法看见实体，但是AI工作正常。（没有给它隐形药水效果）\n在spigot1.13.2中，它是可见的。\n在1.12.1中，它是看不见的\n用EntitySpawnEvent替换原版僵尸。\n\n生成代码:\n    public DoomsdayZombie spawnDoomsdayZombie(Location loc) {\n        DoomsdayZombie dz = new DoomsdayZombie(loc);\n        CraftWorld craftWorld = (CraftWorld) loc.getWorld();\n        craftWorld.addEntity(dz, CreatureSpawnEvent.SpawnReason.CUSTOM);\n        return dz;\n    }复制代码\n实体代码:\npublic class DoomsdayZombie extends EntityZombie {\n\n    public ZombieTaskHandleStack taskHandle;\n    public static Double movementSpeed;\n    public ZombieAction action = ZombieAction.Avaiable;\n    public DoomsdaySurvival plugin;\n    public int stopCount = 0;\n    public double last_X, last_Z;\n\n    static {\n        movementSpeed = Config.DOOMSDAY_ZOMBIE_SPEED;\n    }\n\n    public DoomsdayZombie(Location loc) {\n        super(((CraftWorld) loc.getWorld()).getHandle());\n        this.plugin = DoomsdaySurvival.plugin;\n        setPosition(loc.getX(), loc.getY(), loc.getZ());\n        taskHandle = new ZombieTaskHandleStack(plugin, this);\n    }\n\n    @Override\n    protected void initAttributes() {\n        super.initAttributes();\n        getAttributeInstance(GenericAttributes.maxHealth).setValue(Config.DOOMSDAY_ZOMBIE_HEALTH);\n        getAttributeInstance(GenericAttributes.MOVEMENT_SPEED).setValue(movementSpeed);\n        getAttributeInstance(GenericAttributes.FOLLOW_RANGE).setValue(Config.DOOMSDAY_ZOMBIE_FOLLOWRANGE);\n        getAttributeInstance(GenericAttributes.ATTACK_DAMAGE).setValue(Config.DOOMSDAY_ZOMBIE_DAMAGE);\n    }\n\n    public boolean isSameWorldWithTarget() {\n        return getBukkitEntity().getWorld().getName().equals(getTarget().getWorld().getName());\n    }\n\n    public Location getLocation() {\n        return ((org.bukkit.entity.Zombie) getBukkitEntity()).getLocation().clone();\n    }\n\n    public ZombieAction getAction() {\n        return action;\n    }\n\n    public boolean isSameHeightWithTarget() {\n        return hasTarget() && Math.abs(getTarget().getLocation().getY() - locY) <= 0.5;\n    }\n\n    public void ifStop() {\n        if (stopCount == 0) {\n            last_X = locX;\n            last_Z = locZ;\n        }\n        stopCount++;\n        if (stopCount == 60) {\n            stopCount = 0;\n            if (getXZDistance(last_X, last_Z, locX, locZ) < 0.5 && action == ZombieAction.Avaiable) {\n                stop();\n            } else {\n                avaiable();\n            }\n        }\n    }\n\n    public void stop() {\n        action = ZombieAction.Stop;\n        goalSelector = new PathfinderGoalSelector((world != null) && (world.methodProfiler != null) ? world.methodProfiler : null);\n        goalSelector.a(0, new PathfinderGoalFloat(this));\n        targetSelector = new PathfinderGoalSelector((world != null) && (world.methodProfiler != null) ? world.methodProfiler : null);\n    }\n\n    public void avaiable() {\n        action = ZombieAction.Avaiable;\n        goalSelector = new PathfinderGoalSelector((world != null) && (world.methodProfiler != null) ? world.methodProfiler : null);\n        goalSelector.a(0, new PathfinderGoalFloat(this));\n        goalSelector.a(1, new PathfinderGoalZombieAttack(this, 1.0D, false));\n        goalSelector.a(1, new DoomsdayZombieBreakPathfinderGoal(this));\n        goalSelector.a(1, new DoomsdayZombiePlacePathfinderGoal(this));\n        targetSelector = new PathfinderGoalSelector((world != null) && (world.methodProfiler != null) ? world.methodProfiler : null);\n        targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityHuman.class, true));\n        if (world.spigotConfig.zombieAggressiveTowardsVillager) {\n            targetSelector.a(3, new PathfinderGoalNearestAttackableTarget(this, EntityVillager.class, false));\n        }\n\n    }\n\n    @Override\n    public void B_() {\n        if (hasTarget()) {\n            ifStop();\n            if (!isBlockPassable(taskHandle.getHeadBlock().getRelative(BlockFace.DOWN))) {\n                taskHandle.push(new BlockTask(taskHandle.getHeadBlock().getRelative(BlockFace.DOWN)));\n            }\n            if (!isBlockPassable(taskHandle.getHeadBlock())) {\n                taskHandle.push(new BlockTask(taskHandle.getHeadBlock()));\n            }\n            if (getTarget().getLocation().getY() - locY > 0.5 && (action == ZombieAction.Stop || getXZDistance(getTarget().getLocation(), this.getBukkitEntity().getLocation()) < 7)) {\n                stop();\n                Location loc = getLocation();\n                setPosition(loc.getBlockX() + 0.5, locY, loc.getBlockZ() + 0.5);\n                if (!isBlockPassable(taskHandle.getBlockOnHead())) {\n                    taskHandle.push(new BlockTask(taskHandle.getBlockOnHead()));\n                } else {\n                    BlockTask task = new BlockTask(loc, 1);\n                    task.isUp = true;\n                    taskHandle.push(task);\n                }\n            } else {\n                if (locY - getTarget().getLocation().getY() > 1 && getXZDistance(bukkitEntity.getLocation(), getTarget().getLocation()) < 5 && isInWater()) {\n                    Location loc = getLocation().subtract(0, 1, 0);\n                    taskHandle.push(new BlockTask(loc.getBlock()));\n                    motY = -movementSpeed;\n                    avaiable();\n                } else if (locY - getTarget().getLocation().getY() > 1 && getXZDistance(bukkitEntity.getLocation(), getTarget().getLocation()) < 0.3) {\n                    Location loc = getLocation().subtract(0, 1, 0);\n                    taskHandle.push(new BlockTask(loc.getBlock()));\n                    avaiable();\n                } else if (isSameHeightWithTarget() || getTarget().getLocation().getY() - locY > 1 && action == ZombieAction.Stop) {\n                    avaiable();\n                }\n            }\n        } else {\n            avaiable();\n            foundTarget();\n        }\n        taskHandle.doTick();\n        super.B_();\n    }\n\n    public static Block getNMSBlock(CraftBlock b) {\n        return (Block) NBT.doMethod(b, \"getNMSBlock\");\n    }\n\n    public static IBlockData getBlockNMS(CraftBlock b) {\n        return (IBlockData) NBT.doMethod(b, \"getData0\");\n    }\n\n    public static boolean isBlockPassable(org.bukkit.block.Block b) {\n        return b.isEmpty();\n    }\n\n    public void foundTarget() {\n        if (!hasTarget()) {\n            for (org.bukkit.entity.Entity en : bukkitEntity.getNearbyEntities(Config.DOOMSDAY_ZOMBIE_FOLLOWRANGE, Config.DOOMSDAY_ZOMBIE_FOLLOWRANGE, Config.DOOMSDAY_ZOMBIE_FOLLOWRANGE)) {\n                if (en instanceof org.bukkit.entity.LivingEntity) {\n                    if (en instanceof org.bukkit.entity.Player) {\n                        if (((org.bukkit.entity.Player) en).getGameMode() != GameMode.CREATIVE) {\n                            setTarget((LivingEntity) en);\n                            return;\n                        }\n                    }\n                    if (en instanceof org.bukkit.entity.Villager || en instanceof org.bukkit.entity.IronGolem) {\n                        setTarget((LivingEntity) en);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    public static double getXZDistance(double x1, double z1, double x2, double z2) {\n        return Math.sqrt((x1 - x2) * (x1 - x2)\n                + (z1 - z2) * (z1 - z2));\n    }\n\n    public static double getXZDistance(Location loc1, Location loc2) {\n        return Math.sqrt((loc1.getX() - loc2.getX()) * (loc1.getX() - loc2.getX())\n                + (loc1.getZ() - loc2.getZ()) * (loc1.getZ() - loc2.getZ()));\n    }\n\n    public org.bukkit.entity.LivingEntity getTarget() {\n        return ((org.bukkit.entity.Zombie) getBukkitEntity()).getTarget();\n    }\n\n    public boolean hasTarget() {\n        if (((org.bukkit.entity.Zombie) getBukkitEntity()).getTarget() != null) {\n            if (!((org.bukkit.entity.Zombie) getBukkitEntity()).getTarget().isDead() && isSameWorldWithTarget()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public void setTarget(org.bukkit.entity.LivingEntity le) {\n        ((org.bukkit.entity.Zombie) getBukkitEntity()).setTarget(le);\n    }\n\n    @Override\n    public void n() {\n        goalSelector.a(0, new PathfinderGoalFloat(this));\n        goalSelector.a(1, new PathfinderGoalZombieAttack(this, 1.0D, false));\n        targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityHuman.class, true));\n        if (world.spigotConfig.zombieAggressiveTowardsVillager) {\n            targetSelector.a(3, new PathfinderGoalNearestAttackableTarget(this, EntityVillager.class, false));\n        }\n        goalSelector.a(1, new DoomsdayZombieBreakPathfinderGoal(this));\n        goalSelector.a(1, new DoomsdayZombiePlacePathfinderGoal(this));\n    }\n\n    public enum ZombieAction {\n        Avaiable,\n        Stop;\n    }\n}复制代码\n\n",
    "replies": [
        {
            "author": "帅比小樊",
            "timestamp": 1581652020,
            "txt_content": "https://www.mcbbs.net/thread-811096-1-1.html\n请观看 自定义生物的教程 \n如果对有生命的实体进行开发 \n需要注册实体 否则就会看不见 \n1.11为分界线 注册方法不同 \n[img]%5Burl=https://sm.ms/image/642kJDQAVemgYwN%5D[/url][/img]\n以上代码均来自教程\n详情可前往观看"
        },
        {
            "author": "谢谢你了",
            "timestamp": 1581654180,
            "txt_content": "凉拌凑字凑字还好还好"
        },
        {
            "author": "TopLuren",
            "timestamp": 1581677400,
            "txt_content": "正好是我需要的，太感谢了"
        }
    ]
}