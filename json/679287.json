{
    "title": "记mod开发中遇到的一些问题",
    "author": "天朝荡寇",
    "replyCount": 0,
    "timestamp": 1489021680,
    "txt_content": " 本帖最后由 天朝荡寇 于 2017-3-9 12:08 编辑 \n\n本人在Mod（xuan xue）开（xiu）发（lian）过程遇到的一些问题，在这里记录下来解决办法，供大家参考。\n我的forge版本是1.7.10\n\nEntity\n\n（1）Entity的渲染及Techne的使用：\nTechne导出的模型是Model类。在RenderLiving的构造方法中就可以作为一个参数输入。这很方便。\n但是要是继承的是其他的Render（如投射物）就没有这个参数，那怎么办呢？\n我得出的结论是：\nModel类的render()其实就是发送了一组OpenGL命令。在参考了http://www.mcbbs.net/thread-204115-1-1.html这篇教程之后。我将我用Techne做出的Model类生成了一个实例，在这个Render的doRender（）方法中调用model.render（）。就成功了。\n像这样：public  class RenderIceSpear extends  Render{\n        private ModelIceSpear model=new ModelIceSpear();\n\n        private static final ResourceLocation TEXTURE = new ResourceLocation(\"magiccode\" + \":\" + \"models/IceSpear.png\");\n        \n        public RenderIceSpear() {\n                super();\n                // TODO Auto-generated constructor stub\n        }\n        \n        @Override\n        public void doRender(Entity entity, double x, double y, double z, float entityYaw, float partialTicks)\n    {\n                        Tessellator t = Tessellator.instance;\n                \n                GL11.glPushMatrix(); \n                GL11.glDisable(GL11.GL_CULL_FACE); \n                GL11.glDisable(GL11.GL_LIGHTING); \n\n                GL11.glTranslated(x, y, z); \n                GL11.glRotatef(entity.rotationYaw, 0.0F, 1.0F, 0.0F); \n                GL11.glRotatef(-entity.rotationPitch, 1.0F, 0.0F, 0.0F);\n                Minecraft.getMinecraft().renderEngine.bindTexture(getEntityTexture(entity));//\n                model.render(entity,0, 0, 0, 0, 0, 0.0625f);\n                \n                GL11.glEnable(GL11.GL_CULL_FACE);\n                GL11.glEnable(GL11.GL_LIGHTING);\n                GL11.glPopMatrix(); //\n    }复制代码\n\n（2）Entity的附加属性（如技能，蓝条）的制作\n感谢@[size=1em]Jackiecrazy告诉我的IEEP\n使用方法详情参考http://mcforge-cn.readthedocs.io ... edentityproperties/\n看了Entity的FormNBT()的代码之后你就会发现IEEP是在for (String identifier : this.extendedProperties.keySet())\n            {\n                try\n                {\n                    IExtendedEntityProperties props = this.extendedProperties.get(identifier);\n                    props.loadNBTData(p_70020_1_);\n                }\n                catch (Throwable t)\n                {\n                    FMLLog.severe(\"Failed to load extended properties for %s.  This is a mod issue.\", identifier);\n                    t.printStackTrace();\n                }\n            }复制代码\n那么问题就来了，当玩家刚刚生成的时候，没有你注册的这个Key，也就是就是String identifier : this.extendedProperties.keySet()这里没有获取到你的IEEP的Key，那么他是不会读取到你保存的数据的（我使用的时候老是只saveNBT没有loadNBT就是这个原理）。\n怎么解决呢？\n事件EntityConstructing在FormNBT()之前调用，所以说你要在这里给Entity加上这个Key的IEEP（里面的数据什么样无所谓），如果你不是奇葩的话，在这里面调用你的IEEP的init()即可。\n\n\n（3）关于RotationYaw和RotationPicth的玄学；\n我有一段类似于entity.rotationYaw=0;entity.rotationPicth=0;的代码。结果我发现 箭及投掷物 和 玩家 执行了相同的代码之后，头的朝向是正好相反的。mod玄学，勃大茎深啊！\n\n\nItem\n\n（1）如何自定义Item的渲染\npublic class RenderIItem implements IItemRenderer\n{\n        protected ModelSlash swordModel;\n        float scale = 0.6F;\n\n        public RenderIItem()\n        {\n                swordModel= new ModelSlash();\n        }\n\n        @Override\n        public boolean handleRenderType(ItemStack item, ItemRenderType type)\n        {\n                switch(type)\n                {\n                case EQUIPPED: return true;\n\n                case EQUIPPED_FIRST_PERSON: return true;\n\n                default: return false;\n                }\n        }\n        @Override\n        public boolean shouldUseRenderHelper(ItemRenderType type, ItemStack item,ItemRendererHelper helper)\n        {\n                return false;\n        }\n        @Override\n        public void renderItem(ItemRenderType type, ItemStack item, Object... data)\n        {\n\n                switch(type)\n                {\n                        case EQUIPPED://（F5）\n                        {\n                                GL11.glPushMatrix();\n\n\n                                GL11.glScalef(scale, scale, scale);\n          \n                                GL11.glRotatef(95.0F, 1.0F, 0.0F, 0.0F);\n                                GL11.glRotatef(-60F, 0.0F, 1.0F, 0.0F);\n                                GL11.glRotatef(-80F, 0.0F, 0.0F, 1.0F);\n\n                                Minecraft.getMinecraft().renderEngine.bindTexture(new ResourceLocation(\"fantasy\" + \":\" + \"textures/items/UBW.png\"));\n\n                                swordModel.render((Entity)data[1], 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0625F);\n                                \n                                GL11.glPopMatrix();\n                                break;\n                        }\n\n                        case EQUIPPED_FIRST_PERSON://\n                        {\n                                GL11.glPushMatrix();\n\n\n                                GL11.glScalef(scale, scale, scale);\n\n                                GL11.glRotatef(95.0F, 1.0F, 0.0F, 0.0F);\n                                GL11.glRotatef(-60F, 0.0F, 1.0F, 0.0F);\n                                GL11.glRotatef(-80F, 0.0F, 0.0F, 1.0F);\n\n                                GL11.glTranslatef(0.125F, 0, 0);\n\n                                Minecraft.getMinecraft().renderEngine.bindTexture(new ResourceLocation(\"fantasy\" + \":\" + \"textures/items/UBW.png\"));\n\n                                swordModel.render((Entity)data[1], 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0625F);\n\n                                GL11.glPopMatrix();\n                        }\n\n\n                        default:\n                                break;\n\n                }\n\n        }\n}\n复制代码嘛，大约就是这样了。\n然后在Cli端这样：\nMinecraftForgeClient.registerItemRenderer(Item, new RenderIItem());\n（要是你在Server端也这样了的话，只会导致你的mod不支持服务器）\n\n\n（2）在ItemStack储存数据：\nhttp://www.mcbbs.net/forum.php?mod=viewthread&tid=662677&extra=\n参考此教程，在这之前我居然直接存到Item里面，呵呵。。。\n\n\n\n\n针对服务器编程的玄学：\n\n要mod支持服务器主要就是要分开服务端代码（尤其是这货）和客户端代码。只能在客户端出现的代码千万不能在服务端运行。比如\nMinecraftForgeClient.registerItemRenderer();\n\n玄学1、NetWork：\n如果你要向服务器发一个IMessage，很简单 客户端 和 服务器 都注册它就好了\n registerMessage(SlashMsg.Handler.class, SlashMsg.class, Side.SERVER);\n但是如果你要向客户端发送一个IMessage！\n你的IMessage的处理中如果有只能在客户端执行的代码。\n那么你直接 \nregisterMessage(SkillMsg.Handler.class, SkillMsg.class, Side.CLIENT);\n服务端会崩溃！\n那么如果我只在客户端注册它呢？\nif(event.getSide().isClient())\n                registerMessage(SkillMsg.Handler.class, SkillMsg.class, Side.CLIENT);\nOK？\n服务端 和 客户端 都开启而且看似正常的运行了。\n但是如果服务端会发送一个SkillMsg。那么由于没有在它这边注册，那么它不会发送这个msg，客户端也不会收到一个SkillMsg。\n所以你要在服务端也注册一个SkillMsg\nif(event.getSide().isClient())\n        {\n                registerMessage(SkillMsg.Handler.class, SkillMsg.class, Side.CLIENT);\n        }\n        else\n        {\n                registerMessage(SkillMsg.SerHandler.class, SkillMsg.class, Side.SERVER);\n        }\n\n哪怕这个SerHandler什么也不做。\n这样才能正常的运行（当然如果你不进行这些奇葩的行为的话，mod在单人游戏和多人联机的时候也不会有什么问题）\n\n这就是昨天晚上那个磨我到00:30的小妖精\n\n\n仅仅是一些我遇到的问题及解决办法的收录。\n\n\n\n\n\n\n",
    "replies": []
}