{
    "title": "[已解决][1.12][Bukkit]使用Proguard混淆后插件中的自定义序列化类报错，如何解决",
    "author": "Devil_xw",
    "replyCount": 2,
    "timestamp": 1586581800,
    "txt_content": " 本帖最后由 Devil_xw 于 2020-4-12 08:46 编辑 \n\n使用Proguard混淆后插件中的自定义序列化类报错\n\n\n\n\n报错1.png (211.32 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-11 12:52 上传\n\n\n\n\n\n\n\n\n报错2.png (118.55 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-11 12:53 上传\n\n\n\n\n\n\n\nProguard配置内容如下：\n\n-injars 'F:\\Java\\JAR\\SkyDream-v2.6.jar'\n-outjars SkyDream-v2.6.jar\n\n-libraryjars 'F:\\Java\\Example\\Spigot-1.12.2\\Spigot-1.12.2.jar'\n-libraryjars 'F:\\Java\\8u231\\lib\\rt.jar'\n\n-dontshrink\n-allowaccessmodification\n-keeppackagenames\n-keepattributes *Annotation*\n-dontwarn\n\n\n\n# Keep Main\n-keepclassmembers,allowoptimization class * extends org.bukkit.plugin.java.JavaPlugin\n\n# Keep Main\n-keep,allowoptimization class * extends org.bukkit.plugin.java.JavaPlugin\n\n# Keep Main 2\n-keepclassmembers,allowoptimization,allowobfuscation class * extends org.bukkit.plugin.java.JavaPlugin\n\n# Keep names - Native method names. Keep all native class/method names.\n-keepclasseswithmembers,allowshrinking class * {\n    native <methods>;\n}\n\n\n-keepnames class * implements java.io.Serializable\n-keepclassmembers class * implements java.io.Serializable {\n    static final long serialVersionUID;\n    private static final java.io.ObjectStreamField[] serialPersistentFields;\n    !static !transient <fields>;\n    private void writeObject(java.io.ObjectOutputStream);\n    private void readObject(java.io.ObjectInputStream);\n    java.lang.Object writeReplace();\n    java.lang.Object readResolve();\n}\n\n# Also keep - Enumerations. Keep the special static methods that are required in\n# enumeration classes.\n-keepclassmembers enum  * {\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n\n# Also keep - Database drivers. Keep all implementations of java.sql.Driver.\n-keep class * extends java.sql.Driver\n\n# Also keep - Swing UI L&F. Keep all extensions of javax.swing.plaf.ComponentUI,\n# along with the special 'createUI' method.\n-keep class * extends javax.swing.plaf.ComponentUI {\n    public static javax.swing.plaf.ComponentUI createUI(javax.swing.JComponent);\n}\n\n# Remove - System method calls. Remove all invocations of System\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.System {\n    public static long currentTimeMillis();\n    static java.lang.Class getCallerClass();\n    public static int identityHashCode(java.lang.Object);\n    public static java.lang.SecurityManager getSecurityManager();\n    public static java.util.Properties getProperties();\n    public static java.lang.String getProperty(java.lang.String);\n    public static java.lang.String getenv(java.lang.String);\n    public static java.lang.String mapLibraryName(java.lang.String);\n    public static java.lang.String getProperty(java.lang.String,java.lang.String);\n}\n\n# Remove - Math method calls. Remove all invocations of Math\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.Math {\n    public static double sin(double);\n    public static double cos(double);\n    public static double tan(double);\n    public static double asin(double);\n    public static double acos(double);\n    public static double atan(double);\n    public static double toRadians(double);\n    public static double toDegrees(double);\n    public static double exp(double);\n    public static double log(double);\n    public static double log10(double);\n    public static double sqrt(double);\n    public static double cbrt(double);\n    public static double IEEEremainder(double,double);\n    public static double ceil(double);\n    public static double floor(double);\n    public static double rint(double);\n    public static double atan2(double,double);\n    public static double pow(double,double);\n    public static int round(float);\n    public static long round(double);\n    public static double random();\n    public static int abs(int);\n    public static long abs(long);\n    public static float abs(float);\n    public static double abs(double);\n    public static int max(int,int);\n    public static long max(long,long);\n    public static float max(float,float);\n    public static double max(double,double);\n    public static int min(int,int);\n    public static long min(long,long);\n    public static float min(float,float);\n    public static double min(double,double);\n    public static double ulp(double);\n    public static float ulp(float);\n    public static double signum(double);\n    public static float signum(float);\n    public static double sinh(double);\n    public static double cosh(double);\n    public static double tanh(double);\n    public static double hypot(double,double);\n    public static double expm1(double);\n    public static double log1p(double);\n}\n\n# Remove - Number method calls. Remove all invocations of Number\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.* extends java.lang.Number {\n    public static java.lang.String toString(byte);\n    public static java.lang.Byte valueOf(byte);\n    public static byte parseByte(java.lang.String);\n    public static byte parseByte(java.lang.String,int);\n    public static java.lang.Byte valueOf(java.lang.String,int);\n    public static java.lang.Byte valueOf(java.lang.String);\n    public static java.lang.Byte decode(java.lang.String);\n    public int compareTo(java.lang.Byte);\n    public static java.lang.String toString(short);\n    public static short parseShort(java.lang.String);\n    public static short parseShort(java.lang.String,int);\n    public static java.lang.Short valueOf(java.lang.String,int);\n    public static java.lang.Short valueOf(java.lang.String);\n    public static java.lang.Short valueOf(short);\n    public static java.lang.Short decode(java.lang.String);\n    public static short reverseBytes(short);\n    public int compareTo(java.lang.Short);\n    public static java.lang.String toString(int,int);\n    public static java.lang.String toHexString(int);\n    public static java.lang.String toOctalString(int);\n    public static java.lang.String toBinaryString(int);\n    public static java.lang.String toString(int);\n    public static int parseInt(java.lang.String,int);\n    public static int parseInt(java.lang.String);\n    public static java.lang.Integer valueOf(java.lang.String,int);\n    public static java.lang.Integer valueOf(java.lang.String);\n    public static java.lang.Integer valueOf(int);\n    public static java.lang.Integer getInteger(java.lang.String);\n    public static java.lang.Integer getInteger(java.lang.String,int);\n    public static java.lang.Integer getInteger(java.lang.String,java.lang.Integer);\n    public static java.lang.Integer decode(java.lang.String);\n    public static int highestOneBit(int);\n    public static int lowestOneBit(int);\n    public static int numberOfLeadingZeros(int);\n    public static int numberOfTrailingZeros(int);\n    public static int bitCount(int);\n    public static int rotateLeft(int,int);\n    public static int rotateRight(int,int);\n    public static int reverse(int);\n    public static int signum(int);\n    public static int reverseBytes(int);\n    public int compareTo(java.lang.Integer);\n    public static java.lang.String toString(long,int);\n    public static java.lang.String toHexString(long);\n    public static java.lang.String toOctalString(long);\n    public static java.lang.String toBinaryString(long);\n    public static java.lang.String toString(long);\n    public static long parseLong(java.lang.String,int);\n    public static long parseLong(java.lang.String);\n    public static java.lang.Long valueOf(java.lang.String,int);\n    public static java.lang.Long valueOf(java.lang.String);\n    public static java.lang.Long valueOf(long);\n    public static java.lang.Long decode(java.lang.String);\n    public static java.lang.Long getLong(java.lang.String);\n    public static java.lang.Long getLong(java.lang.String,long);\n    public static java.lang.Long getLong(java.lang.String,java.lang.Long);\n    public static long highestOneBit(long);\n    public static long lowestOneBit(long);\n    public static int numberOfLeadingZeros(long);\n    public static int numberOfTrailingZeros(long);\n    public static int bitCount(long);\n    public static long rotateLeft(long,int);\n    public static long rotateRight(long,int);\n    public static long reverse(long);\n    public static int signum(long);\n    public static long reverseBytes(long);\n    public int compareTo(java.lang.Long);\n    public static java.lang.String toString(float);\n    public static java.lang.String toHexString(float);\n    public static java.lang.Float valueOf(java.lang.String);\n    public static java.lang.Float valueOf(float);\n    public static float parseFloat(java.lang.String);\n    public static boolean isNaN(float);\n    public static boolean isInfinite(float);\n    public static int floatToIntBits(float);\n    public static int floatToRawIntBits(float);\n    public static float intBitsToFloat(int);\n    public static int compare(float,float);\n    public boolean isNaN();\n    public boolean isInfinite();\n    public int compareTo(java.lang.Float);\n    public static java.lang.String toString(double);\n    public static java.lang.String toHexString(double);\n    public static java.lang.Double valueOf(java.lang.String);\n    public static java.lang.Double valueOf(double);\n    public static double parseDouble(java.lang.String);\n    public static boolean isNaN(double);\n    public static boolean isInfinite(double);\n    public static long doubleToLongBits(double);\n    public static long doubleToRawLongBits(double);\n    public static double longBitsToDouble(long);\n    public static int compare(double,double);\n    public boolean isNaN();\n    public boolean isInfinite();\n    public int compareTo(java.lang.Double);\n    public byte byteValue();\n    public short shortValue();\n    public int intValue();\n    public long longValue();\n    public float floatValue();\n    public double doubleValue();\n    public int compareTo(java.lang.Object);\n    public boolean equals(java.lang.Object);\n    public int hashCode();\n    public java.lang.String toString();\n}\n\n# Remove - String method calls. Remove all invocations of String\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.String {\n    public static java.lang.String copyValueOf(char[]);\n    public static java.lang.String copyValueOf(char[],int,int);\n    public static java.lang.String valueOf(boolean);\n    public static java.lang.String valueOf(char);\n    public static java.lang.String valueOf(char[]);\n    public static java.lang.String valueOf(char[],int,int);\n    public static java.lang.String valueOf(double);\n    public static java.lang.String valueOf(float);\n    public static java.lang.String valueOf(int);\n    public static java.lang.String valueOf(java.lang.Object);\n    public static java.lang.String valueOf(long);\n    public boolean contentEquals(java.lang.StringBuffer);\n    public boolean endsWith(java.lang.String);\n    public boolean equalsIgnoreCase(java.lang.String);\n    public boolean equals(java.lang.Object);\n    public boolean matches(java.lang.String);\n    public boolean regionMatches(boolean,int,java.lang.String,int,int);\n    public boolean regionMatches(int,java.lang.String,int,int);\n    public boolean startsWith(java.lang.String);\n    public boolean startsWith(java.lang.String,int);\n    public byte[] getBytes();\n    public byte[] getBytes(java.lang.String);\n    public char charAt(int);\n    public char[] toCharArray();\n    public int compareToIgnoreCase(java.lang.String);\n    public int compareTo(java.lang.Object);\n    public int compareTo(java.lang.String);\n    public int hashCode();\n    public int indexOf(int);\n    public int indexOf(int,int);\n    public int indexOf(java.lang.String);\n    public int indexOf(java.lang.String,int);\n    public int lastIndexOf(int);\n    public int lastIndexOf(int,int);\n    public int lastIndexOf(java.lang.String);\n    public int lastIndexOf(java.lang.String,int);\n    public int length();\n    public java.lang.CharSequence subSequence(int,int);\n    public java.lang.String concat(java.lang.String);\n    public java.lang.String replaceAll(java.lang.String,java.lang.String);\n    public java.lang.String replace(char,char);\n    public java.lang.String replaceFirst(java.lang.String,java.lang.String);\n    public java.lang.String[] split(java.lang.String);\n    public java.lang.String[] split(java.lang.String,int);\n    public java.lang.String substring(int);\n    public java.lang.String substring(int,int);\n    public java.lang.String toLowerCase();\n    public java.lang.String toLowerCase(java.util.Locale);\n    public java.lang.String toString();\n    public java.lang.String toUpperCase();\n    public java.lang.String toUpperCase(java.util.Locale);\n    public java.lang.String trim();\n}\n\n# Remove - StringBuffer method calls. Remove all invocations of StringBuffer\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.StringBuffer {\n    public java.lang.String toString();\n    public char charAt(int);\n    public int capacity();\n    public int codePointAt(int);\n    public int codePointBefore(int);\n    public int indexOf(java.lang.String,int);\n    public int lastIndexOf(java.lang.String);\n    public int lastIndexOf(java.lang.String,int);\n    public int length();\n    public java.lang.String substring(int);\n    public java.lang.String substring(int,int);\n}\n\n# Remove - StringBuilder method calls. Remove all invocations of StringBuilder\n# methods without side effects whose return values are not used.\n-assumenosideeffects public class java.lang.StringBuilder {\n    public java.lang.String toString();\n    public char charAt(int);\n    public int capacity();\n    public int codePointAt(int);\n    public int codePointBefore(int);\n    public int indexOf(java.lang.String,int);\n    public int lastIndexOf(java.lang.String);\n    public int lastIndexOf(java.lang.String,int);\n    public int length();\n    public java.lang.String substring(int);\n    public java.lang.String \n    substring(int,int);\n}复制代码\n\n自定义的序列化类的代码如下：\n\npackage com.SunST.SkyDream.Objects;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.bukkit.Location;\nimport org.bukkit.World;\nimport org.bukkit.configuration.serialization.ConfigurationSerializable;\n\npublic class SDPosition implements ConfigurationSerializable{\n        public int x, y, z;\n        public int UseX, UseY, UseZ;\n        \n        public SDPosition(Location loc) {\n                this.x = loc.getBlockX();\n                this.y = loc.getBlockY();\n                this.z = loc.getBlockZ();\n                \n                this.UseX = loc.getBlockX();\n                this.UseY = loc.getBlockY();\nthis.UseZ = loc.getBlockZ();\n        }\n        \n        public SDPosition(int x, int y, int z, int UseX, int UseY, int UseZ) {\n                this.x = x;\n                this.y = y;\n                this.z = z;\n                \n                this.UseX = UseX;\n                this.UseY = UseY;\n                this.UseZ = UseZ;\n        }\n        \n        public SDPosition(Location loc, int UseX, int UseY, int UseZ) {\n                this.x = loc.getBlockX();\n                this.y = loc.getBlockY();\n                this.z = loc.getBlockZ();\n                \n                this.UseX = UseX;\n                this.UseY = UseY;\n                this.UseZ = UseZ;\n        }\n        \n        public static boolean isLocEqualPos(Location loc, SDPosition sdpos) {\n                if(loc.getBlockX()==sdpos.x && loc.getBlockY()==sdpos.y && loc.getBlockZ()==sdpos.z)\n                        return true;\n                \n                return false;\n        }\n        \n        public static boolean isLocEqualUsePos(Location loc, SDPosition sdpos) {\n                if(loc.getBlockX()==sdpos.UseX && loc.getBlockY()==sdpos.UseY && loc.getBlockZ()==sdpos.UseZ)\n                        return true;\n                \n                return false;\n        }\n        \n        public Location posToLocation(World world) {\n                Location toLoc = new Location(world, this.x, this.y, this.z);\n                \n                return toLoc;\n        }\n        \n        public Location useToLocation(World world) {\n                Location toLoc = new Location(world, this.UseX, this.UseY, this.UseZ);\n                \n                return toLoc;\n        }\n        \n        @Override\n        public Map<String, Object> serialize(){\n                Map<String, Object> map = new HashMap<String, Object>();\n                \n                map.put(\"x\", x);\n                map.put(\"y\", y);\n                map.put(\"z\", z);\n                \n                map.put(\"UseX\", UseX);\n                map.put(\"UseY\", UseY);\n                map.put(\"UseZ\", UseZ);\n                \n                return map;\n        }\n        \n        public static SDPosition deserialize(Map<String, Object> map) {\n                return new SDPosition(\n                                (map.get(\"x\") != null ? (int)map.get(\"x\") : null),\n                                (map.get(\"y\") != null ? (int)map.get(\"y\") : null),\n                                (map.get(\"z\") != null ? (int)map.get(\"z\") : null),\n                                \n                                (map.get(\"UseX\") != null ? (int)map.get(\"UseX\") : null),\n                                (map.get(\"UseY\") != null ? (int)map.get(\"UseY\") : null),\n                                (map.get(\"UseZ\") != null ? (int)map.get(\"UseZ\") : null)\n                );\n        }\n}\n复制代码\n\n混淆后反编译得到的SDPosition类如下：\npackage com.SunST.SkyDream.Objects;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.bukkit.Location;\nimport org.bukkit.World;\nimport org.bukkit.configuration.serialization.ConfigurationSerializable;\n\npublic class b\n  implements ConfigurationSerializable\n{\n  public int a;\n  public int b;\n  public int c;\n  public int d;\n  public int e;\n  public int f;\n  \n  public b(Location paramLocation)\n  {\n    this.a = paramLocation.getBlockX();\n    this.b = paramLocation.getBlockY();\n    this.c = paramLocation.getBlockZ();\n    this.d = paramLocation.getBlockX();\n    this.e = paramLocation.getBlockY();\n    this.f = paramLocation.getBlockZ();\n  }\n  \n  public b(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5, int paramInt6)\n  {\n    this.a = paramInt1;\n    this.b = paramInt2;\n    this.c = paramInt3;\n    this.d = paramInt4;\n    this.e = paramInt5;\n    this.f = paramInt6;\n  }\n  \n  public b(Location paramLocation, int paramInt1, int paramInt2, int paramInt3)\n  {\n    this.a = paramLocation.getBlockX();\n    this.b = paramLocation.getBlockY();\n    this.c = paramLocation.getBlockZ();\n    this.d = paramInt1;\n    this.e = paramInt2;\n    this.f = paramInt3;\n  }\n  \n  public static boolean a(Location paramLocation, b paramb)\n  {\n    return (paramLocation.getBlockX() == paramb.a) && (paramLocation.getBlockY() == paramb.b) && (paramLocation.getBlockZ() == paramb.c);\n  }\n  \n  public static boolean b(Location paramLocation, b paramb)\n  {\n    return (paramLocation.getBlockX() == paramb.d) && (paramLocation.getBlockY() == paramb.e) && (paramLocation.getBlockZ() == paramb.f);\n  }\n  \n  public Location a(World paramWorld)\n  {\n    Location localLocation = new Location(paramWorld, this.a, this.b, this.c);\n    return localLocation;\n  }\n  \n  public Location b(World paramWorld)\n  {\n    Location localLocation = new Location(paramWorld, this.d, this.e, this.f);\n    return localLocation;\n  }\n  \n  public Map serialize()\n  {\n    HashMap localHashMap = new HashMap();\n    localHashMap.put(\"x\", Integer.valueOf(this.a));\n    localHashMap.put(\"y\", Integer.valueOf(this.b));\n    localHashMap.put(\"z\", Integer.valueOf(this.c));\n    localHashMap.put(\"UseX\", Integer.valueOf(this.d));\n    localHashMap.put(\"UseY\", Integer.valueOf(this.e));\n    localHashMap.put(\"UseZ\", Integer.valueOf(this.f));\n    return localHashMap;\n  }\n  \n  public static b a(Map paramMap)\n  {\n    return new b((paramMap.get(\"x\") != null ? Integer.valueOf(((Integer)paramMap.get(\"x\")).intValue()) : null).intValue(), (paramMap.get(\"y\") != null ? Integer.valueOf(((Integer)paramMap.get(\"y\")).intValue()) : null).intValue(), (paramMap.get(\"z\") != null ? Integer.valueOf(((Integer)paramMap.get(\"z\")).intValue()) : null).intValue(), (paramMap.get(\"UseX\") != null ? Integer.valueOf(((Integer)paramMap.get(\"UseX\")).intValue()) : null).intValue(), (paramMap.get(\"UseY\") != null ? Integer.valueOf(((Integer)paramMap.get(\"UseY\")).intValue()) : null).intValue(), (paramMap.get(\"UseZ\") != null ? Integer.valueOf(((Integer)paramMap.get(\"UseZ\")).intValue()) : null).intValue());\n  }\n}复制代码\n\n\n配置文件存储效果如下：\n\n\n\n\nimage.png (42.27 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-11 13:00 上传\n\n\n\n\n\n\n我觉得有可能是在从配置文件读取数据的时候自定义序列化类的反序列化因为被混淆有问题，\n因为在没混淆或者混淆后第一次没有配置文件时加载插件的情况下一切正常。\n\n但是我又不知道Proguard具体再怎么配置才行...\n\n写了一周的插件发现混淆后有问题...跪求大佬解决！\n\n\n",
    "replies": [
        {
            "author": "a8105",
            "timestamp": 1586644080,
            "txt_content": "public Map<String, Object> serialize()\npublic static SDPosition deserialize(Map<String, Object> map) \n以及类名\n不应该被混淆\nProguard可以指定不混淆什么类的名称和方法名,具体百度"
        },
        {
            "author": "Devil_xw",
            "timestamp": 1586652300,
            "txt_content": "a8105 发表于 2020-4-12 06:28\npublic Map serialize()\npublic static SDPosition deserialize(Map map) \n以及类名\n谢谢，问题解决了。\n就是反序列化方法被混淆的问题。"
        }
    ]
}