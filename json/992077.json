{
    "title": "关于伪加载区块和玩家",
    "author": "隔壁老吕",
    "replyCount": 1,
    "timestamp": 1584707520,
    "txt_content": " 本帖最后由 隔壁老吕 于 2020-3-20 20:39 编辑 \n\n最近嘛，\n帮朋友整一个RPG服，\n写插件，\n发现一堆黑货，\n但是黑货大哥都经验丰富，\n藏货十分隐蔽，\n这就让我朋友十分蛋疼，\n然后我就打算帮他写个查货的插件。\n货在哪？容器和背包以及末影箱\n容器就可以联想到TileEntity，然后我就想起了Chunk的方法getTileEntities，\n那么猜测一下，tileEntity的数据存在Chunk里，查mcwiki\n哦，查到个好东西:\n\n\n\n\nQQ截图20200320195208.png (29.19 KB, 下载次数: 1)\n\n下载附件\n\n2020-3-20 19:55 上传\n\n\n\n\n\n那么这个有什么用呢？\n首先，注意，MC并不会加载所有区块（不然你服务器内存原地爆炸奥）\n所以由mcwiki知，我们可以通过遍历region中的mca文件来实现遍历Chunkpublic static void checkWorld(World world) {\n    world.save();\n    File folder = world.getWorldFolder();\n    File region = new File(folder, \"region\");\n    for (File mca : region.listFiles()) {\n        int regionX = Integer.parseInt(mca.getName().split(\"\\\\.\")[1]) * 32;\n        int regionY = Integer.parseInt(mca.getName().split(\"\\\\.\")[2]) * 32;\n        for (int x = 0; x < 32; x++) {\n            for (int y = 0; y < 32; y++) {\n                checkChunk(world, regionX + x, regionY + y);\n            }\n        }\n    }\n}复制代码这时就有小伙伴问了，为啥要world.save();呢？因为mc的区块不是即时保存的，所以我们要手动保存一次来同步数据\n那么接下来就会有小伙伴问，checkChunk是啥玩意？\nnm你急啥\n其中，代码中的regionX + x和regionY + y即为Chunk的真实坐标\n然后，我们如何去伪加载区块呢？\nBukkitAPI肯定是做不到的（你能写出来我表演吃奥利给）\n那么我们就能去翻翻NMS了\n至于不知道NMS是啥的，那就当做不知道的吧\n经过一番在mcbbs讲起来太麻烦的过程，我找到了原版里区块的加载器ChunkLoader\n那么怎么获取这玩意呢？\nObject nmsWorld = NBT.doMethod(world, \"getHandle\");\nObject chunkProviderServer = NBT.doMethod(nmsWorld, \"getChunkProviderServer\");\nif (chunkProviderServer == null) {\n    chunkProviderServer = NBT.getField(nmsWorld, \"chunkProviderServer\");\n}\nObject iChunkLoader = NBT.getField(chunkProviderServer, \"chunkLoader\");复制代码然后就有小伙伴问，这个NBT又是什么玩意？它是我自己编写的一个工具类，用于完成反射操作及操作NBT，十分便捷（确信）\n文件：\n\n\n\nNBT.rar\n(1.7 KB, 下载次数: 4)\n\n\n\n2020-3-20 20:15 上传\n点击文件名下载附件\n\n\n\n\n\n\n这时就会有小伙伴问，为啥要加“if (chunkProviderServer == null) {”呢？因为1.8没有getChunkProviderServer方法，只能获取chunkProviderServer的值\n那么我们现在就获取了ChunkLoader，本体为ChunkRegionLoader，在NMS中可以找到\n\n\n\n\nQQ截图20200320201903.png (12.03 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-20 20:19 上传\n\n\n\n\n\n然后反编译第一眼就看到一个方法，事实上他就是加载并导入区块到世界的方法\n然后盯住其中的loadChunk方法\n\n\n\n\nQQ截图20200320202039.png (16.02 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-20 20:21 上传\n\n\n\n\n\n一看，秒啊，纯读取文件获取NBT，事实上他就是读取区块的方法\n然后反射获取图示代码中的Object[] data\nObject[] data = (Object[]) NBT.doMethod(iChunkLoader, \"loadChunk\", new ParamGroup(nmsWorld, NBT.Package.MINECRAFT_SERVER.getClass(\"World\")), new ParamGroup(x, int.class), new ParamGroup(z, int.class));复制代码那么区块NBT就是\nObject nbtData = data[1];复制代码既然我们获取了NBT，那么再使出mcwiki大法\n\n\n\n\nQQ截图20200320202425.png (190.32 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-20 20:25 上传\n\n\n\n\n\n然后我们就可以看到tileEntities，秒啊！\nNBT level = new NBT(NBT.doMethod(nbtData, \"getCompound\", new ParamGroup(\"Level\")));\nList<NBT> tileEntities = level.getNBTList(\"TileEntities\", 10);\nfor (NBT nbtTileEntity : tileEntities) {\n    List<NBT> items = nbtTileEntity.getNBTList(\"Items\", 10);\n    BlockContainer blockContainer = new BlockContainer(world.getName(), nbtTileEntity.getInt(\"x\"), nbtTileEntity.getInt(\"y\"), nbtTileEntity.getInt(\"z\"));\n    if (!items.isEmpty()) {\n        for (NBT item : items) {\n            blockContainer.items.add(item.toItemStack());\n        }\n        ret.add(blockContainer);\n    }\n}复制代码然后我们就可以遍历读取TileEntitiy\n通过mcwiki，我们又能查到，Items即为方块物品的key\n\n\n\n\nQQ截图20200320202733.png (41.92 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-20 20:28 上传\n\n\n\n\n\n奥，上面已经写了，然后就可以用我的工具类将NBT直接转为物品\n完整代码：\npublic static List<BlockContainer> getChunkTileEntityBlocks(org.bukkit.World world, int x, int z) {\n    List<BlockContainer> ret = new ArrayList<>();\n    Object nmsWorld = NBT.doMethod(world, \"getHandle\");\n    Object chunkProviderServer = NBT.doMethod(nmsWorld, \"getChunkProviderServer\");\n    if (chunkProviderServer == null) {\n        chunkProviderServer = NBT.getField(nmsWorld, \"chunkProviderServer\");\n    }\n    Object iChunkLoader = NBT.getField(chunkProviderServer, \"chunkLoader\");\n    Object[] data = (Object[]) NBT.doMethod(iChunkLoader, \"loadChunk\", new ParamGroup(nmsWorld, NBT.Package.MINECRAFT_SERVER.getClass(\"World\")), new ParamGroup(x, int.class), new ParamGroup(z, int.class));\n    if (data != null) {\n        Object nbtData = data[1];\n        NBT level = new NBT(NBT.doMethod(nbtData, \"getCompound\", new ParamGroup(\"Level\")));\n        List<NBT> tileEntities = level.getNBTList(\"TileEntities\", 10);\n        for (NBT nbtTileEntity : tileEntities) {\n            List<NBT> items = nbtTileEntity.getNBTList(\"Items\", 10);\n            BlockContainer blockContainer = new BlockContainer(world.getName(), nbtTileEntity.getInt(\"x\"), nbtTileEntity.getInt(\"y\"), nbtTileEntity.getInt(\"z\"));\n            if (!items.isEmpty()) {\n                for (NBT item : items) {\n                    blockContainer.items.add(item.toItemStack());\n                }\n                ret.add(blockContainer);\n            }\n        }\n    }\n    return ret;\n}复制代码那么ret中即为该chunk的物品\n经过实际测试通过这个办法伪加载的区块是不会载入到世界里的，并且可以随意异步操作\n然后就能通过x，y，z值获取容器的真实方块并进行操作\n\n累死我了，玩家的待会写\n算了，玩家的不写了\n",
    "replies": [
        {
            "author": "秋韵",
            "timestamp": 1584721860,
            "txt_content": "支持一下，老吕辛苦了\n"
        }
    ]
}