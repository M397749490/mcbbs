{
    "title": "[编程][SC]MethodCall——一个可以监听/拦截任意方法的插件|让你花式艹nms![全版本]",
    "author": "弱鸡绿毛怪",
    "replyCount": 6,
    "timestamp": 1522481640,
    "txt_content": " 本帖最后由 MagicLocyDragon 于 2018-3-31 15:54 编辑 \n\n 前言\n 本插件是前置插件，并无实际用处，怎么用可以看各位开发者们的想法了，比如说拦截setOp、获得成就给个提醒啥的。若不是开发者，但是需要本插件，下载并按步骤安装即可，下载地址:\n\n\n\nMethodCall.jar\n(746.35 KB, 下载次数: 26)\n\n\n\n2018-3-31 15:22 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n\nMethodCallPlugin.jar\n(750.53 KB, 下载次数: 17)\n\n\n\n2018-3-31 15:22 上传\n点击文件名下载附件\n\n\n\n\n\n\n(两个都要安装，都是放在plugins文件夹里的，但是有一个在启动的时候会报错，这是正常现象)\n\n 安装方法 在两个jar文件都放入plugins文件夹里之后，用Notepad打开你的运行.bat。就是那个启动服务器的东东(.bat)，找到这一行:\njava xxxxx.jar\n有的服务器可能是\njava -Xmx1G -jar xxx.jar\n无所谓，然后在java后面加一句:\n-javaagent:plugins/MethodCall.jar\n比如说\njava -javaagent:plugins/MethodCall.jar xxxxx.jar\n或者是\njava -javaagent:plugins/MethodCall.jar -Xmx1G -jar xxxxxx.jar\n然后启动服务器，安装完成\n\n\n\n\n1.png (20.23 KB, 下载次数: 0)\n\n下载附件\n\n2018-3-31 15:25 上传\n\n\n\n\n\n 使用截图 \n\n\n\n\n1.png (18.63 KB, 下载次数: 0)\n\n下载附件\n\n2018-3-31 15:28 上传\n\n\n\n\n\n\n\n 开发者部分\n 在ide中导入前置 \"MethodCallPlugin\"\n首先，先在Plugin.yml里 depend: [MethodCall] 然后随便创建一个类，让他继承CallTask类，并实现public static Object onBeforeCall(Object instance)  方法，其中传入的instance变量是被调用方法的实例对象\nimport org.bukkit.craftbukkit.v1_11_R1.entity.CraftPlayer;\n\nimport com.locydragon.mc.api.CallTask;\n\npublic class MethodListener extends CallTask {\n    public static Object onBeforeCall(Object instance) {\n       return null;\n    }\n}\n然后在onEnable调用MethodCallManager的静态方法addCallTask方法，监听一个方法:\nMethodCallManager.addCallTask(Method 你监听的方法, CallTask 执行类); 这个方法不能是static方法\n比如我们监听一个op方法\nMethodCallManager.addCallTask(Class.forName(\"org.bukkit.craftbukkit.v1_11_R1.entity.CraftPlayer\").getMethod(\"setOp\", boolean.class), new MethodListener());\nok了，这样子当setOp方法执行的时候就会调用MethodListener的onBeforeCall方法，但是并不会拦截，怎么拦截呢？\n注意:当 onBeforeCall 的返回值不是null时，监听的方法就会被拦截，否则将不会拦截，并且拦截的方法的返回值必须是void，不然会导致服务端逻辑混乱\n所以我们只要\nimport org.bukkit.craftbukkit.v1_11_R1.entity.CraftPlayer;\n\nimport com.locydragon.mc.api.CallTask;\n\npublic class MethodListener extends CallTask {\n    public static Object onBeforeCall(Object instance) {\n       CraftPlayer who = (CraftPlayer)instance;\n       System.out.println(who.getName()+\"尝试修改op记录，已经拦截.\");\n       return new Object();\n    }\n}\n即可。\n\n\n预计实现:\n\n监听static方法\n[groupid=1533]SpicyChicken[/groupid]",
    "replies": [
        {
            "author": "pxiaotu",
            "timestamp": 1522483020,
            "txt_content": "前排高能，谢谢分享。"
        },
        {
            "author": "神奈川归尘",
            "timestamp": 1522484280,
            "txt_content": "这个应该是用于防止后门插件吧"
        },
        {
            "author": "弱鸡绿毛怪",
            "timestamp": 1522484520,
            "txt_content": "逗比的幻影 发表于 2018-3-31 16:18\n这个应该是用于防止后门插件吧\n前置插件\n不单单有这一个功能\n或者说功能远比这个强大得多"
        },
        {
            "author": "神奈川归尘",
            "timestamp": 1522484580,
            "txt_content": "MagicLocyDragon 发表于 2018-3-31 16:22\n前置插件\n不单单有这一个功能\n或者说功能远比这个强大得多\n很棒人气送上 膜拜大佬 然后小组名字叫\"香辣鸡肉\" 很强"
        },
        {
            "author": "Slaine",
            "timestamp": 1522487040,
            "txt_content": "冒昧的问一下可以加泛型吗?怎么有种类型全靠猜的感觉"
        },
        {
            "author": "弱鸡绿毛怪",
            "timestamp": 1522487160,
            "txt_content": "Slaine 发表于 2018-3-31 17:04\n冒昧的问一下可以加泛型吗?怎么有种类型全靠猜的感觉\nnms这种东西都是反编译的阿"
        }
    ]
}