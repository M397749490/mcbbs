{
    "title": "【真·理论向】各种莫名其妙的算法教程",
    "author": "914554688wyt",
    "replyCount": 27,
    "timestamp": 1454497440,
    "txt_content": "整个版都是工程向的帖子 让我带领大家走入奇幻的算法殿堂(lz作大死中){:10_492:}\n【真·理论向】各种莫名其妙的算法教程\n请轻触♂上方“只看该作者”   ",
    "replies": [
        {
            "author": "914554688wyt",
            "timestamp": 1454506560,
            "txt_content": " 本帖最后由 914554688wyt 于 2016-2-3 21:50 编辑 \n\n此处出现的代码资料多数为网上c+c c+v而来\n第一种常见的算法 排序类算法\n冒泡排序：每两个相邻元素都对比一次，需要交换则交换，重复操作直到扫过一边没有需要交换的为止 最坏时间复杂度O(n^2)\n选择排序：每次选出一个最大的最坏时间复杂度O(n^2)\n\n接下来要介绍的是我们的快速排序-qsort\n基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 (二分)\n最坏时间复杂度O(n^2) 一般时间复杂度O(n log2 n)  \n\n 实现\npackagecom.sort;public class快速排序 {    public static void main(String[] args) {        int[]a={49,38,65,97,76,13,27,49,78,34,12,64,1,8};        System.out.println(\"排序之前：\");        for (int i = 0; i < a.length; i++) {            System.out.print(a+\"\");        }        //快速排序        quick(a);        System.out.println();        System.out.println(\"排序之后：\");        for (int i = 0; i < a.length; i++) {            System.out.print(a+\"\");        }    }    private static void quick(int[] a) {        if(a.length>0){            quickSort(a,0,a.length-1);        }    }    private static void quickSort(int[] a, int low,int high) {        if(low<high){ //如果不加这个判断递归会无法退出导致堆栈溢出异常            int middle = getMiddle(a,low,high);            quickSort(a, 0, middle-1);            quickSort(a, middle+1, high);        }    }    private static int getMiddle(int[] a, intlow, int high) {        int temp = a[low];//基准元素        while(low<high){            //找到比基准元素小的元素位置            while(low<high &&a[high]>=temp){                high--;            }            a[low] = a[high];             while(low<high &&a[low]<=temp){                low++;            }            a[high] = a[low];        }        a[low] = temp;        return low;    }}\n接下来是堆排序\n　　1、基本思想：\n　　堆排序是一种树形选择排序，是对直接选择排序的有效改进。 (可用优先队列实现)\n　　堆的定义下：具有n个元素的序列（h1,h2,...,hn),当且仅当满足（hi>=h2i,hi>=2i+1）或（hi<=h2i,hi<=2i+1） (i=1,2,...,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。\n思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。Java实现 ：\n\npackage com.sort;\nimport java.util.Arrays;\n\npublic class HeapSort {\n    public static voidmain(String[] args) {        int[] a={49,38,65,97,76,13,27,49,78,34,12,64};\n        intarrayLength=a.length;          //循环建堆  \n        for(inti=0;i<arrayLength-1;i++){              //建堆  \n           buildMaxHeap(a,arrayLength-1-i);              //交换堆顶和最后一个元素            swap(a,0,arrayLength-1-i);             System.out.println(Arrays.toString(a));         }  \n    }\n    //对data数组从0到lastIndex建大顶堆\n    public static voidbuildMaxHeap(int[] data, int lastIndex){         //从lastIndex处节点（最后一个节点）的父节点开始 \n        for(inti=(lastIndex-1)/2;i>=0;i--){            //k保存正在判断的节点 \n            int k=i;\n            //如果当前k节点的子节点存在  \n           while(k*2+1<=lastIndex){                //k节点的左子节点的索引 \n                intbiggerIndex=2*k+1;                //如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在\n               if(biggerIndex<lastIndex){                      //若果右子节点的值较大                    if(data[biggerIndex]<data[biggerIndex+1]){                         //biggerIndex总是记录较大子节点的索引                          biggerIndex++;  \n                    }  \n                }  \n                //如果k节点的值小于其较大的子节点的值  \n               if(data[k]<data[biggerIndex]){                     //交换他们  \n                   swap(data,k,biggerIndex);                      //将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值  \n                   k=biggerIndex;                  }else{  \n                   break;                  }  \n            }\n        }\n    }\n    //交换\n    private static voidswap(int[] data, int i, int j) {          int tmp=data;  \n        data=data[j];  \n        data[j]=tmp;  \n    } \n}\n\n最坏时间复杂度为O(n log2 n)\n\n最后是归并排序\n　　1、基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。\n时间复杂度稳定O(n log2 n)\n\n总结：\n一、稳定性:\n　   稳定：冒泡排序、插入排序、归并排序和基数排序\n　　不稳定：选择排序、快速排序、希尔排序、堆排序\n二、平均时间复杂度\n　　O(n^2):直接插入排序，简单选择排序，冒泡排序。\n　　在数据规模较小时（9W内），直接插入排序，简单选择排序差不多。当数据较大时，冒泡排序算法的时间代价最高。性能为O(n^2)的算法基本上是相邻元素进行比较，基本上都是稳定的。\n　　O(nlogn):快速排序，归并排序，希尔排序，堆排序。\n　　其中，快排是最好的， 其次是归并和希尔，堆排序在数据量很大时效果明显。\n三、排序算法的选择\n　　1.数据规模较小\n  　　（1）待排序列基本序的情况下，可以选择直接插入排序；\n  　　（2）对稳定性不作要求宜用简单选择排序，对稳定性有要求宜用插入或冒泡\n　　2.数据规模不是很大\n　　（1）完全可以用内存空间，序列杂乱无序，对稳定性没有要求，快速排序，此时要付出log（N）的额外空间。\n　　（2）序列本身可能有序，对稳定性有要求，空间允许下，宜用归并排序\n　　3.数据规模很大\n   　　（1）对稳定性有求，则可考虑归并排序。\n    　　（2）对稳定性没要求，宜用堆排序\n　　4.序列初始基本有序（正序），宜用直接插入，冒泡\n\n下一章唔。。 hash散列表!  与   神奇的高精度"
        },
        {
            "author": "CatSeed",
            "timestamp": 1454506920,
            "txt_content": "noip出生？"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1454508660,
            "txt_content": " 本帖最后由 914554688wyt 于 2016-2-3 22:14 编辑 \n\n剧透一下\n选择排序，插入排序，快速排序，归并排序，希尔排序帮您排忧解难。\n有向图，无向图，完全图，稠密图，拓扑图祝您宏图大展。\n线性动归，区间动归，坐标动归，背包动归，树型动归为您在新的一年里规划精彩。\n哈希表，邻接表，双向链表，循环链表帮您表达情意。\n费马，欧几里得，欧拉，哈密尔顿，图灵各路大神助您一臂之力，紫气东来，风调雨顺！\n大家猴年快乐！"
        },
        {
            "author": "Bryan33",
            "timestamp": 1455422520,
            "txt_content": "914554688wyt 发表于 2016-2-3 21:36\n此处出现的代码资料多数为网上c+c c+v而来\n第一种常见的算法 排序类算法\n冒泡排序：每两个相邻元素 ...\n转为List\n直接调用排序方法不就好了"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1455456240,
            "txt_content": "a390807154 发表于 2016-2-14 12:02\n转为List\n直接调用排序方法不就好了\n咦我发过这个帖子咩？\n。。好吧记起来了\n主要是让大家了解下la"
        },
        {
            "author": "t9044",
            "timestamp": 1455458100,
            "txt_content": "a390807154 发表于 2016-2-14 12:02\n转为List\n直接调用排序方法不就好了\n真6,简直是暴击"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469776440,
            "txt_content": " 本帖最后由 914554688wyt 于 2016-7-29 17:25 编辑 \n\n忽然记起来这个帖子\n那就让我来更一贴\n\n\n一个写小游戏的时候可能会用到的算法\n动态规划！\n那么现在有一个问题\n一个跑酷游戏（一条线）总长为X （X<=10^3），每一次玩家能跳0~K (k<x)格，而且每一格有分数值，跳出游戏算结束  一开始在位置1 玩家最多能跳Z次    问能跳出分数值最高是多少.\n\n最直观的想法就是去试试... 然而搜索的时间是指数级别的  k^z次方  1000的1000次方  不多 也就那么1后面接3000个0\n还有什么别的想法吗？"
        },
        {
            "author": "0x3B800001",
            "timestamp": 1469780460,
            "txt_content": "目测楼主OIer？\n我觉得楼上的那个问题有点bug啊。。如果一格一格跳岂不是可以把所有分都拿到手？建议楼主修改一下"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469781600,
            "txt_content": "丶皇天 发表于 2016-7-29 16:21\n目测楼主OIer？\n我觉得楼上的那个问题有点bug啊。。如果一格一格跳岂不是可以把所有分都拿到手？建议楼主修 ...\n哦忘了。。。 还有次数限制"
        },
        {
            "author": "0x3B800001",
            "timestamp": 1469782680,
            "txt_content": " 本帖最后由 丶皇天 于 2016-7-29 17:04 编辑 \n914554688wyt 发表于 2016-7-29 16:40\n哦忘了。。。 还有次数限制\n另外lz对于搜索算法的时间复杂度分析有误，应该是O(k^z)\n我的状态转移方程：\nf(x,z)=max{f(x-1,z-1) , f(x-2,z-1) ... f(x-k,z-1) }+v[x](v为方格中的数值)这个状态转移方程最后的答案不一定在f(x,z)，而应该在f(x-k,z) f(x-k+1,z)...f(x,z)之间\n时间复杂度O(k^2 *z)，空间复杂度为O(x*z)"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469784240,
            "txt_content": "丶皇天 发表于 2016-7-29 16:58\n另外lz对于搜索算法的时间复杂度分析有误，应该是O(k^z)\n我的状态转移方程：\nf(x,z)=max{f(x-1,z-1) , f(x ...\n哦 我k最大能到x嘛 所以就k^z次方好了.... 这个一时疏漏\n时间复杂度的话还能再优化"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469784540,
            "txt_content": "丶皇天 发表于 2016-7-29 16:58\n另外lz对于搜索算法的时间复杂度分析有误，应该是O(k^z)\n我的状态转移方程：\nf(x,z)=max{f(x-1,z-1) , f(x ...\n可以发现每次求答案的z-1是给定的，可以考虑数据结构维护一波，这样的话时间就降到O(xz*log k)"
        },
        {
            "author": "Debug.Twilight",
            "timestamp": 1469785380,
            "txt_content": "楼主，我这有一个用Clojure实现的排序算法，您看如何：\n(defn merge1 [a1 a2]\n  \"Merges elements from array1 and array2 in ascend order.\"\n  (loop [i 0 j 0 result []]\n    (if (or (= i (count a1)) (= j (count a2)))\n      (if (= i (count a1)) \n        (apply conj result (subvec a2 j))\n        (apply conj result (subvec a1 i)))\n      (if (<= (a1 i) (a2 j))\n        (recur (+ i 1) j (conj result (a1 i)))\n        (recur i (+ j 1) (conj result (a2 j)))))))"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469792460,
            "txt_content": "Debug.Twilight 发表于 2016-7-29 17:43\n楼主，我这有一个用Clojure实现的排序算法，您看如何：\n(defn merge1 [a1 a2]\n  \"Merges elements from arr ...\n并看不懂... 神马玩意"
        },
        {
            "author": "Debug.Twilight",
            "timestamp": 1469807460,
            "txt_content": "clojure是一门jvm上的lisp实现"
        },
        {
            "author": "ZhangJiaMinglv",
            "timestamp": 1469846760,
            "txt_content": "排序啥的可以看看这个：https://www.toptal.com/developers/sorting-algorithms/\n然后那个跑酷啥的. .将分数排列出来找到最高的那些，全部加起来不就好了吗. ."
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469852400,
            "txt_content": "ZhangJiaMinglv 发表于 2016-7-30 10:46\n排序啥的可以看看这个：https://www.toptal.com/developers/sorting-algorithms/\n然后那个跑酷啥的. .将分 ...\n看清楚题目好伐    牛头不对马嘴啊。。"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469975340,
            "txt_content": "劲啊！\n还有DFS，BFS，IDDFS，启发式等等\n树方面还有各种平衡树（SPlay，Treap，RBT），LCA，LCT，树链剖分\n图论还有最短路，网络流，强联通分量，双联通分量\n还有字符串的KMP，Accept自动机（雾），后缀数组\n{:10_492:}"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469975880,
            "txt_content": "天空之城TMD 发表于 2016-7-31 22:29\n劲啊！\n还有DFS，BFS，IDDFS，启发式等等\n树方面还有各种平衡树（SPlay，Treap，RBT），LCA，LCT，树链剖分 ...\n噫捕获同坑一只ac自动机只是缩写ac。。。。不是accept。。。。"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469976120,
            "txt_content": "914554688wyt 发表于 2016-2-3 22:11\n剧透一下\n选择排序，插入排序，快速排序，归并排序，希尔排序帮您排忧解难。\n有向图，无向图，完全图，稠密 ...\n话说你少了链式前向星这个神器啊{:10_492:}"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1469976600,
            "txt_content": "天空之城TMD 发表于 2016-7-31 22:42\n话说你少了链式前向星这个神器啊\n然而只会边集{:10_565:}"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469976780,
            "txt_content": "914554688wyt 发表于 2016-7-29 15:14\n忽然记起来这个帖子\n那就让我来更一贴\n这题就DP直接搞吧，设f[j]为前i个格子跳j次能得到的最大价值，然后\nfor i=1 to x\n  for j=1 to z\n    for l=1 to min(k,i)\n        f[j]=max(f[j],f[i-l][j-1]+a[i-l]);\n复杂度是O(xkz),考虑k<x的话就是O(x^2*z)，略微有点大，如果z太大的话据某神犇说可以用单调队列压掉1维但是我这种蒟蒻不知道具体方法"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469977260,
            "txt_content": "914554688wyt 发表于 2016-7-31 22:38\n噫捕获同坑一只ac自动机只是缩写ac。。。。不是accept。。。。\n我知道。。。。。只是吐槽一下而已{:10_492:}"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469977380,
            "txt_content": "914554688wyt 发表于 2016-7-31 22:50\n然而只会边集\n边集是啥啊QAQ"
        },
        {
            "author": "天空之城TMD",
            "timestamp": 1469977620,
            "txt_content": "914554688wyt 发表于 2016-7-31 22:50\n然而只会边集\n话说楼主会写mod么？\n上次看着教程配置个MDK都花了好几天感觉自己好蠢。。。。"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1470008940,
            "txt_content": "天空之城TMD 发表于 2016-7-31 22:53\n这题就DP直接搞吧，设f[j]为前i个格子跳j次能得到的最大价值，然后\nfor i=1 to x\n  for j=1 to z\n是，看我上面写的"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1470009420,
            "txt_content": "天空之城TMD 发表于 2016-7-31 23:07\n话说楼主会写mod么？\n上次看着教程配置个MDK都花了好几天感觉自己好蠢。。。。 ...\n只会插件  MOD太麻烦"
        }
    ]
}