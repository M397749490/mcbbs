{
    "title": "BlockChest源代码文档",
    "author": "a1017752020",
    "replyCount": 0,
    "timestamp": 1489373040,
    "txt_content": " 本帖最后由 a1017752020 于 2017-3-13 10:58 编辑 \n\nBlockChest\n包结构net.minecraft.block;\n继承树BlockChest -> BlockContainer -> Block -> Impl<VextendsIforgeRegistryEntry<T> >\n成员变量[td]     变量名\n      描述\n     FACING\n    朝向\n    NORTH_CHEST_AABB\n    面向北时的包围盒\n    SOUTH_CHEST_AABB\n    面向南时的包围盒\n    WEST_CHEST_AABB\n    面向西时的包围盒\n    EAST_CHEST_AABB\n    面向东时的包围盒\n    NOT_CONNECTED_AABB\n    未连成大箱子时的包围盒\n    BlockChest.Type\n    箱子类型：0为正常，1为陷阱箱\n  方法[td]     方法名\n      描述\n     protected  BlockChest(BlockChest.Type chestTypeIn)\n    构造方法\n    public  boolean isOpaqueCube(IBlockState state)\n    是否为不透明方块，重建区块时由此决定渲染\n    public  boolean isFullCube(IBlockState state)\n    是否是充满的方块\n    public  EnumBlockRenderType getRenderType(IBlockState state)\n    获得渲染类型，INVISIBLE为透明,LIQUID为液体,  ENTITYBLOCK_ANIMATED为有生命的实体,MODEL为模型\n    public  AxisAlignedBB getBoundingBox(IBlockState state, IBlockAccess source, BlockPos  pos)\n    获得包围盒\n    public  void onBlockAdded(World worldIn, BlockPos pos, IBlockState state)\n    在箱子周围放置方块时进行更新检测\n    public  IBlockState onBlockPlaced(World worldIn, BlockPos pos, EnumFacing facing,  float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer)\n    在一个方块放置到世界上前，可以由ItemBlocks调用这个函数来对方块进行调整\n    public  void onBlockPlacedBy(World worldIn, BlockPos pos, IBlockState state,  EntityLivingBase placer, ItemStack stack)\n    在一个方块放置后发生，来实现放置方块后的逻辑\n    public  IBlockState checkForSurroundingChests(World worldIn, BlockPos pos,  IBlockState state)\n    判断箱子方块放置后的方向，同时还有确认是否能放（不确定？和下一个方法要另加逻辑判断）\n    public  IBlockState correctFacing(World worldIn, BlockPos pos, IBlockState state)\n    将方块的面放对\n    public  boolean canPlaceBlockAt(World worldIn, BlockPos pos)\n    对方块能否放置进行判断\n    private  boolean isDoubleChest(World worldIn, BlockPos pos)\n    判断是否是大箱子\n    public  void neighborChanged(IBlockState state, World worldIn, BlockPos pos, Block  blockIn)\n    方块更新检测，像红石状态，仙人掌掉落\n    public  void breakBlock(World worldIn, BlockPos pos, IBlockState state)\n    在箱子破坏时，丢出箱子里的东西\n    public  boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state,  EntityPlayer playerIn, EnumHand hand, @Nullable ItemStack heldItem,  EnumFacing side, float hitX, float hitY, float hitZ)\n    右击触发，打开操作GUI\n    public  ILockableContainer getLockabner(World worldIn, BlockPos pos)\n    获得内部容器，即箱子方块中存储物品的实例\n    public  ILockableContainer getContainer(World p_189418_1_, BlockPos p_189418_2_,  boolean p_189418_3_)\n    获得此方块内部容器，同时获得相连容器\n    public  TileEntity createNewTileEntity(World worldIn, int meta)\n    返回一个新实例对象\n    public  boolean canProvidePower(IBlockState state)\n    是否能够提供信号，应该是陷阱箱专用，而且只能输出信号到红石线（貌似）\n    public  int getWeakPower(IBlockState blockState, IBlockAccess blockAccess, BlockPos  pos, EnumFacing side)\n    提供的红石信号强度，当然不能提供就返回0\n    public  int getStrongPower(IBlockState blockState, IBlockAccess blockAccess, BlockPos  pos, EnumFacing side)\n    如果是从上面打开就调用getWeakPower,否则返回0\n    private  boolean isBlocked(World worldIn, BlockPos pos)\n    取下面两个函数的或运算\n    private  boolean isBelowSolidBlock(World worldIn, BlockPos pos)\n    判断箱子上侧是否有方块阻挡\n    private  boolean isOcelotSittingOnChest(World worldIn, BlockPos pos)\n    是不是有猫在箱子上（笑）\n    public  boolean hasComparatorInputOverride(IBlockState state)\n    是否有比较器输入重载（应该是红石比较器是否能够生效），恒返回true\n    public  int getComparatorInputOverride(IBlockState blockState, World worldIn,  BlockPos pos)\n    返回红石比较器应该得到的数值，计算方法是Container.calcRedstoneFromInventory方法\n    public  IBlockState getStateFromMeta(int meta)\n    把mdtadata数据转变成此方块的BlockState数据\n    public  int getMetaFromState(IBlockState state)\n    上面的逆过程\n    public  IBlockState withRotation(IBlockState state, Rotation rot)\n    使用旧blockstate的旋转角度来将blockstate转变成新的，如果方法不适应，就直接把旧的返回\n    public  IBlockState withMirror(IBlockState state, Mirror mirrorIn)\n    使用旧blockstate的镜子（对称面？）来将blockstate转变成新的，如果方法不适应，就直接把旧的返回\n    protected  BlockStateContainer createBlockState()\n    创建新的BlockStateContainer\n  内部类public static enum Type{    \n    BASIC,//普通箱子类型    \n    TRAP;//陷阱箱类型\n}\n多调整了几次发现不支持MarkDown,最好的方式就是使用Word导入，最后加个附加吧\n\n\n\n\n\n\n\n\n\n\nBlockChest.zip\n\n\n2017-3-13 10:57 上传\n点击文件名下载附件\n\n\n\n\n3.66 KB, 下载次数: 9\n\n\nBlockChest文档试翻译\n\n\n\n",
    "replies": []
}