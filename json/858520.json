{
    "title": "红石激活",
    "author": "陈宇鹏",
    "replyCount": 5,
    "timestamp": 1555566060,
    "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽",
    "replies": [
        {
            "author": "森林蝙蝠",
            "timestamp": 1555580940,
            "txt_content": "if（world.isBlockPowered（blockPos））{\n//do sth\n}"
        },
        {
            "author": "陈宇鹏",
            "timestamp": 1555582200,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "森林蝙蝠",
            "timestamp": 1555583520,
            "txt_content": "陈宇鹏 发表于 2019-4-18 18:10\nemm，有点不懂，能不能说一下原版的活塞是怎么实现红石激活的（源码），我好在forge的库里查看\n ...\n就是这样，world.isBlockPowered（）是判端某一位置是否有红石信号的。\n学会读英语很重要。"
        },
        {
            "author": "陈宇鹏",
            "timestamp": 1555584060,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "3TUSK",
            "timestamp": 1555609620,
            "txt_content": " 本帖最后由 u.s.knowledge 于 2019-4-19 01:55 编辑 \n\n-1. 没有游戏版本，没有 Forge 版本，甚至也没说是不是基于 Forge 框架…… 不妨假定 Minecraft 1.12.2+MCP stable_39+Forge 14.23.5.2811 的组合好了。本回复将统一使用这个组合。\n0. 这不是一个事件。这是方块自身的逻辑。见下文。\n1.\n能不能说一下原版的活塞是怎么实现红石激活的（源码）// 简单来说，对于一个方块，如果紧挨着它的方块发生了更新\n//（即 World.setBlockState 被调用，且 update flag 中最低有效位为 1）\n// 那么该方块的 neighborChanged 方法就会被调用\n@Override\npublic void neighborChanged(IBlockState state, World world, BlockPos pos, Block block, BlockPos fromPos) {\n  // state 为当前方块状态，world 为当前世界实例，pos 为当前方块坐标\n  // block 为发生更新的方块的类型，fromPos 为发生更新的方块的坐标\n  // 如果要实现“红石激活”，只需要在这里检查红石信号情况然后刷新方块状态即可。\n  world.setBlockState(pos, state.withProperty(..., ...), 1 | 2); // 0b00011, [0] 上的 1 代表产生方块更新， [1] 上的 1 代表同步到客户端。\n}复制代码\n原版活塞在这个时候会重新尝试执行活塞臂伸缩的逻辑。类似的还有原版红石中继器也使用此方法更新自身提供的信号强度。\n2.\nWorld 类下有这么几个方法允许你检查目标坐标红石信号的情况： MCP Srg 描述检查弱充能（即间接充能）？ int getStrongPower(BlockPos, EnumFacing)func_175627_a 返回指定坐标上指定方向上当前提供的强红石信号强度否 int getStrongPower(BlockPos)func_175676_y 返回指定坐标上各个方向上提供的强红石信号的最大强度是boolean isSidePowered(BlockPos, EnumFacing)func_175709_b 返回指定坐标上指定方向上是否接收到了红石信号见 int getRedstonePower(BlockPos, EnumFacing)int getRedstonePower(BlockPos, EnumFacing)func_175651_c 返回指定坐标上指定方向上接受到的信号强度由实际方块决定（Forge patch，boolean shouldCheckWeakPower，默认为原版逻辑，绝大多数方块会检查弱充能）boolean isBlockPowered(BlockPos)func_175640_z返回指定坐标上各个方向上是否有接受到强度非零的红石信号见 int getRedstonePower(BlockPos, EnumFacing)int getRedstonePowerFromNeighbors(BlockPos)func_175687_A返回指定坐标上各个方向上接受到的红石信号的最大强度见 int getRedstonePower(BlockPos, EnumFacing)\n\n\n"
        }
    ]
}