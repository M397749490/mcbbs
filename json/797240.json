{
    "title": "关于命令方块执行setblock",
    "author": "星际要塞",
    "replyCount": 16,
    "timestamp": 1527859920,
    "txt_content": "怎么每次执行命令让x坐标加一",
    "replies": [
        {
            "author": "Sssss...",
            "timestamp": 1527859920,
            "txt_content": "先召唤一个实体（以盔甲架为例）\n（脉冲，执行一次）summon armor_stand ~ ~ ~复制代码\n然后每次让盔甲架x坐标加一\n（高频）execute @e[type=armor_stand] ~ ~ ~ tp @e[r=1] ~1 ~ ~复制代码\n然后执行命令即可\n（连锁，连接上一个方块）execute @e[type=armor_stand] ~ ~ ~ setblock ~ ~ ~ <方块>复制代码"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527861240,
            "txt_content": "Sssss... 发表于 2018-6-1 21:46\n先召唤一个实体（以盔甲架为例）\n\n然后每次让盔甲架x坐标加一\n那方块怎么弄？"
        },
        {
            "author": "Sssss...",
            "timestamp": 1527862200,
            "txt_content": "星际要塞 发表于 2018-6-1 21:54\n那方块怎么弄？\n方块就写你的方块id\n比如石头就是stone"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527863940,
            "txt_content": "Sssss... 发表于 2018-6-1 22:10\n方块就写你的方块id\n比如石头就是stone\n第二个和第三个好像执行不了"
        },
        {
            "author": "Sssss...",
            "timestamp": 1527893940,
            "txt_content": "星际要塞 发表于 2018-6-1 22:39\n第二个和第三个好像执行不了\n你是哪个版本？\n把你执行不了的报错内容截图一下"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527902220,
            "txt_content": " 本帖最后由 星际要塞 于 2018-6-2 09:30 编辑 \nSssss... 发表于 2018-6-2 06:59\n你是哪个版本？\n把你执行不了的报错内容截图一下\n1.13预览版，18w22c\n\n好像少了什么\n"
        },
        {
            "author": "Sssss...",
            "timestamp": 1527912720,
            "txt_content": "星际要塞 发表于 2018-6-2 09:17\n1.13预览版，18w22c\n\n好像少了什么\n哦 1.13的execute格式和以前的不一样\n要在execute 和 @之间插入run"
        },
        {
            "author": "Sssss...",
            "timestamp": 1527912720,
            "txt_content": " 本帖最后由 Sssss... 于 2018-6-2 12:14 编辑 \n星际要塞 发表于 2018-6-2 09:17\n1.13预览版，18w22c\n\n好像少了什么\n那个盔甲架不需要命令方块召唤 直接按T就行\n还有那个高频也可以换成脉冲+红石信号或者不需要setblock，直接fill就行\nfill <初始x,y,z> <目标x,y,z> <方块> [数据值] ......"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527944460,
            "txt_content": " 本帖最后由 星际要塞 于 2018-6-2 23:08 编辑 \nSssss... 发表于 2018-6-2 12:12\n哦 1.13的execute格式和以前的不一样\n要在execute 和 @之间插入run\n好像格式改动的不仅仅这么一点\n\n好像1.13中r=R被取消了https://minecraft-zh.gamepedia.com/%E5%91%BD%E4%BB%A4#execute\nhttps://minecraft-zh.gamepedia.c ... 3&variant=zh-cn\n"
        },
        {
            "author": "Sssss...",
            "timestamp": 1527984660,
            "txt_content": "星际要塞 发表于 2018-6-2 21:01\n好像格式改动的不仅仅这么一点\n\n好像1.13中r=R被取消了https://minecraft-zh.gamepedia.com/%E5%91%BD%E4% ...\n\nexecute @e[type=armor_stand] run tp @s ~1 ~ ~\nexecute @e[type=armor_stand] run setblock ~ ~ ~ 方块\n上面的肯定是错的\n我wiki打不开……无法访问……\n第一条指令把@e[type=armor_stand] 每次 tp @s ~1 ~ ~\n第二条指令execute这个@e[type=armor_stand] 每次 setblock ~ ~ ~ 方块"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527991080,
            "txt_content": " 本帖最后由 星际要塞 于 2018-6-3 10:01 编辑 \nSssss... 发表于 2018-6-3 08:11\nexecute @e[type=armor_stand] run tp @s ~1 ~ ~\nexecute @e[type=armor_stand] run setblock ~ ~ ~ 方 ...\n/execute/execute的语法被拆分。\n修饰子命令将可以改变指令的执行方式：\nas <指定实体> <连锁子命令>以<指定实体>执行命令（只改变执行者，不改变执行位置）。at <指定实体> <连锁子命令>以<指定实体>的坐标，旋转角度和维度来执行命令（只改变执行位置，不改变执行者）。positioned <指定坐标> <连锁子命令>从<指定坐标>的坐标来执行命令。positioned as <指定实体> <连锁子命令>仅用指定实体的坐标（x y z）执行命令align <坐标轴> <连锁子命令>执行命令时会先把执行位置转换为方块坐标（向下取整，只针对指定坐标轴的坐标），<坐标轴>的写法就是x、y、z的任意组合（例子：x,xz、code>zyx和yz）。\n使用示例：\n当x=-1.8,y=2.3,z=5.9使用x将变为x=-2,y=2.3,z=5.9当x=2.4,y=-1.1,z=3.8使用yxz将变为x=2,y=-2,z=3\n\nfacing <x y z> <连锁子命令>会使命令执行得如同朝向指定坐标<x y z>。facing entity <指定朝向实体> (eyes|feet) <连锁子命令> 会使命令执行得如同朝向指定朝向实体的脚或眼睛。rotated as <指定实体> or rotated [垂直旋转度数 水平旋转度数] 会使命令执行得如同执行者转向到指定方向。rotated as <指定实体> <连锁子命令>会使命令执行得如同执行者转向到实体的方向。rotated <y x> <连锁子命令>会使命令执行得如同执行者转向到指定方向。in (overworld|the_end|the_nether) <连锁子命令> 会使命令执行得如同位于指定维度。anchored (feet|eyes) <连锁子命令> 会在使用朝向坐标或朝向指令时调整此命令的判断坐标为脚或眼睛。\n条件子命令可以让你避免在特定情况运行命令：\n(if|unless) block <指定坐标> <指定方块> <连锁子命令> 如果（unless则为除非，即条件不成功）<指定坐标>（的方块）与<指定方块>，才执行后续的命令。(if|unless) blocks <起始框选点> <终止框选点> <对照区域> (all|masked) <连锁子命令>如果（除非）<起始框选点>和<终止框选点>之间的区域与<对照区域>相符，才执行后续的命令。(if|unless) entity <指定实体> <连锁子命令>如果（除非）<指定实体>存在（1个或以上）时执行命令。可能包括死亡的玩家，这取决于目标选择器的类型。(if|unless) score <指定实体/玩家名> <指定记分板记分项> (<|<=|=|>=|>) <对照实体/玩家名> <对照记分板记分项> <连锁子命令>如果（除非）)<指定实体/玩家名>的<指定记分板记分项>分数与<对照实体/玩家名>的<对照记分板记分项>分数符合指定的比较符时执行命令。(if|unless) score <指定实体/玩家名> <指定记分板记分项> matches <指定范围> <连锁子命令>指定目标的记分板记分项是否在指定范围内(如1, 1..5）。\n作为/stats的替代，新的store子命令将允许你将命令结果储存于某处：\nresult将会选择命令的结果来输出，用于取代过去的这些统计：AffectedBlocks、AffectedEntities、AffectedItems、QueryResult。success将会记录这个命令到底执行的成功次数是多少。虽然此数值通常会是0或1, 但是如果此命令被分开每个实体执行（像是as @a）那么其成功数也就大于1了。这取代了SuccessCount。命令统计会被储存，并在整个命令被完整执行后返回（返回值）。注意返回值必定为整数，小数会被向下取整。如果指命令没有成功（像success是0时），result也会被设为0。之后会明确每个命令的预期结果。store (result|success) score <目标实体/玩家名> <指定记分板记分项> <连锁子命令>\n返回值会被储存在<目标实体/玩家名>的<指定记分板记分项>分数里。记分项必须存在，但相对于/stats你不需要为<目标实体/玩家名>的分数设定初始值\nstore (result|success) block <目标坐标> <标签路径> (byte|double|float|int|long|short) [倍率] <连锁子命令>\n将返回值储存在目标坐标方块在标签路径的NBT标签上，并储存为byte、double、float、int、long或short。可选的倍率可以用于把输出值乘以一个倍数方便储存（如整数与小数的转换）。注意不能通过此命令为数组/列表标签加入新元素，只能取代现有元素。\nstore (result|success) entity <目标实体> <标签路径> (byte|double|float|int|long|short) [倍率] <连锁子命令>\n将返回值储存在目标实体标签路径的NBT标签上，并储存为byte、double、float、int、long、或short。和/data类似，store不能修改玩家的NBT。在玩家Inventory或EnderItems中的物品tag键的NBT是例外，并可以用store修改[8]。可选的倍率可以用于把输出值乘以一个倍数方便储存（如整数与小数的转换）。注意不能通过此命令为数组/列表标签加入新元素，只能取代现有元素。\nstore (result|success) bossbar <id> (value|max) <连锁子命令>\n值的ID以id的形式储存在value或max的bossbar设置里。\n标签路径的形式类似于：foo.bar[0].\"一个[随便写个好听的]\".baz\nfoo.bar是foo的子标签bar。bar[0]表示bar的元素0（索引值）。\"用引号括起来的字符串\"在串内字符需要被转义(escape)时可以使用。即字串不是只由0-9、a-z、_和-的字符组成时需要使用引号括起来。例如，引号\"及反斜杠\\是需要被转义的。\n例子：\n/execute store success score @a foo run say hi/execute as @e[type=pig] at @s store success entity @s Saddle byte 1 if entity @p[distance=..5]\n你可以将所有需要的子命令串连在一起。同一个子命令可以多次出现。要这么做时，你必须将一个子命令直接连接到下一个子命令。最后当你完成整条子命令连锁，写上run来让你继续写下你实际想要执行的命令。\n不可将/写在命令之前。\n例：/execute as somebody at somebody run say 嘿游戏会在执行/execute命令之后的命令前，先处理子命令的数据，故之后的命令无法影响之前的命令。\n旧命令转换式示例：\n/execute @e ~ ~ ~ detect ~ ~ ~ stone 0 say 石头！变成/execute as @e at @s if block ~ ~ ~ stone run say 石头！/execute @e ~ ~ ~ detect ~ ~ ~ grass 0 summon pig变成/execute at @e if block ~ ~ ~ grass run summon pig/execute @e ~ ~ ~ say 嗨！变成/execute as @e run say 嗨！\n目标选择器引入了更多对错误的处理。参数可以被引号括住（如果参数包含一些特殊字符，如@e[name=\"bla bla\"]中的空格）不允许limit=0、level=-10和gamemode=purple之类的错误输入。不再存在最小值与最大值的分别设定，取而代之地是可以设定范围。level=10要求等级为10level=10..12要求等级为10、11或12level=5..要求等级大于等于5level=..15要求等级小于等于15\n将难懂的简写进行了重命名。m -> gamemodel与lm -> levelr与rm -> distancerx与rxm -> x_rotationry与rym -> y_rotationc -> limit\nx、y、z、r、rm、dx、dy、dz现在是双精度浮点数了，支持12.34这样的数值。x和z不再有中心修正了，取而代之是可以使用小数形式的实体坐标。这意味着x=0不再等同于x=0.5。\n\ngamemode（原本的m）不再支持数字ID或缩写了。limit (以前是c）不再支持负数。请使用sort=furthest作为替代。\nname参数现在支持空格了（需要使用引号括起来）。现在在目标选择器中可以重复使用参数了。tag=foo,tag=bar,tag=!baz将选择有foo、bar标签而没有baz的目标。type=!cow,type=!chicken将选择不是牛也不是鸡的目标。type=cow,type=chicken是不允许的，因为没有目标会同时是鸡与牛。\n你可以指定排序方式。sort=nearest是原来的默认值，按距离排序（@p的默认值）sort=furthest则与预设相反（之前你会使用c=-5来达到这点）sort=random为随机排序（当前@r的默认值）sort=arbitrary为不进行排序（当前@e和@a的默认值，可以提高选择器效率）\n指定分数现在是scores={foo=1,bar=1..5}。不同的记分项都写在{}里，以逗号分隔。你可以用advancements={foo=true,bar=false,custom:something={criterion=true}}来测试进度true代表“已完成进度/判据”，false代表“未完成进度/判据”不同的进度都写在{}里，以逗号分隔。也可以使用一组进度的判据(criteria)来测试，只需要把其进度的数值写作{criteria1=true/false,criteria2=true/false...}即可。\n\n/tp与/teleport/tp现在是/teleport的别名（与/w、/msg与/tell一样）。对/teleport进行了简化，以避免表意模糊。/teleport <指定实体> 不支持旋转或朝向，能将你传送到指定实体的坐标。/teleport <x y z> 不支持旋转或朝向，能使执行者传送到指定坐标。/teleport <指定实体> <指定实体> 不支持旋转或朝向，能使目标对象传送到指定实体坐标。/teleport <目标对象> <x y z> [垂直旋转度数 水平旋转度数] 能使目标对象传送到指定坐标并选择性改变转向。/teleport <目标对象> <x y z> facing [指定朝向坐标] 能使目标对象传送到指定坐标并朝向指定的座标。/teleport <目标对象> <x y z> facing entity <指定朝向实体> [feet|eyes]能使目标对象传送到指定坐标并指定朝向实体的脚或眼睛坐标（预设为feet）。现在允许跨维度的传送。\n\n/setblock/setblock语法被修改了/setblock <目标坐标> <目标方块名称> [数据值] [模式] [数据标签]将变为/setblock <目标坐标> <目标方块> [模式]参阅下方的方块参数类型以获取更多细节。\n\n/fill/fill语法被修改了/fill <起始框选点> <终止框选点> <方块> <数据> replace [替代方块] [替代方块数据]变成/fill <起始框选点> <终止框选点> <目标方块> replace [方块]/fill <起始框选点> <终止框选点> <方块> [数据] [destroy|hollow|keep|outline|replace] [数据标签]变成/fill <起始框选点> <终止框选点> <方块> [destroy|hollow|keep|outline|replace]\n\n\nWiki有关的设定\n"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527992580,
            "txt_content": " 本帖最后由 星际要塞 于 2018-6-3 10:31 编辑 \nSssss... 发表于 2018-6-3 08:11\nexecute @e[type=armor_stand] run tp @s ~1 ~ ~\nexecute @e[type=armor_stand] run setblock ~ ~ ~ 方 ...\nover，我都弄好了\n后面的坐标~1 ~ ~是第一个@e[type=armor_stand]的，后面的tp执行对象是第二个@e[type=armor_stand]的，位置是第一个@e[type=armor_stand]的坐标~1 ~ ~\n1.循环/execute at @e[type=armor_stand] run tp @e[type=armor_stand] ~1 ~ ~\n2.连锁/execute at @e[type=armor_stand] run setblock ~1 ~ ~ minecraft:white_stained_glass"
        },
        {
            "author": "星际要塞",
            "timestamp": 1527993120,
            "txt_content": "Sssss... 发表于 2018-6-3 08:11\nexecute @e[type=armor_stand] run tp @s ~1 ~ ~\nexecute @e[type=armor_stand] run setblock ~ ~ ~ 方 ...\n非常感谢"
        },
        {
            "author": "zuizun",
            "timestamp": 1528287300,
            "txt_content": "这样的话都解决了吗"
        },
        {
            "author": "星际要塞",
            "timestamp": 1528560840,
            "txt_content": "zuizun 发表于 2018-6-6 20:15\n这样的话都解决了吗\n嗯，解决了"
        },
        {
            "author": "zuizun",
            "timestamp": 1529403600,
            "txt_content": "嗯嗯嗯，很好很好233"
        }
    ]
}