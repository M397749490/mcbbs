{
    "title": "通讯加密的方法(双向)",
    "author": "轻光233",
    "replyCount": 6,
    "timestamp": 1557644280,
    "txt_content": " 本帖最后由 轻光233 于 2019-6-6 10:33 编辑 \n\n最近在做远程管理的插件，其中牵扯到加密的技术\n由于个人只是个初中生，并没有了解过什么加密算法\n请问吧里有什么dalao知道双向加密的算法，务必教教我这个萌新qwq\n(已解决，感谢3l和6l的dalao，之前我说base64是加密算法的说法也是极其错误的，在此道歉，也感谢7l的dalao的提醒)",
    "replies": [
        {
            "author": "森林蝙蝠",
            "timestamp": 1557646680,
            "txt_content": "RSA/AES算法，非常常见"
        },
        {
            "author": "roj234",
            "timestamp": 1557653100,
            "txt_content": " 本帖最后由 roj234 于 2019-5-12 17:27 编辑 \nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n \n/**\n **\n * AES128 算法，加密模式为ECB，填充模式为 pkcs7（实际就是pkcs5）\n *\n *\n */\npublic class AESUtil {\n \n    /**\n     * 加密\n     *\n     * @param content 需要加密的内容\n     * @param key  加密密码\n     * @return\n     */\n    public static byte[] encrypt(String content, String key) {\n        try {\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            random.setSeed(key.getBytes());\n            kgen.init(128, random);\n            SecretKey secretKey = kgen.generateKey();\n            byte[] enCodeFormat = secretKey.getEncoded();\n            SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");// 创建密码器\n            byte[] byteContent = content.getBytes(\"UTF-8\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);// 初始化\n            byte[] result = cipher.doFinal(byteContent);\n            return result; // 加密\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n \n    /**解密\n     * @param content  待解密内容\n     * @param key 解密密钥\n     * @return\n     */\n    public static byte[] decrypt(byte[] content, String key) {\n        try {\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            random.setSeed(key.getBytes());\n            kgen.init(128, random);\n            SecretKey secretKey = kgen.generateKey();\n            byte[] enCodeFormat = secretKey.getEncoded();\n            SecretKeySpec secretKeySpec = new SecretKeySpec(enCodeFormat, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");// 创建密码器\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);// 初始化\n            byte[] result = cipher.doFinal(content);\n            return result; // 加密\n        }catch (NoSuchAlgorithmException e) {\n            //e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            //e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            //e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            //e.printStackTrace();\n        } catch (BadPaddingException e) {\n            //e.printStackTrace();\n        }\n        return null;\n    }\n \n    /**\n     * 字符串加密\n     * @param content 要加密的字符串\n     * @param key 加密的AES Key\n     * @return\n     */\n    public static String encryptString(String content, String key) {\n        return parseByte2HexStr( encrypt(content, key));\n    }\n \n    /**\n     * 字符串解密\n     * @param content 要解密的字符串\n     * @param key 解密的AES Key\n     * @return\n     */\n    public static String decryptString(String content, String key){\n        byte[] decryptFrom = parseHexStr2Byte(content);\n        byte[] decryptResult = decrypt(decryptFrom,key);\n        return new String(decryptResult);\n    }\n \n \n    /**将16进制转换为二进制\n     * @param hexStr\n     * @return\n     */\n    public static byte[] parseHexStr2Byte(String hexStr) {\n        if (hexStr.length() < 1)\n            return null;\n        byte[] result = new byte[hexStr.length()/2];\n        for (int i = 0;i< hexStr.length()/2; i++) {\n            int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);\n            int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);\n            result[i] = (byte) (high * 16 + low);\n        }\n        return result;\n    }\n \n \n    /**将二进制转换成16进制\n     * @param buf\n     * @return\n     */\n    public static String parseByte2HexStr(byte buf[]) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < buf.length; i++) {\n            String hex = Integer.toHexString(buf[i] & 0xFF);\n            if (hex.length() == 1) {\n                hex = '0' + hex;\n            }\n            sb.append(hex.toUpperCase());\n        }\n        return sb.toString();\n    }\n}</i></i>复制代码"
        },
        {
            "author": "Ariy",
            "timestamp": 1557657000,
            "txt_content": " 本帖最后由 tian_wc 于 2019-5-12 18:32 编辑 \n\n\n具体怎么用建议百度，node和java都有现成的包可以用\n非对称、双向，很符合你的要求\n\n"
        },
        {
            "author": "gooding300",
            "timestamp": 1557658920,
            "txt_content": "建议先了解一下不对称加密\nhttps://www.zhihu.com/question/33645891"
        },
        {
            "author": "萝娜娜",
            "timestamp": 1557734400,
            "txt_content": " 本帖最后由 lona 于 2019-5-13 16:09 编辑 \n\n1.这里不是贴吧2.你需要使用的是AES+RSA\n3.AES-对称加密（速度较快\n4.RSA-非对称加密（速度较慢\n5.AES的实现在openssl,mbedtls等广泛使用的库均有实现，同时现在的部分CPU也支持AES\n\n    mbedtls\n    aes指令集\n6.RSA的实现同样在openssl和mbedtls中有实现，但是没有CPU支持\n    openssl\n7.如果你是期待的java示例代码，那就更简单了\n    rsa\n    aes"
        },
        {
            "author": "Lss233",
            "timestamp": 1557742920,
            "txt_content": "楼上各位大佬已经介绍的很详细了。但是看了楼主的帖子，我还是忍不住想补充一点：\nBASE64不是加密算法！不是加密算法！它不是！！！\n\n加密算法的要求是需要通过一个特殊的密钥来解密，才能获取到原来的内容，\n但是，根据英文维基百科的介绍，base64只是一种数据编码算法，它能做到的，就是把一串数据用另外一种方式6KGo6L6+5Ye65p2l而已，任何人只要知道是这种算法处理过的数据，就可以直接得到原来的数据。\n“base64是加密算法”是极具误导性的错误说法。\n\n相关链接：\nhttps://en.m.wikipedia.org/wiki/Base64\n\nhttps://stackoverflow.com/questi ... -encoding-algorithm\n"
        }
    ]
}