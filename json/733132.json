{
    "title": "1.10.2以上的方块与物品渲染",
    "author": "金坷居士",
    "replyCount": 2,
    "timestamp": 1508325660,
    "txt_content": " 本帖最后由 金坷居士 于 2017-10-20 22:56 编辑 \n\n难度：中级\\进阶\n\n似乎还木有1.10.2级以上的渲染方面的教程，那窝就来弄一个辣~\n本教程中介绍的方块和物品渲染技巧完全适用1.10.2和以上的版本，包括1.11.2，1.12.2等，内容部分适用1.8-1.8.9，不过作者并没有接触过1.8-1.8.9而且感觉那些版本很不成熟，于是选择无视，实体Entity由于本人吔木有研究过就不写辣。\n1.7.10升级高版本需要特殊渲染技巧的也可以参考本教程w\n另外说个题外话，各位modder应该考虑停止为1.7.10开发mod了，应该往前看，Mojang这版本刷的这么辛苦，我们是不是吔要来一起资磁一鉿啊？升级吧升级吧，升级就有大鸡rou腿bang吃哦~\n作者比较咸鱼，难免有错误或者不严谨的地方，很难让这里几百个modder一致通过，指出错误窝会很鉿铍的~\n\n1. 首先说下最好升级的TileEntitySpecialRender部分\nTileEntitySpecialRender(TESR)是一种高级的方块渲染方式，能用GL一切的功能，当然开销也很大，在1.10.2之后推荐尽可能使用FastTESR代替，对性能可以极大的提高，教程之后会讲。\n1.7.10里面可能会出现这种渲染代码Tessellator t = Tessellator.instance;\n\n..................................................................................................\n\nGL11.glPushMatrix();\nbindTexture(xxx);\nt.startDrawingQuads();\nt.addVertexWithUV(-maxX / 2, 0, -maxZ / 2, 0, 1);\nt.addVertexWithUV(-maxX / 2, 0, maxZ / 2, 1, 1);\nt.addVertexWithUV(-maxX / 2, maxY, maxZ / 2, 1, 0);\nt.addVertexWithUV(-maxX / 2, maxY, -maxZ / 2, 0, 0);\nt.draw();\nGL11.glPopMatrix();复制代码\n在1.10.2之后Tessellator这个类biu的一下就变了，那么就需要这么写\npublic static void startDrawingQuads() {\n        Tessellator.getInstance().getBuffer().begin(7, DefaultVertexFormats.POSITION_TEX);\n    }\n\n    public static void addVertexWithUV(double x, double y, double z, double u, double v) {\n        Tessellator.getInstance().getBuffer().pos(x, y, z).tex(u, v).endVertex();\n    }\n\n    public static void draw() {\n        Tessellator.getInstance().draw();\n    }\n\n..................................................................................................\n\nGlStateManager.pushMatrix();\nbindTexture(xxx);\nstartDrawingQuads();\naddVertexWithUV(-maxX / 2, 0, -maxZ / 2, 0, 1);\naddVertexWithUV(-maxX / 2, 0, maxZ / 2, 1, 1);\naddVertexWithUV(-maxX / 2, maxY, maxZ / 2, 1, 0);\naddVertexWithUV(-maxX / 2, maxY, -maxZ / 2, 0, 0);\ndraw();\nGlStateManager.popMatrix();复制代码基本上能一一对应~\n\n2. 方块的渲染\n物品和方块是Minecraft的很重要的组成部分。首先来回顾一下物品和方块的定义。方块顾名思义就素在世界里面玩家看到的摆在地上的方块（Block类），比如石头什么的。物品（Item类）指的是一切能放到玩家物品栏里的东西，方块在物品栏中也是以物品的形式呈现的（ItemBlock类）。更准确的说，玩家手中、物品栏里、箱子容器里的是物品堆（ItemStack类，final的不可继承）。值得注意的是被丢掉地上之后方块并不是Item或者ItemStack，而是EntityItem，实体的一种，在本文中不讨论。\n\n在1.8版本之后，MC引入了BlockState的概念，在代码中用IBlockState代表， 一个IBlockState可以包含若干IProperty，就是属性，每个属性有可以设置的值。IBlockState取代了之前的meta在代码中的绝大部分地位，这样最大的好处就是，原来毫无意义的meta数字被封装成了有意义的IProperty属性，提高了代码的可读性。\n\n\n方块状态，其实是一种所谓的有限状态。每个IProperty都要求声明自己的有效值（参见IProperty#Collection<T> getAllowedValues()），并且有效值的个数是有限的，比如布尔类型的PropertyBool只能有True和False两种状态，PropertyEnum取决于被选用的枚举的数量，而PropertyInteger可以在创建的时候指定有效范围。方块状态的实现会在加载游戏的时候进行实例化，而且在游戏的时候不会变，withProperty返回的是另一个已经存在的实例而不是对当前方块状态的修改，还有就是可以用==判断方块状态是否相等。\nmeta其实没有消失，在储存的时候依然需要将IBlockState手动映射成meta，参考Block的BlockState getStateFromMeta(int meta)和int getMetaFromState(IBlockState state)，这两个映射必须一致不然会鬼畜。IBlockState方块状态除了包装了meta之外还可以包含一些和meta无关的属性，比如栏杆有east,north,south,west四个布尔属性指示和周围方块的连接状态，这些属性不是meta映射来的，在渲染的时候，MC会调用Block的getActualState，在getActualState中modder可以设定这些与meta无关的属性的值。值得注意的是，IBlockAccess (World, WorldClient, WorldServer)的getBlockState以及各种Block函数里传进来的state都只包含和meta相关的属性值，也就是getStateFromMeta里面的，如果需要和meta无关的属性的值，需要手动调用getActualState。\n\n\nMC的理念是，一种状态对应一种渲染姿势（这个不严谨，本教程会详细讲）。举个例子，熔炉有4个朝向，这就是4种方块状态，对应4种方块模型（IBakedModel）。\n\n下面就开始高能了，首先来看MC渲染方块的流程！（有些地方精简了，为了方便理解，不过关键的类都保留了，看不清的话附件有pdf高清版）\n\n\n\n\nr.png (343.53 KB, 下载次数: 3)\n\n下载附件\n\n2017-10-20 22:48 上传\n\n\n\n\n\n从左上角开始看。当有方块变动之类的事件发生时，就需要重新根据方块的状态来更新渲染的缓存，这成为编译渲染区块。RendererChunk是一个16x16x16的区域，它把一个普通的区块Chunk分成16个，里面储存的“编译”好的区块渲染指令，游戏会把它送给OpenGL这样玩家就看到这些方块了。RendererChunk首先会遍历这个16x16x16区域内所有的方块位置（MutableBlockPos），用ChunkCache中获取缓存的方块状态IBlockState（只包含meta相关状态的）。然后这个IBlockState被传到BlockRendererDispatcher中（方块渲染分发器），在这里面Block的getActualState被调用，然后这个状态被用来在BlockModelShapes里获取到对应的IBakedModel（用来渲染的模型），之后BlockRendererDispatcher会调用Block的getExtendedState，这时state就包含所有可能需要的信息了。最后IBlockState和IBakedModel一起被传到BlockModelRenderer中进行渲染，在这期间IBakedModel的getQuads方**被多次调用来获取相应的BakedQuad（平面），BlockModelRenderer根据IBakedModel返回的平面来产生int[]然后送到VertexBuffer. 至此渲染区块\n编译完成。之后由游戏来每帧渲染各种VertexBuffer就是玩家看到的方块世界。\n\n\n少女施工中.....\n\n\n\n\n\n\n\n\n\n\n\n\n\nMinecraft方块渲染精通到女装.zip\n\n\n2017-10-20 22:02 上传\n点击文件名下载附件\n\n\n\n\n499.94 KB, 下载次数: 54\n\n\n\n\n\n",
    "replies": [
        {
            "author": "金坷居士",
            "timestamp": 1508410680,
            "txt_content": " 本帖最后由 金坷居士 于 2017-10-20 21:41 编辑 \n\n自占沙发的字数补丁"
        },
        {
            "author": "zhangkaijianb",
            "timestamp": 1594622820,
            "txt_content": "挺好的啊"
        }
    ]
}