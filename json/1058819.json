{
    "title": "[Java]ReflectionFX - 高效Java反射库",
    "author": "夏雨吖",
    "replyCount": 0,
    "timestamp": 1591971840,
    "txt_content": " 本帖最后由 夏雨吖 于 2020-7-5 21:49 编辑 \n\n\nReflectionFX - 高效反射\n项目地址: ReflectionFX开源协议: GPL 3.0欢迎提出BUG: Github\n\nReflectionFX介绍这个轮子来源于一次偶然的机会，听说继承java的MagicAccessorImpl可以调用私有的方法，自己写了一个栗子试了一下真的可以，就有了写这个轮子的想法\n\n这是一个开放的类库，几乎没有任何检查，你甚至可以用来反射这个类库本身\n已测试可用版本Java8+ 不会还有人用Java7叭？\n\n包括:\nReflectionAccessor\n通用的反射调用接口，可以(任意)反射方法，成员变量，构造对象等\n\nEnumHelper\n为枚举设计的接口，可以构造新的枚举实例，增加/删除/修改枚举列表，对于枚举类中枚举项此接口暂时不支持修改\n\n动态绑定\n自己定义一个接口，写上方法声明，交给ReflectionFX实现，完成动态绑定\n这是一种新的反射方法，至少我没见到过有用这种方法的类库  如果有请务必告诉我，谢谢谢谢!\n\n注:本贴教程的所有内容仅限release 4.2.5和commit 3449b76df09fd0a6ea12f09d1f4e3b38dafece52及之前的版本\n接下来会以这个类作为测试用例的目标类: Test.java\nReflectionAccessorReflectionAccessor是类库提供的通用反射接口，用泛型标记返回值\n\n在ReflectionFactory里提供了构造ReflectionAccessor的方法\n\n反射方法注：\n反射静态方法时可以直接传入参数，反射非静态方法时第一个参数为调用方法用到的对象，之后填方法参数\n如果要反射一个已经实例化的对象的构造方法，方法名必须是<init>\nGithub\nGithub\nGithub\nGithub\n\n第一个方法\n参数:\n - target 目标方法所在的类\n - methodName 目标方法的方法名\n - isStatic 目标方法是否静态\n - special 是否忽略方法重写调用目标方法\n - isAbstract 目标方法是否是抽象方法\n - returnType 目标方法的返回值类型\n - params 目标方法的参数列表类型\n\n第二个方法\n参数:\n - target 目标方法所在的类\n - methodName 目标方法的方法名\n - isStatic 目标方法是否静态\n - special 是否忽略方法重写调用目标方法\n - isAbstract 目标方法是否是抽象方法\n - type 目标方法的MethodType\n\n第三个方法:\n参数:\n - method 目标方法\n\n第四个方法:\n参数:\n - method 目标方法\n - special 是否忽略方法重写调用目标方法\n\n用例: Main1.java\n\n\n反射变量\nGithub\nGithub\n\n第一个方法\n参数:\n - target 目标变量所在的类\n - fieldName 目标变量的变量名\n - type 目标变量的类型\n - isStatic 目标变量是否静态\n - isFinal 目标变量是否final\n\n第二个方法\n参数:\n - field 目标变量\n\n用例：Main2.java\n\n\n构造实例\n注: 构造实例只分配对象的内存，不调用对象的构造方法\nGithub\nGithub\n\n第一个方法\n参数:\n - target 目标类\n\n第二个方法\n参数:\n - target 目标类\n - initialize 是否调用无参构造方法\n\n用例：Main3.java\n\n\n反射构造方法\nGithub\nGithub\nGithub\n\n第一个方法\n参数:\n- target 目标类\n- initialize 是否调用无参构造方法\n\n第二个方法\n参数:\n - target 目标类\n - params 构造方法的参数列表\n\n第三个方法\n参数:\n - ctr 目标构造方法\n\n用例: Main4.java\nEnumHelperEnumHelper是为枚举设计的接口，可以操作枚举类中的枚举列表\n\n在ReflectionFactory中提供了构造EnumHelper的方法\nGithub\n\nEnumHelper.java\n方法:\nEnumHelper#construct(String)\n构造一个新的枚举实例\n参数:\n - name 新枚举实例的名字\n\nEnumHelper#construct(String, int)\n构造一个新的枚举实例\n参数:\n - name 新枚举实例的名字\n - ordinal 新枚举实例的序数\n\nEnumHelper#values()\n返回枚举类中的枚举列表\nJava会为每个枚举类编译一个values方法，返回枚举列表时会复制枚举列表\nEnumHelper中的values不会复制枚举列表而是直接返回枚举类中枚举列表的引用\n\nEnumHelper#values(T[])\n修改枚举类的枚举列表\n参数:\n - values 新的枚举列表\n\nEnumHelper#add(T)\n添加一个新的枚举项到枚举列表\n参数:\n - value 新的枚举项\n\nEnumHelper#remove(int)\n从枚举列表中删除一个枚举项\n参数:\n - index 枚举项索引\n\n用例: Main5.java\n动态绑定动态绑定是一种新的反射实现，它可以使用自己定义的接口完成反射调用\n\n在ReflectionFactory里提供了动态绑定的实现\n\n使用动态绑定之前先了解几种调用类型\nReflectionFactory#KIND_INVOKE_VIRTUAL\n调用非静态方法\n\nReflectionFactory#KIND_INVOKE_SPECIAL\n忽略方法覆盖调用非静态方法\n\nReflectionFactory#KIND_INVOKE_STATIC\n调用静态方法\n\nReflectionFactory#KIND_INVOKE_INTERFACE\n调用抽象方法\n\nReflectionFactory#KIND_GET\n获取类中的变量\n\nReflectionFactory#KIND_PUT\n修改类中的变量\n\n\n动态绑定需要MethodKind构造方法:\nMethodKind#MethodKind(String, MethodType)\n参数:\n - name 方法名\n - type 方法返回值类型和参数列表, 参考JDK MethodType\n\nMethodKind#MethodKind(String, Class, Class)\n参数:\n - name 方法名\n - returnType 返回值类型\n - params 参数列表[/fond]\n\n动态绑定的几个方法ReflectionFactory#ReflectionFactory(Class, Class)\n构造一个新的ReflectionFactory实例\n参数:\n - handle 动态绑定的绑定点(自己定义的绑定接口)\n - target 动态绑定的目标类\n\nReflectionFactory#method(MethodKind, MethodKind, int)\n绑定一个方法\n参数:\n - implementation 声明在绑定点接口里的方法\n - invocation 绑定的目标方法\n - kind 方法的调用类型\n\nReflectionFactory#field(MethodKind, String, int)\n绑定一个变量\n参数:\n - implementation 声明在绑定点接口里的方法\n - operation 绑定的变量的变量名\n - kind 变量的操作类型\n\nReflectionFactory#instantiation(MethodKind)\n实例化一个对象\n只会为对象分配内存，不会调用对象的任何构造方法\n参数:\n - implementation 声明在绑定点接口里的方法\n\nReflectionFactory#construct(MethodKind, MethodKind)\n实例化一个对象并调用对象的构造方法\n参数:\n - implementation 声明在绑定点接口里的方法\n - invocation 实例化时调用的构造方法\n\nReflectionFactory#enumHelper()\n加入enum helper绑定\nenum helper绑定会在接口实现类里添加和EnumHelper里面相同声明的方法\n\n用例: Main6.java\n\n动态绑定点方法声明规范\n注: 除了enumHelper之外的所有绑定点声明，方法名可以随便写绑定静态方法\npublic class Something {\n  private static void print(String text) {\n    System.out.println(text);\n  }\n}复制代码绑定点的方法声明返回值和绑定目标的返回值相同，参数列表相同\npublic interface BindSite {\n  void print(String text);\n}复制代码\n绑定非静态方法\npublic class Something {\n  public void print(String text) {\n    System.out.println(text);\n  }\n}复制代码绑定点的方法声明返回值和绑定目标的返回值相同，参数列表第一个必须是绑定目标所在的类的类型，之后的参数列表和绑定目标的参数列表相同public interface BindSite {\n  void print(Something obj, String text);\n}复制代码\n绑定静态变量\npublic Something {\n  private static String text;\n}复制代码绑定PUT的时候，绑定点方法声明返回值为void，参数列表为绑定目标变量的类型\n绑定GET的时候，绑定点方法声明返回值为绑定目标变量的类型，参数列表为空\npublic interface BindSite {\n  void set(String text);\n  String get();\n}复制代码\n\n绑定非静态变量\npublic class Something {\n  private String text;\n}复制代码绑定PUT的时候，绑定点方法声明返回值为void, 参数列表第一个是被绑定目标所在类的类型，第二个为被绑定目标的类型\n绑定GET的时候，绑定点方法声明返回值为被绑定目标的类型，参数列表只有一个，必须是被绑定目标所在类的类型\npublic interface BindSite {\n  void set(Something obj, String text);\n  String get(Something obj);\n}复制代码\n绑定对象实例化\n对象实例化只分配对象内存不调用对象的构造方法\npublic class Something {\n}复制代码绑定点方法声明返回值为绑定目标类的类型，参数列表为空\npublic interface BindSite {\n  Something newSomething();\n}复制代码\n绑定构造方法\npublic class Something {\n  private Something(String text) {\n    System.out.println(text);\n  }\n}复制代码绑定点方法声明返回值为绑定目标类的类型，参数列表为绑定目标构造方法的参数列表\npublic interface BindSite {\n  Something construct(String text);\n}复制代码\n绑定enum helper\npublic enum Something {\n  A, B, C\n}复制代码绑定enum helper的时候，绑定点方法声明的方法名必须和EnumHelper里面声明的方法的方法名相同\n绑定点可以继承EnumHelper，也可以自己声明方法\n自己声明方法可以不全部声明，比如只添加construct方法和add方法, 声明方法时候的泛型可以改成具体的绑定目标的类型\npublic interface BindSite extends org.mve.invoke.EnumHelper<Something> {\n}复制代码或\npublic interface BindSite {\n  Something construct(String name, int ordinal);\n  void add(Something value);\n}复制代码实用工具ReflectionFactory里面提供了一些有用的小工具\nReflectionFactory#constant(Object)\n返回一个持有一个常量的ReflectionAccessor\n只可以获取它的常量，不可以修改(如果你反射它那就可以)\n\nReflectionFactory#throwException()\n返回一个用来抛出异常的ReflectionAccessor\n用这个抛出异常不需要在方法声明里添加throws\n\nReflectionFactory#UNSAFE\n一个JDK Unsafe的包装，Java8到Java14的所有Unsafe的方法\n如果在低版本调用高版本才有的方**抛出异常\n其中还有一个获取当前JVM运行版本的方法，返回的版本为当前JVM支持的Class文件头最高版本\n比如 JVM版本为8会返回52\n每加一个版本，这个值会+1\n\nReflectionFactory#TRUSTED_LOOKUP\nJDK 中权限最高的Lookup\n可以无视访问权限查找任何类的任何元素\n\nReflectionFactory#METHOD_HANDLE_INVOKER\n用来调用MethodHandle的工具\n用这个来调用MethodHandle不需要捕获异常\n\nReflectionFactory#ACCESSOR\n实现了MagicAccessor接口的一个类，包括了一些有用的方法MagicAccessorMagicAccessor里面有一些很有用的方法\nMagicAccessor#setAccessible(AccessibleObject, boolean)\nJDK9或更高的版本里，设置一个默认不可访问的元素可访问时会输出非法访问警告\n用这个方法就不会有警告\n\nMagicAccessor#forName(String)\n默认实现为调用Class.forName(String)但是不需要捕获异常\n\nMagicAccessor#forName(String, boolean, ClassLoader)\n默认实现为调用Class.forName(String, boolean, ClassLoader)但是不需要捕获异常\n\nMagicAccessor#defineClass(ClassLoader, byte[])\n用给定的ClassLoader define一个类\n因为默认实现为调用传入的ClassLoader的defineClass方法所以不可以为null\n\nMagicAccessor#getCallerClass()\n获取调用当前方法的方法所在的类\n\nMagicAccessor#getClassContext()\n获取当前调用栈中的每一个栈帧的方法所在的类\n\nMagicAccessor#construct(Class)\n实例化一个对象调用无参构造方法\n实现为获取类的无参构造方法Constructor然后调用newInstance方法\n\nMagicAccessor#construct(Class, Class[], Object[])\n实例化一个对象，调用拥有给定参数类型列表的构造方法\n实现为获取类的给定参数列表构造方法Constructor然后调用newInstance方法\n\nMagicAccessor#invokeMethodHandle(MethodHandle, Object...)\n和ReflectionFactory#METHOD_HANDLE_INVOKER相同的作用\n\nMagicAccessor#getField(Class, String)\n获取类中指定名字的变量\n\nMagicAccessor#getMethod(Class, String, Class[])\n获取类中指定名字和参数列表的方法\n\nMagicAccessor#getConstructor(Class, Class[])\n获取类中指定参数列表的构造方法\n\nMagicAccessor#getFields(Class)\n获取类中定义的所有变量\n\nMagicAccessor#getMethods(Class)\n获取定义在类中的所有方法\n\nMagicAccessor#getConstructors(Class)\n获取类中定义的所有构造方法\n\nMagicAccessor#throwException(Throwable)\n抛出一个异常\n\nMagicAccessor#initialize(Object)\n调用一个对象的Object#Object()构造方法\n\nReflectionFX - 实现原理\n\nReflectionFX - 实现原理ReflectionAccessor反射方法的实现\nprivate static <T> ReflectionAccessor<T> generic(\n  ClassLoader callerLoader,\n  Class<?> clazz,\n  String methodName,\n  MethodType type,\n  boolean isStatic,\n  boolean special,\n  boolean isAbstract)复制代码在这个方法里面会先实例化一个ClassWriter对象\n声明一个类继承jdk的MagicAccessorImpl实现ReflectionAccessor 908行\n在实现invoke方法的时候会先判断目标方法是不是静态方法 913行 如果不是静态方法，会先从可变参里面取出第一个对象\n之后从可变参里面取出调用方法需要的参数 914行\n然后根据最后三个boolean决定方法调用指令然后调用方法 915行\n在取出参数的时候会判断目标方法的参数，如果有基本类型会拆箱 1128行\n最后判断返回值类型\n如果目标方法返回值是void，会返回null 923行\n如果目标方法的返回值是基本类型会自动装箱，然后返回 924行\n如果目标方法是静态方法并且参数列表为空，会实现无参的invoke方法 929行\n\n反射变量的实现\nprivate static <T> ReflectionAccessor<T> generic(\n  ClassLoader callerLoader,\n  Class<?> clazz,\n  String fieldName,\n  Class<?> type,\n  boolean isStatic,\n  boolean isFinal)复制代码同样会构造一个ClassWriter，声明一个类继承jdk的MagicAccessorImpl实现ReflectionAccessor\n在invoke方法的实现里面\n会先判断可变参是不是null 947行\n然后判断数组的长度 952行\n目标变量是静态并且数组长度为1表示要改掉变量\n目标变量非静态并且数组长度为2也表示要改掉变量\n然后加入改掉变量的值的实现 957-1020行\n会先判断变量类型为基本类型，如果是会拆箱 957行\n\n如果变量是final，会用Unsafe修改变量\n先获取变量的offset 971行\n然后取出ReflectionFactory里面的Unsafe 972行\n如果是静态变量会直接加载变量的类型 974行\n非静态的话会取出可变参的第一个参数 975行\n然后加载变量的offset 976行\n然后从可变参里面取出第二个参数，判断基本类型拆箱 然后调用Unsafe里面的方法 984-997行\n\n如果变量不是final，会直接用PUT指令 1005-1017行\n然后返回新的变量值 1023-1030行\n\n如果变量是static，会实现无参的invoke方法，默认为获取变量的值 1033-1040行\n\n实例化对象的实现\nprivate static <T> ReflectionAccessor<T> generic(\n  ClassLoader callerLoader,\n  Class<?> clazz)复制代码实例化对象只分配内存，所以不需要传入参数\n所以会相同的实现两个invoke方法\n直接用NEW指令实例化对象然后返回 1090 - 1091行\n因为新实例化的对象，JVM会标记为Uninitialized，不可以直接使用，所以也要继承MagicAccessorImpl来跳过字节码检查\n\n反射构造方法的实现\nprivate static <T> ReflectionAccessor<T> generic(\n  ClassLoader callerLoader,\n  Class<?> clazz,\n  MethodType type)复制代码因为需要调用构造方法，所以只有当构造方法没有参数的时候才会实现无参invoke方法\n默认实现可变参的invoke方法\n同样先用NEW指令实例化对象 1058行\n然后取出可变参里面的参数 1062行\n然后调用构造方法 1063行\n最后加入返回指令返回对象 1070行EnumHelperEnumHelper的实现是用默认的EnumHelper接口作为绑定点，调用动态绑定 897行\n绑定enumHelper的具体的实现会在动态绑定里面说哒动态绑定ReflectionFactory对象有两个非静态变量\n动态绑定实现类的生成器 406行\n动态绑定的目标类 407行\n在构造方法里会把传入的目标类赋值给target变量\n实例化一个ClassWriter，继承MagicAccessorImpl实现传入的绑定点接口，赋值给generator变量\n\n绑定方法\n绑定方法的时候会实给generator添加一个MethodWriter，方法声明和传入的implementation的方法声明一样 434行\n然后在MethodWriter里面添加一个CodeWriter\n把所有参数按顺序入栈 436-445行\n然后根据传入的kind和invocation添加方法调用指令 446行\n最后添加返回指令 447-461行\n因为在动态绑定里参数列表和返回值类型是确定哒，所以不用自动装箱和拆箱\n\n绑定变量\n和绑定方法一样会先添加方法，根据implementation声明 480行\n然后根据变量的类型和修饰符计算出如果要修改变量的话会用到的变量加载指令 485-491行\n绑定为PUT的时候，如果变量是final，会调用Unsafe来修改变量，调用方法和ReflectionAccessor的调用方法相同 496-511行\n如果变量不是final，会直接用PUT指令修改\n会先判断变量如果非静态，会从参数列表加载第一个参数到栈作为被修改的对象 515行\n然后用刚才计算出的加载命令加载参数列表第二个参数作为变量的新值 517行\n然后添加修改指令 518行\n最后空返回 519行\n如果绑定为GET，会直接用GET指令加载变量到栈然后返回 525-532行\n\n实例化对象\n绑定为实例化对象的方法实现和ReflectionAccesor的实例化对象实现相同\n添加方法声明，在方法里用NEW指令实例化对象然后返回 544-547行\n\n绑定构造方法\n绑定构造方法时会先NEW指令实例化对象 560行\n然后参数列表里面的参数按顺序入栈 564-573行\n然后调用构造方法最后返回 575-576行\n\n绑定enum helper\n绑定enum helper的时候，原EnumHelper接口里面带泛型的方法除了实现泛型方法之外会另外实现一个具体类型的方法，所以可以自己在绑定点声明方法的时候把泛型改成具体类型\n\nEnumHelper#construct(String)\n在这个方法里，新枚举实例的name是传入的name，ordinal是已有的枚举列表的数组长度\n用NEW指令实例化一个枚举实例\n用传入的name和数组长度做ordinal，调用Enum#Enum(String, int)构造方法\n\nEnumHelper#construct(String, int)\n这个方**直接用传入的name和ordinal调用Enum的构造方法，实现和上一个方法相同\n\nEnumHelper#values()\n这个方法的实现是直接用GETSTATIC指令取出枚举类里面的枚举列表然后返回\n获取枚举类里面的枚举列表并不是直接用一般的$VALUES变量名，而是在绑定时在从类的所有变量里面查找可能的变量\n这和MC的EnumHelper也许是相同的实现\n\nEnumHelper#values(Object[])\n这个方法是调用Unsafe来更改枚举类里面的枚举实例\n更改变量值之前会清空枚举类的Class实例里面的枚举缓存(赋值为null)\n\nEnumHelper#add(Object)\n这个方法里面会先实例化一个比枚举类里面的枚举列表长度多1的数组，复制之前的枚举列表，然后把传入的枚举项添加到数组最后，然后用Unsafe改掉枚举类里面的数组\n同样也会先清空Class实例里面的枚举缓存\n\nEnumHelper#remove(int)\n这个方法里也是复制数组，不会复制传入的索引项，复制之后改掉枚举类里面的数组其他ReflectionFactory#constant(Object)\nconstant的实现是在实现类里有一个私有不可变的非静态常量，在构造方法赋值 878行 884行\n构造方法的参数是要持有的对象\ninvoke方法的实现是从对象里取出持有的变量然后返回 888-890行\n\nReflectionFactory#throwException()\nthrowException的实现是从可变参里取出第一个变量，然后用ATHROW指令抛出 863-867行\n\nReflectionFactory#UNSAFE\nUnsafe的实现也是动态绑定，在static代码块里绑定Unsafe的方法，不支持的方**抛出异常 1307-1392行\nJVM的版本是在static的开头读取Object.class的类文件头的major version 1231-1236行\n\nReflectionFactory#TRUSTED_LOOKUP\nTRUSTED_LOOKUP是在Lookup类里面的一个静态常量IMPL_LOOKUP，在static里面用反射取出 1254-1282行\n\nReflectionFactory#METHOD_HANDLE_INVOKER\n这个实现是，默认可变参的第一个参数为被调用的MethodHandle，后面的参数是调用MethodHandle传入的参数\n因为MethodHandle#invoke(Object[])方法在编译之后会被改成具体的参数列表和返回值类型，所以用了invokeWithArguments方法\n调用的时候，从可变参取出第一个参数入栈作为MethodHandle\n然后调用Arrays.copyOfRange方法复制可变参数组的后面的元素为一个新的数组返回入栈\n然后调用invokeWithArguments方法最后返回 完整实现 1939-1980行MagicAccessorMagicAccessor#setAccessible(AccessibleObject, boolean)\n这个方法的实现是直接修改AccessibleObject里面的override变量 2021-2024行\n\nMagicAccessor#forName(String)\n这个的实现是先获取调用者方法所在的类的Class，然后取出类的classLoader然后调用Class的forName0方法 2030-2042行\n\nMagicAccessor#forName(String, boolean, ClassLoader)\n这个方法的实现是直接调用Class的forName0方法 2047-2056行\n\nMagicAccessor#defineClass(ClassLoader, byte[])\n这个方法里面是直接调用ClassLoader#defineClass(String, byte[], int, int) 2061-2072行\nname默认是null\n\nMagicAccessor#getCallerClass()\n这个方法里面调用的是SecurityManager#getClassContext()，然后返回数组中索引2的元素 2079-2087行\ngetClassContext返回的是从调用getClassContext方法的方法开始一直到栈顶的所有类的数组\n\nMagicAccessor#getClassContext()\n这个方法的实现是调用SecurityManager#getClassContext从索引1复制数组然后返回 2094-2106行\n\nMagicAccessor#construct(Class)\n实现是获取传入的类的无参构造器Constructor然后调用newInstance方法 2113-2127行\n\nMagicAccessor#construct(Class, Class[], Object[])\n实现是获取传入的类的指定参数列表的构造器Constructor，然后用传入的参数调用newInstance方法 2134-2146行\n\nMagicAccessor#invokeMethodHandle(MethodHandle, Object...)\n实现和ReflectionFactory#METHOD_HANDLE_INVOKER相同，就不再说一遍啦\n\nMagicAccessor#getField(Class, String)\n实现和Class#getDeclaredField(String)的实现相同，但是不是直接调用 2165-2185行\n但是这个实现不会用过滤器，所以可以真正的获取到任何变量\n\nMagicAccessor#getMethod(Class, String, Class[])\n和上一个方法类似，实现和Class#getDeclaredMethod(String, Class[])的实现相同 2191-2224行\n同样也不会用过滤器过滤\n\nMagicAccessor#getConstructor(Class, Class[])\n和Class#getDeclaredConstructor(Class[])的实现相同，不会用过滤器过滤 2231-2284行\n\nMagicAccessor#getFields(Class)\n实现是直接调用native方法Class#getDeclaredFields(boolean)传入false然后返回 2291-2298行\n\nMagicAccessor#getMethods(Class)\n实现是直接调用Class#getDeclaredMethods(boolean)传入false然后返回 2305-2312行\n\nMagicAccessor#getConstructors(Class)\n实现是调用Class#getDeclaredConstructors(boolean)传入false然后返回 2319-2326行\n\nMagicAccessor#throwException(Throwable)\n这个方法是直接用ATHROW指令抛出参数传入的Throwable对象 2333-2336行\n\nMagicAccessor#initialize(Object)\n这个方法是直接调用传入的对象的Object的无参构造 2343-2349行\n\n这里上传一份MagicAccessor的实现类的生成的类文件和反编译源码 ReflectionMagicAccessor\n",
    "replies": []
}