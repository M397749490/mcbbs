{
    "title": "1.14利用data的傳送指令",
    "author": "abel820114",
    "replyCount": 6,
    "timestamp": 1556424960,
    "txt_content": " 本帖最后由 abel820114 于 2019-4-28 21:56 编辑 \n\n版本：1.14\n\n問題：以下原本1.13.2能用的指令哪裡出問題了？具體上應該怎麼修正？\n\n問題描述：\n\n請教一下各位dalao，我在1.13.2用data做了一個傳送的系統，利用召喚AEC、更改AEC的POS到傳送點、再把玩家傳送到AEC\n前陣子更新到1.14就失效了。\n指令是這樣的－－\n\n==================================\n\n1. functionA\n\n偵測左手拿物品A →被加上tagA →以下四條指令儲存\"當下位置\" 到 3個記分板 (x, y, z)  →清除tagA →清除物品A\nexecute as @a[tag=A] store result score @s x run data get entity @s Pos[0]\nexecute as @a[tag=A] store result score @s y run data get entity @s Pos[1]\nexecute as @a[tag=A] run scoreboard players add @s y 1\nexecute as @a[tag=A] store result score @s z run data get entity @s Pos[2]\n2. functionB\n偵測左手拿物品B  →被加上tagB →以下指令 召喚 藥水雲 於位置x, y, z 對應於 tagB者的記分板xyz分數\n\n →傳送tagB者 到 藥水雲位置  →清除tagB →清除物品B\nexecute at @a[nbt] run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:[\"aecPosA\"],NoGravity:1,Invisible:1,Duration:20}\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[0] double 1 run scoreboard players get 玩家名稱 x\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[1] double 1 run scoreboard players get 玩家名稱 y\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[2] double 1 run scoreboard players get 玩家名稱 z\nexecute at @a[nbt] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\n==================================\n以上(nbt恕刪)\n\n更新1.14後的出錯時的狀況是：近處的地點依然能夠傳送，但遠處(沒有被加載的區塊?) 就無法傳送了 (但傳送以外的功能有正常運作)。雖然理論上遠處的實體會因為區塊沒被加載而不能傳送，但不知為何1.13.2還是可以先把AEC傳過去，再把人傳到AEC上。\n然而1.14之後貌似就不行了？，請問應該如何修正？\n\n查了很久，發現1.14貌似有個data modify的功能 (不知道能不能用？)\n從別人的指令中(1.14)，也有一條：execute store result entity @s Pos[0] double 1 run data get entity @s Item.tag.Pos[0] 好像能用？(這條裡面的\"Item.tag.\"這個路徑是從哪裡來的？要去哪裡查看？)\n\n\n指令新手問的問題可能很基礎，望dalao不吝解答或指路\n\n=======\n\n追加描述：\n\n又試了一下，發現原來：\n\n在1.13.2時，AEC在這三條更改的POS的指令後實際上沒有被傳送到遠方儲存的地點。\n但最後的\"execute at @a[nbt] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\" 是會把玩家傳送到遠方的...(命令輸出也顯示:傳送玩家至AEC，即使AEC還留在使用道具時的地點...)\n\n而在1.14 (或是快照)時，AEC在\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[0] double 1 run scoreboard players get 玩家名稱 x\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[1] double 1 run scoreboard players get 玩家名稱 y\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[2] double 1 run scoreboard players get 玩家名稱 z\n後也依然留在原地，而\nexecute at @a[nbt] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\n就無法把玩家傳送到遠處了，但近處卻可以(正常運作)\n\n我對 \"store result entity @e Pos[0] double 1 run scoreboard players get 玩家名稱 x\" 的理解是把@e的Pos[0]替換成從 玩家 的記分板x get到的分數值，好像錯了?(汗\n\n\n",
    "replies": [
        {
            "author": "⊙v⊙",
            "timestamp": 1556424960,
            "txt_content": " 本帖最后由 ⊙v⊙ 于 2019-4-29 00:38 编辑 \n\n我自己试过，也在JIRA上看到过报告\n\n实锤了...是BUG\nhttps://bugs.mojang.com/browse/MC-149334\n如果希望能尽快被修复的话，就进去右边点一下vote吧...\n\n更新...目前有个解决办法，使用@s，虽然说命令优化的时候的确会用到@s，但这BUG的确让人无奈...\n\n这是我测试时用的，传送不到未加载区块的命令\n#run once\n#scoreboard objectives add x dummy\n#scoreboard objectives add y dummy\n#scoreboard objectives add z dummy\n\n#scoreboard players set coord x 1000\n#scoreboard players set coord y 50\n#scoreboard players set coord z 1000\n\n#for 1.13\n#execute if data entity @a {SelectedItemSlot:8} run say trigger\nexecute if entity @a[nbt={SelectedItemSlot:8}] run say trigger\nexecute at @a[nbt={SelectedItemSlot:8}] run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:[\"aec\"]}\nexecute as @e[tag=aec] store result entity @s Pos[0] double 1 run scoreboard players get coord x\nexecute as @e[tag=aec] store result entity @s Pos[1] double 1 run scoreboard players get coord y\nexecute as @e[tag=aec] store result entity @s Pos[2] double 1 run scoreboard players get coord z\nteleport @a[nbt={SelectedItemSlot:8}] @e[tag=aec,limit=1]\nkill @e[tag=aec]复制代码\n\n\n\n问完也是一头雾水的大佬们后的改动如下...\n#run once\n#scoreboard objectives add x dummy\n#scoreboard objectives add y dummy\n#scoreboard objectives add z dummy\n#scoreboard players set coord x 1000\n#scoreboard players set coord y 50\n#scoreboard players set coord z 1000\n\n#for 1.13\n#execute if data entity @a {SelectedItemSlot:8} run say trigger\nexecute if entity @a[nbt={SelectedItemSlot:8}] run say trigger\nexecute at @a[nbt={SelectedItemSlot:8}] run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:[\"aec\"]}\n\nexecute as @e[tag=aec] at @s run function test:0\nkill @e[tag=aec]复制代码\n#test:0\nexecute store result entity @s Pos[0] double 1 run scoreboard players get coord x\nexecute store result entity @s Pos[1] double 1 run scoreboard players get coord y\nexecute store result entity @s Pos[2] double 1 run scoreboard players get coord z\n\nteleport @a[nbt={SelectedItemSlot:8}] @s复制代码\n"
        },
        {
            "author": "⊙v⊙",
            "timestamp": 1556437680,
            "txt_content": " 本帖最后由 ⊙v⊙ 于 2019-4-27 22:01 编辑 \n\n问题略多...\n\n首先是你贴出来的部分命令，一个问题是Tags:[\"aecPosA\"]\n但是，如果不是你实际的命令，且原本是能用的话，就没什么好看的了\n\n另外一个是优化的地方，data get储存分数时可以把分数往上放大，在store时在缩小以保留精度。\n这样也就不用y+1了（y+1有被玩家利用的可能...）\n\n“利用召喚AEC、更改AEC的POS到傳送點、再把玩家傳送到AEC”\n如果是在同一tick下先生成后传送玩家过去的话，\n这个逻辑完全没问题。而且还是标准的做法...\n记得当初1.14还是前一个快照出来时有个部分实体不能被选取的严重BUG。\n\n那么我的对策是...放到最后一个快照版本下测试（非pre），如果没问题的话，估计就是bug了，可能下个版本就修。\n如果最新快照下也有问题的话就真的是哪里出问题了，先打开gameoutput查看是否有error\n不行的话，再来把命令贴过来...\n\n哦对了...data modify的路径\nItem.tag.Pos[0]\nItem是当物品为实体形式时拥有的nbt，tag后面的pos是玩家自己创的路径。\n大概应该就长这样...{Item:{tag:{Pos:[0,1,2]}}}\n\n不过使用这个的话方法或许会更麻烦（除非方法改为丢出物品记录坐标，或记录在一个实体上）\n物品a记录坐标，物品b执行传送对吧？\n那么，原因则会是data modify无法直接修改玩家的背包物品，虽然还是有其他办法可以把坐标储存到手持物上，但对比你现在的方法，麻烦太多...\n"
        },
        {
            "author": "abel820114",
            "timestamp": 1556448720,
            "txt_content": " 本帖最后由 abel820114 于 2019-4-28 19:09 编辑 \n⊙v⊙ 发表于 2019-4-28 15:48\n问题略多...\n\n首先是你贴出来的部分命令，一个问题是Tags:[\"aecPosA\"]\n感謝回覆！\n\n我剛剛試了一下，發現原來：\n\n在1.13.2時，AEC在這三條更改的POS的指令後實際上沒有被傳送到遠方儲存的地點。\n但最後的\"execute at @a[nbt] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\" 是會把玩家傳送到遠方的...(命令輸出也顯示:傳送玩家至AEC，即使AEC還留在使用道具時的地點...)\n\n而在1.14 (或是快照)時，AEC在\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[0] double 1 run scoreboard players get 玩家名稱 x\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[1] double 1 run scoreboard players get 玩家名稱 y\nexecute as @a[nbt] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[2] double 1 run scoreboard players get 玩家名稱 z\n後也依然留在原地，而\nexecute at @a[nbt] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\n就無法把玩家傳送到遠處了，但近處卻可以(正常運作)\n\n我對 \"store result entity @e Pos[0] double 1 run scoreboard players get 玩家名稱 x\" 的理解是把@e的Pos[0]替換成從 玩家 的記分板x get到的分數值，好像錯了?(汗\n\n\n\n順帶一提，以下是原命令#function realmcommands:waystone\nexecute as @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:flint\",tag:{display:{Name:\"{\\\"text\\\":\\\"路標石\\\"}\"}}}]}] run tag @s add waystone\nexecute as @a[tag=waystone] store result score @s x run data get entity @s Pos[0]\nexecute as @a[tag=waystone] store result score @s y run data get entity @s Pos[1]\nexecute as @a[tag=waystone] store result score @s z run data get entity @s Pos[2]\nexecute at @a[tag=waystone] run tellraw @p {\"text\":\"你使用路標石刻下了標記\"}\nexecute at @a[tag=waystone] run particle minecraft:witch ~ ~ ~ 0 0 0 0.1 1000\nexecute at @a[tag=waystone] run playsound minecraft:entity.zombie_villager.cure master @p ~ ~ ~ 0.5 2 0.5\nreplaceitem entity @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:flint\",tag:{display:{Name:\"{\\\"text\\\":\\\"路標石\\\"}\"}}}]}] weapon.offhand air 1\nexecute at @a[tag=waystone] run give @p minecraft:flint{display:{Name:\"{\\\"text\\\":\\\"路標石\\\"}\"}} 1\ntag @a[tag=waystone] remove waystone#function realmcommands:waystone_a\nexecute at @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:[aecPosA],NoGravity:1,Invisible:1,Duration:20}\nexecute as @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[0] double 1 run scoreboard players get 玩家A的ID x\nexecute as @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[1] double 1 run scoreboard players get 玩家A的ID y\nexecute as @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] store result entity @e[type=area_effect_cloud,tag=aecPosA,limit=1] Pos[2] double 1 run scoreboard players get 玩家A的ID z\nexecute at @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] run tp @p @e[type=area_effect_cloud,tag=aecPosA,limit=1]\nexecute at @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] run playsound minecraft:block.portal.travel master @a[distance=..5] ~ ~1 ~ 0.5 1 0.5\nreplaceitem entity @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] weapon.offhand air 1\n"
        },
        {
            "author": "⊙v⊙",
            "timestamp": 1556452260,
            "txt_content": "肉眼是不能分辨出改变过Pos的AEC的(的碰撞箱[F3+B])。因为渲染不更新...(除非重进游戏)\n可以改用AS或让AEC在自己的位置执行particle...\n\n你现在这么一说我才注意到。\nexecute at @a[...] run tp @p @e[...AEC]\n这个execute at是多余的，直接tp @a[...] @e[AEC...]\n\n理解没错..只是想说计分板只记整数，放大获取缩小保存可以在放进Pos时保留当时坐标的小数位。\n\n尽量使用@s，调用function，并理清命令前后逻辑关系可以优化减轻游戏处理的负担，不过问题不大...\n\n如果这个真的是你的命令的话...\nTags:[\"need_double_quote\"]  需要用双引号括着\n玩家A的ID  这个真的能用吗？...还是说这里本来是某些指定玩家的ID?"
        },
        {
            "author": "abel820114",
            "timestamp": 1556455920,
            "txt_content": "⊙v⊙ 发表于 2019-4-28 19:51\n肉眼是不能分辨出改变过Pos的AEC的(的碰撞箱[F3+B])。因为渲染不更新...(除非重进游戏)\n可以改用AS或让AEC ...\n原來渲染不更新會看不見，了解了\n\n我又試了一下，即使是把儲存點紀錄在世界出生點區塊也無法傳送過去，只能傳送到附近有玩家的區塊\n\n>>这个execute at是多余的，直接tp @a[...] @e[AEC...]\nyes! thx\n\n>>Tags:[\"need_double_quote\"]  需要用双引号括着\n啊，好像是，已經修正了(不過之前沒加時，不知道為召喚出來的生物還是有tag上@@)\n\n>>玩家A的ID  这个真的能用吗？...还是说...\n沒錯，就是某玩家的ID\n\n我只是想在小小的伺服器做個傳送卷軸的功能，怎麼這麼難!!!(憤怒)"
        },
        {
            "author": "abel820114",
            "timestamp": 1556547720,
            "txt_content": " 本帖最后由 abel820114 于 2019-4-29 22:34 编辑 \n⊙v⊙ 发表于 2019-4-29 17:39\n我自己试过，也在JIRA上看到过报告\n\n实锤了...是BUG\n原來用@s優化可以這樣做，學習了\n\n我試了一下 以AEC的名義單獨執行一個function來修改目標＋傳送，竟然可以傳到未加載區域了。\n#function realmcommands:waystone_a\nexecute at @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] run summon minecraft:area_effect_cloud ~ ~ ~ {Tags:[\"aecPosA\"],NoGravity:1,Invisible:1,Duration:20}\nexecute as @e[tag=aecPosA] at @s run function realmcommands:waystone_a2\nexecute at @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] run playsound minecraft:block.portal.travel master @a[distance=..7] ~ ~1 ~ 0.3 1 0.1\nreplaceitem entity @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] weapon.offhand air 1#function realmcommands:waystone_a2\nexecute store result entity @s Pos[0] double 1 run scoreboard players get Abel x\nexecute store result entity @s Pos[1] double 1 run scoreboard players get Abel y\nexecute store result entity @s Pos[2] double 1 run scoreboard players get Abel z\ntp @a[nbt={Inventory:[{Slot:-106b,id:\"minecraft:enchanted_book\",tag:{display:{Name:\"{\\\"text\\\":\\\"指路卷軸(A)\\\"}\"}}}]}] @s修好了!!\n非常感謝!!\n命令真好玩!!\n\n"
        }
    ]
}