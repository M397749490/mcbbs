{
    "title": "预设建筑的储存方式",
    "author": "woaiwen1234",
    "replyCount": 1,
    "timestamp": 1584517500,
    "txt_content": "我的想法是在随机位置生成预设模板的建筑物，既然是预设模板，那么用什么方式储存更好，大家有什么思路请告诉我",
    "replies": [
        {
            "author": "roj234",
            "timestamp": 1584522720,
            "txt_content": " 本帖最后由 roj234 于 2020-3-18 17:16 编辑 \n\n推荐用二进制方式，优点速度快，缺点(普通人)没法修改\nu4: unsigned int\nu2: unsigned short\nu1: unsigned byte\nstruct file {\n  u4 magic_number; //可选文件标识，确定这是你的二进制格式\n  u4 width;   // 三个INT长宽高随便啦\n  u4 height;\n  u4 length;\n  plate blockIdMap;\n  blockinfo[width * height * length] info;\n}\nstruct plate {\n  u2 length;\n  block_info[length] datas;\n}\nstruct block_info {\n  u2 id; // 因为是插件所以int就可以如果是mod可以用string\n  u1 meta;\n}\nstruct blockinfo {\n    u2 tableId; // 在plate中的id\n}\n// 你只需要用下面的三个工具类就可以实现读取了\n\npublic final class ByteReader {\n    private byte[] bytes;\n    public int index = 0;\n    public int length;\n    public ByteReader(byte[] bytes) {\n        refresh(bytes);\n    }\n\n    public final void refresh(byte[] bytes) {\n        this.bytes = bytes;\n        this.length = bytes.length;\n    }\n\n    public final byte getByte() {\n        return bytes[index++];\n    }\n\n    public final short getUByte() {\n        return (short)(bytes[index++] & 0xff);\n    }\n\n    public final boolean isFinished() {\n        return index >= bytes.length;\n    }\n\n    public final String getString() {\n        return new String(getBytes(getInt()));\n    }\n\n    public final void getBytes(byte[] array, int start, int length) {\n        if(index + length > bytes.length) {\n            throw new RuntimeException(\"ByteReader: not enough data to process\");\n        }\n        System.arraycopy(bytes, index, array, start, length);\n        index += length;\n    }\n\n    public final byte[] getBytes(int length) {\n        byte[] result = new byte[length];\n        getBytes(result, 0, length);\n        return result;\n    }\n\n    public final byte[] getBytesPlusAnEmpty(int length) {\n        byte[] result = new byte[length + 1];\n        getBytes(result, 0, length);\n        return result;\n    }\n\n    // &0xff将byte值无差异转成int,避免Java自动类型提升后,会保留高位的符号位\n    public final int getIntR() {\n        return (bytes[index++] & 0xff) << 8 | (bytes[index++] & 0xff) | (bytes[index++] & 0xff) << 24 | (bytes[index++] & 0xff) << 16;\n    }\n\n    public final int getInt() {\n        return (bytes[index++] & 0xff) << 24 | (bytes[index++] & 0xff) << 16 | (bytes[index++] & 0xff) << 8 | (bytes[index++] & 0xff);\n    }\n\n    public final long getLongR() {\n        return (long) (bytes[index++] & 0xff) << 24 |\n          (long) (bytes[index++] & 0xff) << 16 |\n          (long) (bytes[index++] & 0xff) << 8  |\n          (long) (bytes[index++] & 0xff) |\n          (long) (bytes[index++] & 0xff) << 56 | \n          (long) (bytes[index++] & 0xff) << 48 |\n          (long) (bytes[index++] & 0xff) << 40 |\n          (long) (bytes[index++] & 0xff) << 32;\n\n    }\n\n    public final long getLong() {\n        return (long) (bytes[index++] & 0xff) << 56 | \n          (long) (bytes[index++] & 0xff) << 48 |\n          (long) (bytes[index++] & 0xff) << 40 |\n          (long) (bytes[index++] & 0xff) << 32 |\n          (long) (bytes[index++] & 0xff) << 24 |\n          (long) (bytes[index++] & 0xff) << 16 |\n          (long) (bytes[index++] & 0xff) << 8  |\n          (long) (bytes[index++] & 0xff);\n\n    }\n\n    public final float getFloat() {\n        return Float.intBitsToFloat(getInt());\n    }\n\n    public final double getDouble() {\n        return Double.longBitsToDouble(getLong());\n    }\n\n    public final int getUShort() {\n        return (bytes[index++] & 0xff) << 8 | (bytes[index++] & 0xff);\n    }\n\n    public final int getUShortR() {\n        return (bytes[index++] & 0xff) | (bytes[index++] & 0xff) << 8;\n    }\n\n    public final short getShort() {\n        return (short)((bytes[index++] & 0xff) << 8 | (bytes[index++] & 0xff));\n    }\n\n    public static boolean isBitTrue(int i, int bit) {\n        return bit == 0 ? ((i & 1) == 1) : ((i & (1 << bit)) >> bit) == 1;\n    }\n\n    public static int getSpecifyBit(int n, int fromInclude, int toInclude) {\n        int k = 0;\n        for(int i = fromInclude; i <= toInclude; i++) {\n            k |= (1 << i);\n        }\n        return (n & k) >>> fromInclude;\n    }\n}\n\n\n///////////////////////////////////////////////////////////////////////////////\n\npublic class ByteWriter {\n    public final ByteList list;\n    public ByteWriter() {\n        list = new ByteList();\n    }\n\n    public ByteWriter(int len) {\n        list = new ByteList(len);\n    }\n\n    public ByteWriter writeByte(short b) {\n        list.add((byte)b);\n        return this;\n    }\n\n    public ByteWriter writeString(String s) {\n        byte[] b;\n        writeInt((b = s.getBytes()).length);\n        writeBytes(b);\n        return this;\n    }\n\n    public ByteWriter writeBytes(byte[] bs) {\n        if(list.id + bs.length >= list.length) {\n            byte[] newArr = new byte[list.id + bs.length + 512];\n            System.arraycopy(list.list, 0, newArr, 0, list.id);\n            list.list = newArr;\n            list.length = newArr.length;\n        }\n        System.arraycopy(bs, 0, list.list, list.id, bs.length);\n        list.id += bs.length;\n        return this;\n    }\n\n    public ByteWriter writeIntR(int i) {\n        list.add((byte)(i >>> 8));\n        list.add((byte)(i));\n        list.add((byte)(i >>> 24));\n        list.add((byte)(i >>> 16));\n        return this;\n    }\n\n    public ByteWriter writeInt(int i) {\n        list.add((byte)(i >>> 24));\n        list.add((byte)(i >>> 16));\n        list.add((byte)(i >>> 8 ));\n        list.add((byte)(i));\n        return this;\n    }\n\n    public ByteWriter writeLong(long l) {\n        list.add((byte)(l >>> 56));\n        list.add((byte)(l >>> 48));\n        list.add((byte)(l >>> 40));\n        list.add((byte)(l >>> 32));\n        list.add((byte)(l >>> 24));\n        list.add((byte)(l >>> 16));\n        list.add((byte)(l >>> 8 ));\n        list.add((byte)(l));\n        return this;\n    }\n\n    public ByteWriter writeFloat(float f) {\n        writeInt(Float.floatToIntBits(f));\n        return this;\n    }\n\n    public ByteWriter writeDouble(double d) {\n        writeLong(Double.doubleToLongBits(d));\n        return this;\n    }\n\n    public ByteWriter writeShort(int s) {\n        list.add((byte)(s >>> 8));\n        list.add((byte)(s));\n        return this;\n    }\n\n    public ByteWriter writeShortR(int s) {\n        list.add((byte)(s));\n        list.add((byte)(s >>> 8));\n        return this;\n    }\n\n    public byte[] toByteArray() {\n        return list.toByteArray();\n    }\n\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\npublic class ByteList {\n    public byte[] list;\n    protected int id = 0;\n    protected int length;\n\n    public ByteList() {\n        this(1024);\n    }\n\n    public ByteList(int len) {\n        list = new byte[len];\n        length = len;\n    }\n\n    public int size() {\n        return id;\n    }\n\n    public int add(byte e) {\n        list[id++] = e; // [1,1,1,2]\n        if(id >= length){\n            byte[] newList = new byte[length+128];\n            System.arraycopy(list,0,newList ,0,length);\n            list = newList;\n            length += 128;\n        }\n        return id-1; //[3]\n    }\n\n    public void set(int index, byte e) {\n        list[index] = e;\n    }\n\n    public boolean remove(int index){\n        if(index >= 0){\n            for(int i=index;i<list.length-1;i++){\n                list = list[i+1];\n            }\n            list = Arrays.copyOf(list, list.length-1);\n            return true;\n        }\n        return false;\n    }\n\n    public byte get(int _id){\n        if(_id >= length) // 3 < 4\n            return 0;\n        return list[_id]; // 2\n    }\n\n    public byte[] toByteArray() {\n        byte[] result = new byte[size()];\n        System.arraycopy(list, 0, result , 0, result.length);\n        return result;\n    }\n\n    public void clear() {\n        id = 0;\n    }\n}\n\n"
        }
    ]
}