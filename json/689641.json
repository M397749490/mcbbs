{
    "title": "匿名类的坑爹之处",
    "author": "pedroj",
    "replyCount": 31,
    "timestamp": 1493560560,
    "txt_content": "interface Inter\n{\n        void method();\n}\n\nclass Test\n{\n        static Inter function()//为什么这个接口名Inter可以作为类名使用\n        {\n                return new Inter()\n                {\n                        public void method()\n                        {\n                                System.out.println(\"method show run\");\n                        }\n                };\n        }\n}\n\nclass demo\n{\n        public static void main(String[] args)\n        {\n                Test.function().method();\n        }\n}\n\n",
    "replies": [
        {
            "author": "zghh008",
            "timestamp": 1493581980,
            "txt_content": "匿名类实现了这个接口，当然能用。"
        },
        {
            "author": "pedroj",
            "timestamp": 1493599020,
            "txt_content": "zghh008 发表于 2017-5-1 03:53\n匿名类实现了这个接口，当然能用。\n好吧**了发这种东西出来"
        },
        {
            "author": "1245892483",
            "timestamp": 1493702340,
            "txt_content": "恕在下直言，表示看不懂这串代码。"
        },
        {
            "author": "Yaossg",
            "timestamp": 1493704320,
            "txt_content": "它哪里当作类名来用啊？你理解的不够透彻好吗"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1493829000,
            "txt_content": "姚氏帅哥 发表于 2017-5-2 13:52\n它哪里当作类名来用啊？你理解的不够透彻好吗\n…话有些太狠了\n\n匿名类其实更多是用在写UI时临时写个类似于侦听器的玩意来处理界面事件…比方说swing包里JButton被点啦,Android里需要临时画个Activity做信息框啦…"
        },
        {
            "author": "Yaossg",
            "timestamp": 1493853480,
            "txt_content": "langyo_v3 发表于 2017-5-4 00:30\n…话有些太狠了\n\n匿名类其实更多是用在写UI时临时写个类似于侦听器的玩意来处理界面事件…比方说swing包 ...\n我又没有说错，Java中几乎不能直接控制“对象”，都是掌握“对象引用”\n而楼主却说Inter是类名？这实在是没有理解Java透彻的表现啊"
        },
        {
            "author": "zghh008",
            "timestamp": 1494002460,
            "txt_content": "不是很懂楼上的姚氏帅哥在说什么。。。。在其他场合不甚有用的类可以写在指定类中，作为内部类。匿名类提供灵活的处理，比如lz在上面举的梨子。此外在java8以上的环境中可以用lambda表达式节省书写匿名类的时间，具体可以百度"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494030840,
            "txt_content": " 本帖最后由 姚氏帅哥 于 2017-5-6 15:27 编辑 \nzghh008 发表于 2017-5-6 00:41\n不是很懂楼上的姚氏帅哥在说什么。。。。在其他场合不甚有用的类可以写在指定类中，作为内部类。匿名类提供 ...\n显然接口并不是像楼主说的那样作为类名使用\n而是作为接口来使用，接口里定义了method方法，但是没有实现它\n因为他只是一个接口，就好像电灯开关不会实现电灯的功能一样←这个比喻不恰当\n那个new返回一个对象的引用，就是那个匿名类的对象的引用\n此外我发现楼主用了function这说明他认为他写的是“函数”\n虽然本质上是，但是在Java中没有函数只有方法\n可见极有可能是受了c++的影响才认为Inter是当作类名来使用\nJava中的的确确不操作对象而是操作对象引用\n说白了Java就是把对象的地址传来传去，而不是把对象传来传去\n所以你明白我说的吗？\n\n顺便再叫个人来@langyo_v3"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494045300,
            "txt_content": "姚氏帅哥 发表于 2017-5-6 08:34\n显然接口并不是像楼主说的那样作为类名使用\n而是作为接口来使用，接口里定义了method方法，但是没有实现 ...\n嗯……你为啥要使劲强调java不传递对象而是传递对象地址？\n1. 如果是码代码的时候，java里根本就没有对象地址这个概念。像java这样完全面向对象的语言，根本就没有地址这个概念啊，就是对对象的操作，操作的就是对象……所以不应该强调\"地址\"(等等好像比c++高级的语言都没有地址这个概念的样子……)\n2. 如果是运行的时候，绝大多数语言(包括java c++)写的程序在运行时，底层实现都不会传递对象，只会传递对象引用或对象拷贝(所谓\"传值\"的实际实现方式)的地址……所以在运行时，底层传递的都是地址，根本无需而是对象地址强调不是对象\n\n你那个比喻不恰当啊，接口的话，应该是电灯概念模型不会实现电灯功能才对啊……\n还有，受javascript影响的也会写function啊……\n另外，我觉得硬要说的话那个Inner是作为一个标识符使用的，标识匿名类所实现的接口……不过这样说的话，作为接口名似乎也行，不过得强调是匿名类实现的接口"
        },
        {
            "author": "zghh008",
            "timestamp": 1494049440,
            "txt_content": "姚氏帅哥 发表于 2017-5-6 08:34\n显然接口并不是像楼主说的那样作为类名使用\n而是作为接口来使用，接口里定义了method方法，但是没有实现 ...\n方法函数只是叫法差异，本身没什么区别。\n对基本类型java传递值参，对对象则传递址参，我想没有一种oop语言会传递整个对象，这个无须解释\n感觉你们说的不是一个东西，楼主已经明白了自己一开始犯的问题\n他只是在解释匿名类的作用，但是你只顾着批评他一开始的错\n你的说法是没问题的，但是举的例子让人觉得很不舒服和不科学\n电灯开关/电灯与接口/匿名类没有任何相似点\n开关和电灯有不同用途，是两个不同的组件，而在这里匿名类是对接口的实现,我不能说电灯实现了开关"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494055560,
            "txt_content": "言灵乀Poison 发表于 2017-5-6 12:35\n嗯……你为啥要使劲强调java不传递对象而是传递对象地址？\n1. 如果是码代码的时候，java里根本就没有对象 ...\n我不是在强调地址，而是在强调引用\n电灯的例子只是帮助理解，确实是有误，当时没想这么多\n还有你说java完全面向对象？？？基本类型是什么东西？？？\n还有Java从头至尾传输值，从未传输过引用，对象引用也是按值传输\n另外什么叫做“比C++高级的语言”？C++就是高级语言\n比高等数学还高(nan)等(dong)的高级语言"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494064680,
            "txt_content": " 本帖最后由 言灵乀Poison 于 2017-5-6 18:12 编辑 \n姚氏帅哥 发表于 2017-5-6 15:26\n我不是在强调地址，而是在强调引用\n电灯的例子只是帮助理解，确实是有误，当时没想这么多\n还有你说java完 ...\nC++……我偏向三层分类，不是只有高低两层，汇编低级，C中级，C++虽然有高级语言特性，但是同时C++也要考虑不同机器的int/long/pointer类型可能有不同的字节长度，或者说由于语言本身的设计，在没有从底层操纵系统的代码的时候，程序的源码需要依赖硬件，所以我偏向认为它算介于高级与中级之间的中高级语言……\n\n基本类型嘛…好吧我错了，那我换一种说法，离开\"类\"就写不了程序的语言\n\n\n非要说值传递的话只有基本类型是值传递。其它所有的传递都是对象(用C的说法可以叫对象的const指针)。对象引用的话…虽然有这个说法但我觉得在你的语境里用指针这个词还合适一点，Java把某个变量引用一个对象看做是\"对象引用\"，那对象引用就不可能传递啊，没可能方法里还能改变caller的某个变量的引用，这时候再谈有没有传递真的有问题好吗\n那我们换成对象指针\n从Java来看，对对象的操作会作用到原对象，那就不可能是值传递，因为值传递的实质是传递拷贝，所以值传递的话对对象的操作都不会影响原对象(无视浅拷贝问题)，所以传递过去的就是那个对象(如果换成C的说法，传递的是对象指针，并且是const指针)"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494070500,
            "txt_content": "言灵乀Poison 发表于 2017-5-6 17:58\nC++……我偏向三层分类，不是只有高低两层，汇编低级，C中级，C++虽然有高级语言特性，但是同时C++也要考 ...\n前半部分完全认同\n后半部分开始乱了\n我希望说明：对象引用就是平时Java中使用的这样的东西\nString s = \"hello\";\n//一般我说s是一个对象\n//但是准确的说，是一个对象的引用\n复制代码\ns本身只不过是一个整数，储存一个地址而已\n[对象引用（栈）]------->[对象（堆）]\n你说的“const指针”指的是 T const *还是 T * const呢\n其实事实非常明显，对象引用不是上面的任何一种\n因为你既可以对引用本身进行修改，同时也可以对引用的对象进行修改\n\n看这段代码\nclass A{\npublic static void swap(Object a,Object b)\n{Object t = a;\na = b;\nb = t;\n}\npublic static void main()\n{\nInteger a = 5,b = 6;\nA.swap(a,b);//会起作用吗？\n}\n}复制代码\n显然不会，因为他仅仅只是把一个对象引用传递给了swap\n对象引用就是指针，指针就是整数，传输引用就是传递整数\n或者说，仅仅是对象被引用，但引用本身是不能被引用的\n而在Java中，只有基本类型和对象引用可以传递\n综上，Java从始至终都在传递值\n\n观众席位@langyo_v3"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494081180,
            "txt_content": " 本帖最后由 言灵乀Poison 于 2017-5-6 23:06 编辑 \n姚氏帅哥 发表于 2017-5-6 19:35\n前半部分完全认同\n后半部分开始乱了\n我希望说明：对象引用就是平时Java中使用的这样的东西\n我指的是\nT const *\n比如\nint a = 5;\nint b = 6;\nint const * p = &a;\n我可以p = &b，但不能*p = b\n反映到Java上，就是\np = &b,，就像你swap里面对变量的重新赋值，是可行的\n*p = b，就像是期望真的能修改main里的a变量的值，是不可行的\n\n当然还是有区别的，C是直接编译错误\nJava像你的代码那样做就是当前作用域有效但实际上并不会影响到调用者作用域的变量……\n不过这是C里面我能找到的最接近的概念了\n\n\n"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494085080,
            "txt_content": "言灵乀Poison 发表于 2017-5-6 22:33\n我指的是\nT const *\n比如p = &b,，就像你swap里面对变量的重新赋值，是可行的\n*p = b，就像是期望真的能修改main里的a变量的值，是不可行的\n越来越弄不明白你在说什么\np是可以被修改的\n就像这样：\nObject a = new Object();\na = new Object();复制代码\n*p也是可以被修改的\n就像这样：\nMyClass{\npublic int a;\n}\nMyClass A;\nA.a = 5;复制代码\n至于你说的\n*p= b 不行是因为调用函数时执行：\np2 = p1;\np1[main函数对象引用]----->obj[对象]<-----p2[swap函数对象引用]\n所以说*p2不是main函数里的引用而是对象！！！\n当\np2 = new Object();\n时\np1[main函数对象引用]----->obj[对象]\np2[swap函数对象引用]----->obj2[另外一个对象]\n对象引用就是指针，指针就是整数，传输引用就是传递整数\n而在Java中，只有基本类型和对象引用可以传递\n综上，Java从始至终都在传递值\n你还没看懂吗？Java将对象引用，也就是对象的地址拷贝一份到方法中\n我不打算再白费口舌了，直接上名书\n有些程序员认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的\n——Core Java Volume I(第九版)\n缘由就如同我反复强调的那样，拷贝对象地址，不是传输对象引用的引用！"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1494086580,
            "txt_content": "姚氏帅哥 发表于 2017-5-6 23:38\n越来越弄不明白你在说什么\np是可以被修改的\n就像这样：\n需要Java7虚拟机标准的pdf吗?"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494124140,
            "txt_content": " 本帖最后由 言灵乀Poison 于 2017-5-7 11:15 编辑 \n\n你那样当然能修改对象的内容，但前提是那个类提供了修改的门路，如果我是private呢，你还要反射修改吗？你那只不过是Field access，并非修改\"整个对象\"\n我指的修改，是C那样的，只要类型一致就能任意修改，而且修改的是\"整个对象\"，如果用Java的方式，就是\"在不覆写hashCode的情况下，改变hashCode的返回值\"，或者\"用==判断结果为false\"，这样才算是修改了\"整个对象\"\n\n*p确实不是引用，但也不能相当于Java中的对象，*p看做是一块内存更合适一点，有类型的内存，虽然不够准确，但更容易理解\n\n另外，我很认同JVM里传递的就是地址的拷贝，但我只是想说，Java本身是没有地址这个概念的，而JVM也不是只有Java编译的程序才能运行，所以我不认同在Java里谈论地址和指针这个概念，也因此我前面一直有加\"从C的角度说\"\n还有我从来没说过Java是传递对象引用，我前面已经说过了，不可能传递引用。\n因此，在Java本身并没有地址这个概念的时候，应该说传递的是对象，这就是我的观点。我们谈的毕竟是Java不是JVM，而且JVM已经不是Java的专属运行时了。\n\n根据《Java语言规范：基于Java8》\nWhen the method or constructor is invoked (§15.12), the values of the actual\nargument expressions initialize newly created parameter variables, each of the\ndeclared type, before execution of the body of the method or constructor.\n也就是说，方法调用时，用实参初始化形参。\n也就是说\n\nClass A {\n    static void swap(Object sa, Object sb) { sa = sb; }\n    public static void main() {\n        Integer a = 5, b = 6;\n        swap(a, b);\n    }\n}\n复制代码\n按照Java语言规范，这里对swap方法的调用相当于\nsa = [Integer(5)这个对象]\nsb = [Integer(6)这个对象]\nsa = sb\n所以，Java传递的是对象，成立\n\n而JVM传递的是什么，这点我们的观点一直是一致的"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494124380,
            "txt_content": "langyo_v3 发表于 2017-5-7 00:03\n需要Java7虚拟机标准的pdf吗?\nJava7虚拟机标准除了类型推导验证的过程没看以外，其它我已经看过两遍了。\n另外，我认为在谈论Java的时候，应该看官方的《Java语言规范:基于Java SE X》(X为大版本)。\n而如果你去看JVM规范，那谈论的到底是Java还是Scala还是其它在JVM上运行的语言？"
        },
        {
            "author": "zghh008",
            "timestamp": 1494594060,
            "txt_content": "姚氏帅哥 发表于 2017-5-6 19:35\n前半部分完全认同\n后半部分开始乱了\n我希望说明：对象引用就是平时Java中使用的这样的东西\n你说的有一定道理，不过值得注意的是java里并不能操纵指针,而是称为引用，这是为了安全考虑。调用方法的时候，传递的是一个新的引用拷贝，新引用在初始状态下指向调用方法时输入的参数所指向的对象内存。所以这里可以说是传递了一个“拷贝的指向对象的引用”.\n\n而我想引用不大可能是一个基本类型，甚至c++中的指针也不大可能是，因为指针除引用一个地址之外，还会记载所指向内存（因为c++中指针可以指向基本类型,所以这里不称为对象）的类型,知道的类型占用字节数，更好地配合指针算法\n\n你也不能说指针存的地址就是一个整数,有整数的所有性质，引用c++ primer plus的一句话，整数相乘有意义，指针相乘没有任何意义,他们还是有一定区别的\n\n所以，你说java始终在传递值我还是不太认同的.如果真如你所说，也无需传址（引用传递）这个名词了"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494595260,
            "txt_content": "言灵乀Poison 发表于 2017-5-7 10:29\n你那样当然能修改对象的内容，但前提是那个类提供了修改的门路，如果我是private呢，你还要反射修改吗？你 ...\n理解是一回事(理解java语言本身\n实现又是另一回事(实现JVM\n所以你说得对。。\n不过与此同时另外一个人貌似也加入了讨论，我去回复他了"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494595620,
            "txt_content": "zghh008 发表于 2017-5-12 21:01\n你说的有一定道理，不过值得注意的是java里并不能操纵指针,而是称为引用，这是为了安全考虑。调用方法的 ...\n参见十八楼\n你说的传输地址，地址不是值吗？\n地址的确不能乘，难道能乘的就是值？\n理解是一回事，实现又是一回事\n我说的本质上，是在讲java，或者准确一点JVM是怎样实现的\n理解它和它的本质是不一样的。\n你可以这么理解，但一定不能忘了本质"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494595800,
            "txt_content": "言灵乀Poison 发表于 2017-5-7 10:33\nJava7虚拟机标准除了类型推导验证的过程没看以外，其它我已经看过两遍了。\n另外，我认为在谈论Java的时候 ...\n他只不过在问我需不需要。。。他应当是看过的\n话说看这东西好玩吗，好玩的话我也要看XD\n\n(下面这句话不是给你看的\n@langyo_v3 你看下21和22楼"
        },
        {
            "author": "zghh008",
            "timestamp": 1494596820,
            "txt_content": "姚氏帅哥 发表于 2017-5-12 21:27\n参见十八楼\n你说的传输地址，地址不是值吗？\n地址的确不能乘，难道能乘的就是值？\n不管怎么说，他传递的毕竟不仅仅是一个整数，还有一系列确定这个引用的东西。"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494596940,
            "txt_content": "zghh008 发表于 2017-5-12 21:47\n不管怎么说，他传递的毕竟不仅仅是一个整数，还有一系列确定这个引用的东西。 ...\n一系列？你告诉我一个地址是一系列？"
        },
        {
            "author": "zghh008",
            "timestamp": 1494597240,
            "txt_content": "姚氏帅哥 发表于 2017-5-12 21:49\n一系列？你告诉我一个地址是一系列？\n不仅有引用，还要确定这个引用适用于什么对象。"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1494601500,
            "txt_content": " 本帖最后由 言灵乀Poison 于 2017-5-12 23:51 编辑 \nzghh008 发表于 2017-5-12 21:54\n不仅有引用，还要确定这个引用适用于什么对象。\n\"适用于什么对象\"这个词…\n\n如果你是指的这个引用(地址/指针…什么都好)所指向的对象，那这个引用的值(也就是地址)本身就能找到对象所在的内存。这个\"还\"，很奇怪啊，是想说什么呢\n\n如果你是指的\"对象类型(Class)\"，那JVM是没有传递的。在JVM中，对象的内存结构是8字节头部(32位/64位开启指针压缩)+对象实际数据，其中8字节头部的前四个字节指向自身所对应的Class对象，5-8字节是Mark Word(存放比如是否加锁，GC标志什么的)。\n既然对象中已经包含，或者说特意加入了自身类型的指针，那么传递引用(地址/指针…什么都好) 的时候附带上类型是没必要也没意义的\n\n如果你是谈与JVM无关的纯Java理论的话，那…Java传递的是对象而不是引用"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494631140,
            "txt_content": "zghh008 发表于 2017-5-12 21:54\n不仅有引用，还要确定这个引用适用于什么对象。\n昨天那个you wim是我手滑了\n一觉醒来本来想要反驳的\n但是27楼写的太好所以我懒得写了\n其实你想一下所有对象引用都可以传给Object\n那请问他“保存”的“适用于什么对象”在哪里？\n(object适用于所有对象不是吗)"
        },
        {
            "author": "Java_command",
            "timestamp": 1494631800,
            "txt_content": "匿名类是什么XD，你说的是Inner Class吧？\n这就是直接创建一个接口/抽象类的子类。\n编译出来是这样的：\na.class（原文件）\na$1.class （InnerClass）\n这种情况在某些地方非常普遍，比如：\nRunnable runnable = new Runnable(){\n   @Override\n   public void run() {\n        //random code XD\n   }\n}复制代码\n大多数是用来创建线程的，比如说fx的按钮：\nbutton.setOnAction(new EventHandler<ActionEvent>() {\n    @override public void handle(ActionEvent e) {\n        //random code\n    }\n});\n因为一个按钮的onaction只有这一个按钮需要使用，所以并不需要单独创建新的类。\n相反，如果说多个按钮共用一个Onaction，就可以单独拿出来一个类\nclass Handler extends EventHandler<ActionEvent>{\n    @Override\n    public void handle(ActionEvent e){\n        //random code\n    }\n}复制代码"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1495160220,
            "txt_content": "匿名类，听着挺6，其实和那些奇形怪状的内部类，静态类，还有**类一样，我个人理解，只要用class修饰了，那他就是普通的类，所谓匿名、内部、静态仅仅是这个类的状态、加载顺序、对外可见性和访问权限发生了变化。\n由此引申出去的接口、抽象类也是如此，他们都是普普通通的class文件，只不过是在自己所在的集成体系里起到一些小作用而已。\nJava是人创造的，不是神。只要按照创造者的思路去想，就不觉得难了。\n楼主可能会问为什么编程语言这么多看起来很高大上、很难懂的词汇？借用我的导师的一句话：\n不把你整蒙了，编程语言怎么推广？当成大白菜吗？\n另外看楼主这function，经常写js吧"
        },
        {
            "author": "zghh008",
            "timestamp": 1495261620,
            "txt_content": "姚氏帅哥 发表于 2017-5-13 07:19\n昨天那个you wim是我手滑了\n一觉醒来本来想要反驳的\n但是27楼写的太好所以我懒得写了\n27楼dalao私下和我解释过了，现在已经弄懂.抱歉的是前面说的也有错误，我不知道c++是支持传对象也支持传地址的，误以为OOP语言都是传址，然后我建议你和dalao新开个贴讨论，这个地方可以完结了。"
        },
        {
            "author": "Yaossg",
            "timestamp": 1495262760,
            "txt_content": "zghh008 发表于 2017-5-20 14:27\n27楼dalao私下和我解释过了，现在已经弄懂.抱歉的是前面说的也有错误，我不知道c++是支持传对象也支持传 ...\n我们早就讨论完惹，达成了一致\nC++的传引用是真正的引用哦~"
        }
    ]
}