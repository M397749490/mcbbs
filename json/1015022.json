{
    "title": "Bukkit插件开发--使用PlaceHolderAPI",
    "author": "William_Shi",
    "replyCount": 0,
    "timestamp": 1586583060,
    "txt_content": " 本帖最后由 William_Shi 于 2020-5-5 21:05 编辑 \n\n我本在MCBBS编程开发区写了这个教程但是MCBBS的插入代码功能出了很多问题现在我在这里再写一遍吧最近更新于2020.5.5 在折叠的一条回复中得知PAPI已经在周日（5.3）更新至2.10.6\n在七空幻音的相同教程https://www.acgxt.com/468.html也是我本人所写\n近期看到有一些MCBBS坛友在询问PlaceHolderAPI的使用方法\n包括如何注册PAPI变量和使用PAPI变量\n的确，网上的一些教程已经过时\n现在我根据 https://github.com/PlaceholderAPI/PlaceholderAPI/wiki也即PlaceHolderAPI官方文档写一篇教程\n\n\n\n\n零：添加前置\n先按这个网站的方法，把PAPI作为前置插件\nhttps://github.com/PlaceholderAPI/PlaceholderAPI/wiki/Hook-into-PlaceholderAPI#adding-placeholders-to-placeholderapi比如说Maven，那就在POM.xml里面加上<repositories>\n <repository>\n    <id>placeholderapi</id>\n    <url>https://repo.extendedclip.com/content/repositories/placeholderapi/</url>\n</repository>\n    </repositories>\n    <dependencies>\n        <dependency>\n         <groupId>me.clip</groupId>\n          <artifactId>placeholderapi</artifactId>\n          <version>{VERSION}</version>\n         <scope>provided</scope>\n        </dependency>\n    </dependencies>复制代码\n其中{version}替换成自己使用的版本（目前的最新版是2.10.6）--2020.5.5修订\n如果不使用maven而是普通javaproject，你可以按照导入自己bukkit核心的方法导入抑或是gradle，那就在gradle.build里面加上\nrepositories {\n    maven {\n        url = 'https://repo.extendedclip.com/content/repositories/placeholderapi/'\n    }\n}dependencies {\n    compileOnly 'me.clip:placeholderapi:{VERSION}'\n}复制代码\n如何添加dependency不再多做说明了\n接下来就是在plugin.yml当中添加依赖\n比如说depend: [PlaceholderAPI]\n此处中括号在YAML里面表示的是列表，你也可以depend: [xxxxxx, PlaceholderAPI]\n来为自己的插件添加多个依赖（扯远了）如果你的插件必须有它作为前置就使用前者如果是可有可无的就使用软依赖\n注意Placeholder不是PlaceHolder，大小写区分开\n\n\n\n一、插件内使用PAPI变量\n先看原文：To use placeholders from other plugins in our own plugin, we simply have to use the setPlaceholders method.public void onEnable() { \n    if (Bukkit.getPluginManager().getPlugin(\"PlaceholderAPI\") != null) {\n         /*\n          * We register the EventListeneres here, when PlaceholderAPI is installed.             \n          * Since all events are in the main class (this class), we simply use \"this\"\n          * 说的是在主类注册的事件监听，因此使用了this\n          * 如何注册事件监听不做讲解\n          */\n         Bukkit.getPluginManager().registerEvents(this, this);\n     } else {            \n         /*\n          * 如果没有找到papi这个插件就直接报错\n          */\n         throw new RuntimeException(\"Could not find PlaceholderAPI!! Plugin can not work without it!\");\n     }\n}    \n   \n@EventHandler(priority = EventPriority.HIGHEST)    \npublic void onJoin(PlayerJoinEvent event) {        \n    String joinText = \"%player_name% &ajoined the server! He/she is rank &f%vault_rank%\";        \n    // We parse the placeholders using \"setPlaceholders\"\n    // 使用setPlaceholders方法\n    joinText = PlaceholderAPI.setPlaceholders(event.getPlayer(), joinText);\n    event.setJoinMessage(withPlaceholdersSet);\n}复制代码\n接下来仔细研究一下这一段代码\n说的是你已经有了一段字符串，并且其中已经有PlaceHolder\n比如 “你好，我是%player_name%”\n那么此时就使用setPlaceholders方法，把%player_name%换成玩家的名字\n至于哪一些placeholder能被替换就取决于服务器有没有安装对应的papi扩展\n这里不一定非要传入Player对象，同样也可以使用OfflinePlayer对象\n\n\n\n\n二、插件内注册PAPI变量需要在插件中使用一个独立的类来注册papi变量\n看原文的实例\n这段实例注册的是%someplugin_placeholder1%和%someplugin_placeholder2%请注意！2.10.4版本及以后的PAPI已经不再支持旧的EZPlaceholderHook！/**\n * This class will be registered through the register-method in the plugins\n * onEnable-method.\n */\npublic class SomeExpansion extends PlaceholderExpansion {\n\n    private Test plugin;\n\n    /**\n     * Since we register the expansion inside our own plugin, we can simply use\n     * this method here to get an instance of our plugin.\n     *\n     * @param plugin The instance of our plugin.\n     */\n    public SomeExpansion(Test plugin) {\n        this.plugin = plugin;\n    }\n\n    /*\n         *上面是使用构造函数传入插件主类实例\n         *主类实例的传入方法很多\n         *这里不多作讲解了\n     */\n    /**\n     * Because this is an internal class, you must override this method to let\n     * PlaceholderAPI know to not unregister your expansion class when\n     * PlaceholderAPI is reloaded\n     *\n         * 这里指是不是要让papi扩展持久化\n         * 不持久化则使用reload指令之后你的变量就没了\n         *\n     * [url=home.php?mod=space&uid=491268]@Return[/url] true to persist through reloads\n     */\n    @Override\n    public boolean persist() {\n        return true;\n    }\n\n    /**\n     * Because this is a internal class, this check is not needed and we can\n     * simply return {[url=home.php?mod=space&uid=28815]@code[/url] true}\n     *\n         * 不用管这个，直接return true就可以了\n         *\n     * @return Always true since it's an internal class.\n     */\n    @Override\n    public boolean canRegister() {\n        return true;\n    }\n\n    /**\n     * The name of the person who created this expansion should go here.\n     * <br>For convienience do we return the author from the plugin.yml\n     *\n         * papi扩展的作者，这里使用的是插件的作者\n         *\n     * @return The name of the author as a String.\n     */\n    @Override\n    public String getAuthor() {\n        return plugin.getDescription().getAuthors().toString();\n    }\n\n    /**\n     * The placeholder identifier should go here.\n     * <br>This is what tells PlaceholderAPI to call our onRequest method to\n     * obtain a value if a placeholder starts with our identifier.\n     * <br>This must be unique and can not contain % or _\n     *\n         * 对于%someplugin_placeholder1%，这里需要返回someplugin\n         *\n     * @return The identifier in {@code %<identifier>_<value>%} as String.\n     */\n    @Override\n    public String getIdentifier() {\n        return \"someplugin\";\n    }\n\n    /**\n     * This is the version of the expansion.\n     * <br>You don't have to use numbers, since it is set as a String.\n     *\n     * For convienience do we return the version from the plugin.yml\n     *\n         * papi扩展的版本，和plugin.yml当中版本的版本号规范是一样的\n         * 这边方便一点使用插件作者\n         * \n     * @return The version as a String.\n     */\n    @Override\n    public String getVersion() {\n        return plugin.getDescription().getVersion();\n    }\n\n    /**\n     * This is the method called when a placeholder with our identifier is found\n     * and needs a value.\n     * <br>We specify the value identifier in this method.\n     * <br>Since version 2.9.1 can you use OfflinePlayers in your requests.\n     *\n         * 真正实现papi变量返回值的地方\n         * \n     * @param player A {[url=home.php?mod=space&uid=41191]@link[/url] org.bukkit.Player Player}.\n     * @param identifier A String containing the identifier/value.\n     *\n     * @return possibly-null String of the requested identifier.\n     */\n    @Override\n    public String onPlaceholderRequest(Player player, String identifier) {\n        \n        if (player == null) {\n            return \"\";\n        }\n\n        // %someplugin_placeholder1%\n                // 如果是%someplugin_placeholder1%，这里需要检测placeholder1\n        if (identifier.equals(\"placeholder1\")) {\n            return plugin.getConfig().getString(\"placeholder1\", \"value doesnt exist\");\n        }\n\n        // %someplugin_placeholder2%\n        if (identifier.equals(\"placeholder2\")) {\n            return plugin.getConfig().getString(\"placeholder2\", \"value doesnt exist\");\n        }\n\n        // We return null if an invalid placeholder (f.e. %someplugin_placeholder3%) \n        // was provided\n                // 错误的papi后缀，比如说someplugin_placeholder666，并没有被我们所定义\n        return null;\n    }\n}\n复制代码\n注：onRequest方法不一定使用Player对象作为参数，同样可以OfflinePlayer\n然后还需要在主类onEnable方法注册public void onEnable(){       \n// Small check to make sure that PlaceholderAPI is installed</font>\n   if(Bukkit.getPluginManager().getPlugin(\"PlaceholderAPI\") != null){ \n        new SomeExpansion(this).register();\n   }\n}复制代码\n使用register方法来注册papi变量\n需要注意的是比如我写了两个变量%mtxz_state% %mtxz_attainments%第一个标示符返回mtxz第二个标示符则是你自己的后缀判断，比如state这里不要重复加上mtxz_的前缀还有papi变量尽量使用xxxx_xxxx的形式，不要随意改动\n\n\n\n\n三、单独的PAPI扩展\n（没有继承JavaPlugin的类，只有papi变量这一个功能）\n这种变量不需要一些你自己插件所记录的独有内容\n而只是返回一些玩家统计数据或是进行一些计算什么的\n此时你可以直接写一个和上文一样的注册的类继承PlaceholderExpansion\n然后构建成一个jar\n放进papi的文件夹，即服务端的/plugins/PlaceholderAPI/expansions\n\n\n\n\n四、云扩展\n腐竹直接在服务器使用/papi ecloud download指令来下载请看这里https://github.com/PlaceholderAPI/PlaceholderAPI/wiki/Expansion-cloud本质上和三是一样的只不过不需要腐竹自己下载jar再扔进目录输入指令之后papi会搞定一切注意这种方法对于版本号等参数的要求很严格如果你要写这种扩展请仔细阅读原文\n\n\n\n最后还是给一下莫老群的群号942025944进群能变强\n可能没上次的详细了，主要是因为吞代码让我很失望，没有什么动力再完全重新写一遍，但是应该足以理解\n",
    "replies": []
}