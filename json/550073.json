{
    "title": "新建维度无法加载",
    "author": "AFP",
    "replyCount": 0,
    "timestamp": 1454326440,
    "txt_content": "前几天自学新建维度，按照教程的写，可是进入世界后世界里一个方块都没有……因为天空和雾气的颜色还有时间没有错，所以worldprovider应该没错，所以做了个实验换成末地的chunkprovider结果可以生成方块了（哇好神奇）所以肯定是chunkprovider的锅，现在研究了许久末地的chunkprovider，综合了一下，可是传送去世界的时候一直显示“下载世界中”根本无法知道成功了没……\n以下是代码package liudaopig.explorer.dimension;\n\nimport java.util.List;\nimport java.util.Random;\n\nimport liudaopig.explorer.Blocks.BlockLoader;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockFalling;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.block.state.IBlockState;\nimport net.minecraft.entity.EnumCreatureType;\nimport net.minecraft.init.Blocks;\nimport net.minecraft.util.BlockPos;\nimport net.minecraft.util.IProgressUpdate;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.world.World;\nimport net.minecraft.world.biome.BiomeGenBase;\nimport net.minecraft.world.chunk.Chunk;\nimport net.minecraft.world.chunk.ChunkPrimer;\nimport net.minecraft.world.chunk.IChunkProvider;\nimport net.minecraft.world.gen.NoiseGenerator;\nimport net.minecraft.world.gen.NoiseGeneratorOctaves;\nimport net.minecraftforge.common.*;\nimport net.minecraftforge.fml.common.eventhandler.Event.*;\nimport net.minecraftforge.event.terraingen.*;\n\npublic class ChunkProviderIceAge implements IChunkProvider\n{\n    private Random iceageRNG;\n    private NoiseGeneratorOctaves noiseGen1;\n    private NoiseGeneratorOctaves noiseGen2;\n    private NoiseGeneratorOctaves noiseGen3;\n    public NoiseGeneratorOctaves noiseGen4;\n    public NoiseGeneratorOctaves noiseGen5;\n    private World iceage;\n    private double[] densities;\n    /** The booms that are used to generate the chunk */\n    private BiomeGenBase[] biomesForGeneration;\n    double[] genBuff;\n    double[] noiseData1;\n    double[] noiseData2;\n    double[] noiseData3;\n    double[] noiseData4;\n    double[] noiseData5;\n    private static final String __OBFID = \"CL_00000397\";\n    private NoiseGeneratorOctaves noiseGeneratorOctaves;\n\n    public ChunkProviderIceAge(World worldIn, long p_i2007_2_)\n    {\n        this.iceage = worldIn;\n        \n        this.iceageRNG = new Random(p_i2007_2_);\n        this.noiseGen1 = new NoiseGeneratorOctaves(this.iceageRNG, 16);\n        this.noiseGen2 = new NoiseGeneratorOctaves(this.iceageRNG, 16);\n        this.noiseGen3 = new NoiseGeneratorOctaves(this.iceageRNG, 8);\n        this.noiseGen4 = new NoiseGeneratorOctaves(this.iceageRNG, 10);\n        this.noiseGen5 = new NoiseGeneratorOctaves(this.iceageRNG, 16);\n\n        NoiseGenerator[] noiseGens = {noiseGen1, noiseGen2, noiseGen3, noiseGen4, noiseGen5};\n        noiseGens = TerrainGen.getModdedNoiseGenerators(worldIn, this.iceageRNG, noiseGens);\n        this.noiseGen1 = (NoiseGeneratorOctaves)noiseGens[0];\n        this.noiseGen2 = (NoiseGeneratorOctaves)noiseGens[1];\n        this.noiseGen3 = (NoiseGeneratorOctaves)noiseGens[2];\n        this.noiseGen4 = (NoiseGeneratorOctaves)noiseGens[3];\n        this.noiseGen5 = (NoiseGeneratorOctaves)noiseGens[4];\n    }\n    public void generation(int x, int z, Block[] blocks)\n    {\n            this.genBuff = this.noiseGeneratorOctaves.generateNoiseOctaves(this.genBuff,x*16,0,z*16, 16, 1,16, 1000, 8000, 1000);\n        int i=0;\n        //遍历每个生成的高度\n        for(double d:genBuff){\n              \n                int by=(int) (60+d/8000);\n              \n                for(int in=0;in<by;in++){\n                        int bi =(i * 256)| in;\n                      \n                        if(in<2){\n                                blocks[bi]=Blocks.bedrock;\n                        }else if(in>=by-2){\n                                blocks[bi]=BlockLoader.icedirt;\n                        }else{\n                                blocks[bi]=BlockLoader.icestone;\n                        }\n                }\n                        int bi =(i * 256)| by;\n                        \n                        blocks[bi]=blocks[bi]=BlockLoader.icedirt;\n                i++;\n        }\n\n    }\n    public Chunk loadChunk(int p_73158_1_, int p_73158_2_)\n    {\n        return this.provideChunk(p_73158_1_, p_73158_2_);\n    }\n    private int chunkX=0, chunkZ=0;\n   \n    public Chunk provideChunk(int x, int z)\n    {\n        chunkX = x; chunkZ = z;\n       \n        this.iceageRNG.setSeed((long)x * 341873128712L + (long)z * 132897987541L);\n        ChunkPrimer chunkprimer = new ChunkPrimer();\n        Block[] blocks = new Block[65536];\n        this.biomesForGeneration = this.iceage.getWorldChunkManager().loadBlockGeneratorData(this.biomesForGeneration, x * 16, z * 16, 16, 16);       \n        this.generation(x, z, blocks);\n        Chunk chunk = new Chunk(this.iceage, chunkprimer, x, z);\n        byte[] abyte = chunk.getBiomeArray();\n\n        for (int k = 0; k < abyte.length; ++k)\n        {\n            abyte[k] = (byte)this.biomesForGeneration[k].biomeID;\n        }\n\n        chunk.generateSkylightMap();\n        return chunk;\n    }\n\n    /**\n     * generates a subset of the level's terrain data. Takes 7 arguments: the [empty] noise array, the position, and the\n     * size.\n     */\n    private double[] initializeNoiseField(double[] p_73187_1_, int p_73187_2_, int p_73187_3_, int p_73187_4_, int p_73187_5_, int p_73187_6_, int p_73187_7_)\n    {\n        ChunkProviderEvent.InitNoiseField event = new ChunkProviderEvent.InitNoiseField(this, p_73187_1_, p_73187_2_, p_73187_3_, p_73187_4_, p_73187_5_, p_73187_6_, p_73187_7_);\n        MinecraftForge.EVENT_BUS.post(event);\n        if (event.getResult() == Result.DENY) return event.noisefield;\n\n        if (p_73187_1_ == null)\n        {\n            p_73187_1_ = new double[p_73187_5_ * p_73187_6_ * p_73187_7_];\n        }\n\n        double d0 = 684.412D;\n        double d1 = 684.412D;\n        this.noiseData4 = this.noiseGen4.generateNoiseOctaves(this.noiseData4, p_73187_2_, p_73187_4_, p_73187_5_, p_73187_7_, 1.121D, 1.121D, 0.5D);\n        this.noiseData5 = this.noiseGen5.generateNoiseOctaves(this.noiseData5, p_73187_2_, p_73187_4_, p_73187_5_, p_73187_7_, 200.0D, 200.0D, 0.5D);\n        d0 *= 2.0D;\n        this.noiseData1 = this.noiseGen3.generateNoiseOctaves(this.noiseData1, p_73187_2_, p_73187_3_, p_73187_4_, p_73187_5_, p_73187_6_, p_73187_7_, d0 / 80.0D, d1 / 160.0D, d0 / 80.0D);\n        this.noiseData2 = this.noiseGen1.generateNoiseOctaves(this.noiseData2, p_73187_2_, p_73187_3_, p_73187_4_, p_73187_5_, p_73187_6_, p_73187_7_, d0, d1, d0);\n        this.noiseData3 = this.noiseGen2.generateNoiseOctaves(this.noiseData3, p_73187_2_, p_73187_3_, p_73187_4_, p_73187_5_, p_73187_6_, p_73187_7_, d0, d1, d0);\n        int k1 = 0;\n\n        for (int l1 = 0; l1 < p_73187_5_; ++l1)\n        {\n            for (int i2 = 0; i2 < p_73187_7_; ++i2)\n            {\n                float f = (float)(l1 + p_73187_2_) / 1.0F;\n                float f1 = (float)(i2 + p_73187_4_) / 1.0F;\n                float f2 = 100.0F - MathHelper.sqrt_float(f * f + f1 * f1) * 8.0F;\n\n                if (f2 > 80.0F)\n                {\n                    f2 = 80.0F;\n                }\n\n                if (f2 < -100.0F)\n                {\n                    f2 = -100.0F;\n                }\n\n                for (int j2 = 0; j2 < p_73187_6_; ++j2)\n                {\n                    double d2 = 0.0D;\n                    double d3 = this.noiseData2[k1] / 512.0D;\n                    double d4 = this.noiseData3[k1] / 512.0D;\n                    double d5 = (this.noiseData1[k1] / 10.0D + 1.0D) / 2.0D;\n\n                    if (d5 < 0.0D)\n                    {\n                        d2 = d3;\n                    }\n                    else if (d5 > 1.0D)\n                    {\n                        d2 = d4;\n                    }\n                    else\n                    {\n                        d2 = d3 + (d4 - d3) * d5;\n                    }\n\n                    d2 -= 8.0D;\n                    d2 += (double)f2;\n                    byte b0 = 2;\n                    double d6;\n\n                    if (j2 > p_73187_6_ / 2 - b0)\n                    {\n                        d6 = (double)((float)(j2 - (p_73187_6_ / 2 - b0)) / 64.0F);\n                        d6 = MathHelper.clamp_double(d6, 0.0D, 1.0D);\n                        d2 = d2 * (1.0D - d6) + -3000.0D * d6;\n                    }\n\n                    b0 = 8;\n\n                    if (j2 < b0)\n                    {\n                        d6 = (double)((float)(b0 - j2) / ((float)b0 - 1.0F));\n                        d2 = d2 * (1.0D - d6) + -30.0D * d6;\n                    }\n\n                    p_73187_1_[k1] = d2;\n                    ++k1;\n                }\n            }\n        }\n\n        return p_73187_1_;\n    }\n\n    /**\n     * Checks to see if a chunk exists at x, z\n     */\n    public boolean chunkExists(int x, int z)\n    {\n        return true;\n    }\n\n    /**\n     * Populates chunk with ores etc etc\n     */\n    public void populate(IChunkProvider p_73153_1_, int p_73153_2_, int p_73153_3_)\n    {\n        BlockFalling.fallInstantly = true;\n\n        MinecraftForge.EVENT_BUS.post(new PopulateChunkEvent.Pre(p_73153_1_, iceage, iceage.rand, p_73153_2_, p_73153_3_, false));\n\n        BlockPos blockpos = new BlockPos(p_73153_2_ * 16, 0, p_73153_3_ * 16);\n        this.iceage.getBiomeGenForCoords(blockpos.add(16, 0, 16)).decorate(this.iceage, this.iceage.rand, blockpos);\n\n        MinecraftForge.EVENT_BUS.post(new PopulateChunkEvent.Post(p_73153_1_, iceage, iceage.rand, p_73153_2_, p_73153_3_, false));\n\n        BlockFalling.fallInstantly = false;\n    }\n\n    public boolean func_177460_a(IChunkProvider p_177460_1_, Chunk p_177460_2_, int p_177460_3_, int p_177460_4_)\n    {\n        return false;\n    }\n\n    /**\n     * Two modes of operation: if passed true, save all Chunks in one go.  If passed false, save up to two chunks.\n     * Return true if all chunks have been saved.\n     */\n    public boolean saveChunks(boolean p_73151_1_, IProgressUpdate progressCallback)\n    {\n        return true;\n    }\n\n    /**\n     * Save extra data not associated with any Chunk.  Not saved during autosave, only during world unload.  Currently\n     * unimplemented.\n     */\n    public void saveExtraData() {}\n\n    /**\n     * Unloads chunks that are marked to be unloaded. This is not guaranteed to unload every such chunk.\n     */\n    public boolean unloadQueuedChunks()\n    {\n        return false;\n    }\n\n    /**\n     * Returns if the IChunkProvider supports saving.\n     */\n    public boolean canSave()\n    {\n        return true;\n    }\n\n    /**\n     * Converts the instance data to a readable string.\n     */\n    public String makeString()\n    {\n        return \"RandomLevelSource\";\n    }\n\n    public List getPossibleCreatures(EnumCreatureType creatureType, BlockPos pos)\n    {\n        return this.iceage.getBiomeGenForCoords(pos).getSpawnableList(creatureType);\n    }\n\n    public BlockPos getStrongholdGen(World worldIn, String structureName, BlockPos position)\n    {\n        return null;\n    }\n\n    public int getLoadedChunkCount()\n    {\n        return 0;\n    }\n\n    public void recreateStructures(Chunk p_180514_1_, int p_180514_2_, int p_180514_3_) {}\n\n    public Chunk provideChunk(BlockPos blockPosIn)\n    {\n        return this.provideChunk(blockPosIn.getX() >> 4, blockPosIn.getZ() >> 4);\n    }\n\n        @Override\n        public List func_177458_a(EnumCreatureType p_177458_1_, BlockPos p_177458_2_) {\n                \n                return null;\n        }\n}复制代码求大神\n",
    "replies": []
}