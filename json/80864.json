{
    "title": "论MCP把net.minecraft.src下的类分别放到不同的包，弊大于利",
    "author": "yuxuanchiadm",
    "replyCount": 5,
    "timestamp": 1358973540,
    "txt_content": "以下内容非MOD开发人员无需纠（思）结（考）。\n\n\n\n------------------------------------------------------------群众过滤线------------------------------------------------------------\n\n\n\n1.首先，Minecraft原来混淆前的代码，是直接放在缺省包里的，本不应该在反编译时移到net.minecraft.src下。\n2.刚开始MCP分类net.minecraft.src下的类的时候，我觉得方便找类了。但是，别忘了有些类里的方法，字段是protected修饰的，将导致我们无法方便访问到这些字段，这将大大降低我们对游戏的可修改性。\n\n解决方法：\n1.直接把自己想访问到的方法或字段改为public，并使MOD调用这些方法和字段时，所调用的那个类都在net.minecraft.src包或缺省包下。\n2.使用反射运行时动态修改（不解释了）。\n3.不调用这些函数或字段。\n4.想办法把这些东西给改回来。\n\n\n以上",
    "replies": [
        {
            "author": "天空の遗迹",
            "timestamp": 1358975160,
            "txt_content": "正在努力越过过滤线的表示我还是先收藏了吧…以后再思考…"
        },
        {
            "author": "专业坑爹三十年",
            "timestamp": 1358987820,
            "txt_content": "虽不明但觉厉"
        },
        {
            "author": "sanddudu",
            "timestamp": 1358990280,
            "txt_content": " 本帖最后由 sanddudu 于 2013-1-24 09:19 编辑 \n\n简单解释一下LZ\n\nJava内的成员变量有很多种可以被设置的限制，介绍几个和LZ说的相关的\nPublic（哪里都可以调用的）\nPrivate（只有在被定义的类中可以调用）\nProtected（子类可以调用，不同包的类不可以调用）\n对于类外的包，Private和Protected是一个效果\n显然易见，每个源代码说存放的包都是不同的，所以有的时候Protected修饰的成员变量就不能被访问，开发者不能修改\n其实MOD编写时常用的继承其中的子类（extends）可以解决部分的问题，但是总不能每个类继承很多个子类来获得对所有变量的控制权\nMCP本意是好的，如果不分类的话没看文档的会被超级多的类文件搞晕.......但是在另一方面，我们需要的变量也会无法访问。\n所以说改才是王道，反正MCP又不查你"
        },
        {
            "author": "当风过时",
            "timestamp": 1359000240,
            "txt_content": "非常同意，用Forge的从1.3升到1.4如果还继续放在src下的话，源码就有得你改了"
        },
        {
            "author": "yuxuanchiadm",
            "timestamp": 1359008580,
            "txt_content": "sanddudu 发表于 2013-1-24 09:18 \n简单解释一下LZ\n\nJava内的成员变量有很多种可以被设置的限制，介绍几个和LZ说的相关的\n1.是4种：public、private、protected、默认型（啥修饰符都不填）\n2.public：共有的不解释了\n3.private：只有当前类可以访问，子类也不行\n4.protected：只可以被当前包中的所有类、这个类本身和其子类调用。（特别注意、继承那个类的子类即使和你想访问这个字段的类在同一个包中，也无法访问。）\n5.默认型：在同一类中和同一包中的其他类访问，子类不行\n6.继承其子类然后创建GET/SET函数是个不错的想法，可惜这样做会降低MOD对其他MOD的兼容性。（比如想访问Item***这个类中的某个字段，于是乎创建一个类，继承自它，建立GET/SET方法，覆盖Item类中其对象的引用为你创建的子类。但是其他MOD也这样做呢？于是乎总有一个的修改会被忽略）\n7.注意对象可不只一个哦，所以继承，成为其子类后，只能修改这个对象中的protected字段和方法，对与从外部传入的这个类的父类的对象，其中的protected方法和字段依然无法使用。\n8.所以我个人认为面对这种情况，只需把你想要修改的方法或字段改为public，只要逻辑上，正编译打包后在同一包中，就可以畅快的使用这个类，而不需要用编译后得到的你改protected为public的类覆盖客户的这个如果类。（当然不在同一包中，则需要客户端覆盖。（兼容性-99%））\n9.或者直接用反射，最直接，最符合中等水平程序员思维。"
        }
    ]
}