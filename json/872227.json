{
    "title": "本人打算写个服务端管理器.希望志同道合的人一起来开发",
    "author": "tmkmk",
    "replyCount": 8,
    "timestamp": 1560131100,
    "txt_content": " 本帖最后由 tmkmk 于 2019-6-10 09:48 编辑 \n\n       软件的中心思想有2个:\n             1:所有操作使用web;\n             2:面向对象为服务器租赁商,而不是单个的服主.\n      总所周知,每个服务器要想运行起来,那肯定是需要一定的额外开销.如果自己装一个实体的服务期.那么额外开销可大了去了.所以大家都选择VPS类的.虽然额外开销少了,但还是有啊.比如说一个系统.额外开销至少都得是系统运行起来所占的内存把.有这么多内存,足够再开一个MC了.所以呢,针对小型MC服务器,自行独立租用一个VPS显然很不划算.相当于使用了两个MC服务器的资源,换来的却是1个服务器.而我想写的这个软件呢,就是为了解决这一现象的.\n       使用一个配置较高的服务器,里面运行多个MC服务器,互相独立管理,互不影响.而管理方式呢.则使用目前最流行的web方式.服务器管理员只需要给各个服主一个ID,一个登陆地址即可.让各个服主们自己捣腾去.当然了.这个ID 肯定会限定一些资源. 比如限制内存.限制MC的端口号.免得和其他人的端口重叠.这样一来,MC服务器越多,那么 服务器自身系统所消耗的资源占比就会越少.从而达到充分的利用.这只是内存. 还有一个就是CPU.不可能所有的MC服务器都同时占用很高的CPU把.那么,共享CPU的优势就出来了.当然了,劣势还是有的.所以,这就需要后期管理.以及集合进去一定的优化插件之类的了.总之,好处还是大于坏处的.\n\n\n\n测试_最原始_功能BUG一大堆.7z.zip\n(101.37 KB, 下载次数: 11)\n\n\n\n2019-6-10 09:47 上传\n点击文件名下载附件\n后缀名是7z\n\n\n\n\n\n      如果各位感兴趣的话.可以在帖子下方讨论一下啊.本帖子不要水啊.我希望看到所有回帖的人都是有兴趣的人,可以提出意见的人,有能力的人.\n最后.帖子中的点一下展开内容的那种文章怎么发啊?不会.\n下面.我粘贴一下我粗略写出来的说明.\n\n网页很粗糙.甚至有很多未完成的,还有很多bug.改起来有点累.希望有人能一起合作修改.\n\nfunction bequery(data, curl,yibu = true) {\n        kztcon= kztcon && data.charCodeAt(0)==2;// 如果传递过来的参数第一位是2 则继续投递,保证控制台信息实时显示\n        var arrd = new Array();\n        $.ajax({\n                async:yibu,// 异步执行\n                url: curl,\n                type: 'POST',\n                data: data,\n                datatype: \"json\",\n                success: function(msg){\n                        switch (data.charCodeAt(0)){\n                                case 0:\n                                        //createitem(eval(msg));\n                                        break;\n                                case 1:\n                                        console.log('首页');\n                                        break;\n                                case 2:\n                                        addkzt(msg);\n                                        if(kztcon && commond == '') setTimeout('bequery(2)',500);\n                                        break;\n                                case 3:\n                                        // 插件\n                                        arrd=fgarray(msg);\n                                        tablelist = new Array('插件名称', '版本', '本地文件名', '安装时间', '操作');\n                                        CreateTable(arrd, document.getElementById('divybl'));\n                                        break;\n                                case 4:\n                                        // MOD\n                                        arrd=fgarray(msg);\n                                        tablelist = new Array('MOD名称', '版本', '本地文件名', '安装时间', '操作');\n                                        CreateTable(arrd, document.getElementById('divybl'));\n                                        break;\n                                case 5:\n                                        // 玩家管理\n                                        arrd=fgarray(msg);\n                                        tablelist = new Array('玩家ID', '游戏模式', '是否OP', '登录时间', '操作');\n                                        CreateTable(arrd, document.getElementById('divybl'));\n                                        break;\n                                case 6:\n                                        // 目录浏览\n                                        mcmanager.value=msg;\n                                        break;\n                                case 7:\n                                        // 文件编辑\n                                        mcmanager.value=msg;\n                                        break;\n                                case 8:\n                                        // 目录管理\n                                        mcmanager.value=msg;\n                                        break;\n                                default:\n                                        console.log(Number(value));\n                                        break;\n                        }\n                },\n                error: function(){\n                        ret = false;\n                }\n    })\n}\nbequery(data, curl,yibu = true); 函数解释: 参数1,为所发送具体数据.参数二为请求页面.\n                例如:是服主的命令的话.所有参数2.都必须是\"game\",这里对应配置文件中的[game] page=/game \n                的值. 配置文件中.第一个符号/不能省略.因为这是大多数浏览器必带的一个前缀.可在配置文件中\n                修改,如果是服务器管理员(不是服主哦),则 第二参数为\"admin\",也可以在前面加上/.\n\n投递消息机制: 例如 bequery(\"\\x00用户名&密码\") 第一位是0.注意这一点.js坑爹设定中,\n        转义符\"\" 后面是8进制的,有的浏览器又是10进制,为了保险起见,还是使用16进制比较安全.\\x0a 表示\n        十进制中的 10. 如果是8进制的话,十进制中的10 就需要 \\12. 然后 后面跟随想要发送的命令.\n        例如: 向控制台发送一条\"op 123\"的命令(开启玩家123用户OP权限), 那么在这里就变为\n        bequery(\"\\x02op 123\\r\\n\");  注意一点,结尾的换行符一定要加, 否则就变成了 向控制台发送了一条\n        op 123然后没有最后敲回车的效果了. 这其中 \\x02就代表向控制台发送数据, 以此类推.\n        对于服主管理后台的接口 分别为 \n                0:登录,格式为 \"用户名&密码\"; \n                        例如:bequery(\"\\x00用户名&密码\",\"game\");\n                        返回值.\n                                \\x00        登录成功\n                                \\x01        密码错误;\n                                \\x02        用户名错误;\n                1:服务器开关.\n                        例如:bequery(\"\\x01\\x00\",\"game\");强制关闭服务器.(这里的关闭是强制关闭,与控制台里的stop\n                                        不同,控制台里的stop之后.会重新启动.相当于重启,这里的关闭则不会)\n                                bequery(\"\\x01\\x01\",\"game\"); 强制重启服务器. 如果服务器正在运行中.则会关闭服务器,\n                                        然后打开服务器,如果服务器没有开启.则直接打开服务器.\n                        另外,在服务器启动之前.会删除服务器目录下 \".del\"结尾的文件.因为删除文件这个功能如果\n                                遇到无法直接删除的文件时.则会将文件名改为以.del结尾的文件,如果连改文件名都失败的\n                                话,则会在整个服务器重启后执行这一步.\n                        返回值.\\x00.只有这一个.没想到还有什么需要返回的.\n                        \n                2:请求控制台数据, 发送此命令后,服务端会将最近的控制台数据返回来,至于如何处理,由IE的js自\n                        行处理.例如历程中,我将返回来的数据追加到 控件 <textarea>的末尾.就好像真实控制台一样.\n                        如果\\x02之后有数据,会将之后的数据原封不动的发送到控制台.然后服务端再返回.\n                        例如:bequery(\"\\x02say 123456\\r\\n\",\"game\");发送给服务器后,服务器会将\"say 123456回车\"\n                        发送到MC控制台.\n                3:获取插件信息,返回来的数据格式为:// 这里与下面获取目录不一样,因为这里会获取插件内部名称\n                                                                                        插件名称1|版本1|本地文件名1|安装时间1\\n\n                                                                                        插件名称2|版本2|本地文件名2|安装时间2\\n\n                        这里需要注意一下,结尾处为\\n 不是\\r\\n 本例子是将得到的数据制作成一个表格,显示出来.\n                        例如:bequery(\"\\x03\",\"game\");\n                                特别说明:这里所获取到的内容,是服务器正在运行的插件,如果是刚刚上传的插件,这里是不\n                                        会显示出来的,只有重启MC之后.才会显示出来.下面的MOD也是一样.因为如果读取插件\n                                        的版本,以及插件名称,比较消耗服务器资源.\n                4:获取MOD信息,与插件一致.        格式为:MOD名称1|版本1|本地文件名1|安装时间1\\n\n                        例如:bequery(\"\\x04\",\"game\");\n                5:获取玩家信息,与之前的一致.格式为:玩家名称1|游戏模式|是否OP|登录时间\\n\n                        解释一下,游戏模式:就是说这个玩家是生存,还是创造等,至于登录时间统一发送为0.待后续添加\n                        例如:bequery(\"\\x05\",\"game\");\n                6:目录浏览, 会将请求url路径下的目录所有文件列表显示出来.\n                        例如:bequery(\"\\x06\",\"game\\\\plugins\\\\*\")\n                                                                                                                                                \\x01目录1\\n\n                                                                                                                                                \\x01目录2\\n\n                                                                                                                                                \\x02文件1\\n\n                                                                                                                                                \\x02文件2\\n\n                        这里,目录会在前面加一个字节\\x01 而文件则为\\x02 以\\n换行.\n                7:创建目录, 例:bequery(\"\\x07\",\"game\\\\plugins\\\\233\"),会在服主MC目录下创建一个plugins\\233\n                        目录. 如果没有 plugins 目录的话.理论上也会跟着创建.不过不建议这么操作.最好一层一层的\n                        创建.\n                8:删除目录,例:bequery(\"\\x08\",\"game\\\\plugins\\\\233\"), 会删除服主MC目录下的plugins\\233 目录\n                        注意:这里有个漏洞.删除目录的方式是在服务期以cmd命令方式进行.如果请求页面有其他命令并\n                        存,则会一起执行,最终导致控制整个服务器.虽然意识到了这个漏洞.但不想马上修改.\n                9:读取文件,例:bequery(\"\\x09\",\"game\\\\plugins\\\\1.txt\"), 会将服主MC目录下的plugins\\1.txt\n                        文件读取,并以二进制的形式发送过来.(与get方式的是不一样的哦.)\n                a:写入文件, 这里要注意一下.与上传文件不一样, 最大支持8000字节. \n                        例:bequery(\"\\x0A正式的文件数据\",\"game\\\\plugins\\\\1.txt\"), 看一下参数1中第一个字节.\n                        \\x0a就是写入文件的命令开关了.plugins\\\\1.txt表示文件名.会将\"正式的文件数据\"写入到文件\n                        中去.\n                b:上传文件: 上传文件使用浏览器的form控件实现.请参考历程中的updata.js\n                        这里,请求页面必须是不包含文件名的路径.例如: \"game\\\\aaa\\\" 作为请求页面,然后上传form\n                        数据. 因为form组件包含有文件名的信息.所以 完整的写入文件路径出来了.那就是\n                        \"game\\\\aaa\\\\你上传时候的文件名\";这里有一点坑爹.我本来的意愿是将文件的最后修改日期作\n                        为标准的,结果上传的文件中.是不包含时间信息的.只能通过其他方法实现.请看下一个功能,修\n                        改时间. 有哪位大佬能提供下相关的资料也行.\n                        注意:请求页面一定要以\\\\结尾哦.否则最终文件名就变成了\"game\\\\aaa你上传时候的文件名\"\n                c:修改文件时间(最后修改日期);只这一项.本身时间信息有3个的.感觉其他的没卵用.所以,不添加了\n                \n                后续处理接口等待添加.\n        下面是上传文件的事例:\n由于IE的js可操作性特殊性,导致无法进行本地文件的直接读写操作.所以,专门为上传文件做了另外一个接口\n        function UpLoadFile(path) {\n                var form = document.getElementById('upload'),\n                formData = new FormData(form);\n                $.ajax({\n                        url: path,\n                        type: \"post\",\n                        data: formData,\n                        datatype: \"json\",\n                        processData: false,\n                        contentType: false,\n                        success: function(res) {\n                                if (res == \"ok\") {\n                                        alert(\"上传成功!\");\n                                }else alert(\"出现错误.如:没有写权限\");\n                                console.log(res);\n                                $(\"#pic\").val(\"\");\n                        },\n                        error: function(err) {\n                                alert(\"网络连接失败,稍后重试\", err);\n                                console.log(err);\n                        }\n                })\n                return false;/**/\n        }\n        例子中.path为请求目录.会将你的文件放在这个目录下.\n而下载文件就简单了.直接get请求就可以了..当然了.未登陆的GET请求,只允许读取软件中\"网页\"目录下的所有\n        文件,如果是需要访问软件管理,或者服主路径的话,就需要登陆后,才可访问.而访问的url则会变换.\n                http://域名/目录1/文件1                当打开这样的url时,不需要权限,可以直接进行访问.实际的物理文件\n                        为:路径\\网页\\目录1\\文件1\n                http://域名/admin/目录1/文件1 此时在域名后,紧跟着的第一个目录为关键字目录.表示将物理路径\n                        切换到管理员路径中去.所以.此时就需要访问权限了.\n                http://域名/game/目录1/文件1 同上, 域名后的一级路径遇到关键字game了.表示切换物理路径到各\n                        个服主的目录中去.\n                由上述规则可以知道:在\"网页\"这个目录下的 \"admin\"以及\"game\"这两个目录将无效.\n最后说一下登录问题:\n        登录后,会将你当前建立的TCP连接放到白名单,以后凡是这个连接所发生的命令,都会被执行.反之,如果不\n                是发送过登录命令的连接所请求的post内容.将会被拒绝执行.当然,get就不存在了.所以.不要再网页\n                这个文件夹里放什么重要东西哦.\n        \ngame组已经介绍完毕.下面开始介绍admin组.也就是服务器管理员.所需要的接口就比较少了.\n\n同样是bequery();只不过请求页面变为了admin 而不是之前的 game;\n        0:登录.与game组格式一致 例:bequery(\"\\x00用户名&密码\",\"admin\");\n                只不过是将game改为admin 表示这是发起的admin 命令.\n                返回值与game相同\n        1:cmd控制台. 由于是管理员,所以这个权限就是相当的大了.就相当于在服务器上执行cmd命令一样.\n                用法与game的一样,只不过这里是发送到服务器的控制台,而不是MC的控制台.\n        2:注册新用户.就是新增加一个game服主.\n                例:bequery(\"\\x02用户名&密码&2G&25565&路径\",\"admin\");\n                        bequery(\"\\x02用户名&密码&内存&端口&路径\",\"admin\"); 这种形式\n                操作完之后.会自动创建一个路径.完整的路径是, 路径前缀\\用户名.  这里的路径前缀可以增加盘符\n                目录,等信息.\n                        这里,会有返回值.可根据返回值进行确定具体状态.(返回值具有两个字节.)\n                                其中,第一个字节代表在注册账号的哪一步出错了. 第二字节 表示为什么出错(大部分是内存不够).\n                                第一个字节:\n                                        0:正常.注册通过.\n                                        1:已经存在相同的用户名. 此两项第二字节都是0\n                                        2:在写入总ID列表是出错.就是配置文件中的 gameID这里.\n                                        3:写入密码时出错\n                                        4:写入端口时出错\n                                        5:写入路径时出错\n                                        6:格式不正确\n                                第二个字节:\n                                        0:正确\n                                        1:申请配置文件节点名长度的内存时失败\n                                        2:申请配置项长度内存时失败\n                                        3:申请读取整个config.ini文件长度内存时失败\n                                        4:读取config.ini文件时报错\n                                        5:申请 配置项名+节点名+数据+1 长度内存失败.\n                                        6:写入到配置文件时报错.\n                                        7:申请 config.ini文件长度 + 欲写入数据长度+1 内存时报错\n                                        8:移动读写位置准备写入数据时出错.\n                                        9:插入数据时报错.\n                                        10:再次申请 长度为 写入数据长度 时出错\n                                        11:缺少必要参数\n                                        \n        3:删除game.会将服主的信息进行删除.包括停止MC服务器.以及删除整个文件夹.\n                例:bequery(\"\\x03dd|\",\"admin\");\n                切记.必须以 符号\"|\"结尾.否则有可能会误删;\n                \n        还将会有很多很多远程控制的功能.只能等以后慢慢开发了.\n\n复制代码\n\n\n",
    "replies": [
        {
            "author": "tmkmk",
            "timestamp": 1560302520,
            "txt_content": "这么久了.没有一个人回帖.看样子是没戏了."
        },
        {
            "author": "B1ng_gan",
            "timestamp": 1560427560,
            "txt_content": "感觉你是想要docker之类的"
        },
        {
            "author": "tmkmk",
            "timestamp": 1560474840,
            "txt_content": "对.差不多吧.专门为mc服务器做个web的API"
        },
        {
            "author": "ItsZeroHikari",
            "timestamp": 1560511860,
            "txt_content": "multicraft了解一下？"
        },
        {
            "author": "tmkmk",
            "timestamp": 1560559680,
            "txt_content": "tutity_tiger 发表于 2019-6-14 19:31\nmulticraft了解一下？\n与那个不同.我想写的只是一个API而已.功能上来说,应该会比那个多一点点."
        },
        {
            "author": "hmm1313133",
            "timestamp": 1560572580,
            "txt_content": "是打算写成multicraft那样的还是只打算写api？"
        },
        {
            "author": "roj234",
            "timestamp": 1561197060,
            "txt_content": "MCSERVERMANAGER?"
        },
        {
            "author": "tmkmk",
            "timestamp": 1572600900,
            "txt_content": "hmm1313133 发表于 2019-6-15 12:23\n是打算写成multicraft那样的还是只打算写api？\n只写api.毕竟众人拾柴火焰高嘛"
        }
    ]
}