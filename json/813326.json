{
    "title": "关于判断玩家是否走出一个范围,这是我的想法",
    "author": "Gyzer",
    "replyCount": 6,
    "timestamp": 1533894480,
    "txt_content": "随机选取两个点，和圈地一样。然后存起来。再判断玩家是否走出这个范围这是我的想法：(给一些需要的人帮助吧...大佬不要吐槽，给点意见就行啦~谢谢)\n\n\n#开始在事件中判断\npublic void onm(PlayerMoveEvent e)\n{\n\nLocation loc1=随机选取的两个坐标中其中一个;\nLocation loc2=随机选取的两个坐标中另外一个;\n#获取该区域的中心点(一次函数了解一下..)\nLocation zxd=new Location(world,(loc1.getBlockX()+loc2.getBlockX())/2, y ,(loc1.getBlockZ()+loc2.getBlockZ())/2,);\n#获取该区域半径\nint r=(loc1.getBlockX()+loc2.getBlockX())-zxd.getBlockX();\n    .....\n  if ( p.getLoction().getBlockX() > zxd.getBlockX()+r || p.getLoction().getBlockX() < zxd.getBlockX()-r ||p.getLoction().getBlockZ() > zxd.getBlockZ()+r || p.getLoction().getBlockZ() < zxd.getBlockZ()-r)\n{\n取消事件.\np.sendMessage(\"你无法走出这区域！);\n}\n\n关于Y判断自行添加，这里只举出X和Z。\n大佬们看看给着点意见\n小白们可用学习学习。嘻嘻嘻   \n\n",
    "replies": [
        {
            "author": "@TGL",
            "timestamp": 1533895380,
            "txt_content": "坐标/2没看懂"
        },
        {
            "author": "Gyzer",
            "timestamp": 1533958020,
            "txt_content": "上面的代码有问题~~~\n不知道为什么编辑不了帖子...\n\n随机选取两个点，和圈地一样。然后存起来。再判断玩家是否走出这个范围这是我的想法：(给一些需要的人帮助吧...大佬不要吐槽，给点意见就行啦~谢谢)\n\n\npublic static boolean isInFw(Location loc1,Location loc2)\n{\n\n#获取该区域的中心点(一次函数了解一下..)\nLocation zxd=new Location(world,(loc1.getBlockX()+loc2.getBlockX())/2, y ,(loc1.getBlockZ()+loc2.getBlockZ())/2,);\n#获取该区域x轴的半径\n  \n        int xr = 0;\n        int yr = 0;\n        int zr = 0;\n        if (loc1.getBlockX() > loc2.getBlockX()) {\n          xr = (loc1.getBlockX() - loc2.getBlockX()) / 2;\n        }\n        if (loc1.getBlockX() < loc2.getBlockX()) {\n          xr = (loc2.getBlockX() - loc1.getBlockX()) / 2;\n        }\n        if (loc1.getBlockY() > loc2.getBlockY()) {\n          yr = (loc1.getBlockY() - loc2.getBlockY()) / 2;\n        }\n        if (loc1.getBlockY() < loc2.getBlockY()) {\n          yr = (loc2.getBlockY() - loc1.getBlockY()) / 2;\n        }\n        if (loc1.getBlockZ() > loc2.getBlockZ()) {\n          zr = (loc1.getBlockZ() - loc2.getBlockZ()) / 2;\n        }\n        if (loc1.getBlockZ() < loc2.getBlockZ()) {\n          zr = (loc2.getBlockZ() - loc1.getBlockZ()) / 2;\n        }\n    .....\n  if ( p.getLoction().getBlockX() > zxd.getBlockX()+xr || p.getLoction().getBlockX() < zxd.getBlockX()-xr ||p.getLoction().getBlockZ() > zxd.getBlockZ()+zr || p.getLoction().getBlockZ() < zxd.getBlockZ()-zr||p.getLoction().getBlockY() > zxd.getBlockY()+yr || p.getLoction().getBlockY() < zxd.getBlockY()-yr)\n{\nreturn false;\n}\nelse\n{\nreturn true;\n}\n\n\n#开始在事件中判断\npublic void onm(PlayerMoveEvent e)\n{\n if (isInFw(随机位置1,随机位置2,e.getPlayer().getLocation()))\n{\n  .......\n}\nelse\n{\np.sendMessage(\"你已经离开了这篇区域\");\n}\n}\n大佬们看看给着点意见\n小白们可用学习学习。嘻嘻嘻   \n\n#该段代码亲测完美无错~"
        },
        {
            "author": "耗子",
            "timestamp": 1533960240,
            "txt_content": "楼主做了过多的除法运算，在频繁调用的PlayerMoveEvent中会使服务器卡顿。\n何不先预处理一下两点，使一点的x，y，z坐标分别大于另一点的x，y，z坐标呢？\n然后直接判断玩家的坐标是否全部小于最大坐标的x，y，z坐标，且是否全部大于最小坐标的x，y，z坐标。"
        },
        {
            "author": "602723113",
            "timestamp": 1533985920,
            "txt_content": "#获取该区域的中心点(一次函数了解一下..)\nLocation zxd=new Location(world,(loc1.getBlockX()+loc2.getBlockX())/2, y ,(loc1.getBlockZ()+loc2.getBlockZ())/2,);\n\nemmm，那个东西不叫一次函数\n这东西叫做中点坐标公式"
        },
        {
            "author": "tdiant",
            "timestamp": 1534055700,
            "txt_content": "其实我想吐槽Java里的注释是双斜线 //, 不是井号#."
        },
        {
            "author": "OharaRinne",
            "timestamp": 1534140240,
            "txt_content": "不知道Vector.isInAABB能不能实现"
        }
    ]
}