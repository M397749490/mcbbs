{
    "title": "[新帖][硬核][科技向][1.7+]OpenComputers——开放式电脑/开放式计算机深度攻略",
    "author": "sunch420",
    "replyCount": 11,
    "timestamp": 1573070100,
    "txt_content": " 本帖最后由 sunch420 于 2019-11-7 23:18 编辑 \n前言\n\n啊虽然是一个已经玩我的世界玩了十多年的老头子了但是从来没自己写过帖子，那正好最近又重新入坑了，写个关于一个...非常冷门的mod：OpenComputers的深度教程吧。OpenComputers简单介绍下哈，虽然来看这帖子的人应该都是老玩家了但是程序还是要走的。就是一个mod，可以让你在我的世界里面自己组装电脑，然后使用真实的编程语言lua5.3编程。好的。以上就是介绍。（肉眼可见的敷衍）<--那就对了\n然后我想你们应该都看过基础教程了，然后知道了怎么让机器人前进后退，然后怎么使用电脑之类的，但是更多的可能还没探索，于是这个教程就是为了那些不知道该怎么做的人准备的！\nOpenComputers其实是一款很强大的插件。因为它可以帮助你做一切事情。搭建游戏内服务器，跨世界网络，让机器人送快递，打怪种田，只要你想，就可以做得到。再说说lua，是一款很棒的语言，因为它很简单（但是学到metatable你就不会这么认为了）。初学者也能很快入门（我只用了三个小时，当然我是有其他语言比如python基础的）。[WARNING]我真的只是一个萌新，各位大佬看到了错误勿喷，真心地欢迎指正，并且欢迎有人和我一起研究和改善我的代码。\n\n这里是我给你们提供的一个包含OC的整合包以及配套服务器。服务器我已经配置好了，一键开服。\n整合包在这里下载（这里还要感谢酷车手bb弹，我用他的包改的）\nhttps://github.com/sun-wilhelm/MCS\n1.12.2.zip是客户端。MCS.zip是服务端，也就是说如果你觉得好玩你可以自己下载了服务端和你的朋友们一起玩。具体怎么开（外网）服的话，可以问我也可以网上搜。挺容易的。\nPS I：这个整合包因为加了很多多世界插件，比如Twillingforest，Galaxy Craft之类的，所以格外的吃内存。推荐8GB以上电脑尝试。另外，我还附带了六边形材质包（我爱六边形，六边形不知道爱不爱我，六边形使我快乐。）。\nPS II：外网服指的是你和你的朋友不在一个Wi-Fi下一起玩游戏的情况。要是用的同一个Wi-Fi你把服务器打开你朋友就能看到了。\n\n主要的部分：\n\nI'm very 懒。于是图片可能不是很多（主要是我没开我的游戏，一会儿写着写着觉得十分愧疚的话会把游戏开开给你们截图的，于是前期可能没图）。\n首先先说说机器人吧，你们应该都知道了怎么前进了吧。\n首先提一句，你们打开电脑之后可以输入lua来进入编程界面，也可以将代码写入一个文件中，后缀命名为.lua然后运行。比如下面的代码在输入lua后就可以分成两行输入进去。除此之外，鼠标中键可以将你电脑剪贴板里的内容粘贴到游戏里。\nlocal Action = require(\"robot\")\nAction.forward()复制代码很容易对吧。\n为了大家看起来方便我会在有必要时将中文术语或者说，专业名词用双引号扩起来并且用小括号在双引号内标注它在其他语言中的称呼。以免大家分不清楚哪个是我要说的话。\n另外鬼畜的mcbbs不能缩进代码，你们凑合看吧。\n相信很多学过python和C/C++的人都知道“对象（Object）”这个概念吧（不我说的不是你们的女朋友）。\n对于lua而言，某种意义上来说，“库（library）”调用是不存在的。之所以是“某种意义上”是因为如果你想调用一个库的话，需要新建一个“对象（Object）”来承载这个库的内容。就如代码中的Action就是一个承载了“robot”库内容的对象。\n并且从某种意义上来说，“类（class）”也是不存在的。因为在lua中会使用“表（table）”来代替“数组（Array）”以及“类（class）”的功能。也就是说，在lua中，“类（class）”可以被称为“函数数组（Function Array）”。这个一会儿会详细介绍。\n接下来进行逐个成分的讲解：\nlocal关键字可以被理解为其他语言中的“private”。也就是说是一个私有化的，别的“类（class）”无法访问的内容。\n在lua中，变量不需要事先声明类型。只需要赋值他就会自动初始化变量。查看变量的类型可以使用type(变量名)的方法。如果一个变量被赋予了nil值，也就是null，他就会被内存回收机制自动释放掉。在lua中，主要类型有int，string，table，userdata等等（我懒得挨个数了，反正你也不需要初始化，就像python一样，基础使用的话不需要关心他的类型）。\nrequire或者import，在lua中都可以使用。对于OC来讲，没什么区别。因为OC在环境变量中会试图寻找所有扩展名为“.lua”的文件并且加入环境中。所以require可以替代import的功能。在require或者import的括号中，你需要引用的库类型必须是string，也就是说你需要加双引号。\n小数点是域控制符，它可以用来访问你所引用的类里面的内容。\n\n表（table）和元表（metatable）\n下面是关于lua语言中最重要的部分：“表（table）”的讲解。“元表（metatable）”属于高级语法我在这里就不讲解了，如果感兴趣可以去百毒自己看。\n好的现在开始说一说“表（table）”。\n表是lua中很重要的一种数据结构，它可以被修改。可以增加减少。初始化一个空表需要像以下这样。\nlocal example1= {}复制代码如果你使用type(example1)来查看他的类型，你会得到“table”<--这是一个string类型的返回值。\n你也可以初始化一个具有内容的表。比如...\nlocal example2 = {\n  [1] = \"a\",\n  [2] = \"b\",\n  [3] = \"c\"\n}复制代码这样你就会初始化一个具有三个元素的表。1代表的是字符串a，2代表的是字符串b，3代表的是字符串c。记得加逗号！你不仅可以使用数字作为索引，可以使用字符串作为索引，比如...\nlocal example3 = {\n  [\"a\"] = \"first\",\n  [\"b\"] = \"second\",\n  [\"c\"] = \"third\"\n}复制代码这样的话你就可以使用字符串来访问数组元素了。访问数组元素有两种方式，如下：print(example1.a)\n    --nil，因为已经注册为table的表example1中没有a这个元素\nprint(example2.1)\n    --报错，因为int类型的索引不可以用小数点访问\nprint(example2[1])\n    --a\nprint(example3.a)\n    --first\nprint(example3[a])\n    --nil，因为此时a被视为变量a，而不是字符串a，因为变量a并没有被注册，所以实际上值是nil\nprint(example3[\"a\"])\n    --first，这里a指的是字符串a复制代码所以，对于一个表来讲，你可以使用小数点，或者中括号（角标）来访问他的元素。表在lua中之所以是最重要的组成部分是因为它可以实现函数数组。\n你可以通过注册新元素的方式来为一个表添加新数组。就可以通过小数点来访问这个函数了。如下。example4 = {}\n\nfunction example4.exampleFunction()\n  print(\"Hello World!\")\nend\n\nexample4.exampleFunction()\n    --Hello World!复制代码如果你在表中注册了一个具有local关键字的函数，那么你就不可以在表外访问他。比如：local example4.privateExampleFunction()\nprint(\"This is a local function.\")\nend\n\nexample4.privateExampleFunction()\n--报错，因为你无法从example4外访问一个属于example4的local函数复制代码行了，大概的说完了。如果你想要更详细的内容可以看看lua的教程上去，百度一搜啥都有。我就不说是哪家了省得你们说我恰饭。\nOC中的组件操作和硬件注册\n接下来是组件操作和硬件注册，在这里你将会学到如何注册你已经连接至计算机或安装至机器人的硬件或者升级并且使用它们提供的方法来操纵它们。\n先说说OC特有的模块吧。OC常用的模块有以下几个：\ncomponent（组件）\nfilesystem（文件系统）\ncomputer（电脑相关）\nthread（多线程）\nevent（监听器）\nrobot（机器人硬件操纵，电脑没有，只有机器人才有）\n当然，还有以下几个系统自带的库，是不需要import的：\nstring（字符串操作）\ntable（表操作）\nmath（数学方法和算法）\nos（系统）\nio（输入输出）\n咱们就先说component吧。\n废话不说，直接代码。local Main = require(\"component\")\n\nlocal MODEM = Main.proxy(Main.list(\"modem\")())\n    --注册硬件网卡/无线网卡/高级无线网卡（虽然很坑但是他们都叫modem）\nlocal TUNNEL = Main.proxy(Main.list(\"tunnel\")())\n    --注册P2P网卡（就是连接卡啦）复制代码所以说实际上，你连接的所有硬件都是归component管的。他才是老大。那么，怎么查看你已经安装了的硬件呢？\n你可以使用component提供的list()函数。这将会列出所有已经安装的硬件。但是注意，他可能会省略很多内容。Main.list()返回的是一个表，于是你print他的话他会给你返回这个表的地址（看起来是这样滴-->0x????????????）。于是你就可以使用迭代器来输出所有的表内容。\nfor addr, name in pairs(Main.list()) do print(addr..\": \"..name) end复制代码这样他就会输出你所有已经安装的硬件了。左侧将会显示硬件的地址，右侧会显示硬件的类型。component提供的proxy()函数意在于将一个硬件所提供的功能列表整合为一个表返回，返回值是一个table。要求一个参数，就是硬件的地址。在OC中硬件地址是一个长度为36位的包含四个横线，若干小写字母和数字的字符串。四个横线将32个数字和字母分为了五个部分，每个部分的长度是固定的，分别为8，4，4，4，12。一般来讲注册硬件可以使用一个嵌套，比如我在上文中注册变量MODEM时那样书写。要注意如果想要按条件搜索地址的话list()函数要求的括号有两个，第二个要留空。形如local 变量名 = Main.proxy(Main.list(\"硬件名\")())复制代码如果要输出全部的硬件以及他的地址的话，只要一个括号就足够了。为什么呢\n因为如果你的电脑装有多个相同的硬件，比如服务器会链接大量的中继器，那么你在使用list(\"relay\")时它会将所有的叫做relay的硬件整合成一个table传送回去。但是Main.proxy()要求的是一个字符串，于是就会报错。使用list(\"relay\")()的话他会只返回第一个叫做relay的硬件的地址。\n那么，如果我有N多的相通的硬件，我不能只加载一个啊，咋办？\n那就遍历呗。一个个加。说到遍历，你可以手动，也可以使用“迭代器（iterator）”比如这样的。local tunnelList = {}\n\nfor addr, name in pairs(Main.list(\"硬件名称\")) do\n  table.insert(tunnelList, Main.proxy(addr))\nend复制代码我这里就是使用了迭代器。对表tunnelList进行迭代，每迭代一次获得一个地址和它所对应的名字（因为我筛选过了实际上这里的名字一直都是字符串tunnel）。这个就是lua中迭代器的结构。其实你不仅可以对表进行迭代，还可以对字符串进行迭代。对表进行迭代的迭代器结构如下：for 索引, 键值 in pairs(要迭代的表) do\n  要执行的内容\nend复制代码这样你就可以很简单地从tunnelList中找到已经注册好的所有连接卡了。因为使用的是table.insert()方法，所以他们的索引是以数字进行排序的，也就是从tunnelList[1]到tunnelList[N]。使用print(#tunnelList)可以查看你注册了的数量。如果你要查看一个硬件具有的方法的话，可以使用：for func, explain in pairs(注册好的硬件) do\n  if func ~= \"slot\" and func ~= \"type\" then\n    print(func)\n    print(explain)\n  end\nend复制代码这样他就会把硬件的方法名和解释打印在屏幕上。\n\n游戏内因特网系统，结构，以及游戏内服务器（包含地址解析服务器）的搭建\n这是一个大坑，但是做到了之后是一种十分荣耀的事情，这意味着你可以在你的服务器中关闭T键通讯而开始使用...平板电脑来通讯！出了服务区就相当于失联了，但是这也会提供很多有趣的功能（比如水果阵营VS机器人阵营）。有兴趣的人可以尝试一下。我会在帖子最后附上我自己编写的源代码。你们只需要站贴进机器里运行就可以获得整套的完整网络服务了。\n好的，说完了这个，来说说网络吧。首先，你要知道有三种连接方式：\n插线（网线）\n无线连接（无线网卡&高级无线网卡）\nP2P连接（连接卡）\n其中第一种最稳定但是没法用在平板电脑，机器人，无人机等等移动设备上。而且比较贵。第二种覆盖范围大（最大400格）但是出了范围就收不到信号，被黑曜石阻挡更是只能射出10格）。第三种可就牛逼了，点对点。距离就是扯淡，跨世界都不怂。可惜只能连一个。你们少跟我提能量的问题，你都能造出来电脑了，还缺那点儿电不成？我不信你们一个儿个儿的没有核电站。而且实际上根本不用那么高级的玩意儿。一个同位素温差发电机就够了。放上6块靶丸。靶丸你们不缺吧，钚很好弄的。而且可以无限嫖电，岂不美哉？\n那么，我现在发了一条信息，你就会发现你隔壁的机器并miu鸟你。为什么呢？你需要监听啊。就像我跟你说话，我喊了半天你带着耳机听都没听，没用。所以你要在想接受信息的机器上这么写...local Event = require(\"event\")\n\nwhile true do\n  print(Event.pull(\"modem_message\"))\nend复制代码于是你就可以无限收消息了。然而这很讨厌啊，你只能通过ctrl+alt+c来退出这个程序，如果你想远程暂停怎么办呢？好啊，加一个Header吧。那么你现在就具有了一个非常具有结构的数据包。你收到的数据包应该包含以下几个内容。信号类型（在这里是modem_message，即使你是从tunnel接收到的信号，依旧叫做它）\n本地地址（就是那个36位的）\n远程地址（谁发的这个消息）\n端口号（是从哪个端口发来的，对于连接卡而言是0）\n距离（这个只是对于无线网卡而言，有线的和连接卡会显示为0）\n消息体（那个人写了点儿啥）\n因为消息体可以有很多个部分组成。这些零碎消息及合成一个数据包，这个包的名字叫做“帧（frame）”于是就可以从他入手。我常用的帧有以下几个部分：（其中开头字母小写的是由系统自动生成的）\nsignal_type，信号类型\nlocalAddr，本地地址\nremoteAddr，远程地址\nport，端口号\ndistance，距离\nTTL，是嘤语Time To Live的缩写。规定一个包的最大转发次数，超过这个次数的包将会被丢弃。（跟你们讲一定要加，不加的话就会导致“广播风暴（Boradcast Strom）”，相当于遭受了一次ARP病毒的袭击，现实网络那个运算频率都承受不住，更何况我的世界这个20Hz的渣渣？）\nTime，发送这条信息的（游戏内，因为你无法重置OpenOS的时间，至少我现在没发现怎么同步时间到现实时间）时间。\nSender，原始发送者是谁，如果一个消息被某个服务器路由了，有可能会导致系统自动附加的发信人地址不准确。\nReceiver，谁会收信，将会由DNS服务器解析并路由到负责收件人的区域的通讯的总线服务器。总线服务器会继续路由到分支服务器，最终传送到收件人手上。DNS服务器一会儿会说。\nHeader，帧头，用来表示这个数据包的用途。\nBody，数据包包含的实际内容。\n其中Header部分又分为以下几种（当然只是我个人的划分，你们自己看着办）：\nCommand，用来让远程机器执行一个指令。这将会导致远程机器对本地机器产生若干INFO，WARNING或者ERROR反馈。\nSay，向远程机器发送一条不具有任何功能的消息，并且如果Receiver开启了消息接受，它将被显示在屏幕上。并且接受者将对发送者进行一次INFO反馈。\nAddr，从DNS服务器申请地址服务，比如地址解析服务或者更新本地地址数据库等。这将会导致远程机器对本地机器产生若干INFO，WARNING或者ERROR反馈。\ncallBack，远程机器对于你的消息的处理过程或者结果将会以这种帧头被返回。本地机器不会进行反馈。它将在可能的情况下被显示在屏幕上。\nReport，每隔一段时间每个机器会自动地试图联络DNS服务器并报告所属服务区。用来刷新DNS服务器的地址解析数据库。他将不会导致任何来自远程机器的反馈。并且使用者不被允许手动发送具有此种帧头的帧。只能由机器自动决定是否发送。所以建议建立一个独立进程来控制。\n好的那我现在就可以整理一下我的数据发送方法了（我就不写判断输入合法性以及请求地址服务的内容了，比较复杂<--其实只是懒）local Header = {\"Say\", \"Command\", \"Addr\", \"Report\"}\nprint(\"你要发送什么样的数据？\\n[1]向远程机器发送一条短消息\\n[2]在远程机器上运行指令\\n[3]从DNS服务器请求地址服务\")\nlocal choice = io.read()\nprint(\"你是否要指定发送端口？0使用默认端口\")\nlocal port = io.read()\nif port == 0 then port = 1 end\nprint(\"你要发送给谁？要求输入URL或者36位地址\")\nlocal receiver = io.read()\nprint(\"你要发送什么内容？\")\nlocal message = io.read()\nMODEM.send(port, 20, os.date(), MODEM.address, receiver, Header[choice], message)复制代码好的那么我现在再改善一下我的消息接受方法。while true do\n  local type, localAddr, remoteAddr, port, distance, TTL, Time, Sender, Receiver, Header, Body = Event.pull(\"modem_message\")\n  if Header == \"Command\" and Body == \"Stop_remote\" then break end\n  print(\"[\"..Time..\"] from \"..Sender..\": \"..Body)\nend复制代码那么现在我要说了，我在pull的时候只能干等着啊，电脑也用不了，太麻烦了。那好的，改。local Thread = require(\"thread\")\n\nlocal listen = Thread.create(function()\n  while true do\n    local type, localAddr, remoteAddr, port, distance, TTL, Time, Sender, Receiver, Header, Body = Event.pull(\"modem_message\")\n    if Header == \"Command\" and Body == \"Stop_remote\" then break end\n    print(\"[\"..Time..\"] from \"..Sender..\": \"..Body)\n  end\nend)复制代码好的，多线程，perfect。现在这个线程在你启动程序的时候就会潜藏在下面，如果你收到了消息他就会把消息显示在屏幕上。并且不会影响你使用其他的功能。具体怎么停止掉这个线程留给你们思考咯。其实kill就行了。\n然后到了大家最喜欢的机器人环节\n\n机器人\n对，开始说机器人\n机器人吧其实主要就是靠component里面的list+proxy读他的说明书来操纵的，没了。（好敷衍）\n不过其实就是这个意思，实际上很简单。比如判断路的话你可以先扫描一下前方看一下有没有方块有的话扫左面如果还有的话扫右面如果还有的话就扫上面和下面之类的，有一定的顺序。主要说一说“地质分析仪（geolyzer）”吧。这是一个和挖矿息息相关的东西。\n地质分析仪可以一次返回最大64个格之内的所有方块的硬度信息。返回类型是table。具有64个数字。如果扫面范围不足64个后面的内容将会以随机数字补齐至64个。硬度信息，其中：\n基岩硬度为-1（原理是破坏的过程实际上就是一直在减少他的硬度，一旦硬度被减小为0方块就被视为“已经被破坏”，但是-1无论减多大的数字都永远不可能为0，所以基岩无法破坏）\n空气或者其他流体（比如水，岩浆等）的硬度为0\n土等易破坏物体硬度为1\n石头等比较坚硬的物体硬度为2\n矿石的硬度为3（无论是来自于哪个mod的矿石硬度都是3）\n黑曜石的硬度是50\n其他的方块具体看情况分析。\n他返回的硬度实际上不是准确的数字，而是一个不确定的值，这个值的偏差在正负0.5。也就是说如果你的前方有一块黑曜石他会返回一个介于49.5到50.5之间的数字，而且小数位数很长...你不要管他。反正你的目的就是挖矿。也就是说你要找到硬度在2.5到3.5之间的方块然后挖掉它。\n然而寻路一直是一个很困难的问题，这需要一种非常高端的模型叫做TSP（旅行商模型），是一种状压dp算法（具有状态压缩的动态编程算法）...没学过OI的应该懵逼了。算了你不要理他。所以，如果你不想去研究它的话，最好的方式就是...\n全都挖了= =\n或者你也可以选择直线挖过去，直线挖回来。否则运行TSP的话可能会让JVM爆了你电脑/服务器的菊花。（那我他妈的为什么还要装geolyzer？？？）\n不骗你们。真的。骗你们我是小狗。到时候把石头和土再撇掉就好了。\n说到收集物品。机器人是不会自动吸取物品的。也就是说你需要手动设置吸取。这里很推荐各位合个物品磁铁。真的很有用。天使方块没用，飞行升级更没用。储物空间搞大点儿，电池升级和太阳能升级选一个（我全都要<--精神小伙不请自来），大电池就是没电了回家，太阳能就是没电了浮上去充电（无惨来出来我请你晒太阳啊！）所以机器人一定要注意能源管理，否则你可能就要失去你亲爱的宝...机器人了（我就是这么丢过很多，但是还好后来我开发了个极限电池电量自动报告坐标的功能于是避免了再丢机器人）。\n另外，机器人一定！一定！一定！要带连接卡！无线网卡进地底下就废了！别图便宜不带连接卡最后整个机器人都没了！\n稍微提一下吧，detect()方法是检测方块，他会告诉你是不是可以穿透的，是空气，方块，实体还是流体。空气和流体属于可以穿透的，实体和方块是不可以穿透的。另外，如果你的机器人被什么东西卡住，他就会被卡在那里，比如你让他往前走10步，但是他走第5步时被卡住了，那么就算你之后把他面前的障碍物移开，他也停在那里不会走了。对于这一点那些用记步来定位的小伙伴们要注意了，要避障。被挡住的时候不要记步数。否则你们的机器人可能不会从正门回来，而是从...你家地下室挖穿你可爱的墙回来...这一点主要是针对于实体，就比如在矿洞挖矿时被某只怪物挡住了路。\n另外，尽量让移动和电量检测作为同级别的线程来运行，一旦电量检测发现机器人电量过低就把移动线程kill掉然后强制执行上浮/回家的方法。\n\n关于因特网卡\n这个卡他就是爸爸，他就是神。他可以使用真实的互联网，对，我指的是那种可以登录百毒.com的互联网。所以你可以使用wget来获取你在其他地方的内容。将它直接下载到游戏内。\n使用\nwget 下载链接复制代码就可以将你想要的内容下载下来了，注意，是下载链接。比如我就在用github的raw连接下载。而不是blob链接。徕，话说Sublime写lua是真的舒服，不过我用的是Mac，不知道Windows有miu这个玩意儿。\n\n后记\n我也不知道我这次还能回坑多久，所以这个帖子还会更新，不会弃坑，但是更新频率不一定。有问题的话在下面留言，我会尽可能回复你们的。有事情也可以加我QQ2530325542，玄学上线，所以你们发了加好友之后可能得等几天。\n\n最后\n附上我的一段DNS服务器代码吧（还没写完，你们先凑合看，回头我再完善），顺便介绍下网络搭建的机制。\nDNS服务器的作用是将一个36位地址解析为一个网址，或者将一个网址解析为一个36位地址。以及寻址。\n在我的服务器里DNS服务器在地球，他连接了18个中继器，每个中继器都有一个连接卡连接着各个世界的骨干服务器（也就是那个世界的最高级服务器，所有骨干服务器的老大就是这个DNS服务器）。因为Report帧的存在每个机器（比如你随身带的平板）在开机时都会以固定频率发送自己的位置。可以刷新DNS服务器中的客户端-服务器的匹配。把你定位在最合适的服务区内（因为无线网卡只有最大400格的有效距离），以为你提供数据服务。骨干服务器在收到来自于DNS服务器的消息之后就会把消息再分配到子级服务器，再层层分配，最后到你的手里。或者选择合适的链路将这个信息在服务器间传递（如果你离那个世界的骨干服务器很远的话）。\n所以实际上你发送一条消息的过程是这样的：\n发件人\n    编辑消息\n    发送消息\n子服务器（发件人）\n    通过有线/无线网络\n    路由消息到骨干服务器/下一个子服务器\n骨干服务器（发件人）\n    通过连接卡P2P\n    路由消息到DNS服务器\nDNS服务器\n    解析发件人地址到URL\n    解析收件人URL到地址（如果可能）\n    解析收件人所处服务器，指定骨干服务器\n    检查发件人是否存在于已注册设备列表中\n    检查收件人是否存在于已注册设备列表中\n    检查帧头是否合法\n    路由信息到收件人所处的骨干服务器\n骨干服务器（收件人）\n    检查收件人是否是自己\n    解析收件人所处子服务器，如果过于遥远选择合适线路\n    路由信息到收件人所处的子服务器\n子服务器（收件人）\n    检查收件人是否是自己\n    检查收件人是否位于服务区内（向收件人发送一条具有Command帧头空报文的帧并要求反馈）\n    路由信息到收件人\n收件人\n    收到信息\n这个是对于Command和Say的信息，对于Report信息就比较复杂。它是一个广播式的传递\n发件人\n    发送Report信息\n子服务器\n    路由信息到骨干服务器\n骨干服务器\n    路由信息到DNS服务器\nDNS服务器\n    检查Report信息是否和数据库所存储的内容一致\n    如果不一致，刷新数据库并且下发刷新的内容到更新前后的服务区所属的骨干服务器以及其全部子服务器\n骨干服务器\n    使用刷新的内容刷新本地数据库\n    将刷新的内容派发至全部子服务器\n子服务器\n    使用刷新的内容刷新本地数据库\n我现在也在完善这个转发机制，如果双方都同在一个服务区内子服务器可以通过请求DNS.addr_service.translate()方法<--OC没有自带这个方法，必须要你自己实现）来在URL和36位地址之间互相翻译。然后不通过DNS服务器直接派发至收件人。当然，我需要时间。\n我发这么长的帖子花了五个小时，但是估计浏览量也不会很高，毕竟是冷门的mod，而且非常技术向。但是我只是觉得OC在国内的汉化资料和教程太少了，想补充这一块儿而已。好了，祝大家玩得愉快。后续还有Server.lua，Main_Server.lua，Device.lua以及Robot.lua等等，但是都还没写完，我正在重新构建。代码在这里：文件名：DNS.lua已经重构完了，可以用了。local Thread = require(\"thread\")\nlocal Core = require(\"computer\")\nlocal Monitor = require(\"event\")\nlocal Main = require(\"component\")\nlocal File = require(\"filesystem\")--注册模块\n\nlocal MO = {}\nlocal TU = {}--注册硬件\n\nlocal TTL = 0\nlocal Time = \"Unknown\"\nlocal Sender = \"Unknown\"\nlocal Receiver = \"Unknown\"\nlocal Header = \"Unknown\"\nlocal Body = \"Unknown\"\nlocal Proxy = \"Unknown\"\nlocal Addr = \"Unknown\"--注册帧段\n\nDNS = {}\nDNS.main = {}\nDNS.communi = {}\nDNS.data = {}\nDNS.data.resolute = {}\nDNS.URL = {}\nDNS.IPA = {}\nDNS.Header = {\n        [\"Command\"] = true,\n        [\"Say\"] = true,\n        [\"callBack\"] = true,\n        [\"Addr\"] = true,\n        [\"Report\"] = true\n}--注册DNS组件\n\nlocal e = \"ERROR\"\nlocal w = \"WARNING\"\nlocal i = \"INFO\"--注册缩写\n\nDNS.ARS = {}\nDNS.AuS = {}\nDNS.Update = {}\nDNS.timer = {}--注册线程组\n\nlocal adminPassword = \"password\"--设置管理员密码\n\nfunction DNS.main.load()--加载数据库到内存\n        local member = \"main.load\"\n        local URL, IPA = io.open(\"URL.lua\", \"r\"), io.open(\"IPA.lua\", \"r\")\n        io.input(URL)\n        if URL ~= nil then\n                if io.read() ~= \"DNS: URL.lua: Database_Header\" then\n                        DNS.main.call(w, member, \"ILG_DB\", \"rewrite\")\n                        DNS.main.create(\"addr\")\n                        URL = io.open(\"URL.lua\", \"r\")\n                end\n        else\n                DNS.main.call(w, member, \"NO_DB\", \"rewrite\")\n                DNS.main.create(\"addr\")\n                URL = io.open(\"URL.lua\", \"r\")\n        end\n        io.input(IPA)\n        if IPA ~= nil then\n                if io.read() ~= \"DNS: IPA.lua: Database_Header\" then\n                        DNS.main.call(w, member, \"ILG_DB\", \"rewrite\")\n                        DNS.main.create(\"proxy\")\n                        IPA = io.open(\"IPA.lua\", \"r\")\n                end\n        else\n                DNS.main.call(w, member, \"ILG_DB\", \"rewrite\")\n                DNS.main.create(\"proxy\")\n                IPA = io.open(\"IPA.lua\", \"r\")\n        end\n        if URL == nil or IPA == nil then\n                DNS.main.call(e, member, \"UNK_ER\", \"untergebrochen\")\n                error(0)\n        end\n        DNS.main.call(i, member, \"DB_LD\", \"fortfahren\")\n        io.input(URL)\n        while true do\n                local url = io.read()\n                if url then\n                        local addr = io.read()\n                        DNS.URL[url] = addr\n                else\n                        break\n                end\n        end\n        io.input(IPA)\n        while true do\n                local addr = io.read()\n                if addr then\n                        local proxy = io.read()\n                        DNS.IPA[addr] = proxy\n                else\n                        break\n                end\n        end\n        return true\nend\n\nfunction DNS.main.create(target)--对被篡改的或者未找到的数据库进行重新建立\n        local member = \"main.create\"\n        if target == \"addr\" then\n                local url = io.open(\"URL.lua\", \"w\")\n                url:write(\"DNS: URL.lua: Database_Header\\nDNS\\n\"..MO.address)\n                url:close()\n        elseif target == \"proxy\" then\n                local ipa = io.open(\"IPA.lua\", \"w\")\n                ipa:write(\"DNS: IPA.lua: Database_Header\\n\")\n                ipa:close()\n        else\n                DNS.main.call(e, member, \"BAD_ARG\", \"fortfahren\")\n                return false\n        end\n        return true\nend\n\nfunction DNS.main.init()--初始化DNS服务器\n        local member = \"main.init\"\n        local port = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,80,8080}\n        local hardware = Main.list(\"modem\")()\n        if hardware ~= nil then\n                MO = Main.proxy(Main.list(\"modem\")())\n                DNS.main.call(i, member, \"HW_LD\", \"fortfahren\")\n        else\n                DNS.main.call(e, member, \"HW_MS\", \"untergebrochen\")\n                error(0)\n        end\n        hardware = Main.list(\"tunnel\")()\n        if hardware ~= nil then\n                TU = Main.proxy(Main.list(\"tunnel\")())\n                DNS.main.call(i, member, \"HW_LD\", \"fortfahren\")\n        else\n                DNS.main.call(w, member, \"HW_MS\", \"fortfahren\")\n        end\n        for key, val in pairs(port) do\n                MO.open(val)\n        end\n        DNS.main.load()\n        DNS.main.watcher()\n        return true\nend\n\nfunction DNS.main.call(range, reporter, class, status)--输出日志信息\n        local member = \"main.call\"\n        print(\"[\"..os.date()..\"] [\"..range..\"] DNS.\"..reporter..\": \"..class..\" status: \"..status)\nend\n\nfunction DNS.main.callR(range, reporter, class, status, receiver)--反馈callBack信息\n        local member = \"main.call\"\n        print(\"[\"..os.date()..\"] [\"..range..\"] from \"..receiver..\": DNS.\"..reporter..\": \"..class..\" status: \"..status)\n        MO.send(DNS.data.proxy(receiver), 1, 100, os.date(), \"DNS\", DNS.data.resolute.url(receiver), \"callBack\", \"[\"..os.date()..\"] [\"..range..\"] DNS.\"..reporter..\": \"..class..\" status: \"..status)\nend\n\nfunction DNS.main.watcher()--看门狗，用来在按下特定按键时kill掉主进程达到结束后台的目的。\n        local member = \"main.WATCHER\"\n        local watcher = Thread.create(function()\n                while true do\n                        local typ, addr, key_1, key_2 = Monitor.pull(\"key_down\")\n                        if key_1 == 0 and key_2 == 54 then DNS.main.call(i, member, \"PRG_END\", \"Main Thread has been killed by DNS.main.WATCHER.\") main:kill() end\n                end\n        end)\nend\n\nfunction DNS.communi.monitor()--创建主监视器\n        DNS.main.init()\n        local member = \"communi.monitor\"\n        DNS.main.call(i, member, \"MT_LD\", \"fortfahren\")\n        local main = Thread.create(function()\n                while true do\n                        while true do\n                                _, localAddr, remoteAddr, port, distance, TTL, Time, Sender, Receiver, Header, Body = Monitor.pull(\"modem_message\")\n                                if TTL <= 0 then break end\n                                TTL = TTL-1\n                                Sender = DNS.data.resolute.url(Sender)\n                                if Sender == nil then DNS.main.call(e, member, \"UNK_SED\", \"abuntergebrochen\") break end\n                                if Receiver == \"DNS\" then\n                                        if Header == \"Addr\" then\n                                                table.insert(DNS.ARS, Thread.create(DNS.data.ARS(Sender, Header, Body)))\n                                        elseif Header == \"Command\" then\n                                                table.insert(DNS.AuS, Thread.create(DNS.communi.AuS(Sender, Header, Body)))\n                                        elseif Header == \"Say\" then\n                                                DNS.main.callR(e, member, \"NO_PER\", \"REF\", DNS.data.resolute.addr(Sender))\n                                                break\n                                        elseif Header == \"callBack\" then\n                                                print(\"[\"..os.date()..\"] [INFO] [callBack] from \"..Sender..\": \"..Body)\n                                        elseif Header == \"Report\" then\n                                                local proxy = \"\"\n                                                local time = 0\n                                                for word in pairs(Body, \"%w+\") do\n                                                        proxy = proxy..word\n                                                        time = time + 1\n                                                        if time == 5 then break end\n                                                        proxy = proxy..\"-\"\n                                                end\n                                                DNS.data.IPAupdate(DNS.data.resolute.addr(Sender), proxy)\n                                        end\n                                end\n                                Receiver = DNS.data.resolute.addr(Receiver)\n                                if Receiver == nil then DNS.main.callR(e, member, \"UNK_REC\", \"abuntergebrochen\", DNS.resolute.addr(Sender)) break end\n                                MO.send(DNS.data.proxy(Receiver), 1, TTL, Time, Sender, Receiver, Header, Body)\n                        end\n                end\n        end)\n        os.execute(\"clear\")\n        DNS.main.call(i, member, \"Press right SHIFT to kill the monitor.\", \"fortfahren\")\n        print(\"\\n\\n\")\n        DNS.main.call(i, member, \"Press ctrl+alt+C to continue.\", \"fortfahren\")\n        print(\"\\n\\n\")\nend\n\nfunction DNS.communi.AuS(sender, header, body)--鉴权\n        local member = \"communi.AuS\"\n        MO.send(DNS.data.proxy(sender), 1, 100, os.date(), \"DNS\", DNS.data.resolute.addr(sender), \"Command\", \"Authentication.\")\n        table.insert(DNS.timer, Thread.create(function() os.sleep(20) DNS.ARS[pos]:kill() return end))\n        local posT = #DNS.timer\n        while true do\n                local _, localeAdre, remoteAdre, anschluss, abstand, ttl, zeit, sed, empfaenger, kopf, koerper = Monitor.pull(\"modem_message\")\n                if sed == sender and kopf == \"Command\" and koerper == \"password\" then break\n                elseif sed == sender and kopf == \"Command\" and koerper ~= adminPassword then DNS.main.callR(e, member, \"NO_PER\", \"abgelehnt\", DNS.resolute.addr(sender)) return false end\n        end\n        DNS.timer[posT]:kill()\n        DNS.main.calR(i, member, \"CMD_ACP\", \"fortfahren\", DNS.resolute.addr(sender))\n        os.execute(body)\n        return true\nend\n\nfunction DNS.data.resolute.addr(target)--ARS服务，强制解析为MAC地址\n        local member = \"data.resolute.addr\"\n        for addr, url in pairs(DNS.URL) do\n                if target == addr or target == url then return addr end\n        end\n        return nil\nend\n\nfunction DNS.data.resolute.change(target)--ARS服务，切换解析内容\n        local member = \"data.resolute.change\"\n        for addr, url in pairs(DNS.URL) do\n                if target == addr then return url end\n                if target == url then return addr end\n        end\n        return nil\nend\n\nfunction DNS.data.resolute.url(target)--ARS服务，强制解析为URL\n        local member = \"data.resolute.url\"\n        for addr, url in pairs(DNS.URL) do\n                if target == addr or target == url then return url end\n        end\n        return nil\nend\n\nfunction DNS.data.proxy(target)--ARS服务，解析所在服务区\n        local member = \"data.proxy\"\n        for addr, proxy in pairs(DNS.IPA) do\n                if target == addr or target == proxy then return proxy end\n        end\n        return nil\nend\n\nfunction DNS.data.ARS(sender, header, body)--ARS远程解析服务\n        local member = \"data.ARS\"\n        local pos = #DNS.ARS\n        local message = {}\n        for word in string.gmatch(body, \"a%+\") do\n                table.insert(message, word)\n        end\n        if message[1] == \"download\" then\n                if message[2] then DNS.main.callR(e, member, \"BAD_ARG\", \"untergebrochen\", DNS.resolute.addr(sender)) return false end\n                MO.send(DNS.data.proxy(sender), 1, 100, os.date(), \"DNS\", DNS.data.resolute.addr(sender), \"Addr\", \"Request accepted.\")\n                table.insert(DNS.timer, Thread.create(function() os.sleep(10) DNS.ARS[pos]:kill() return end))\n                local posT = #DNS.timer\n                while true do\n                        local _, localeAdre, remoteAdre, anschluss, abstand, ttl, zeit, sed, empfaenger, kopf, koerper = Monitor.pull(\"modem_message\")\n                        if sed == sender and kopf == \"Addr\" and koerper == \"ready.\" then break end\n                end\n                DNS.timer[posT]:kill()\n                for addr, url in pairs(DNS.URL) do\n                        MO.send(DNS.data.proxy(sender), 1, 100, os.date(), \"DNS\", DNS.data.resolute.addr(sender), \"Addr\", addr..\" \"..url)\n                end\n                MO.send(DNS.data.proxy(sender), 1, 100, os.date(), \"DNS\", DNS.data.resolute.addr(sender), \"Addr\", \"Request ended.\")\n                return true\n        elseif message[1] == \"request\" then\n                if message[3] then DNS.main.callR(e, member, \"BAD_ARG\", \"untergebrochen\", DNS.resolute.addr(sender)) return false end\n                MO.send(DNS.data.proxy(sender), 1, 100, os.date(), \"DNS\", DNS.data.resolute.addr(sender), \"Addr\", DNS.data.change(body[2]))\n                return true\n        elseif message[1] == \"update\" then\n                if message[3] then DNS.main.callR(e, member, \"BAD_ARG\", \"untergebrochen\", DNS.resolute.addr(sender)) return false end\n                DNS.data.URLupdate(sender, message[2])\n        else\n                DNS.main.callR(e, member, \"BAD_ARG\", \"untergebrochen\", DNS.resolute.addr(sender))\n                return false\n        end\n        return true\nend\n\nfunction DNS.data.URLupdate(target, url)--刷新URL数据\n        for addr, val in pairs(DNS.URL) do\n                if target == addr then\n                        if val ~= url then \n                                DNS.URL[target] = url\n                                DNS.data.writeDownown(\"addr\")\n                                DNS.main.call(i, member, \"DB_UPD\", \"fortfahren\")\n                        else return true end\n                end\n        end\n        return true\nend\n\nfunction DNS.data.IPAupdate(target, proxy)--刷新IPA数据\n        for addr, server in pairs(DNS.IPA) do\n                if target == addr then\n                        if server ~= proxy then \n                                DNS.IPA[target] = proxy\n                                DNS.data.writeDownown(\"proxy\")\n                                DNS.main.call(i, member, \"DB_UPD\", \"fortfahren\")\n                        else return true end\n                end\n        end\n        return true\nend\n\nfunction DNS.data.writeDown(target)--将内容写至数据库\n        if target == \"addr\" then\n                DNS.main.create(target)\n                local file = io.open(\"URL.lua\", \"a\")\n                io.output(file)\n                for addr, url in pairs(DNS.URL) do\n                        io.write(addr..\"\\n\")\n                        io.write(url..\"\\n\")\n                end\n                io.close(file)\n        elseif target == \"proxy\" then\n                DNS.main.create(target)\n                local file = io.open(\"IPA.lua\", \"a\")\n                io.output(file)\n                for addr, proxy in pairs(DNS.IPA) do\n                        io.write(addr..\"\\n\")\n                        io.write(proxy..\"\\n\")\n                end\n                io.close(file)\n        end\nend复制代码\n\n\n\n文件名：Server.lua\n正在重构\n\n\n\n文件名：Main_Server.lua\n正在重构\n\n\n\n文件名：Device.lua\n正在重构\n\n\n\n\n文件名：Robot.lua\n正在重构\n\n\n接下来是图示服务器构成。名词解释：\nADS = Address Download Service，地址解析数据库下载服务\nAS = Address Service，地址服务\nARS = Address Resolution Service，地址解析服务\nAuS = Authentication Service，鉴权服务\nAUS = Address Update Service，地址刷新服务\nBBNA = Backbone Network Architecture，骨干网络体系结构BNS = Backbone Network Server，骨干网络服务器\nBS = Broadcast Storm，广播风暴\nDNS = Domain Name System，域名系统\nLSA = Loop Server Array，环路服务器阵列\nMAC地址 = Media Access Control Address，媒体存取控制地址，物理地址\nSA = Service Area，服务区\nSSA = Star Server Array，星型服务器阵列\nTTL = Time To Live，生存时间\n\n\nINFO，WARNING以及ERROR中的缩写及德语词汇解释：\nILG = ILeGal非法的OFL = OFfLine，离线的\nHDR = HeaDeR帧头\nHW = HardWare，硬件\nMS = MiSsing，缺少\nBAD = BAD，无法识别的，损坏的，被篡改的\nARG = ARGument，参数\nUNK = UNKnown，未知的，无法识别的\nDB = DataBase，数据库\nNO = NO，缺少，丢失\nLD = LoaDed，已经挂载\nPRG = PRoGramme，程序\nEND = END，结束\nMT = Main Thread，主进程\nSED = SEnDer，发报人，发送者\nPER = PERmission，权限\nREC = RECeiver，收报人，收件人\nCMD = CoMmanD，指令，命令\nACP = ACcepted，被接受的\nUPD = UPDated，已升级的\nfortfahren = （德语）=continue，继续\nuntergebrochen = （德语）=has been broken，被中断\nabgelehnt = （德语）=refused，被拒绝的\n\n\n端口用途解释：\n\n0，留空，P2P端口。\n1，DNS和BNS通讯端口。\n2，DNS和BNS通讯端口。\n3，DNS和BNS通讯端口。\n4，BNS和auxiliary Server通讯端口。\n5，BNS和auxiliary Server通讯端口。\n6，BNS和auxiliary Server通讯端口。\n7，auxiliary Server间通讯端口。\n8，auxiliary Server间通讯端口。\n9，auxiliary Server间通讯端口。\n10，auxiliary Server间通讯端口。\n11，auxiliary Server间通讯端口。\n12，auxiliary Server和Client间通讯端口。\n13，auxiliary Server和Client间通讯端口。\n14，auxiliary Server和Client间通讯端口。\n15，auxiliary Server和Client间通讯端口。\n16，auxiliary Server和Client间通讯端口。\n17，auxiliary Server和Client间通讯端口。\n18，auxiliary Server和Client间通讯端口。\n19，auxiliary Server和Client间通讯端口。\n20，auxiliary Server和Client间通讯端口。\n21，auxiliary Server和Client间通讯端口。\n22，auxiliary Server和Client间通讯端口。\n23，auxiliary Server和Client间通讯端口。\n80，特殊端口。\n8080，特殊端口。\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "cybmp3",
            "timestamp": 1573084020,
            "txt_content": "我是因为装了曲率驱动才装了这玩意。这也太炫酷了吧！支持楼主完善编辑。以后有的学习了。"
        },
        {
            "author": "sunch420",
            "timestamp": 1573114080,
            "txt_content": "cybmp3 发表于 2019-11-7 00:47\n我是因为装了曲率驱动才装了这玩意。这也太炫酷了吧！支持楼主完善编辑。以后有的学习了。 ...\n好啊我也正在肝代码????"
        },
        {
            "author": "E.T.星落辰",
            "timestamp": 1573275900,
            "txt_content": "……十多年？"
        },
        {
            "author": "sunch420",
            "timestamp": 1573292460,
            "txt_content": "E.T.星落辰 发表于 2019-11-9 06:05\n……十多年？\n啊，对啊。大概吧，刚出的时候就有在玩了。因为是在德国读书所以接触的比较早些。就是地狱还长树的那个版本。iPad版也是刚开始就玩了，刚开始还是Lite不能保存地图，一删后台地图就没了。"
        },
        {
            "author": "Twilight_Two",
            "timestamp": 1574067780,
            "txt_content": "这就是传说中的服中服脑中脑吗"
        },
        {
            "author": "w1453656098",
            "timestamp": 1574128620,
            "txt_content": "零基础详细教学！支持一下"
        },
        {
            "author": "w1453656098",
            "timestamp": 1574485380,
            "txt_content": "教程很详细 谢谢大佬"
        },
        {
            "author": "血影Czray",
            "timestamp": 1576987380,
            "txt_content": "。。。。。。。。。。。，"
        },
        {
            "author": "名为123的貘",
            "timestamp": 1580479440,
            "txt_content": "sunch420 发表于 2019-11-9 17:41\n啊，对啊。大概吧，刚出的时候就有在玩了。因为是在德国读书所以接触的比较早些。就是地狱还长树的那个版 ...\n十几年？"
        },
        {
            "author": "zhengyi200012",
            "timestamp": 1580618220,
            "txt_content": "世界最远的距离，不是生和死，而是路就在你身旁，你却看不到"
        },
        {
            "author": "2670115244",
            "timestamp": 1580624580,
            "txt_content": "这模组，教我我也不一定会呀。。。"
        }
    ]
}