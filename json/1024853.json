{
    "title": "PVPIN教程RL--ItemStack NBT 的理论基础与反射操作理论部分",
    "author": "William_Shi",
    "replyCount": 0,
    "timestamp": 1587438300,
    "txt_content": " 本帖最后由 William_Shi 于 2020-6-25 13:08 编辑 \n\n本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引\n本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\n\n译名规范（PVPIN式翻译）\n\nNBTTagCompound           NBT混合数据包   \nNBTTagByte                     NBT字节数据包\nNBTTagDouble                 NBT双精度小数数据包（更习惯称作NBT双精度浮点数数据包）\nNBTTagFloat                    NBT单精度小数数据包（更习惯称作NBT单精度浮点数数据包）\nNBTTagI                           NBT整数数据包\nNBTTagLong                    NBT长整数数据包\nNBTTagShort                    NBT短整数数据包\nNBTTagString                   NBT字符串数据包\nNBTTagIntArray                NBT整数数组数据包\nNBTTagByteArray              NBT字节数组数据包\nNBTTagList                       NBT列表数据包\nNBTTagBase                     NBT基础数据包\n\n\n\nNBT介绍\nhttps://www.mcbbs.net/thread-697478-1-1.html\n在莫老的教程里对于“NBT是什么”有完整介绍\n每个物品都可能有一个NBT混合数据包\n如果物品堆有一个NBT混合数据包，那么它有且仅有一个最外层的NBT混合数据包，就像json中最外层的{}一样，表示了最外层的一个大对象，包括其所有数据\n在这个NBT混合数据包中，有很多数据键\n每一个数据键都对应了一个NBT基础数据包（亦可能有NBT混合数据包）\nNBT基础数据包是上述译名规范中所有数据包的父类，是抽象类，\n所有的其他NBT数据包都是NBT基础数据包的子类\n然而BukkitAPI本身操作NBT是受到很大局限的（只能操作display和属性修改等原版定义好的数据键，无法操作自定义数据键）\n因此使用NMS去操作NBT就很为重要\n\n元数据操作\n这是Bukkit自带的NBT操作\n任何带有Meta字样且继承ItemMeta的接口或类，本质上都是NBT操作，只不过不需要你去操心NMS的版本号\n如：\npublic interface PotionMeta\nextends ItemMeta\n\n这些“元数据（Meta）”本质上都是对着NBT进行了操作\n比如说PotionMeta就是对着CustomPotionEffects数据键进行操作（以及原版的Potion数据键）\n而这些元数据的好处就是不会涉及任何OBC、NMS的内容\n因此元数据的操作是很方便的，具体如何操作可看doc，编程开发区也有相关教程\n比如说https://www.mcbbs.net/thread-782974-1-1.html\n\n较为常用的就是display数据键，存储物品displayname、lore等等数据\n同样较为常用的是AttributeModifier，即（我个人喜欢叫）NMS属性修改器，莫老的教程介绍的很详细，这里也不展开了\n\n接下来介绍NMS的操作\nNMS，是net.minecraft.server.v1_1x_Rx包的简称\nOBC，是org.bukkit.craftbukkit.v1_1x_Rx包的简称\n这里的1_1x_Rx是版本号，mc的版本不同，对应不同的包名\n由此可见，obc、nms操作会对插件兼容性产生很大影响\n接下来我的所有操作将会全程反射\n如果您认为反射不好，可以直接使用ProtocolLib，因为plib的包名不变\n当然也有另外的办法比如说修改字节码改版本号，此处就不去讨论了\n\n通过NMS进行操作\n首先是版本号\npublic String version = org.bukkit.Bukkit.getServer().getClass().getPackage().getName().replace(\".\", \",\").split(\",\")[3];\n接下来直接反射取我们需要的类\n\n之后进行反射，建议写一个Utils类并且在onEnable里调用初始化的方法，完成全部反射\n\n这里就使用了字符串的拼接消除NMS的影响\n并没有反射获取所有的数据包类型，可以根据需要获取你需要的数据包类型\n\n这里有一点我想着重强调\n每个版本的nms都有一些小的差异\n比如说1.13里可以新建某个NBT数据包（比如说双精度浮点数数据包），但是1.15里构造器被私有化了，用一个 a 方法 来新建数据包（加上了入参检测），那也就意味着，很可能原来的新建数据包的方式就不能用了\n那么如何消除这些带来的影响呢？\n其实有一种办法，不涉及到NBT数据包本身，那就是直接使用setxxx和getxxx\n\nnet.minecraft.server.v1_15_R1.NBTTagCompound 类：\n  \n  @Nullable\n  public NBTBase set(String var0, NBTBase var1) {\n    return this.map.put(var0, var1);\n  }\n  \n这就是直接调用set方法，需要传入NBTBase参数，实际使用就是比如传入NBT整数数据包这样的具体数据包\n那么由上文所说，很有可能因为版本间的小改动，导致多版本兼容很麻烦\n\n该怎么办呢？\n\n\n\n  public void setByte(String var0, byte var1) {\n    this.map.put(var0, NBTTagByte.a(var1));\n  }\n  \n  public void setShort(String var0, short var1) {\n    this.map.put(var0, NBTTagShort.a(var1));\n  }\n  \n  public void setInt(String var0, int var1) {\n    this.map.put(var0, NBTTagInt.a(var1));\n  }\n  \n  public void setLong(String var0, long var1) {\n    this.map.put(var0, NBTTagLong.a(var1));\n  }\n\n  \n  public void setFloat(String var0, float var1) {\n    this.map.put(var0, NBTTagFloat.a(var1));\n  }\n  \n  public void setDouble(String var0, double var1) {\n    this.map.put(var0, NBTTagDouble.a(var1));\n  }\n  \n  public void setString(String var0, String var1) {\n    this.map.put(var0, NBTTagString.a(var1));\n  }\n  \n  public void setByteArray(String var0, byte[] var1) {\n    this.map.put(var0, new NBTTagByteArray(var1));\n  }\n  \n  public void setIntArray(String var0, int[] var1) {\n    this.map.put(var0, new NBTTagIntArray(var1));\n  }\n  \n  public void setBoolean(String var0, boolean var1) {\n    this.map.put(var0, NBTTagByte.a(var1));\n  }\n  \n\n\n同理可得\n\n\n  \n  public byte getByte(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asByte(); \n    } catch (ClassCastException classCastException) {}\n    return 0;\n  }\n  \n  public short getShort(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asShort(); \n    } catch (ClassCastException classCastException) {}\n    return 0;\n  }\n  \n  public int getInt(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asInt(); \n    } catch (ClassCastException classCastException) {}\n    return 0;\n  }\n  \n  public long getLong(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asLong(); \n    } catch (ClassCastException classCastException) {}\n    return 0L;\n  }\n  \n  public float getFloat(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asFloat(); \n    } catch (ClassCastException classCastException) {}\n    return 0.0F;\n  }\n  \n  public double getDouble(String var0) {\n    try {\n      if (hasKeyOfType(var0, 99))\n        return ((NBTNumber)this.map.get(var0)).asDouble(); \n    } catch (ClassCastException classCastException) {}\n    return 0.0D;\n  }\n  \n  public String getString(String var0) {\n    try {\n      if (hasKeyOfType(var0, 8))\n        return ((NBTBase)this.map.get(var0)).asString(); \n    } catch (ClassCastException classCastException) {}\n    return \"\";\n  }\n  \n  public byte[] getByteArray(String var0) {\n    try {\n      if (hasKeyOfType(var0, 7))\n        return ((NBTTagByteArray)this.map.get(var0)).getBytes(); \n    } catch (ClassCastException var1) {\n      throw new ReportedException(a(var0, NBTTagByteArray.a, var1));\n    } \n    return new byte[0];\n  }\n  \n  public int[] getIntArray(String var0) {\n    try {\n      if (hasKeyOfType(var0, 11))\n        return ((NBTTagIntArray)this.map.get(var0)).getInts(); \n    } catch (ClassCastException var1) {\n      throw new ReportedException(a(var0, NBTTagIntArray.a, var1));\n    } \n    return new int[0];\n  }\n  \n  public long[] getLongArray(String var0) {\n    try {\n      if (hasKeyOfType(var0, 12))\n        return ((NBTTagLongArray)this.map.get(var0)).getLongs(); \n    } catch (ClassCastException var1) {\n      throw new ReportedException(a(var0, NBTTagLongArray.a, var1));\n    } \n    return new long[0];\n  }\n  \n  public NBTTagCompound getCompound(String var0) {\n    try {\n      if (hasKeyOfType(var0, 10))\n        return (NBTTagCompound)this.map.get(var0); \n    } catch (ClassCastException var1) {\n      throw new ReportedException(a(var0, a, var1));\n    } \n    return new NBTTagCompound();\n  }\n  \n  public NBTTagList getList(String var0, int var1) {\n    try {\n      if (e(var0) == 9) {\n        NBTTagList var2 = (NBTTagList)this.map.get(var0);\n        if (var2.isEmpty() || var2.a_() == var1)\n          return var2; \n        return new NBTTagList();\n      } \n    } catch (ClassCastException var2) {\n      throw new ReportedException(a(var0, NBTTagList.a, var2));\n    } \n    return new NBTTagList();\n  }\n  \n  public boolean getBoolean(String var0) {\n    return (getByte(var0) != 0);\n  }\n  \n\n\n那么在数据类型已知的情况下就可以直接对着java本身的变量进行操作，避免NBT数据包的类型\n当然如果有必要也可以直接使用get和set方法得到NBT基础数据包再进行转换\n\n具体如何写出反射获取NBT数据包的代码呢？\n我们先理出思路：\n\n使用OBC的CraftItemStack这个类的方法asNMSCopy获取NMS物品堆\n对NMS物品堆使用getTag获取最外层的NBT混合数据包\n然后对NBT混合数据包再使用hasKey确定是不是存在某一个数据键\n如果存在，那么再使用get对应数据类型的方法来获取数据包（比如getDouble、getFloat）\n\n那么就不难写出这样的代码初始化反射\n\n\n\n\n\n}1S8GE[PQ_1Y)DE7NRR0{4B.png (9.89 KB, 下载次数: 1)\n\n下载附件\n\n2020-4-21 12:42 上传\n\n\n\n\n\n\n\n\n%]H}}`(_ZO(Q9~4MS(G9AF4.png (45.04 KB, 下载次数: 1)\n\n下载附件\n\n2020-4-21 12:45 上传\n\n\n\n\n\n\n说白了就是反射取到NMS、OBC对应的类\n所有的NBT数据包类型在本文最上方给了，其他都是拼接而已\n以上代码建议在插件加载时完成反射\n诚然当反射的方法调用多了之后JVM能提高其效率但是初次反射还是有一定性能占用\n注意我这里没有使用任何含混淆的方法\n因此理论上这段代码是全版本通用的（没仔细查看旧版本的NMS，不过应该都是一样的public方法）\n\n接下来我以取 某个物品的最外层NBT混合数据包是否存在test数据键为例\n\n\n\n\n\n)5LB@_(4%4SUEIEFH_Q4~]U.png (24.71 KB, 下载次数: 1)\n\n下载附件\n\n2020-5-28 20:38 上传\n\n\n\n\n\n\n可以看到此处先判断了物品是不是hasTag，这是为什么呢？\n原因是物品堆不一定有NBT混合数据包\n如果没有，直接new一个出来就可以了（无参构造器）\n然后再通过hasKey判断是不是有这个数据键\n（当然了，如果连混合数据包都没有肯定不存在这个数据键）\n\n在接下来的是取 gettest 这个数据键对应的 NBT整数数据包\n\n\n\n\n\nD~]VD$%6@]T]T43HN%W9$)D.png (21.71 KB, 下载次数: 1)\n\n下载附件\n\n2020-5-28 20:38 上传\n\n\n\n\n\n\n这也非常简单了，直接使用getInt方法就行\n当然我这里先用了NBTBase再toString然后parse\n是为了额外说明，NBTBase覆写了toString方法\n\n之后我在写NBT实践的时候会仔细写一段实例并详解\n另外这篇实例也不错，值得学习借鉴\nhttps://www.mcbbs.net/thread-1049313-1-2.html\n\n",
    "replies": []
}