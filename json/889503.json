{
    "title": "【第二章】Scala从入门到入土 - 函数类型，Function以及PartialFunction",
    "author": "yuxuanchiadm",
    "replyCount": 0,
    "timestamp": 1563716220,
    "txt_content": " 本帖最后由 yuxuanchiadm 于 2019-7-21 21:36 编辑 \n\n【索引贴】https://www.mcbbs.net/thread-887515-1-1.html\n\n函数类型\n\n在Scala中，函数类型实际上是Function0到Function22类型的值例如：\nFunction0[String] ≡ () => StringFunction1[Int, String] ≡ Int => StringFunction2[Int, Unit, String] ≡ (Int, Unit) => String\n参数数量大于等于2的函数类型都有2个成员函数：\ncurried：将此函数类型的值进行柯里化tupled：将此所有的参数打包进Tuple内\n需要注意的是以上函数类型都应该对所有参数的所有可能的值有定义，也就是[ruby=Total Function]全函数[/ruby]，任何函数类型的值都应该遵守这个约定。但是并不要求其必须是[ruby=Pure Function]纯函数[/ruby]，也就是说函数类型的值是可以有[ruby=Side Effect]副作用[/ruby]的，虽然引入副作用在大多数情况下都可能是不必要的。且只要副作用不暴露在外部，就没有任何问题，例如对函数进行求值后缓存其结果就是对副作用的正确应用方式。\n\n部分函数\n\n如果你的函数可能对部分参数的值没有定义，则应该将其定义为[ruby=Partial Function]部分函数[/ruby]。部分函数在Scala中是PartialFunction类型，可以由A => Option[B]类型的函数的值通过Function.unlift函数转换得到，也可以通过模式匹配匿名函数的方式来定义，如下例所示：\nval pf0: PartialFunction[Int, String] = Function.unlift(i => if(i == 0) Option(\"Zero\") else Option.empty)\nval pf1: PartialFunction[Int, String] = { case 0 => \"Zero\" }复制代码另外可以调用lift成员函数将其转换回A => Option[B]的普通函数。\n",
    "replies": []
}