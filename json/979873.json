{
    "title": "[Tutorial][数学向]从零开始的MC特效(六 | 坐标系的旋转)",
    "author": "602723113",
    "replyCount": 6,
    "timestamp": 1583646300,
    "txt_content": " 本帖最后由 602723113 于 2020-3-19 19:38 编辑 \n\n[Tutorial][数学向]从零开始的MC特效(六 | 坐标系的旋转)我胡汉三又回来啦！目录:\n导读Location点的旋转坐标系的修正与在玩家背部建立坐标系制作简易翅膀\n导读本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)本教程使用的 PaperSpigot1.12.2-R0.1-SNAPSHOT 核心在阅读之前请确保你具有高中数学必修4和和Java基础的知识\n\n\n<To初中生>: 如果你是初中的话，别慌，你有趋向的概念就可以读懂本教程(应该吧...) <To高中生>: 如果你还未学到关于上面的那本书，别慌学到了再来看也行233 (雾 <To大学生>: 没什么好说的...\n\n\n\nLocation点的旋转\n首先我们引入平面上点围绕另一个点进行旋转的公式 (数学上) 平面中，一个点(x,y)绕任意点(x0,y0)逆时针旋转a度后的坐标\ndx = (x - x0)*cos(a) - (y - y0)*sin(a) + x0 ;\ndy = (x - x0)*sin(a) + (y - y0)*cos(a) + y0 ;复制代码那么我们写入代码看看是怎么样的\n/**\n * 在二维平面上利用给定的中心点逆时针旋转一个点\n * \n * @param location 待旋转的点\n * @param angle    旋转角度\n * @param point    中心点\n * [url=home.php?mod=space&uid=491268]@Return[/url] {[url=home.php?mod=space&uid=41191]@link[/url] Location}\n*/\npublic static Location rotateLocationAboutPoint(Location location, double angle, Location point) {\n    double radians = Math.toRadians(angle);\n    double dx = location.getX() - point.getX();\n    double dz = location.getZ() - point.getZ();\n\n    double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();\n    double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();\n    return new Location(location.getWorld(), newX, location.getY(), newZ);\n}复制代码总所周知，在mc坐标内，玩家走动的二维平面，其实是影响x轴和z轴的内容，所以我们上方的代码就套用x，z\n坐标系的修正与在玩家背部建立坐标系\n\n在我们之前的教程中，我们都会发现，我们在做一些让特效出现在玩家面前时，会出现特效出现在另外一边，这其实就是我们没有经过玩家朝向的修正，而发生的情况，比如下面这一张图\n\n\n\n\n\nfile_1584617704000.jpg (159.41 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-19 19:35 上传\n\n\n\n\n\n那么我们可以重新建立一个修正过后的坐标系，用的方法就是利用Location点的旋转\nimport org.bukkit.Location;\n\n/**\n * 自动修正在平面上的粒子朝向\n * \n * [url=home.php?mod=space&uid=1231151]@author[/url] Zoyn\n */\npublic class PlayerFixedCoordinate {\n\n    private Location zeroDot;\n    private double rotateAngle;\n\n    public PlayerFixedCoordinate(Location playerLocation) {\n        // 旋转的角度\n        rotateAngle = playerLocation.getYaw();\n        zeroDot = playerLocation.clone();\n        zeroDot.setPitch(0);\n        // 重设仰俯角, 防止出现仰头后旋转角度不正确的问题\n    }\n\n    public Location getZeroDot() {\n        return zeroDot;\n    }\n\n    public Location newLocation(double x, double z) {\n        return rotateLocationAboutPoint(zeroDot.clone().add(-x, 0, z), rotateAngle, zeroDot);\n    }\n\n        /**\n     * 在二维平面上利用给定的中心点逆时针旋转一个点\n     * \n     * @param location 待旋转的点\n     * @param angle    旋转角度\n     * @param point    中心点\n     * @return {@link Location}\n     */\n    public static Location rotateLocationAboutPoint(Location location, double angle, Location point) {\n        double radians = Math.toRadians(angle);\n        double dx = location.getX() - point.getX();\n        double dz = location.getZ() - point.getZ();\n\n        double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();\n        double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();\n        return new Location(location.getWorld(), newX, location.getY(), newZ);\n    }\n}复制代码首先我们来分析这个类是怎么写的，首先我们要旋转一个点，就需要旋转的角度，那么这时候 location 里的 yaw 就可以帮助我们完成这个工作，所以我在构造器里将 yaw 记录为 rotateAngle \n\n之后我们看newLocation这个方法，需要填入两个参数分别是 x, y （为了方便理解，我其实直接将其设计为数学上的平面直角坐标系（右手坐标系））\n\n而我们在看\nzeroDot.clone().add(-x, 0, z)复制代码这行代码, 首先它是 rotateLocationAboutPoint 方法里的待旋转的点，那么我们为什么要add呢？ 因为啊, zeroDot 就是我们坐标系的原点，经过add之后就可以得到新的x，y了，\n比如说，zeroDot是(0, 0)，方法填入3, 2, 那么add完之后就得到 (3, 2) 这个点\n那么为什么是-x呢？？？ \n因为啊，在Mc中的坐标系是遵循左手坐标系来设计的，所以它的x轴我们要乘以一个-1才能按照我们平常理解的右手坐标系来绘图。现在我们套用上这个修复过的坐标系来看看效果\n完整代码:\nPlayer player = ........\nPlayerFixedCoordinate coordinate = new PlayerFixedCoordinate(player.getLocation());\n\ndouble radius = 10;\nfor (double t = -1; t <= 1; t += 0.001) {\n    double x = radius * Math.sin(t) * Math.cos(t) * Math.log(Math.abs(t));\n    double y = radius * Math.sqrt(Math.abs(t)) * Math.cos(t);\n\n    Location loc = coordinate.newLocation(x, y);\n    loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, 1, 0, 0, 0, 0);\n}复制代码下面分享一个PlayerBackCoordinate为了让读者能够举一反三，希望读者能够自行添加 z 轴的变化（思考：z轴的变化在右手坐标系中是如何变化，又应该如何将其转换至MC坐标系内）\n绘图思考可以参照这张图：\n\n\n\n\n\n8109631-9ffc52cc57748de2.png (11.33 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-19 19:35 上传\n\n\n\n\n\nimport org.bukkit.Location;\n\n/**\n * 将玩家背后转换为一个平面直角坐标系\n * \n * @author Zoyn\n */\npublic class PlayerBackCoordinate {\n\n    private Location zeroDot;\n    private double rotateAngle;\n\n    public PlayerBackCoordinate(Location playerLocation) {\n        // 旋转的角度\n        rotateAngle = playerLocation.getYaw();\n        zeroDot = playerLocation.clone();\n        zeroDot.setPitch(0); // 重设仰俯角\n        zeroDot.add(zeroDot.getDirection().multiply(-0.3)); // 使原点与玩家有一点点距离\n    }\n\n    public Location getZeroDot() {\n        return zeroDot;\n    }\n\n    public Location newLocation(double x, double y) {\n        return rotateLocationAboutPoint(zeroDot.clone().add(-x, y, 0), rotateAngle, zeroDot);\n    }\n\n        /**\n     * 在二维平面上利用给定的中心点逆时针旋转一个点\n     * \n     * @param location 待旋转的点\n     * @param angle    旋转角度\n     * @param point    中心点\n     * @return {@link Location}\n     */\n    public static Location rotateLocationAboutPoint(Location location, double angle, Location point) {\n        double radians = Math.toRadians(angle);\n        double dx = location.getX() - point.getX();\n        double dz = location.getZ() - point.getZ();\n\n        double newX = dx * Math.cos(radians) - dz * Math.sin(radians) + point.getX();\n        double newZ = dz * Math.cos(radians) + dx * Math.sin(radians) + point.getZ();\n        return new Location(location.getWorld(), newX, location.getY(), newZ);\n    }\n}复制代码上方代码的使用：实例1：在玩家后背绘制一个圆\nPlayer player = (Player) sender;\nPlayerBackCoordinate coordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1.6D, 0));\n\nfor (int angle = 0; angle < 360; angle++) {\n    double radians = Math.toRadians(angle);\n    double x = Math.cos(radians);\n    double y = Math.sin(radians);\n\n    Location loc = coordinate.newLocation(x, y);\n    loc.getWorld().spawnParticle(Particle.FLAME, loc, 1, 0, 0, 0, 0);\n}复制代码具体效果：\n\n\n\n\n\n8109631-630f0e23257a8242.png (139.26 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-19 19:35 上传\n\n\n\n\n\n\n制作简易翅膀\n不说这么多，直接上代码好吧，用的就是上面的代码\nPlayer player = (Player) sender;\nPlayerBackCoordinate coordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1.5D, 0));\n\nfor (double angle = 0; angle <= 135; angle++) {\n    double x = Math.toRadians(angle);\n    double y = Math.sin(2 * x);\n\n    Location loc = coordinate.newLocation(x, y);\n    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, 1, 0, 0, 0, 0);\n}\n\nfor (double angle = -135; angle <= 0; angle++) {\n    double x = Math.toRadians(angle);\n    double y = Math.cos((2 * x) + (Math.PI / 2));\n\n    Location loc = coordinate.newLocation(x, y);\n    loc.getWorld().spawnParticle(Particle.VILLAGER_HAPPY, loc, 1, 0, 0, 0, 0);\n}\n\ncoordinate = new PlayerBackCoordinate(player.getLocation().add(0, 1, 0));\ndouble radius = 0;\nfor (double angle = 0; angle <= 3 * 360; angle++) {\n    double radians = Math.toRadians(angle);\n    double x = radius * Math.cos(radians);\n    double y = radius * Math.sin(radians);\n\n    Location loc = coordinate.newLocation(x, y);\n    loc.getWorld().spawnParticle(Particle.FIREWORKS_SPARK, loc, 1, 0, 0, 0, 0);\n    radius += 0.001;\n}复制代码具体效果: \n\n\n\n\n\n8109631-f1633dad8c40835b.png (329.09 KB, 下载次数: 0)\n\n下载附件\n\n2020-3-19 19:35 上传\n\n\n\n\n\n结语\n是的这个教程又开始更新了，就当做没事拿来玩玩的了，毕竟上了大学，还是可以拿线性代数来学以致用的嘛嘻嘻嘻。此外我想开一个ParticleLib的坑，专门来制作这类特效，希望各位看官可以多多支持\n\n看情况更新 —— 撰写: 一个来自已经上了带学的大一新生 2020/3/8\n[groupid=1701]Complex Studio[/groupid]",
    "replies": [
        {
            "author": "5igm1",
            "timestamp": 1583646420,
            "txt_content": "莫老牛逼！"
        },
        {
            "author": "MoonDrinkWind",
            "timestamp": 1583646420,
            "txt_content": "老铁们，给点点关注"
        },
        {
            "author": "ITGSCF",
            "timestamp": 1583650800,
            "txt_content": "可以 大佬厉害大佬厉害！！！！！！！！！"
        },
        {
            "author": "Cutter_",
            "timestamp": 1583652960,
            "txt_content": "虽然不太懂 但是看起来很厉害"
        },
        {
            "author": "William_Shi",
            "timestamp": 1583657700,
            "txt_content": "越往后看越觉得一些东西开始看不懂了\n高一学生表示三角函数题目和这里的三角函数运用真的没关系TAT"
        },
        {
            "author": "DouYinXiGuaGeGe",
            "timestamp": 1587279780,
            "txt_content": "小学生看懂了怎么办"
        }
    ]
}