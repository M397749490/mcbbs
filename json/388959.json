{
    "title": "1.7.10网页白名解决方案~",
    "author": "akkz",
    "replyCount": 6,
    "timestamp": 1421999760,
    "txt_content": " 本帖最后由 akkz 于 2015-1-23 15:57 编辑 \n\n        因为一直在网上找不到满意的解决方案，花了几天时间，终于自己解决了1.7.10的网页白名问题。QAQ\n\n        下面就分享下，说不定有作用呢~哈哈~~~\n\n        方案一：使用程序模拟人工从控制台输入的方式。\n                优点：不需要服务端任何改动\n                缺点：稳定性不强，需要淘宝上买那种带控制面板的服务姬\n\n        （楼主的话：这是我一开始想到的方案，因为发现在网页控制面板可以输入命令，于是想到是否可以写个程序自动完成命令的输入，于是顺着思路做了下。由于需要让机器自动发Http请求，然而发送命令后无法直接通过服务器返回的信息判断是否成功……所以理论上稳定性不强，但经过测试……发现还可以的qwq下面就介绍下~~）\n\n        首先，这个方案的难点是使用php（其他语言一样啦~）发送HTTP的Get和Post请求，并能做到session的存储。\n        这里我在网上找到了一个大神写的HttpClient.php的组件，直接拿来用~~\n \n<?php\n/**\n* Full featured Http Client class in pure PHP (4.1+)\n*\n* API list:\n* Object  $http = new Http_Client([bool $verbose = false]);\n* integer $http->getStatus();\n* string  $http->getTitle();\n* string  $http->getUrl();\n* void    $http->setHeader(string $key[, string $value = null]);\n* mixed   $http->getHeader([string $key = null]);\n* void    $http->setCookie(string $key, string $value);\n* mixed   $http->getCookie([string $key = null[, string $host = null]]);\n* bool    $http->saveCookie(string $filepath);\n* bool    $http->loadCookie(string $filepath);\n* void    $http->addPostField(string $key, mixed $value);\n* void    $http->addPostFile(string $key, string $filename[, string $content = null]);\n* string  $http->Get(string $url[, bool $redirect = true]);\n* mixed   $http->Head(string $url[, bool $redirect = true]);\n* string  $http->Post(string $url[, bool redirect = true]);\n* bool    $http->Download(string $url[, string $filepath = null[, bool overwrite = false]);\n*\n* @author hightman <[email]hightman@twomice.net[/email]>\n* [url=home.php?mod=space&uid=41191]@link[/url] [url]http://www.hightman.cn/[/url]\n* @copyright Copyright &copy; 2008-2010 Twomice Studio\n* @version $Id: http_client.class.php,v 1.22 2010/10/16 16:42:47 hightman Exp $\n*/\n\n/**\n* Defines the package name.\n*/\ndefine ('HC_PACKAGENAME',    'HttpClient');\n/**\n* Defines the package version.\n*/\ndefine ('HC_VERSION',        '2.0-beta');\n/**\n* This constant defines how many times should be tried on I/O failure (timeout and error).\n* Defaults to 3, it should be greater than 0.\n*/\ndefine ('HC_MAX_RETRIES',    3);\n\n/**\n* Http_Client is a full featured client class for the HTTP protocol.\n*\n* It currently implements some HTTP/1.x protocols, including request method HEAD, GET, POST,\n* and automatic handling of authorization, redirection request, and cookies.\n*\n* Features include:\n* 1) Pure PHP code, none of extensions is required, PHP version just from 4.1.0;\n* 2) Ability to set/get any HTTP request headers, such as user-agent, referal page, etc;\n* 3) Includes full featured cookie support, automatic sent cookie header if required on next request;\n* 4) Handle redirected requests automatically (such as HTTP/301, HTTP/302);\n* 5) Support real Keep-Alive connections, used for multiple requests;\n* 6) Can resume getting a partially-downloaded file use special download() method;\n* 7) Support multiple files upload via post method, support array named request variable (arr[]=...)\n* 8) SSL support\n*\n* The whole library code is open and free, you can use it for any purposes.\n*\n* @author hightman <[email]hightman@twomice.net[/email]>\n* @version 2.0-beta $\n*/\nclass Http_Client\n{\n    /**\n     * local private variables\n     * [url=home.php?mod=space&uid=859888]@access[/url] private\n     */\n    var $headers, $status, $title, $cookies, $socks, $url, $filepath, $verbose;\n    var $post_files, $post_fields;\n\n    /** \n     * Constructor (PHP5).\n     * @param boolean wheather to display verbose execute messages\n     */\n    function __construct($verbose = false)\n    {\n        $this->verbose = $verbose;\n        $this->cookies = array();\n        $this->socks = array();    \n        $this->_reset();\n    }\n    \n    /** \n     * Constructor (PHP4-style).\n     * @param boolean wheather to display verbose execute messages\n     */\n    function Http_Client($verbose = false)\n    {\n        $this->__construct($verbose);\n    }\n    \n    /** \n     * Destructor (PHP5 only).\n     * Close all opened socket connections.\n     */\n    function __destruct()\n    {\n        foreach ($this->socks as $host => $sock) { @fclose($sock); }\n        $this->socks = array();\n    }\n\n    /** \n     * Get HTTP respond status code of the last HTTP request.\n     * [url=home.php?mod=space&uid=491268]@Return[/url] integer http respond status code\n     */\n    function getStatus()\n    {\n        return $this->status;\n    }\n\n    /** \n     * Get HTTP respond short title of the last HTTP request.\n     * @return string http respond short title\n     */\n    function getTitle()\n    {\n        return $this->title;\n    }\n    \n    /** \n     * Get the real URL of the last HTTP request.\n     * @return string real URL of the last http request after redirecting\n     */    \n    function getUrl()\n    {\n        return $this->url;\n    }\n\n    /** \n     * Get the downloaded file path after calling Download() method.\n     * @return string filepath saved on local disk\n     */    \n    function getFilepath()\n    {\n        return $this->filepath;\n    }\n\n    /** \n     * Set a HTTP header for the next request.\n     * @param string the name of the request header\n     * @param string the value of the request header\n     * If the value is NULL, the header will be dropped.\n     * Note: special key 'x-server-addr' will force to use instead of gethostbyname(host)\n     */\n    function setHeader($key, $value = null)\n    {\n        $this->_reset();\n        $key = strtolower($key);\n        if (is_null($value)) unset($this->headers[$key]);\n        else $this->headers[$key] = strval($value);\n    }\n    \n    /** \n     * Get one or more HTTP headers of the last request.\n     * @param string the name of the header to be fetched.\n     * If is NULL, return the all headers of the last request.\n     * @return mixed fetched header value or headersas key-value array.\n     * If the header dose not exists, NULL is returned.\n     */    \n    function getHeader($key = null)\n    {\n        if (is_null($key)) return $this->headers;\n        $key = strtolower($key);\n        if (!isset($this->headers[$key])) return null;\n        return $this->headers[$key];\n    }\n\n    /** \n     * Add a HTTP cookie sent for the next request.\n     * @param string the name of the cookie to be added\n     * @param string the value of the cookie to be added\n     */\n    function setCookie($key, $value)\n    {\n        $this->_reset();\n        if (!isset($this->headers['cookie'])) $this->headers['cookie'] = array();\n        $this->headers['cookie'][$key] = $value;\n    }\n\n    /** \n     * Get a HTTP cookie item by name\n     * @param string the name of the cookie to be fetched\n     * If the name is NULL, all matched cookies are returned as key-value array.  \n     * @param string host of all saved cookies (include expired)\n     * If the host is NULL, fetch the cookie from last request.\n     * @return mixed fetched cookie item or cookies as key-value array.\n     * Every cookie item is a assoc array, keys include: value, expires, path, host\n     * If the cookie dose not exists, NULL is returned.    \n     */\n    function getCookie($key = null, $host = null)\n    {\n        // fetch from last request\n        if (!is_null($key)) $key = strtolower($key);\n        if (is_null($host))\n        {\n            if (!isset($this->headers['cookie'])) return null;\n            if (is_null($key)) return $this->headers['cookie'];\n            if (!isset($this->headers['cookie'][$key])) return null;\n            return $this->headers['cookie'][$key];\n        }\n        // fetch from all saved cookies.\n        $host = strtolower($host);\n        while (true)\n        {\n            if (isset($this->cookies[$host]))\n            {\n                if (is_null($key)) return $this->cookies[$host];\n                if (isset($this->cookies[$host][$key])) return $this->cookies[$host][$key];\n            }\n            // search for next sub-domain\n            $pos = strpos($host, '.', 1);\n            if ($pos === false) break;\n            $host = substr($host, $pos);\n        }\n        return null;\n    }\n\n    /** \n     * Save all cookies to a file.\n     * @param string the file path that cookies will be saved to.\n     * @return boolean save result, return true on success and false on faiulre.\n     * Note: all cookies are serialized before saving.\n     */\n    function saveCookie($fpath)\n    {\n        if (false === ($fd = @fopen($fpath, 'w')))\n            return false;\n        $data = serialize($this->cookies);\n        fwrite($fd, $data);\n        fclose($fd);\n        return true;\n    }\n\n    /** \n     * Load cookies from a file\n     * @param string the file path that cookies has been saved to.\n     * The cookie file should be created by saveCookie() method.\n     */\n    function loadCookie($fpath)\n    {\n        if (file_exists($fpath) && ($cookies = @unserialzie(file_get_contents($fpath))))\n            $this->cookies = $cookies;\n    }\n\n    /** \n     * Add a post field for the next request\n     * @param string the name of the field.\n     * @param mixed the value of the field, can be array or string.\n     * If the value is an array, converted to arr[key][key2] fields automatically.\n     */\n    function addPostField($key, $value)\n    {\n        $this->_reset();\n        if (!is_array($value))\n            $this->post_fields[$key] = strval($value);\n        else\n        {\n            $value = $this->_format_array_field($value);\n            foreach ($value as $tmpk => $tmpv)\n            {\n                $tmpk = $key . '[' . $tmpk . ']';\n                $this->post_fields[$tmpk] = strval($tmpv);\n            }\n        }\n    }\n\n    /**\n     * Add a multipart post file for the next request\n     * @param string the name of the field\n     * @param string the filename or filepath to be uploaded\n     * @param string content the file content\n     * If the content is null and fname is a valid filepath, \n     * content will be set to the file content.\n     */\n    function addPostFile($key, $fname, $content = '')\n    {\n        $this->_reset();\n        if ($content === '' && is_file($fname)) $content = @file_get_contents($fname);\n        $this->post_files[$key] = array(basename($fname), $content);\n    }\n\n    /**\n     * Do a http request via get method\n     * @param string the absolute URL\n     * @param boolean handle redirected requests automatically or not\n     * @return string respond body data or false on failure before server respond.\n     */\n    function Get($url, $redir = true)\n    {\n        return $this->_do_url($url, 'get', null, $redir);\n    }\n\n    /**\n     * Do a http request via head method\n     * @param string the absolute URL\n     * @param boolean handle redirected requests automatically or not     \n     * @return mixed all respond HTTP header or false on failure before server respond.\n     */\n    function Head($url, $redir = false)\n    {\n        if ($this->_do_url($url, 'head', null, $redir) !== false)\n            return $this->getHeader(null);\n        return false;\n    }\n\n    /**\n     * Do a http request via post method\n     * @param string the absolute URL\n     * @param boolean handle redirected requests automatically or not\n     * @return string respond body data or false on failure before server respond.\n     * Note: post request variable should be set by ::addPostField() and ::addPostFile()\n     */\n    function Post($url, $redir = true)\n    {\n        $data = '';\n        if (count($this->post_files) > 0)\n        {\n            $boundary = md5($url . microtime());\n            foreach ($this->post_fields as $tmpk => $tmpv)\n            {\n                $data .= \"--{$boundary}\\r\\nContent-Disposition: form-data; name=\"{$tmpk}\"\\r\\n\\r\\n{$tmpv}\\r\\n\";\n            }\n            foreach ($this->post_files as $tmpk => $tmpv)\n            {\n                $type = 'application/octet-stream';\n                $ext = strtolower(substr($tmpv[0], strrpos($tmpv[0],'.')+1));\n                if (isset($GLOBALS['___HC_MIMES___'][$ext])) $type = $GLOBALS['___HC_MIMES___'][$ext];\n                $data .= \"--{$boundary}\\r\\nContent-Disposition: form-data; name=\"{$tmpk}\"; filename=\"{$tmpv[0]}\"\\r\\nContent-Type: $type\\r\\nContent-Transfer-Encoding: binary\\r\\n\\r\\n\";\n                $data .= $tmpv[1] . \"\\r\\n\";\n            }\n            $data .= \"--{$boundary}--\\r\\n\";\n            $this->setHeader('content-type', 'multipart/form-data; boundary=' . $boundary);\n        }\n        else\n        {\n            foreach ($this->post_fields as $tmpk => $tmpv)\n            {\n                $data .= '&' . rawurlencode($tmpk) . '=' . rawurlencode($tmpv);\n            }\n            $data = substr($data, 1);\n            $this->setHeader('content-type', 'application/x-www-form-urlencoded');\n        }\n        $this->setHeader('content-length', strlen($data));\n        return $this->_do_url($url, 'post', $data, $redir);\n    }\n\n    /**\n     * Download a file to local via get method with range support\n     * @param string the absolute URL\n     * @param string local filepath to saved, default is the same filename on current working directory.\n     * @param boolean weather to overwrite the exists file \n     * when filepath exists and not a valid partially-downloaded file.\n     * @return boolean true on success and false on failure.\n     * Note: this method can be used to resume getting a partially-downloaded file.\n     */\n    function Download($url, $filepath = null, $overwrite = false)\n    {\n        // get filepath & head\n        if ($filepath === true)\n        {\n            $overwrite = true; \n            $filepath = null;\n        }\n        if (is_null($filepath) || empty($filepath)) $filepath = '.';\n        // get normal headers first\n        $savehead = $this->getHeader(null);\n        if (!$this->Head($url, true))\n        {\n            if ($this->verbose) echo \"[ERROR] failed to get headers for downloading file.\\n\";\n            return false;\n        }\n        else if ($this->getStatus() != 200)\n        {\n            if ($this->verbose) echo \"[ERROR] can not get a valid 200 HTTP respond status.\\n\";\n            return false;\n        }\n        // get filename & filesize\n        $url = $this->getUrl();\n        if ($this->verbose) echo \"[INFO] real download url is: $url\\n\";\n        if (is_dir($filepath))\n        {\n            if (substr($filepath, -1, 1) != DIRECTORY_SEPARATOR) $filepath .= DIRECTORY_SEPARATOR;        \n            if (($disposition = $this->getHeader('content-disposition')) \n                && preg_match('/filename=[\\'\"]?([^;\\'\" ]+)/', $disposition, $match))\n            {\n                $filename = $match[1];\n                if ($this->verbose) echo \"[INFO] fetch filename from disposition header: $filename\\n\";\n            }\n            else\n            {\n                $tmpstr = ($pos = strpos($url, '?')) ? substr($url, 0, $pos) : $url;\n                $pos = strrpos($tmpstr, '/');\n                $filename = substr($tmpstr, $pos + 1);\n                if ($filename == '') $filename = 'index.html';\n                if ($this->verbose) echo \"[INFO] fetch filename from URL: $filename\\n\";\n            }\n            while (true)\n            {\n                $filepath .= $filename;\n                if (!is_dir($filepath)) break;\n                $filepath .= DIRECTORY_SEPARATOR . $filename;\n            }\n        }\n        // check filepath\n        if (!file_exists($filepath) || !($fsize = @filesize($filepath)))\n        {\n            $savefd = @fopen($filepath, 'w');\n            if ($this->verbose) echo \"[INFO] save file directly to: $filepath\\n\";\n        }\n        else\n        {\n            $length = $this->getHeader('content-length');\n            $accept = $this->getHeader('accept-ranges');\n            if ($length && $fsize < $length && stristr($accept, 'bytes'))\n            {\n                // range request used\n                $this->setHeader('range', 'bytes=' . $fsize . '-');\n                $savefd = @fopen($filepath, 'a');\n                if ($this->verbose) echo \"[INFO] range download used, range: {$fsize}-\\n\";\n            }\n            else if ($overwrite)\n            {\n                $savefd = @fopen($filepath, 'w');\n                if ($this->verbose) echo \"[INFO] overwrite the exists file: $filepath\\n\";\n            }\n            else\n            {\n                // auto append filename '.1, .2, ...'\n                for ($i = 1; @file_exists($filepath . '.' . $i); $i++);\n                $filepath .= '.' . $i;\n                $savefd = @fopen($filepath, 'w');\n                if ($this->verbose) echo \"[INFO] auto skip exists file, last save to: $filepath\\n\";\n            }\n        }\n        // check the savefd\n        if (!$savefd)\n        {\n            if ($this->verbose) echo \"[ERROR] can not open the file to save data: $filename\\n\";\n            return false;\n        }\n        // do real download via get method\n        foreach ($savehead as $hk => $hv) $this->setHeader($hk, $hv);\n        if ($this->_do_url($url, 'get', null, false, $savefd) !== false)\n        {\n            $this->filepath = $filepath;\n            fclose($savefd);\n            if ($this->verbose) echo \"[INFO] downloaded file saved in: $filepath\\n\";\n            return true;\n        }\n        else\n        {\n            if ($this->verbose) echo \"[ERROR] can not download the URL: $url\\n\";\n            return false;\n        }\n    }\n    \n    // -------------------------------------------------\n    // private functions\n    // -------------------------------------------------\n    // read data from socket\n    function _sock_read($fd, $maxlen = 4096, $wfd = false)\n    {\n        $rlen = 0;\n        $data = '';\n        $ntry = HC_MAX_RETRIES;\n        while (!feof($fd))\n        {\n            $part = fread($fd, $maxlen - $rlen);\n            if ($part === false || $part === '') $ntry--;\n            else $data .= $part;\n            $rlen = strlen($data);\n            if ($rlen == $maxlen || $ntry == 0) break;\n        }\n        if ($ntry == 0 || feof($fd)) @fclose($fd);\n        if (is_resource($wfd))\n        {\n            fwrite($wfd, $data);\n            $data = '';\n        }\n        return $data;\n    }\n\n    // write data to socket\n    function _sock_write($fd, $buf)\n    {\n        $wlen = 0;\n        $tlen = strlen($buf);\n        $ntry = HC_MAX_RETRIES;\n        while ($wlen < $tlen)\n        {\n            $nlen = fwrite($fd, substr($buf, $wlen), $tlen - $wlen);\n            if (!$nlen) { if (--$ntry == 0) return false; }\n            else $wlen += $nlen;\n        }\n        return true;\n    }\n\n    // reset some request data (status)\n    function _reset()\n    {\n        if ($this->status !== 0) \n        {\n            $this->status = 0;\n            $this->url = $this->title = $this->filepath = null;\n            $this->headers = $this->post_files = $this->post_fields = array();\n        }\n    }\n    \n    // check is a host belong a domain\n    function _belong_domain($host, $domain)\n    {\n        if (!strcasecmp($domain, $host)) return true;\n        if (substr($domain, 0, 1) == '.')\n        {\n            if (!strcasecmp($host, substr($domain, 1))) return true;\n            $hlen = strlen($host);\n            $dlen = strlen($domain);\n            if ($hlen > $dlen && !strcasecmp(substr($host, $hlen - $dlen), $domain))\n                return true;\n        }\n        return false;\n    }\n\n    // format array field (convert N-DIM(n>=2) array => 2-DIM array)\n    function _format_array_field($value, $pk = NULL)\n    {\n        $ret = array();\n        foreach ($value as $k => $v)\n        {\n            $k = (is_null($pk) ? $k : $pk . $k);\n            if (is_array($v)) $ret += $this->_format_array_field($v, $k . '][');\n            else $ret[$k] = $v;\n        }\n        return $ret;\n    }\n\n    // do a url method\n    function _do_url($url, $method, $data = null, $redir = true, $savefd = false)\n    {\n        // check the url\n        if (strncasecmp($url, 'http://', 7) && strncasecmp($url, 'https://', 8) && isset($_SERVER['HTTP_HOST']))\n        {\n            $base = 'http://' . $_SERVER['HTTP_HOST'];\n            if (substr($url, 0, 1) != '/')\n                $url = substr($_SERVER['SCRIPT_NAME'], 0, strrpos($_SERVER['SCRIPT_NAME'], '/')+1) . $url;            \n            $url = $base . $url;\n        }\n\n        // parse the url\n        $url = str_replace('&amp;', '&', $url);\n        $pa = @parse_url($url);\n        if ($pa['scheme'] && $pa['scheme'] != 'http' && $pa['scheme'] != 'https')\n        {\n            trigger_error(\"Invalid scheme `{$pa['scheme']}`\", E_USER_WARNING);\n            return false;\n        }\n        if (!isset($pa['host']))\n        {\n            trigger_error(\"Invalid request url, host required\", E_USER_WARNING);\n            return false;\n        }\n        if (!isset($pa['port'])) $pa['port'] = ($pa['scheme'] == 'https' ? 443 : 80);\n        if (!isset($pa['path']))\n        {\n            $pa['path'] = '/';\n            $url .= '/';\n        }\n        $host = strtolower($pa['host']);\n        if (isset($this->headers['x-server-addr'])) $addr = $this->headers['x-server-addr'];\n        else $addr = gethostbyname($pa['host']);\n        $port = intval($pa['port']);\n        $skey = $addr . ':' . $port;\n        if ($pa['scheme'] && $pa['scheme'] == 'https') $host_conn = 'ssl://' . $addr;\n        else $host_conn = 'tcp://' . $addr;\n\n        // make the query buffer\n        $method = strtoupper($method);\n        $buf = $method . ' ' . $pa['path'];\n        if (isset($pa['query'])) $buf .= '?' . $pa['query'];\n        $buf .= \" HTTP/1.1\\r\\nHost: {$host}\\r\\n\";\n        \n        // basic auth support\n        if (isset($pa['user']) && isset($pa['pass']))\n            $this->headers['authorization'] = 'Basic ' . base64_encode($pa['user'] . ':' . $pa['pass']);\n\n        // set default HTTP/headers\n        $savehead = $this->headers;\n        $this->_reset();\n        if (!isset($this->headers['user-agent'])) \n        {\n            $buf .= \"User-Agent: Mozilla/5.0 (Compatible; \" . HC_PACKAGENAME . \"/\" . HC_VERSION . \"; +Hightman) \";\n            $buf .= \"php-\" . php_sapi_name() . \"/\" . phpversion() . \" \";\n            $buf .= php_uname(\"s\") . \"/\" . php_uname(\"r\") . \"\\r\\n\";\n        }\n        if (!isset($this->headers['accept'])) $buf .= \"Accept: */*\\r\\n\";\n        if (!isset($this->headers['accept-language'])) $buf .= \"Accept-Language: zh-cn,zh\\r\\n\";\n        if (!isset($this->headers['connection'])) $buf .= \"Connection: Keep-Alive\\r\\n\";\n        if (isset($this->headers['accept-encoding'])) unset($this->headers['accept-encoding']);\n        if (isset($this->headers['host'])) unset($this->headers['host']);\n\n        // saved cookies (session data)\n        $now = time();\n        $ck_str = '';\n        foreach ($this->cookies as $ck_host => $ck_list)\n        {\n            if (!$this->_belong_domain($host, $ck_host)) continue;\n            foreach ($ck_list as $ck => $cv)\n            {\n                if (isset($this->headers['cookie'][$ck])) continue;\n                if ($cv['expires'] > 0 && $cv['expires'] < $now) continue;\n                if (strncmp($pa['path'], $cv['path'], strlen($cv['path']))) continue;\n                $ck_str .= '; ' . $cv['rawdata'];\n            }\n        }\n        foreach ($this->headers as $k => $v)\n        {\n            if ($k != 'cookie')\n                $buf .= ucfirst($k) . \": \" . $v . \"\\r\\n\";\n            else\n            {\n                foreach ($v as $ck => $cv) $ck_str .= '; ' . rawurlencode($ck) . '=' . rawurlencode($cv);\n            }\n        }\n        // TODO: check cookie length?\n        if ($ck_str != '') $buf .= 'Cookie:' . substr($ck_str, 1) . \"\\r\\n\";\n        $buf .= \"\\r\\n\";\n        if ($method == 'POST') $buf .= $data . \"\\r\\n\";\n\n        // force reset status for next query even if failed this time.\n        $this->status = -1;\n        $this->url = $url;\n\n        // show the header buf\n        if ($this->verbose)\n        {\n            echo \"[INFO] request url: $url\\r\\n\";\n            echo \"[SEND] request buffer\\r\\n----\\r\\n\";\n            echo $buf;\n            echo \"----\\r\\n\";\n        }\n\n        // create the sock & send the header\n        $ntry = HC_MAX_RETRIES;\n        $sock = isset($this->socks[$skey]) ? $this->socks[$skey] : false;\n        do\n        {\n            if (is_resource($sock) && $this->_sock_write($sock, $buf)) break;\n            if ($sock) @fclose($sock);\n            $sock = @fsockopen($host_conn, $port, $errno, $error, 3);\n            if ($sock)\n            {\n                stream_set_blocking($sock, 1);\n                stream_set_timeout($sock, 10);\n            }            \n        }\n        while (--$ntry);\n        if (!$sock)\n        {\n            if (isset($this->socks[$skey])) unset($this->socks[$skey]);\n            trigger_error(\"Cann't connect to `$host:$port'\", E_USER_WARNING);\n            return false;\n        }\n        $this->socks[$skey] = $sock;\n        if ($this->verbose)\n        {\n            echo \"[SEND] using socket = {$sock}\\r\\n\";\n            echo \"[RECV] http respond header\\r\\n----\\r\\n\";\n        }\n\n        // read the respond header\n        $with_range = isset($this->headers['range']);\n        $this->headers = array();\n        while ($line = fgets($sock, 2048))\n        {\n            if ($this->verbose) echo $line;\n            $line = trim($line);\n            if ($line === '') break;\n            if (!strncasecmp('HTTP/', $line, 5))\n            {\n                $line = trim(substr($line, strpos($line, ' ')));\n                list($this->status, $this->title) = explode(' ', $line, 2);\n                $this->status = intval($this->status);\n            }\n            else if (!strncasecmp('Set-Cookie: ', $line, 12))\n            {\n                // ignore the cookie options: Httponly\n                $ck_key = '';\n                $ck_val = array('value' => '', 'expires' => 0, 'path' => '/', 'domain' => $host);\n                $tmpa = explode(';', substr($line, 12));\n                foreach ($tmpa as $tmp)\n                {\n                    $tmp = trim($tmp);\n                    if (empty($tmp)) continue;\n                    list($tmpk, $tmpv) = explode('=', $tmp, 2);\n                    $tmpk2 = strtolower($tmpk);\n                    if ($ck_key == '')\n                    {\n                        $ck_key = rawurldecode($tmpk);\n                        $ck_val['value'] = rawurldecode($tmpv);\n                        $ck_val['rawdata'] = $tmpk . '=' . $tmpv;\n                    }\n                    else if ($tmpk2 == 'expires')\n                    {\n                        $ck_val['expires'] = strtotime($tmpv);\n                        if ($ck_val['expires'] < $now)\n                        {\n                            $ck_val['value'] = '';\n                            break;\n                        }\n                    }\n                    else if (isset($ck_val[$tmpk2]) && $tmpv != '')\n                    {\n                        $ck_val[$tmpk2] = $tmpv;\n                        // drop invalid-domain cookies?\n                        if ($tmpk2 == 'domain' && !$this->_belong_domain($host, $tmpv)) $ck_key = '';\n                    }\n                }\n\n                // delete cookie?\n                if ($ck_key == '') continue;\n                if ($ck_val['value'] == '') unset($this->cookies[$ck_val['domain']][$ck_key]);\n                else $this->cookies[$ck_val['domain']][$ck_key] = $ck_val;\n\n                // headers.\n                $this->headers['cookie'][$ck_key] = $ck_val;\n            }\n            else \n            {\n                list($k, $v) = explode(':', $line, 2);\n                $k = strtolower(trim($k));\n                $v = trim($v);\n                $this->headers[$k] = $v;\n            }\n        }\n        if ($this->verbose) echo \"----\\r\\n\";\n        \n        // check savefd\n        if ($savefd && $with_range)\n        {\n            if ($this->status == 200)\n            {\n                ftruncate($savefd, 0);\n                fseek($savefd, 0, SEEK_SET);\n            }\n            else if ($this->status != 206) $savefd = false;\n        }\n\n        // get body\n        $connection = $this->getHeader('connection');\n        $encoding = $this->getHeader('transfer-encoding');\n        $length = $this->getHeader('content-length');\n        if ($method == 'HEAD') \n        {\n            // nothing to do\n            $body = '';\n        }\n        else if ($encoding && !strcasecmp($encoding, 'chunked'))\n        {\n            $body = '';\n            while (is_resource($sock))\n            {\n                if (!($line = fgets($sock, 1024))) break;\n                if ($this->verbose) echo \"[RECV] Chunk Line: \" . $line;\n                if ($p1 = strpos($line, ';')) $line = substr($line, 0, $pos);\n                $chunk_len = hexdec(trim($line));\n                if ($chunk_len <= 0) break;    // end the chunk\n                $body .= $this->_sock_read($sock, $chunk_len, $savefd);\n                fread($sock, 2);            // eat the CRLF\n            }\n\n            // trailer header\n            if ($this->verbose) echo \"[RECV] chunk tailer\\r\\n----\\r\\n\";\n            while ($line = fgets($sock, 2048))\n            {\n                if ($this->verbose) echo $line;\n                $line = trim($line);\n                if ($line === '') break;\n                list($k, $v) = explode(':', $line, 2);\n                $k = strtolower(trim($k));\n                $v = trim($v);\n                $this->headers[$k] = $v;\n            }        \n            if ($this->verbose) echo \"----\\r\\n\";\n        }\n        else if ($length)\n        {\n            $body = '';\n            $length = intval($length);\n            while ($length > 0 && is_resource($sock))\n            {\n                $body .= $this->_sock_read($sock, ($length > 8192 ? 8192 : $length), $savefd);\n                $length -= 8192;\n            }\n        }\n        else\n        {\n            $body = '';\n            while (is_resource($sock) && !feof($sock)) $body .= $this->_sock_read($sock, 8192, $savefd);\n            $connection = 'close';\n        }        \n\n        // check close connection?\n        if ($connection && !strcasecmp($connection, 'close'))\n        {\n            @fclose($sock);\n            unset($this->socks[$skey]);\n        }\n            \n        // check redirect\n        if ($redir && $this->status != 200 && ($location = $this->getHeader('location')))\n        {\n            if (!is_int($redir)) $redir = HC_MAX_RETRIES;\n            if (!preg_match('/^http[s]?:\\/\\//i', $location))\n            {\n                $url2 = $pa['scheme'] . '://' . $pa['host'];\n                if (strpos($url, ':', 8)) $url2 .= ':' . $pa['port'];\n                if (substr($location, 0, 1) == '/') $url2 .= $location;\n                else $url2 .= substr($pa['path'], 0, strrpos($pa['path'], '/') + 1) . $location;\n                $location = $url2;\n            }\n            if (!isset($savehead['referer'])) $savehead['referer'] = $url;\n            foreach ($savehead as $hk => $hv) $this->setHeader($hk, $hv);\n            return $this->_do_url($location, ($method == 'HEAD' ? 'head' : 'get'), null, $redir - 1);\n        }\n\n        // return the body buf\n        return $body;\n    }\n}\n\n// mimetypes used on http_client\n$GLOBALS['___HC_MIMES___'] = array(\n    'gif' => 'image/gif',\n    'png' => 'image/png',\n    'bmp' => 'image/bmp',\n    'jpeg' => 'image/jpeg',\n    'pjpg' => 'image/pjpg',\n    'jpg' => 'image/jpeg',\n    'tif' => 'image/tiff',\n    'htm' => 'text/html',\n    'css' => 'text/css',\n    'html' => 'text/html',\n    'txt' => 'text/plain',\n    'gz' => 'application/x-gzip',\n    'tgz' => 'application/x-gzip',\n    'tar' => 'application/x-tar',\n    'zip' => 'application/zip',\n    'hqx' => 'application/mac-binhex40',\n    'doc' => 'application/msword',\n    'pdf' => 'application/pdf',\n    'ps' => 'application/postcript',\n    'rtf' => 'application/rtf',\n    'dvi' => 'application/x-dvi',\n    'latex' => 'application/x-latex',\n    'swf' => 'application/x-shockwave-flash',\n    'tex' => 'application/x-tex',\n    'mid' => 'audio/midi',\n    'au' => 'audio/basic',\n    'mp3' => 'audio/mpeg',\n    'ram' => 'audio/x-pn-realaudio',\n    'ra' => 'audio/x-realaudio',\n    'rm' => 'audio/x-pn-realaudio',\n    'wav' => 'audio/x-wav',\n    'wma' => 'audio/x-ms-media',\n    'wmv' => 'video/x-ms-media',\n    'mpg' => 'video/mpeg',\n    'mpga' => 'video/mpeg',\n    'wrl' => 'model/vrml',\n    'mov' => 'video/quicktime',\n    'avi' => 'video/x-msvideo'\n);\n复制代码\n\n        第二，就是分析表单结构，构造出合适的表单了~\n        登录很简单，一个post出去就解决，不多说了~\n        但是console那个表单有些迷惑人qwq因为，那个form是假的……其实数据是通过网页最下面的ajax发出去的，试了半天试不出来……\n        这里需要三个参数，参数1:：ajax=command,这个值是固定的。参数2：YII_CSRF_TOKEN=?，这个值需要从网页中获取，所以首先应该发送一个Get请求，然后从网页中抓取YII_CSRF_TOKEN的值，然后再发送Post请求。参数3：command=你的命令。构造完这个表单后再发送就ok啦~~~\n        到这里基本就能成功了QAQ~~~\n\n\n        方案二：开放白名使用Authme插件认证方式。\n                优点：安全稳定~而且能实现论坛游戏公用统一账户的需求~\n                缺点：需要Authme插件支持且要Mysql数据库\n\n        （楼主再多嘴下：这种方案感觉非常不错~~强烈推荐哦~~~另外，如果需要将数据导入mysql，用这个命令/authme convertflattosql。官网都不写……找了半天才找到……）\n        \n        首先，不是很清楚的腐竹可以先弄个测试的数据库，看看Authme到底往数据库里面写什么东西~~~\n        懒得测也可以看我的～我的是这样子～\n        \n\n\n\n\nQQ截图20150123153608.png (46.96 KB, 下载次数: 6)\n\n下载附件\n\n2015-1-23 15:36 上传\n\n\n\n\n\n        经过测试我发现，其实就往里写入username和password就行，其他留给authme自行处理～（email也可以自己写，用于找回密码的）。\n        但是这个密码是加密的密码qwq\n        经过查询，在官网发现这个~\n// @return true if password and nickname match \nfunction check_password_db($nickname,$password) {\n       // Here u have to include your DB connection and select!\n        \n        \n        $a=mysql_query(\"SELECT password FROM authme where username = '$nickname'\");\n        if(mysql_num_rows($a) == 1 )\n {\n               $password_info=mysql_fetch_array($a);\n               $sha_info = explode(\"[        DISCUZ_CODE_142        ]quot;,$password_info[0]);\n         } \nelse return false;\n        if( $sha_info[1] === \"SHA\" ) \n{\n     $salt = $sha_info[2];\n                                                    $sha256_password = hash('sha256', $password);\n                                                    $sha256_password .= $sha_info[2];;\n                                                    if( strcasecmp(trim($sha_info[3]),hash('sha256', $sha256_password) ) == 0 ) \n        return true;\n                                                    else \n        return false;\n        }\n\n}复制代码       这段代码是用来检测密码合法的，大致就是对密码以“$”分割进行拆分，第一个代表加密类型，这里是SHA，第二个为一个字符串（这里先不管），第三个为加密后的串。比较的方法是，对输入密码先进行sha254加密，然后与刚才的第二个字符串拼接，再进行一次sha254加密，再与第三部分比较，一致即验证通过。\n\n        但是我需要的是加密，而这里第二部分的字符串还不知道怎么获取……最后没办法，直接登git，开始看authme源码……看看能看到什么~\n        果然~被我发现了~在源码fr.xephi.authme.security.PasswordSecurity类中找到了生成方式qwq\n       public static String createSalt(int length) throws NoSuchAlgorithmException\n{\n            byte[] msg = new byte[40];\n            rnd.nextBytes(msg);\n            MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\n            sha1.reset();\n            byte[] digest = sha1.digest(msg);\n            return String.format(\"%0\" + (digest.length << 1) + \"x\", new BigInteger(1, digest)).substring(0, length);\n    }复制代码       调用处代码~\ncase SHA256:\n                salt = createSalt(16);\n                break;复制代码       所以，其实就是一个16为的随机字符串啦qwq\n\n        感觉生成的方式好复杂，因为不懂密码学一些东西，所以我就写的简单了些……直接弄一个字符串，然后随机在里面取字符，直到取满16个……\n        OK利用这个串，对用户输入的密码进行加密（和解密操作一样~），然后存到Authme的数据库，打开MC，登录，成功！！！哈哈，剩下的就是完善下业务逻辑和美工了~~（假如配置文件中打开cache的话，就不要直接在mysql中改密码了，改了也没有用……要敲命令改……）\n\n\n        以上就是我总结的内容了qwq希望对各位有帮助把~\n\n\n\n",
    "replies": [
        {
            "author": "SkyCatcher",
            "timestamp": 1422008520,
            "txt_content": "如果用到了authme的话，与其去做个白名单，不如直接接到discuz等系统上面，用这些系统的验证来完成用户的注册，实现的效果一样"
        },
        {
            "author": "akkz",
            "timestamp": 1422011760,
            "txt_content": "SkyCatcher 发表于 2015-1-23 18:22\n如果用到了authme的话，与其去做个白名单，不如直接接到discuz等系统上面，用这些系统的验证来完成用户的注 ...\nqwq额……不会弄……我搜搜看哈~"
        },
        {
            "author": "PETER·篠",
            "timestamp": 1422011820,
            "txt_content": "代碼太長。。。"
        },
        {
            "author": "a289773662",
            "timestamp": 1422090480,
            "txt_content": "看不懂，不过感觉高能~~~顶一个"
        },
        {
            "author": "変態のマギ",
            "timestamp": 1422149460,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "akkz",
            "timestamp": 1422182100,
            "txt_content": "変態のマギ 发表于 2015-1-25 09:31\n**** 作者被禁止或删除 内容自动屏蔽 ****\n额……那个啊……是是HttpClient插件，方便大家直接复制回去用的~\n就看最上面几行API就行啦~\n\n其实主程序更长呢……"
        }
    ]
}