{
    "title": "MCmod制作 1.11(9.投掷物实体基础)",
    "author": "zkm00323",
    "replyCount": 0,
    "timestamp": 1485059280,
    "txt_content": "好几天没更新教程也是因为这几天都在研究投掷物\n终于小有成果来写一篇教程\n\n1.新建Entity\n创建如下3个包\n\n\n\n\nQQ截图20170122112317.png (6.44 KB, 下载次数: 4)\n\n下载附件\n\n2017-1-22 11:26 上传\n\n\n\n\n\n\n\n在Entity内新建一个EntityIcebullet.java\n并继承EntityThrowable,把必要的构造函数和onImpact复写一下\npublic class EntityIcebullet extends EntityThrowable{\n\n\n        public EntityIcebullet(World worldIn){\n            super(worldIn);\n        }\n\n\n        public EntityIcebullet(World worldIn, EntityLivingBase throwerIn){\n            super(worldIn, throwerIn);\n        }\n\n\n        public EntityIcebullet(World worldIn, double x, double y, double z){\n            super(worldIn, x, y, z);\n        }\n\n\n        @Override\n        protected void onImpact(RayTraceResult result) {\n                \n        }\n}\n\n\n\n\n\n\n1.新建Render\n接下来到Render包下面创建RenderIcebullet.java,继承 RenderSnowball\npublic class RenderIcebullet extends RenderSnowball<EntityIcebullet>{\n\n\n        public RenderIcebullet(RenderManager renderManagerIn, Item itemIn, RenderItem itemRendererIn) {\n                super(renderManagerIn, itemIn, itemRendererIn);\n        }\n}\n\n\n构造函数里的RenderItem项我们直接改成Minecraft.getMinecraft().getRenderItem()\n物品也直接给定为原版的雪球\npublic class RenderIcebullet extends RenderSnowball<EntityIcebullet>{\n\n\n        public RenderIcebullet(RenderManager renderManagerIn) {\n                super(renderManagerIn,Items.SNOWBALL, Minecraft.getMinecraft().getRenderItem());\n        }\n}\n\n\n\n\n\n\n3.注册\n我们先回到Main里创建一个Main实例\npublic class Main {\n        \n        @Instance(Name.MOD_ID)\n        public static Main instance;\n        \n        @SidedProxy(clientSide = Name.CLIENT_PROXY_CLASS,serverSide = Name.SERVER_PROXY_CLASS)\n\n\n再创建一个注册入口文件\n\n\n\n\nQQ截图20170122114133.png (10.97 KB, 下载次数: 3)\n\n下载附件\n\n2017-1-22 11:44 上传\n\n\n\n\n\n\n\n在ModEntity里面输入\npublic class ModEntity {\n        public static void init(){\n        }\n\n\n        public static void register(){\n        }\n        \n        private static int entityID = 0;\n        \n        public static void initregister(String name,Class<? extends Entity> entityClass ,int r,int tick ,boolean sendupdata){\n                final ResourceLocation registryName = new ResourceLocation(Name.MOD_ID, name);\n                EntityRegistry.registerModEntity(registryName, entityClass, registryName.toString(), entityID++, Main.instance, r, tick, sendupdata);\n        }\n}\n\n\n initregister方法是方便我们以后注册多个实体简化代码\n\n好,现在把注册信息填进去\n        public static void init(){\n                initregister(\"icebullet\", EntityIcebullet.class, 64, 10, true);\n        }\n        \n        public static void register(){\n                    RenderingRegistry.registerEntityRenderingHandler(EntityIcebullet.class, renderManager -> new RenderIcebullet(renderManager));\n        }\n\n\n\"icebullet\":实体名称\nEntityIcebullet.class:实体文件\n64:渲染距离(距离玩家64格内开始渲染)\n20:逻辑更新频率,和渲染频率无关(单位=1tick?)\ntrue:是否传输动态位置更新?\n\ninit方法拿来注册Entity,而register()注册Render\n所以很明显init()丢到Main去读取\nregister()丢到ClientProxy去读取\nMain.java\n@EventHandler\n        public void preInit(FMLPreInitializationEvent event){\n                ModItems.init();\n                ModEntity.init();\n                ModAchivenent.init();\n                proxy.init();\n        }\n\n\nClientProxy.java\n        public void init(){\n                ModItems.register();\n                ModEntity.register();\n        }\n\n\n现在我们的Icebullet已经注册完毕存在于mc里了\n但是我们还没有一个让他出来的方法\n所以我们先用ItemIceicon右击时生产一个Icebullet\nItemIceicon.java\n        @Override\n        public ActionResult<ItemStack> onItemRightClick(World world, EntityPlayer player, EnumHand hand) {\n            ItemStack item = player.getHeldItemMainhand();\n            player.addStat(ModAchivenent.iceSkillslist[item.getMetadata()]);\n            \n            if(!world.isRemote && item.getMetadata() == 0){\n                EntityIcebullet icebullet = new EntityIcebullet(world, player);\n                icebullet.setHeadingFromThrower(player, player.rotationPitch, player.rotationYaw, 0.0F, 1.5F, 1.0F);\n               world.spawnEntityInWorld(icebullet);\n            }\n                return super.onItemRightClick(world, player, hand);\n        }\n\n\n我们用getMetadata()判断只有Metadata为0的呢个物品可以释放冰弹\n这里要!world.isRemote一下不然一下子射出两个,然后其中一个又会突然消失\n呢个消失的其实就是客户端生成的,但和服务端同步数据后发现不对则么\n多了一颗,然后他就消失了\n而前面获取成就客户端有没有执行其实没什么影响所以我就没限制了\n\n\n\n\nQQ截图20170122115956.png (359.6 KB, 下载次数: 6)\n\n下载附件\n\n2017-1-22 12:08 上传\n\n\n\n\n\n\n现在就可以看到一个雪球被丢出去咯!\n\n\n\n\n\n然而现在的渲染还是十分简单,一个物品贴图\n而且不管以什么角度看都是呢个物品贴图\n而下一章,我们要把他做成像箭一样的立体渲染\n\n源代码\n\n\n\nsrc_教程9.rar\n(25.89 KB, 下载次数: 30)\n\n\n\n2017-1-22 12:28 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n",
    "replies": []
}