{
    "title": "为什么sendMessage不用可变参数呢？",
    "author": "鸭蛋只吃黄",
    "replyCount": 7,
    "timestamp": 1489978980,
    "txt_content": "Player下的sendMessage是个很有用的方法，但是它不支持可变参数。每次想一次发一个数组我都得new String[]{}，难道是官方懒得写代码....",
    "replies": [
        {
            "author": "星",
            "timestamp": 1490158740,
            "txt_content": "什么可变参数 说具体一些吧"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1490169300,
            "txt_content": "小星啊啊啊 发表于 2017-3-22 12:59\n什么可变参数 说具体一些吧\n.............可变参数这四个字已经具体到家了"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1490233200,
            "txt_content": "凋灵兔子 发表于 2017-3-22 15:55\n.............可变参数这四个字已经具体到家了\n不不不，变长参数才是正确说法，看标题的时候我还以为你说泛型呢"
        },
        {
            "author": "q88724653",
            "timestamp": 1490234640,
            "txt_content": "你不会自定义个方法吗，不是官方懒是你懒"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1490248560,
            "txt_content": " 本帖最后由 凋灵兔子 于 2017-3-23 15:01 编辑 \nq88724653 发表于 2017-3-23 10:04\n你不会自定义个方法吗，不是官方懒是你懒\n自定义方法不能定义在Player内部，而且也要包含本来的sendMessage方法，算是二次包装了，抛去其他因素，光是一次一次运行的时候查表找方法的开销就远远超过了new数组的开销，而官方在实现包中加上三个点并不会多余出来什么。其实我这么说有点无理取闹，毕竟谁都不会在乎这点开销.....不过写代码的乐趣之一就是把开销降到最小"
        },
        {
            "author": "言灵乀Poison",
            "timestamp": 1490258940,
            "txt_content": " 本帖最后由 言灵乀Poison 于 2017-3-23 17:00 编辑 \n凋灵兔子 发表于 2017-3-23 13:56\n自定义方法不能定义在Player内部，而且也要包含本来的sendMessage方法，算是二次包装了，抛去其他因素，光 ...\n嗯，写一个MessageUtils.sendMessage(CommandSender receiver, String msgs...) { receiver.sendMessage(msgs); }就能解决问题\n\n至于开销，方法在第一次运行的时候就会被jvm解析，链接。\n之后每次运行的时候是查方法表还是直接运行方法，没看过jvm源码我就不乱讲了，但是我认为，用某些key(不一定是字符串)去查方法表的概率极低，更可能的是，通过内存地址的运算来获取方法。\n事实上相比这个，我觉得进入方法并退出方法的本地栈生成和释放以及各种控制权管理之类的才更耗时间吧。\n\n不过呢，我保证10w次运行的耗时也不会多1ms，另一方面，如果真的运行很多次，JIT会把方法内联，也就不存在查方法表，转移控制权这些东西了(当然前提是你用官方JRE或基于官方修改的JRE运行，并且方法足够简单，就像我在最上面写的那样)\n\n\n如果你坚持看到这里，那我先对你道个歉，说这么多我是我有点小题大做了，我只是看着你的\"任性\"，感觉挺不认同的，所以我还要接着说qwq。\n因为在我看来，程序员的任性应该是在程序的架构，可用性，易用性，然后才是效率(个别专门追求效率的程序除外)\n举个例子，我是专门写了一个信息发送框架\n在程序里调用的话多了这么多开销(不计信息初始化，比如从语言配置获取信息)：\ngetfield 的bytecode两个方法的传递(传信息key, 信息参数，第一个方法是代理)又一个方法的传递hashmap查缓存(没缓存的时候会新建)返回MessageFormat缓存根据信息参数编译信息(嗯其实就是调用MessageFormat对象的format方法)用spilt根据换行符把信息分割成数组最后一个方法的传递(这个方法的内容就是我在最上面写的那个)\n\n\n嗯，开销似乎很多？但实际运行的时候，对性能没有任何影响(硬要说有当然可以，但我指的是能感受到的影响)\n那么花了这么\"多\"开销我获得了什么呢？\n程序里只需要调用messager的info,warning,debug,error，就能分别输出不同样式的信息(每个方法都有xxxConsole的版本)，并且这些样式是可以配置的调用的时候只需要传信息key和信息参数置(参数的意思是，比如，\"你获得了5点积分\"中的5)，信息的具体内容不需要了解，可以硬编码在一个专门的语言类，当然也可以从配置加载，让用户能够自定义(能够让用户自定义就是我使用信息key的初衷)使用messageFormat对信息参数进行设置，不需要自己拼装了，看起来舒服，同时性能也几乎没有更多消耗(看了下MessageFormat的源码，写得挺6的)\n\n\n\n嗯，言辞可能有点激烈，还望多多包涵"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1490312580,
            "txt_content": "言灵乀Poison 发表于 2017-3-23 16:49\n嗯，写一个MessageUtils.sendMessage(CommandSender receiver, String msgs...) { receiver.sendMessage(m ...\n虽然看不懂，但是能写这么多字先跪一波肯定没错"
        }
    ]
}