{
    "title": "第四章：使用Proxy代理让客户端服务端分工合作。",
    "author": "正逍遥0716",
    "replyCount": 0,
    "timestamp": 1446181140,
    "txt_content": " 本帖最后由 正逍遥0716 于 2015-10-30 23:37 编辑 \n\n<基于1.8 Forge的Minecraft mod制作经验分享>\n别被那个Proxy代理吓到，很简单的。我们先讨论为什么要用Proxy代理：像打开新的UI这种操作，比如打开一个背包，每个玩家都有各自的背包，这个操作仅仅应该发生在客户端，服务端通常是不做图形上的操作的。而像发送一个消息广播之类的事件，则应该在服务端处理，客户端只负责接收。因此，我们有了区分当前运行的是客户端还是服务端的需求，以分别处理不同的事件。诚然，我们可以粗暴的每次用if来判定，但这样效率无疑是很低的。所以Proxy就派上用场了。接下来讨论什么是Proxy，它是怎么解决上述问题的：Proxy的含义就是双面代理，通过为不同的运行端实例化不同的类，来使得不同端执行不同操作。这两个面、即两个类，通常分别叫做ClientProxy和CommonProxy，这个实例通常这么申明：public static CommonProxy proxy复制代码并且ClientProxy必须继承自CommonProxy，这样才能用clientProxy初始化proxy实例。但这里有个疑问，就是ClientProxy里的方法是否需要Override并且super父类CommonProxy的方法。不过现在貌似没遇到过问题，那就先往后走吧。好，现在上代码，看看实际中Proxy的用法：\n@SidedProxy(clientSide = \"com.zhengxiaoyao0716.douromod.ClientProxy\", serverSide = \"com.zhengxiaoyao0716.douromod.CommonProxy\")\npublic static CommonProxy proxy;复制代码上面代码的含义：@SideProxy注释是用来标识代理器的，对下面的proxy实例加上了这个标识后，Forge开始时就会自动根据clientSide、serverSide指定的类（是的，要写上完整的包路径）来为其做不同的初始化。所以请注意：1、proxy不可为final（否则你让人家怎么初始化）2、不需要再手动将其初始化。\n接下来的使用就很简单了，你可以把proxy当成一个接口，放心大胆的在其上调用方法，执行时会自动调用ClientProxy或CommonProxy类里面的方法。也不知道我说明白没有老规矩Github：https://github.com/zhengxiaoyao0716/DouroMod，快来一起做啊！！！好吧我承认我写那么认真就是为了如果有一天我弃坑了，能有好心人把斗罗大坑填上。之前在贴吧里面遇到了一个曾经挖过这个坑的前辈，感慨良多啊\n",
    "replies": []
}