{
    "title": "[搬运+翻译][从零学编程]Python3Ⅱ：控制结构",
    "author": "45gfg9",
    "replyCount": 1,
    "timestamp": 1563726960,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-16 17:32 编辑 \n\n索引贴\n答案帖\nPrev: Python3Ⅰ：基本概念\nNext: Python3Ⅲ：函数 & 模块\n\n\n1 布尔值 & 比较\n\n1.1 布尔值\nPython中的另外一种类型叫做[ruby=Boolean]布尔值[/ruby]。布尔值有两个可能的值：[ruby=真]True[/ruby]和[ruby=假]False[/ruby]。它们可以通过对值的比较来产生，在这个例子下，要用到相等操作符==。\n>>> my_boolean = True\n>>> my_boolean\nTrue\n\n>>> 2 == 3\nFalse\n>>> \"hello\" == \"hello\"\nTrue\n注意不要搞混赋值（一个等号）和比较（两个等号）。\nPart题：\nPython中两个布尔值是什么？\nA. True和False\nB. true和false\nC. [ruby=真实]Truth[/ruby]和[ruby=虚假]Falsity[/ruby]\n\n\n1.2 比较（一）\n另外一个比较操作符，叫做不等操作符（!=），当被比较的两个值不相等时算作True，如果相等就算作False。\n>>> 1 != 1\nFalse\n>>> \"十一\" != \"七\"\nTrue\n>>> 2 != 10\nTrue\n\nPart题：\n这行代码的输出是？\n>>> 7 != 8\nA. True\nB. False\n\n\n1.3 比较（二）\nPython也有判断一个数字是否大于或小于另一个数字的操作符，分别是 > 和 < 。\n>>> 7 > 5\nTrue\n>>> 10 < 10\nFalse\n\nPart题：\n这行代码的输出是？\n>>> 7 > 7.0\nA. True\nB. False\n\n\n1.4 比较（三）\n大于等于和小于等于的操作符分别是 >= 和 <= 。\n它们和大于/小于操作符差不多，除了它们在两个值相等的时候都会返回True。\n\n>>> 7 <= 8\nTrue\n>>> 9 >= 9.0\nTrue\n大于/小于操作符也可以用来按字典比较字符串（英文单词的字母顺序由其组成字母决定）。\nPart题：\n这行代码的输出是？\n>>> 8.7 <= 8.70\nA. 出现错误\nB. True\nC. False\n\n\n\n2 if语句\n\n2.1 if语句（一）\n你可以用if语句来运行一段需要条件符合才能运行的代码。\n如果一个条件被算作True，那么就运行一段代码。否则，就不运行那段代码。\n一个if语句长这样：\n\nif 条件:\n  语句\nPython用缩进（每行开头的空格）来界定代码块。其他语言，如C，使用方括号来做到这一点，但是在Python中缩进是强制性的；没了它，程序就不会工作。如你所看到的一样，if中的语句应该被缩进。\nPart题：\nif语句中的哪些部分要被缩进？\nA. 全部部分\nB. 第一行\nC. if中的语句\n\n\n2.2 if语句（二）\n这是一个if语句的举例：\n\nif 10 > 5:\n   print(\"10大于5\")\n\nprint(\"程序终结\")\n表达式先检测10是不是大于5。由于10确实大于5，被缩进的语句被运行了，输出“10大于5”。然后，没有被缩进的语句，不属于if语句的范围，被运行了，输出“程序终结”。\n注意if语句表达式后面的冒号 ( : )。\n\n由于这个程序包含几行代码，你应该为它创建一个单独的文件运行。\nPart题：\n下面代码的输出是？\n\nspam = 7\nif spam > 5:\n  print(\"five\")\nif spam > 8:\n  print(\"eight\")\nA. 没有输出\nB. five\nC. eight\n\n\n2.3 if语句（三）\n为了实现更复杂的条件检测，if语句可以被嵌套，也就是if语句中还有if语句。这也就是说里面的if语句是外面的if的一部分。这是一种检测几条条件是否都成立的方法。\n举例：\n\nnum = 12\nif num > 5:\n   print(\"大于5\")\n   if num <=47:\n      print(\"5和47之间\")\n结果：\n\n>>>\n大于5\n5和47之间\n>>>\nPart题：\n下面代码的输出是？\nnum = 7\nif num > 3:\n  print(\"3\")\n  if num < 5:\n    print(\"5\")\n    if num == 7:\n      print(\"7\")\n\n\n\n3 else语句\n\n3.1 else语句（一）\n一个else语句要跟随在一个if语句的后面，包含着当if语句的条件被计算为False时要运行的代码。\n和if一样，代码块要缩进。\nx = 4\nif x == 5:\n   print(\"Yes\")\nelse:\n   print(\"No\")\n结果：\n>>>\nNo\n>>>\nPart题：\n下面代码的结果是？\nif 1 + 1 == 2:\n  if 2 * 2 == 8:\n    print(\"if\")\n  else:\n    print(\"else\")\nA. 没有输出\nB. if\nC. else\n\n\n3.2 else语句（二）\n你也一样可以连接一串if和else语句来判断一系列可能性是否为真。\n举例：\nnum = 7\nif num == 5:\n  print(\"数字是5\")\nelse: \n  if num == 11:\n    print(\"数字是11\")\n  else:\n    if num == 7:\n      print(\"数字是7\")\n    else: \n      print(\"数字不是5、11或7\")\n结果：\n\n>>>\n数字是7\n>>>\nPart题：\n填空以比较变量，并输出对应文字：\nx = 10\ny = 20\n__ x > y _\n  print(\"if语句\")\n_____\n  print(\"else语句\")\n\n\n3.3 elif语句\nelif语句（else if的缩写）是if和else语句连接时的快捷写法。一串if elif语句可以在最后有一个else语句，在当之前的if或elif语句的条件没有一个被算作True时执行。\n举例：\nnum = 7\nif num == 5:\n   print(\"数字是5\")\nelif num == 11:\n   print(\"数字是11\")\nelif num == 7:\n   print(\"数字是7\")\nelse:\n   print(\"数字不是5、11或7\")\n输出：\n\n>>>\n数字是7\n>>>\n在其他编程语言中，与elif等价效果的语句有不同的形式，包括else if、elseif或elsif。\nPart题：\n“else if”的缩写是：\n\n\n\n4 布尔逻辑\n\n4.1 布尔逻辑\n\n对于那些需要不止一个条件的if语句来说，布尔逻辑可以为其组合出更复杂的判断条件。\nPython中的布尔操作符有[ruby=与]and[/ruby]、[ruby=或]or[/ruby]和[ruby=非]not[/ruby]。\nand操作符需要两个参数，在只有两个参数都是True的时候自身才算作True。否则，它就算作False。\n>>> 1 == 1 and 2 == 2\nTrue\n>>> 1 == 1 and 2 == 3\nFalse\n>>> 1 != 1 and 2 == 2\nFalse\n>>> 2 < 1 and 3 >  6\nFalse\nPython用单词作为它的布尔操作符，但在很多其他编程语言中用诸如 && 、 || 和 ! 的符号。\nPart题：\n下面代码的结果是？\nif (1 == 1) and (2 + 2 > 3):\n  print(\"true\")\nelse:\n  print(\"false\")\nA. true\nB. false\nC. true false\n\n\n4.2 布尔或\nor操作符也需要两个参数。当两个参数中至少有一个参数为True的时候才算作True，也就是说只有在当两个参数都是False的时候才返回False。\n\n>>> 1 == 1 or 2 == 2\nTrue\n>>> 1 == 1 or 2 == 3\nTrue\n>>> 1 != 1 or 2 == 2\nTrue\n>>> 2 < 1 or 3 >  6\nFalse\n\nPart题：\n填空输出“Welcome”。\nage = 15\nmoney = 500\nif age > 18 __ money > 100:\n  _____(\"Welcome\")\n\n\n4.3 布尔非\n不像我们到现在为止看到的其他操作符，not只需要一个参数，并且将它反相。\nnot True的结果是False，not False的结果是True。\n>>> not 1 == 1\nFalse\n>>> not 1 > 7\nTrue\n\n你可以用布尔操作符将几个判断语句连接在一起，作为if语句的条件。\nPart题：\n下面代码的结果是？\nif not True:\n  print(\"1\")\nelif not (1 + 1 == 3):\n  print(\"2\")\nelse:\n  print(\"3\")\n\n\n\n5 运算优先级\n\n5.1 运算优先级（一）\n运算优先级是编程中一个举足轻重的概念。它是对数学中的运算顺序的一个扩展（乘法先于加法等），扩展了其他的运算（操作）符，比如布尔逻辑中的运算符。\n\n下面的代码说明了 == 比 or 有着更高的优先级。\n>>> False == False or True\nTrue\n>>> False == (False or True)\nFalse\n>>> (False == False) or True\nTrue\nPython的运算顺序和数学是一致的：先括号，再指数运算，之后乘除，最后加减。\nPart题：\n下面代码的结果是？\nif 1 + 1 * 3 == 6:\n  print(\"Yes\")\nelse:\n  print(\"No\")\nA. Yes\nB. No\n\n\n5.2 运算优先级（二）\n下表列出了Python中所有的运算（操作）符，运算优先级由高到低。\n\n\n操作符描述**指数运算（乘方）~, +, -二进制补码，一元加和一元减（后两者的方法名分别是+@和-@）*, /, %, //乘，除，取余，向下取整除+, -加法和减法>>, <<二进制右移、左移&按位与^按位异或|按位或in, not in, is, is not, <, <=, >, >=, !=, ==比较运算符，相等运算符，成员和身份运算符not布尔非and布尔与or布尔或=, %=, /=, //=, -=, +=, *=, **=赋值运算符\n\n同一行的运算符有同样的优先级。\nPart题：\n下面代码的结果是？\nx = 4\ny = 2\nif not 1 + 1 == y or x == 4 and 7 == 8:\n  print(\"Yes\")\nelif x > y:\n  print(\"No\")\nA. Yes\nB. No\nC. Yes No\n\n\n\n6 while循环\n\n6.1 while循环（一）\n如果条件算作True，if语句就执行一次，否则就不会执行。\nwhile语句与它相似，不同的是while可以运行不止一次。只要条件符合，while中的语句会被重复执行。一旦条件被算作False，就去执行下一部分代码。\n下面是一个while循环将变量从1加到5，然后终结。\ni = 1\nwhile i <=5:\n   print(i)\n   i = i + 1\n\nprint(\"完成！\")\n\n结果：\n>>>\n1\n2\n3\n4\n5\n完成！\n>>>\nwhile循环体中的语句被重复执行。这被叫做[ruby=iteration]迭代[/ruby]。\nPart题：\n这段代码输出几个数字？\n\ni = 3\nwhile i>=0:\n  print(i)\n  i = i - 1\n\n\n6.2 while循环（二）\n死循环是一种特殊的while循环；它永远不会停止。它的条件永远算作True。\n死循环的一个例子：\n\nwhile 1==1:\n  print(\"在循环中\")\n这个程序会无限输出“在循环中”。\n\n你可以通过快捷键Ctrl+C或关闭程序来停止程序的运行。\nPart题：\n按要求填空：用循环将x的值每次增加2，并输出偶数。\nx = 0\n_____ x <=20_\n  _____ (x)\n  x += 2\n\n\n6.3 break语句\n如果要提前结束一个while循环，可以用到break语句。\n当在循环内遇到break语句时，它会立即终结循环。\ni = 0\nwhile 1==1:\n  print(i)\n  i = i + 1\n  if i >= 5:\n    print(\"退出中\")\n    break\n\nprint(\"完成\")\n结果：\n>>>\n0\n1\n2\n3\n4\n退出中\n完成\n>>>\n在循环外使用break语句会产生错误。\nPart题：\n这段代码输出几个数字？\ni = 5\nwhile True:\n  print(i)\n  i = i - 1\n  if i <= 2:\n    break\n\n\n6.4 continue语句\n另一个可以在循环中使用的语句叫做continue。\n与break不同的是，continue会跳回到循环的最开始，而不是终结循环。\ni = 0\nwhile True:\n   i = i +1\n   if i == 2:\n      print(\"跳过2\")\n      continue\n   if i == 5:\n      print(\"退出中\")\n      break\n   print(i)\n\nprint(\"完成\")\n结果：\n>>>\n1\n跳过2\n3\n4\n退出中\n完成\n>>>\n基本上来说，continue会停止当前的这次迭代，从下一次迭代继续运行。\n\n在循环外使用continue语句会产生错误。\nPart题：\n哪个语句会停止当前的迭代，从下一次开始？\n\n\n\n7 列表\n\n7.1 列表（一）\n[ruby=Lists]列表[/ruby]是Python中的另一种对象。它被用做存储一列被索引的数据。\n一个列表可以通过方括号和以逗号分隔的数据创建。\n列表中的某个特定数据可以通过在方括号中使用它的索引获得。\n举例：\nwords = [\"Hello\", \"world\", \"!\"]\nprint(words[0])\nprint(words[1])\nprint(words[2])\n结果：\n>>>\nHello\nworld\n!\n>>>\n要注意列表中的第一项数据的索引是0而不是1。\nPart题：\n这段代码的结果是？\nnums = [5, 4, 3, 2, 1]\nprint(nums[1])\n\n\n7.2 列表（二）\n用一对空的方括号可以创建一个空列表。\nempty_list = []\nprint(empty_list)\n结果：\n>>>\n[]\n>>>\n基本上来说，列表中的最后一项不需要跟逗号。但是标上一个是完全可以的，有些时候也鼓励这么做。\nPart题：\n这个列表中有几项？\n[2,]\nA. 1\nB. 2\nC. 3\n\n\n7.3 列表（三）\n一般而言，一个列表包含着一种数据类型，但是也可能包含不同种数据类型。\n列表也可以嵌套列表。\nnumber = 3\nthings = [\"string\", 0, [1, 2, number], 4.56]\nprint(things[1])\nprint(things[2])\nprint(things[2][2])\n结果：\n>>>\n0\n[1, 2, 3]\n3\n>>>\n列表中的列表常被用来代表二维网格，因为Python中没有其他编程语言有的多_维数组。\nPart题：\n填空创建一个列表并输出它的第三项。\nlist = _ 42, 55, 67]\nprint(list[ _ ])\n\n\n7.4 列表（四）\n如果索引超出列表的界限，会产生一个IndexError。\n有些类型，例如字符串，可以像列表一样被索引。对字符串的索引就像是在索引一个包含着字符串中每个字符的列表。\n对于其他类型，例如整型，尝试对其索引会产生一个TypeError。\nstr = \"Hello world!\"\nprint(str[6])\n结果：\n>>>\nw\n>>>\nPart题：\n下面哪一行代码会产生错误？\nnum = [5, 4, 3, [2], 1]\nprint(num[0])\nprint(num[3][0])\nprint(num[5])\nA. 第二行\nB. 第三行\nC. 第四行\n\n\n\n8 列表操作\n\n8.1 列表操作（一）\n列表中特定的数据可以被重新赋值。\n举例：\nnums = [7, 7, 7, 7, 7]\nnums[2] = 5\nprint(nums)\n结果：\n>>>\n[7, 7, 5, 7, 7]\n>>>\nPart题：\n这段代码的结果是？\nnums = [1, 2, 3, 4, 5]\nnums[3] = nums[1]\nprint(nums[3])\n\n\n8.2 列表操作（二）\n列表可以像字符串一样加乘。\n举例：\nnums = [1, 2, 3]\nprint(nums + [4, 5, 6])\nprint(nums * 3)\n结果：\n>>>\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n>>>\n列表和字符串在许多地方有相似之处——字符串可以被想成不能改变其中字符的列表。\nPart题：\n填空创建列表，对其第二项重新赋值，并输出整个列表。\nnums = [33, 42, 56 _\nnums[ _ ] = 22\nprint( ____ )\n\n\n8.3 列表操作（三）\n使用in操作符可以检测一项数据是否存在于列表中。如果这项数据在列表中出现一次以上，返回True。否则就返回False。\nwords = [\"spam\", \"egg\", \"spam\", \"sausage\"]\nprint(\"spam\" in words)\nprint(\"egg\" in words)\nprint(\"tomato\" in words)\n结果：\n>>>\nTrue\nTrue\nFalse\n>>>\nin操作符也可以用来检测一个字符串是不是另一个字符串的子字符串。\nPart题：\n这段代码的结果是？\nnums = [10, 9, 8, 7, 6, 5]\nnums[0] = nums[1] - 5\nif 4 in nums:\n  print(nums[3])\nelse:\n  print(nums[4])\n\n\n8.4 列表操作（四）\n如果要检测一项数据是否不存在于列表中，可以按下面几种方式的一种使用not操作符。\nnums = [1, 2, 3]\nprint(not 4 in nums)\nprint(4 not in nums)\nprint(not 3 in nums)\nprint(3 not in nums)\n结果：\n>>>\nTrue\nTrue\nFalse\nFalse\n>>>\nPart题：\n按要求填空：如果列表中包含'z'，就输出\"Yes\"。\nletters = ['a', 'b', 'z']\n__ \"z\" __ letters:\n  print(\"Yes\")\n\n\n\n9 列表函数\n\n9.1 列表函数（一）\n另一种更改列表的方法是使用append方法。它会将一项数据添加到一个现有列表的末尾。\nnums = [1, 2, 3]\nnums.append(4)\nprint(nums)\n结果：\n>>>\n[1, 2, 3, 4]\n>>>\nappend前的点( . )意味着append是列表类的一个[ruby=method]方法[/ruby]。关于方法，我们以后会讲到。\nPart题：\n这段代码的结果是？\nwords = [\"hello\"]\nwords.append(\"world\")\nprint(words[1])\nA. 产生错误\nB. hello\nC. world\n\n\n9.2 列表函数（二）\n使用len函数可以获取列表中的项数。\nnums = [1, 3, 5, 2, 4]\nprint(len(nums))\n结果：\n>>>\n5\n>>>\n不像append，len是个普通的函数，而不是一个方法。这意味着它写在列表被调用前，也就不需要写点。\nPart题：\n这段代码的结果是？\nletters = [\"a\", \"b\", \"c\"]\nletters.append(\"d\")\nprint(len(letters))\n\n\n9.3 列表函数（三）\ninsert方法与append相似，但它允许你在列表的任意位置插入新的一项，而不是只在最后。\nwords = [\"Python\", \"fun\"]\nindex = 1\nwords.insert(index, \"is\")\nprint(words)\n结果：\n>>>\n['Python', 'is', 'fun']\n>>>\nPart题：\n这段代码的结果是？\nnums = [9, 8, 7, 6, 5]\nnums.append(4)\nnums.insert(2, 11)\nprint(len(nums))\n\n\n9.4 列表函数（四）\nindex方法寻找某一项在列表中第一次出现时的索引，并返回这个索引。\n如果项不存在于列表中，就产生一个ValueError。\nletters = ['p', 'q', 'r', 's', 'p', 'u']\nprint(letters.index('r'))\nprint(letters.index('p'))\nprint(letters.index('z'))\n结果：\n>>>\n2\n0\nValueError: 'z' is not in list\n>>>\n对于列表，还有几个有用的函数和方法。\nmax(list)：返回列表中的最大值\nmin(list)：返回列表中的最小值\nlist.count(obj)：统计一项在列表中出现多少次\nlist.remove(obj)：从列表中移除一项\nlist.reverse()：将列表中项的顺序反过来\nPart题：\n选择下面的选项填空，将'z'添加到list的末尾，并输出list的长度。\nlist.______ ('z')\nprint( ______ ______ )\nlen        (list)        insert        index        append\n\n\n\n10 Range\n\n10.1 Range（一）\nrange函数创建一串序列数字。\n下面的代码创建了一个包含0-9整数的列表。\nnumbers = list(range(10))\nprint(numbers)\n结果：\n>>>\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>>\n对list的调用是必须的，因为range自己创建一个range对象，必须转换为列表才能使用。\nPart题：\n这段代码的结果是？\nnums = list(range(5))\nprint(nums[4])\n\n\n10.2 Range（二）\n如果调用range的时候有一个参数，就产生一个包含从0开始直至那个参数的对象。\n如果有两个参数，就产生一个包含从第一个参数至第二个参数的对象。\n举例：\nnumbers = list(range(3, 8))\nprint(numbers)\n\nprint(range(20) == range(0, 20))\n结果：\n>>>\n[3, 4, 5, 6, 7]\n\nTrue\n>>>\nPart题：\n这段代码的结果是？\nnums = list(range(5, 8))\nprint(len(nums))\n\n\n10.3 Range（三）\nrange可以有第三个参数，指定了序列中数字的间隔。第三个参数必须是整型。\nnumbers = list(range(5, 20, 2))\nprint(numbers)\n结果：\n>>>\n[5, 7, 9, 11, 13, 15, 17, 19]\n>>>\nPart题：\n这段代码的结果是？\nnums = list(range(3, 15, 3))\nprint(nums[2])\nA. 0\nB. 3\nC. 9\nD. 12\n\n\n\n11 for循环\n\n11.1 循环\n有时候需要对列表中的每一项都执行操作。这被称作迭代，可以通过while循环和一个计数变量实现。\n举例：\nwords = [\"hello\", \"world\", \"spam\", \"eggs\"]\ncounter = 0\nmax_index = len(words) - 1\n\nwhile counter <= max_index:\n   word = words[counter]\n   print(word + \"!\")\n   counter = counter + 1\n结果：\n>>>\nhello!\nworld!\nspam!\neggs!\n>>>\n上面的例子迭代列表中所有的项，通过索引访问值，最后将它加上感叹号输出。\nPart题：\n哪种结构能用来迭代列表？\nA. if语句\nB. 循环\nC. 变量赋值\n\n\n11.2 for循环（一）\n用while迭代列表需要挺多代码的，所以Python也提供for循环达到相同的目标。\n上面的例子可以写成效果等同的下面例子：\nwords = [\"hello\", \"world\", \"spam\", \"eggs\"]\nfor word in words:\n  print(word + \"!\")\n结果：\n>>>\nhello!\nworld!\nspam!\neggs!\n>>>\nPython中的for循环和其他编程语言中的foreach循环相似。\nPart题：\n填空创建一个有效的for循环。\nletters = ['a', 'b', 'c']\n___ l __ letters _\n  print(l)\n\n\n11.3 for循环（二）\nfor循环常被用作将代码循环执行一定次数。这样做的方法是将循环和range对象结合起来。\nfor i in range(5):\n  print(\"hello!\")\n结果：\n>>>\nhello!\nhello!\nhello!\nhello!\nhello!\n>>>\n当在for循环中使用range对象时不需要对它调用list，因为不需要将其索引，所以也就不需要转换为列表。\nPart题：\n填空创建一个for循环，仅输出范围中的偶数。\n___ i in range(0, 20, _ ):\n  print( _ )\n\n\n\n12 简单计算器\n\n12.1 创建计算器（一）\n这一章是关于Python中的一个例程：一个简单的计算器。每一小节解释了程序的不同部分。\n第一部分是总体目录，在直到用户输入\"quit\"前都会一直接受输出，所以需要用到一个while循环。\nwhile True:\n   print(\"选项：\")\n   print(\"输入 'add' 将两数相加\")\n   print(\"输入 'subtract' 将两数相减\")\n   print(\"输入 'multiply' 将两数相乘\")\n   print(\"输入 'divide' 将两数相除\")\n   print(\"输入 'quit' 结束程序\")\n   user_input = input(\": \")\n\n   if user_input == \"quit\":\n      break\n   elif user_input == \"add\":\n      ...\n   elif user_input == \"subtract\":\n      ...\n   elif user_input == \"multiply\":\n      ...\n   elif user_input == \"divide\":\n      ...\n   else:\n      print(\"未知输入\")\n上面的代码是我们程序的起点。它接受用户输入，将输入与选项通过if/elif语句比较。\nbreak语句用作停止while循环，在这个例子中是当用户输入\"quit\"的时候。\nPart题：\n如果将程序中的break语句换成\"continue\"，会有什么后果？\nA. 要输入两次\"quit\"才能退出\nB. 会和原来一样正常运行\nC. 会无限运行下去\n\n\n12.2 创建计算器（二）\n程序的下一部分是得到用户想要操作的数字。\n下面的代码实现了加法计算，对于其他部分也可以如法炮制。\nelif user_input == \"add\":\n  num1 = float(input(\"输入第一个数字：\"))\n  num2 = float(input(\"输入第二个数字：\"))\n现在，当用户输入\"add\"的时候，程序指示用户输入两个数字，并将其存储在对应的变量中。\n按这样来看，当指示用户输入的时候得到的不是数字时，程序会崩溃。在之后的模块中我们会学到如何解决这种问题。\nPart题：\n为什么代码中对float的调用是必要的？\nA. 为了删掉输入中的空格\nB. 为了将输入转化为浮点数\nC. 为了检查输入是不是数字\n\n\n12.3 创建计算器（三）\n程序的最后部分处理用户的输入，并输出。\n下面是对于加法部分的代码。\nelif user_input == \"add\":\n  num1 = float(input(\"输入第一个数字：\"))\n  num2 = float(input(\"输入第二个数字：\"))\n  result = str(num1 + num2)\n  print(\"结果是\" + result)\n现在我们已经有了一个能指示用户输入，然后计算，最终显示出和的程序。\n对于其他部分（减、乘、除），也要写相似的代码。\n输出的那行也可以放在if语句外，这样就可以省略代码中重复的部分。\nPart题：\n填空，使计算器能处理乘法。\nelif user_input == \"multiply\":\n  num1 = float(input(\"输入第一个数字：\"))\n  num2 = _____(input(\"输入第二个数字：\"))\n  result = str(num1 _ num2)\n  print(\"结果是\" + ______ )\n\n\n\n章末检测\n1. 这段代码的输出是？\nlist = [1, 1, 2, 3, 5, 8, 13]\nprint(list[list[4]])\n\n\n2. 这段代码的作用是？\nfor i in range(10):\n  if not i % 2 == 0:\n    print(i+1)\nA. 输出0到8之间的所有偶数\nB. 输出2到10之间的所有偶数\nC. 输出1到9之间的所有奇数\n\n\n3. 这段代码会输出多少行？\nwhile False:\n  print(\"循环中...\")\nA. 0\nB. 1\nC. ∞\n\n\n4. 按要求填空：如果列表中有偶数项，就输出其中的第一项。\nlist = [1, 2, 3, 4]\nif ___ (list) % 2 == 0 _\n  print(list[ _ ])\n\n\n5. 这段代码的输出是？\nletters = ['x', 'y', 'z']\nletters.insert(1, 'w')\nprint(letters[2])\n\n\n6. 按要求填空：用for循环迭代列表，并输出列表中的项。\nlist = [1, 2, 3]\n___ var __ list:\n  print( ___ )\n",
    "replies": [
        {
            "author": "这里小雨.",
            "timestamp": 1579400700,
            "txt_content": "在if语句的第三板块.那个课后习题其实有一个你没讲到.就是python恶心扒拉的缩进.因为最下面的一个if在第二个if之下.因为第二个if为假.所以第三个if不执行.所以可能会误导只有第二个if错的从而想到输出3和7"
        }
    ]
}