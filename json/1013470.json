{
    "title": "[1.7.10-1.12.2][CNPC]A* A-Star 迷宫寻路算法",
    "author": "@小明",
    "replyCount": 2,
    "timestamp": 1586452980,
    "txt_content": "//迷宫大小\nvar dungeon_setting = {\n x: 100,\n z: 100\n}\n//tmp = 二维数组(0是空气,1是墙)\n//StartX = 起点坐标X\n//StartZ = 起点坐标Z\n//EndX = 终点坐标X\n//EndZ = 终点坐标Z\nfunction A_Star(e, tmp, StartX, StartZ, EndX, EndZ) {\n //寻路计时器(可省略)\n var test = new Date().getTime();\n var p = e.player;\n var openList = [], //开启列表\n  closeList = [], //关闭列表\n  result = [], //结果数组\n  result_index; //结果数组在开启列表中的序号\n openList.push({\n  x: StartX,\n  y: StartZ,\n  G: 0\n });\n do {\n  //返回最后一个元素\n  var currentPoint = openList.pop();\n  closeList.push(currentPoint);\n  var surroundPoint = SurroundPoint(currentPoint);\n  for (var i in surroundPoint) {\n   var item = surroundPoint[i]; //获得周围的四个点\n   if (\n    item.x >= 0 && //判断是否在地图上\n    item.y >= 0 &&\n    item.x < dungeon_setting.x &&\n    item.y < dungeon_setting.z &&\n    tmp[item.x][item.y] != 1 && //判断是否是障碍物\n    !existList(item, closeList) && //判断是否在关闭列表中\n    tmp[item.x][currentPoint.y] != 1 && //判断之间是否有障碍物，如果有障碍物是过不去的\n    tmp[currentPoint.x][item.y] != 1) {\n    //g 到父节点的位置\n    //如果是上下左右g等于10\n    var g = currentPoint.G + 10;\n    if (!existList(item, openList)) { //如果不在开启列表中\n     //计算H，通过水平和垂直距离进行确定\n     item['H'] = Math.abs(EndX - item.x) * 10 + Math.abs(EndZ - item.y) * 10;\n     item['G'] = g;\n     item['F'] = item.H + item.G;\n     item['parent'] = currentPoint;\n     openList.push(item);\n    } else { //存在在开启列表中，比较目前的g值和之前的g的大小\n     var index = existList(item, openList);\n     //如果当前点的g更小\n     if (g < openList[index].G) {\n      openList[index].parent = currentPoint;\n      openList[index].G = g;\n      openList[index].F = g + openList[index].H;\n     }\n    }\n   }\n  }\n  //如果开启列表空了，没有通路，结果为空\n  if (openList.length == 0) {\n   e.API.executeCommand(e.npc.world, 'title ' + p.name + ' subtitle [\"\",{\"text\":\"§4?\"}]');\n   p.message('§3无路径')\n   p.message(\"§a寻路耗时: \" + (new Date().getTime() - test) + \"ms\");\n   break;\n  }\n  openList.sort(sortF); //这一步是为了循环回去的时候，找出 F 值最小的, 将它从 \"开启列表\" 中移掉\n } while (!(result_index = existList({\n   x: EndX,\n   y: EndZ\n  }, openList)));\n //判断结果列表是否为空\n if (!result_index) {\n  result = [];\n } else {\n  var currentObj = openList[result_index];\n  do {\n   //把路劲节点添加到result当中\n   result.unshift({\n    x: currentObj.x,\n    y: currentObj.y\n   });\n   currentObj = currentObj.parent;\n  } while (currentObj.x != StartX || currentObj.y != StartZ);\n  e.API.executeCommand(e.npc.world, 'title ' + p.name + ' subtitle [\"\",{\"text\":\"§a?\"}]')\n  p.message(\"§a寻路耗时: \" + (new Date().getTime() - test) + \"ms\");\n  p.message('§2有路径');\n }\n return result;\n}\nfunction distanceToFinish(xVal, zVal) {\n return (xVal - 50) * (xVal - 50) + (zVal - 50) * (zVal - 50);\n}\n//获取周围四个点的值\nfunction SurroundPoint(curPoint) {\n var x = curPoint.x,\n  y = curPoint.y;\n return [{\n   x: x,\n   y: y - 1\n  },\n  {\n   x: x + 1,\n   y: y\n  },\n  {\n   x: x,\n   y: y + 1\n  },\n  {\n   x: x - 1,\n   y: y\n  }\n ]\n}\n//判断点是否存在在列表中，是的话返回的是序列号\nfunction existList(point, list) {\n for (var i in list) {\n  if (point.x == list[i].x && point.y == list[i].y) {\n   return i;\n  }\n }\n return false;\n}\n//用F值对数组排序\nfunction sortF(a, b) {\n return b.F - a.F;\n}复制代码\n\n[groupid=1595]CNPC Script Studio[/groupid]",
    "replies": [
        {
            "author": "Twilight_Two",
            "timestamp": 1586518980,
            "txt_content": "这玩意。。。是给npc走迷宫用的？。。"
        },
        {
            "author": "@小明",
            "timestamp": 1586576160,
            "txt_content": "Twilight_Two 发表于 2020-4-10 19:43\n这玩意。。。是给npc走迷宫用的？。。\n可以作用于其他领域嘛 这只是个在随机地牢中 随机确认两个点 然后用寻路方法判断是否连通 如果连通 取最近一条路  "
        }
    ]
}