{
    "title": "[原版模组] sch233's dream - 基本模块",
    "author": "△＠←",
    "replyCount": 10,
    "timestamp": 1597863120,
    "txt_content": " 本帖最后由 △＠← 于 2021-1-2 18:27 编辑 \n\nSch233's Dream - basic====写在前面====    可能会有人好奇为什么这个数据包一开始就是2.0.0以上了，因为这个最开始就是自己做着玩的然后更了好多代。。。。。。    根据在百度上搜索的版本号的标准来看(版本号命名规则-CSDN)，大概还算是合理的吧(因为重写了几次所以版本就上升到了4.0.0了)    关于我本人，，        bilibili的账号名字是sch246个人空间链接        JE版MC账号是sch233，也是这个数据包取名的由来下一版的基本模块链接(与这一版不兼容且用法不同)SPGoding - 所有数据包使用大憨批编辑，大憨批真的好用，另外还有各种教程(断言, 战利品表, 还有,,记不清了)\nruhuasiyu - 潜影盒修改玩家背包的技术教程，以及copy了一下如花影盒的战利品表\n还有谁我想到再加，，====这是干啥的?====    这是一个有那么一点点功能的前置模块，用来搭建其它数据包的运行环境(全gui控制！！)，主要作用就是给我自己用，虽然是前置但选择性需要另一个前置才能更好运行，，在下面\"关于安装\"有说\n    如果有谁用我的这个前置我会挺高兴的，，因为下载前置到我这里就会看到我的其他模块，，\n    所以做出了一个空的负载模块可以让你们下载，，就是那个叫shell的\n如果你打算用这个当自己数据包的前置(应该不会有人吧请在下载基本模块的同时下载  sch233_pack_shell_4.0.0.zip\n然后全局替换test为自己的模块名sch233_pack_shell_4.0.0\\data\\sch233\\functions\\test 的文件夹名也一起改进入sch233:<模块名>/load/func/init 把\"测试V4.0.0\" 和 \"测试的提示信息,点击打开设置\" 改掉版本在sch233:<模块名>/load/run 的前排设置basic数据包提供的支持为所有以shell为基础的数据包提供版本检测以及卸载重装以及打开设置的功能(这个大修了好几遍了)以下显示在玩家进入世界(不管是单机还是多人的，第一次进入还是之后的进入)以及reload时都会显示\n\n\n\n\nimage.png (27.53 KB, 下载次数: 3)\n\n下载附件\n\n2020-10-19 14:04 上传\n\n\n\n\n\n\n\n\n\n\nimage.png (1.06 KB, 下载次数: 5)\n\n下载附件\n\n2020-10-19 14:04 上传\n\n\n\n\n点击打开作者信息(肯定是我的信息啦)\n\n\n\n\n\nimage.png (2.11 KB, 下载次数: 3)\n\n下载附件\n\n2020-10-19 14:05 上传\n\n\n\n\n打开对应模块的设置，悬停文字自定义，最终打开的路径是sch233:<模块名>/tick/player/func/sets(你可以在这里塞你想显示的东西\n\n\n\n\nimage.png (1.62 KB, 下载次数: 6)\n\n下载附件\n\n2020-10-19 14:06 上传\n\n\n\n\n点击运行初始化sch233:<模块名>/load/func/init，基本上是调试用的，因为我一般把计分板的创立放在这里但版本相同的话就不会运行所以这是手动加载\n\n\n\n\nimage.png (3.1 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-19 14:20 上传\n\n\n\n\n运行sch233:<模块名>/load/func/unist，一般在这里卸载，点击会弹出确认信息\n#sch233_<模块名>..active temp 可以控制对应模块是否运行(1开,0关)，用于调试模块，可以不卸载的情况下让模块停止运行，但注意这个没有在tick/run之外的地方加上去，需要的话照着tick的手动加上吧\n\n游戏storage内存的版本与数据包设置的版本不同会有不同的显示，下面是basic的加载过程sch233:load/run\n#初始化\n    #清除输出暂存\n        data remove storage sch233 -.sys.output\n    #初始化基本计分板\n        # scoreboard objectives remove temp\n        scoreboard objectives add temp dummy\n    #设置版本号\n        scoreboard players set #sch233_basic..version temp 40100\n    #初始化玩家存储\n        execute unless data storage sch233 -.player.storage run data modify storage sch233 -.player.storage append value {uid:0}\n    #常加载区块\n        forceload add 1 1\n\n#检查异常状态\n#状态预设为-1为错误(0为正常加载,1为需要更新,2为已安装过更高版本,3为初次加载)\nscoreboard players set #sch233_basic.check temp -1\n    #如果存储存在，检测版本\n    execute store result score #sch233_temp.version temp run data get storage sch233_basic -.version\n    scoreboard players operation #sch233_temp.version temp -= #sch233_basic..version temp\n    execute if score #sch233_temp.version temp matches 0 run scoreboard players set #sch233_basic.check temp 0\n    execute if score #sch233_temp.version temp matches ..-1 run scoreboard players set #sch233_basic.check temp 1\n    execute if score #sch233_temp.version temp matches 1.. run scoreboard players set #sch233_basic.check temp 2\n    #存储不存在则进行彻底的初始化\n    execute unless data storage sch233_basic -.version run scoreboard players set #sch233_basic.check temp 3\n\n#排除异常状态\n    #异常状态为1，更新，并且状态设为已更新\n    execute if score #sch233_basic.check temp matches 1 run function sch233:load/func/init\n    #异常状态为3，加载，状态设为已加载\n    execute if score #sch233_basic.check temp matches 3 run function sch233:load/func/init\n    #显示\n    execute as @a run function sch233:load/func/show\n\n#其它数据包运行load\n    function #sch233:load\n    \n#加上load运行过的痕迹\n    scoreboard players set #sch233..active temp 1\n\n# 检测其它数据包有没有安装\n    scoreboard players set #installed mrcd_system 0\n    function mrcd:init复制代码sch233:load/func/show\n#显示状态\n\ntellraw @s {\"storage\": \"sch233\",\"nbt\": \"-.info.title\",\"interpret\": true}\ntellraw @s {\"text\": \"========================\",\"color\":\"gray\"}\n\n\n# 异常状态\n    #异常状态为-1，状态设为错误\n    execute if score #sch233_basic.check temp matches -1 run tellraw @s {\"text\": \"\",\"extra\":[{\"storage\": \"sch233_basic\",\"nbt\": \"-.name\",\"interpret\": true},\" \",{\"storage\": \"sch233\",\"nbt\": \"-.info.error\",\"interpret\": true},\" \",{\"storage\": \"sch233_basic\",\"nbt\": \"-.unist\",\"interpret\": true}]}\n    #异常状态为1，状态设为已更新\n    execute if score #sch233_basic.check temp matches 1 run tellraw @s {\"text\": \"\",\"extra\":[{\"storage\": \"sch233_basic\",\"nbt\": \"-.name\",\"interpret\": true},\" \",{\"storage\": \"sch233\",\"nbt\": \"-.info.update\",\"interpret\": true},\" \",{\"storage\": \"sch233_basic\",\"nbt\": \"-.unist\",\"interpret\": true}]}\n    #异常状态为2，状态设为未加载\n    execute if score #sch233_basic.check temp matches 2 run tellraw @s {\"text\": \"\",\"extra\":[{\"storage\": \"sch233_basic\",\"nbt\": \"-.name\",\"interpret\": true},\" \",{\"storage\": \"sch233\",\"nbt\": \"-.info.old_version\",\"interpret\": true},\" \",{\"storage\": \"sch233_basic\",\"nbt\": \"-.force_load\",\"interpret\": true}]}\n    #异常状态为3，状态设为已加载\n    execute if score #sch233_basic.check temp matches 3 run tellraw @s {\"text\": \"\",\"extra\":[{\"storage\": \"sch233_basic\",\"nbt\": \"-.name\",\"interpret\": true},\" \",{\"storage\": \"sch233\",\"nbt\": \"-.info.init\",\"interpret\": true},\" \",{\"storage\": \"sch233_basic\",\"nbt\": \"-.unist\",\"interpret\": true}]}\n    #状态为0，状态设为已安装\n    execute if score #sch233_basic.check temp matches 0 run tellraw @s {\"text\": \"\",\"extra\":[{\"storage\": \"sch233_basic\",\"nbt\": \"-.name\",\"interpret\": true},\" \",{\"storage\": \"sch233\",\"nbt\": \"-.info.done\",\"interpret\": true,\"clickEvent\": {\"action\": \"run_command\",\"value\": \"/function sch233:load/func/init\"}},\" \",{\"storage\": \"sch233_basic\",\"nbt\": \"-.unist\",\"interpret\": true}]}\n\n#其它数据包运行load_show\n    function #sch233:load_show\n\n#加上框框\ntellraw @s {\"text\": \"========================\",\"color\":\"gray\"}复制代码为每个玩家分配uid\nuid从1开始计数，同时#sch233..serverID存储当前创立uid的总玩家数，关于先后细节看下面的\"函数标签的用法\"为下一个作基础\n为每个玩家添加专属nbt存储空间(脱离实体)\n采用storage来进行存储，玩家的信息以{uid:<uid>,xx:xx,xxx:xx,...}的形式存储在列表sch233 -.player.storage[]中默认存在{uid:0}作为标记为表达方便设sch233 -.player.storage[0]为列表最前，对应的[-1]为列表最后以下x指执行者的uid，需要执行者有uid才能执行        提供操作的函数有后滚，仅改变顺序，把列表最前移动至列表最后 - sch233:func/player/storage/roll前滚，仅改变顺序，把列表最后移动至列表最前 - sch233:func/player/storage/roll_back\ndata modify storage sch233 -.player.storage append from storage sch233 -.player.storage[0]\ndata remove storage sch233 -.player.storage[0]复制代码\n后滚至0，后滚直到{uid:0}为列表最前(不要删掉{uid:0}，否则无限循环警告)  - sch233:func/player/storage/roll_0\n#滚动\n    function sch233:func/player/storage/roll\n\n#如果0不在最前\n    execute store result score #sch233_stemp.roll_0 temp run data get storage sch233 -.player.storage[0].uid\n    execute unless score #sch233_stemp.roll_0 temp matches 0 run function sch233:func/player/storage/roll_0复制代码\n后滚至x，后滚直到{uid:x}为列表最前或再次使当前值为列表最前(即滚完一遍列表)，需要运行之前记录下当前值 - sch233:func/player/storage/roll_x\n前滚至x，前滚直到{uid:x}为列表最前或再次使当前值为列表最前(即滚完一遍列表)，需要运行之前记录下当前值 - sch233:func/player/storage/roll_back_x\n#向后滚\n    function sch233:func/player/storage/roll\n#得到最前的uid\n    execute store result score #sch233_stemp.uid_ temp run data get storage sch233 -.player.storage[0].uid\n            # tellraw @a [\"得到uid0#sch233_stemp.uid_:\",{\"score\": {\"name\": \"#sch233_stemp.uid_\",\"objective\": \"temp\"}}]\n#如果目标不同或没有循环一圈继续循环\n    execute unless score #sch233_stemp.uid_ temp = @s uid unless score #sch233_stemp.uid_ temp = #sch233_stemp.uid temp run function sch233:func/player/storage/roll_x复制代码\n选择最近的方式滚动使{uid:x}为列表最前 - sch233:func/player/lock_id\n# 锁定玩家的id，并返回第一位的uid，务必与解锁一起使用······解锁没了\n###   输入    sch233 -.player.storage(storage) @s uid(score) #sch233..serverID uid(score)\n###   输出    sch233 -.player.storage(storage) #sch233_stemp.uid temp(score,为第一位的uid)\n###   中间量  #sch233_stemp.len temp(score) #sch233_stemp.roll_count temp(score) #sch233_stemp.roll_back_count(score) #sch233_stemp.uid_ temp(score)\n# ;\n\n#判断向前滚动还是向后滚动，然后滚动到玩家的uid在最前\n    #得到最前的uid\n        execute store result score #sch233_stemp.uid temp run data get storage sch233 -.player.storage[0].uid\n            # tellraw @a [\"得到uid#sch233_stemp.uid:\",{\"score\": {\"name\": \"#sch233_stemp.uid\",\"objective\": \"temp\"}}]\n    #获取列表长度\n        scoreboard players operation #sch233_stemp.len temp = #sch233..serverID uid\n        scoreboard players add #sch233_stemp.len temp 1 \n            # tellraw @a [\"得到列表长度#sch233_stemp.len:\",{\"score\": {\"name\": \"#sch233_stemp.len\",\"objective\": \"temp\"}}]\n    #列表总长为#sch233_stemp.len temp,玩家的uid为@s uid,当前uid为#sch233_stemp.uid temp\n    #分别设为n, x, i\n    #则需要向后滚动的次数为(x-i)%n, 向前滚动的次数为(i-x)%n\n    #得出向后滚动的次数\n        scoreboard players operation #sch233_stemp.roll_count temp = @s uid\n        scoreboard players operation #sch233_stemp.roll_count temp -= #sch233_stemp.uid temp\n        scoreboard players operation #sch233_stemp.roll_count temp %= #sch233_stemp.len temp\n            # tellraw @a [\"向后滚的次数#sch233_stemp.roll_count:\",{\"score\": {\"name\": \"#sch233_stemp.roll_count\",\"objective\": \"temp\"}}]\n    #得出向前滚动的次数\n        scoreboard players operation #sch233_stemp.roll_back_count temp = #sch233_stemp.uid temp\n        scoreboard players operation #sch233_stemp.roll_back_count temp -= @s uid\n        scoreboard players operation #sch233_stemp.roll_back_count temp %= #sch233_stemp.len temp\n            # tellraw @a [\"向前滚的次数#sch233_stemp.roll_back_count:\",{\"score\": {\"name\": \"#sch233_stemp.roll_back_count\",\"objective\": \"temp\"}}]\n    #不重合的情况下，如果向后滚动的次数小于等于向前滚动的次数，运行向后滚循环，否则运行向前滚循环\n        execute unless score #sch233_stemp.uid temp = @s uid if score #sch233_stemp.roll_count temp <= #sch233_stemp.roll_back_count temp run function sch233:func/player/storage/roll_x\n            # say 向后滚结束\n        execute unless score #sch233_stemp.uid temp = @s uid if score #sch233_stemp.roll_count temp > #sch233_stemp.roll_back_count temp run function sch233:func/player/storage/roll_back_x\n            # say 向前滚结束\n#返回第一位的uid\n    execute unless score #sch233_stemp.uid temp = @s uid run scoreboard players operation #sch233_stemp.uid temp = #sch233_stemp.uid_ temp复制代码为下一个作基础\n为每个玩家提供状态保存与读取\n保存的状态包括位置状态与物品状态，目前并没有做细\n\n位置状态需要有不同维度的信息，见下面的\"提供维度标记\"\n可运行的函数有\nsch233:\ncommands/\n    state_load/\n        load_item/run\n        load_location/run\n        load_all\n    state_save/\n        save_all\n        save_item\n        save_location\nfunc/player/\n    player_load/\n        load_item/run\n        load_location/run\n        load_all\n    player_save/\n        save_all\n        save_item\n        save_location\n    state_load/\n        load_item/run\n        load_location/run\n        load_all\n    state_save/\n        save_all\n        save_item\n        save_location\nstate的作用是把玩家的状态存入临时存储以及从临时存储中读取状态，分别是sch233_stemp -.state.item和sch233_stemp -.state.location\n物品读取采用了潜影盒黑科技，由于穷举得挺烂太长了就不帖了\n位置读取采用了@s可以一直追踪的性质sch233:func/player/state_load/load_location/run\n<font size=\"3\">tag @a remove tp_temp\ntag @s add tp_temp\nexecute as @e[name=dimension_marker] at @s run function sch233:func/player/state_load/load_location/func/tp_location\ntag @s remove tp_temp</font>复制代码sch233:func/player/state_load/load_location/func/tp_location\ndata modify storage sch233_stemp str set from storage sch233_stemp -.state.location.Dimension\nexecute store success score #sch233_stemp.compare temp run data modify storage sch233_stemp str set from entity @s Tags[0]\ntag @e[type=area_effect_cloud,name=temp_tp,tag=temp] remove temp\nexecute if score #sch233_stemp.compare temp matches 0 run summon area_effect_cloud ~ ~ ~ {CustomName:'{\"text\": \"temp_tp\"}',Tags:[\"temp\"]}\nexecute as @e[type=area_effect_cloud,name=temp_tp,tag=temp,limit=1] run function sch233:func/player/state_load/load_location/func/tp_location_复制代码sch233:func/player/state_load/load_location/func/tp_location_\nspreadplayers ~ ~ 10 34000000 false @s\ndata modify entity @s Pos set from storage sch233_stemp -.state.location.Pos\ndata modify entity @s Rotation set from storage sch233_stemp -.state.location.Rotation\n# tellraw @a [{\"entity\": \"@s\",\"nbt\": \"Pos\"}]\nexecute at @s run tp @a[tag=tp_temp] ~ ~ ~ ~ ~\ntag @s remove temp\n# say a复制代码player调用了state，作用是把玩家的状态存入临时存储再存入到玩家的专属nbt存储中(sch233 -.player.storage[0].temp.item和-.player.storage[0].temp.location)以及从玩家专属存储中读取到临时存储再读取给玩家，注意这是以列表的形式存储的，所以读取的时候还可以附带一个#sch233_stemp.location.sort或#sch233_stemp.item.sort来指定读取第几位\nsch233:func/player/player_load/load_location/run# 读取位置状态\n### 输入    sch233_stemp -.player.storage[0].temp.location[i](storage)\n###    #sch233_stemp.location.sort(score,i,默认为0)\n### 输出    传送执行者\n### 中间量  @a tp_temp(tag) sch233_stemp str(storage) #sch233_stemp.compare temp(score) @e[type=area_effect_cloud,name=temp_tp,tag=temp] temp(tag) sch233_stemp list(storage) sch233_stemp -.state.location(storage)\n# ;\n# 清掉\n    data remove storage sch233_stemp -.state.location\n# 存入临时变量\n    data remove storage sch233_stemp list\n    data modify storage sch233_stemp list set from storage sch233 -.player.storage[0].temp.location\n\n# 如果没有输入则设为默认值\n    execute unless score #sch233_stemp.location.sort temp matches -2147483648..2147483647 run scoreboard players set #sch233_stemp.location.sort temp 0\n\n# 如果sort大于等于1则从前面开始清除，i等于几就清除几位\n    #   for(;i>=1;i--)remove sch233_stemp list[0]\n        execute if score #sch233_stemp.location.sort temp matches 1.. run function sch233:func/player/player_load/load_location/func/0_\n    #   ;\n    #递归后如果还存在列表则读取当前第一位，这覆盖了i>=0的状态\n        execute if score #sch233_stemp.location.sort temp matches 0 if data storage sch233_stemp list[0] run data modify storage sch233_stemp -.state.location set from storage sch233_stemp list[0]\n\n# 如果sort小于等于-2则从后面开始清除，i每比-1小1就多清除一位\n    #   for(;i<=-2;i++)remove sch233_stemp list[-1]\n        execute if score #sch233_stemp.location.sort temp matches ..-2 run function sch233:func/player/player_load/load_location/func/_0\n    #   ;\n    #递归后如果还存在列表则读取当前最后一位，这覆盖了i<=-1的状态\n        execute if score #sch233_stemp.location.sort temp matches -1 if data storage sch233_stemp list[-1] run data modify storage sch233_stemp -.state.location set from storage sch233_stemp list[-1]\n\n# 如果列表不存在了，返回错误\n    execute unless data storage sch233_stemp list[0] run tellraw @s [{\"text\":\"[!] \",\"color\":\"aqua\"},{\"text\":\"错误的值！\",\"color\":\"red\"}]\n\n# 运行函数\n#   输入    sch233_stemp -.state.location(storage)\n    #中间量  @a tp_temp(tag) sch233_stemp str(storage) #sch233_stemp.compare temp(score)\n    #@e[type=area_effect_cloud,name=temp_tp,tag=temp] temp(tag)\n    function sch233:func/player/state_load/load_location/run\n#   输出    传送执行者复制代码\ncommand下的state的区别就是存入了另一个不是临时存储的存储(sch233 -.state.item和sch233 -.state.location)，给玩家手动调用，意味着可以做到用指令读取别人的状态给自己之类的事情视线检测集成虽然不用前置的话视线检测会比较劣质，，不过还是算有视线检测集成的使用方式见下\"函数标签的用法\"\n视线检测拥有自定义设置的功能，可以选择是否启用前置的视线检测，不启用的话就会使用自带的劣质视线检测 ，\n可以自定义视线检测距离，距离同时作用于前置和自带的视线检测\n见下\n\n\n\n\nimage.png (17.6 KB, 下载次数: 7)\n\n下载附件\n\n2020-10-19 18:28 上传\n\n\n\n\n简单的点击切换和设置，设置完后点上面的\"[基本模块Vx.x.x]\"刷新,\n当然改这种东西需要命令权限\n\n\n\n\nimage.png (14.85 KB, 下载次数: 3)\n\n下载附件\n\n2020-10-19 18:30 上传\n\n\n\n\n\n其它的一些小东西\n        权限系统\n加入了op和temp_op的tag\nop在sch233:commands/op_list里面修改\ntemp_op需要手动加op再套上个temp_op的tag，不过一堆trigger里有直接给予temp_op的trigger\n可以在服务器设置文件中设置op的权限为2，这样就只有op列表内的玩家才能给予temp_op了(途径是function或trigger，但存在bug，其实并不能完全封死temp_op玩家)\n关系到一堆trigger和登录系统的运作方式\n        提供维度标记在每个玩家处tick运行#检测新维度\n    execute at @s positioned 1 1 1 unless entity @e[type=area_effect_cloud,name=dimension_marker,distance=..0.5] run function sch233:func/sys/new_dimension复制代码function sch233:func/sys/new_dimension\n#强加载区块\n    forceload add 0 0\n#召唤marker，以及改数据\n    summon area_effect_cloud ~ ~ ~ {CustomName:'{\"text\": \"dimension_marker\"}',Duration:2147483647}\n    data modify entity @e[type=area_effect_cloud,name=dimension_marker,distance=..0.5,limit=1] Tags prepend from entity @s Dimension\n#发出信息\n    tellraw @a [\"\",{\"selector\": \"@s\",\"color\": \"green\"},{\"text\": \"发现了新的维度\",\"italic\": true,\"color\": \"gray\"},{\"entity\": \"@s\",\"nbt\": \"Dimension\",\"color\": \"aqua\"}]复制代码        时间设定设定tickx20=>secx60=>minx20=>dayx30=>monx12=>year当主手或副手拿着钟的时候会在actionbar上显示\n\n\n\n\nimage.png (143.92 KB, 下载次数: 3)\n\n下载附件\n\n2020-10-19 15:38 上传\n\n\n\n\n左边是游戏开始以来所经过的游戏刻，用time query gametime获得的，目测游戏内常规方法不能更改同时会将时间存入storage中#存到存储里\n    data remove storage sch233 -.sys.time\n    execute store result storage sch233 -.sys.time.tick int 1 run scoreboard players get #sch233..tick temp\n    execute store result storage sch233 -.sys.time.days int 1 run scoreboard players get #sch233..day temp\n    execute store result storage sch233 -.sys.time.year int 1 run scoreboard players get #sch233..year temp\n    execute store result storage sch233 -.sys.time.mon int 1 run scoreboard players get #sch233..mon temp\n    execute store result storage sch233 -.sys.time.day.hour int 1 run scoreboard players get #sch233..day.hour temp\n    execute store result storage sch233 -.sys.time.day.min int 1 run scoreboard players get #sch233..day.min temp\n    execute store result storage sch233 -.sys.time.day.sec int 1 run scoreboard players get #sch233..day.sec temp复制代码用sch233 -.info.time_show.score或者sch233 -.info.time_show.storage可以从score和storage两个方面获取以上的显示格式，虽然就结果而言是一样的，都要放到牌子上固化之后才能做为信息记录存进去        running和sneaking以及一个概率为0.5的random的断言，估计大家都会就不说了        简单地区分了实体(target是从视线检测那里改了下复制过来的，2.1为止那个json在1.16不能用)        \n\n\n\n\nimage.png (25.34 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-19 15:46 上传\n\n\n\n\n函数标签的用法打开shell会发现里面的tags/functions\n\n\n\n\n\nDK0@4@H(YAK}{7P~O]59)KO.png (21.02 KB, 下载次数: 3)\n\n下载附件\n\n2020-10-17 23:30 上传\n\n\n\n\n\n\n解释一下有什么用需要看看basic是怎么启动的，还有,show_sets是废弃的\n#minecraft:load:\n | 基本模块先设置版本号\n | 版本需要更新或检测不到版本就运行初始化，字符串计分板以及预设，只需要执行一遍的就放在这里，初始化不会调用另外的函数\n | 也许会运行一些需要每次加载都运行的东西\n\n | 运行#sch233:load_show，当然用的tellraw(单机进入世界时的显示工作留给tick，reload时又能显示)\n | 运行#sch233:load\n |  | 流程和上面如出一辙，但设sch233_<模块名>..active 为1\n | 设sch233..active为1\n#minecraft:tick:\n | 如果sch233..active为1则运行:\n |  | 一些函数\n |  | as @a at @s运行sch233:tick/player/run\n\n|  |  | 锁定玩家的uid使存储sch233 -.player.storage[0]为该玩家的专用nbt存储\n|  |  | 如果玩家不存在uid或者玩家再次进入世界则运行sch233:tick/player/come_game/run\n\n|  |  |  | 运行一些函数\n\n|  |  |  | 如果没有uid分配uid\n\n|  |  |  | 如果没有专用nbt存储分配专用nbt存储\n|  |  |  | 如果没有安装登录系统，as @a at @s运行#sch233:load_show\n|  |  |  | as @a at @s运行#sch233:player/come_game\n|  |  | 运行一些函数\n |  |  | 执行视线检测，这里需要用到前置的视线检测数据包\n\n |  |  | as玩家at玩家锁定的方块运行#sch233:player/see_block\n |  |  | as玩家at玩家,@e[tag=sch233..see_entity_lock]为玩家锁定的实体运行#sch233:player/see_entity\n |  |  | as玩家at玩家运行#sch233:player/tick\n |  | 运行#sch233:tick\n\n |  | 运行一些收尾的函数\n====关于安装====下载\n所有数据包都是在下面下载的基本模块是 sch233_pack_basic(蓝奏云)或者点这里直接下载\n\n\n\nsch233_pack_basic_4.1.7.zip\n(63.19 KB, 下载次数: 42)\n\n\n\n2020-11-8 16:51 上传\n点击文件名下载附件\n\n\n\n\n\n其它下载蓝奏云的地址1.16\n    第三版全部，V2.0.0和V3.0.0其实能混用，用最新版就行\n    https://wws.lanzous.com/b01hqjrub      第四版全部，选择性需要前置，Minecraft-Ray-Collision-Detector-2.1，不安装的话将只提供相当简陋的视线检测，不保证性能和准确度    https://wws.lanzous.com/b01hqkv7i\n    所有其他数据包要有基本模块的情况下才会运行，除了基本模块外其它所有数据包可以自由组合，相互独立\n安装放入  saves/<存档名>/datapacks/  然后打开游戏就行了，全自动安装的===关于数据包===\n==关于兼容性==强加载了1 1的区块,还改了一个潜影盒的战利品表用来修改玩家背包其余见下的“卸载问题”===关于资源包===并没有====卸载问题====如果你安装并运行了它我觉得你不会问如何卸载这个问题的，所以就是卸载干不干净的问题了其它我不敢保证，但是计分板肯定是卸载干净了存储大概也卸载干净了，就算不是也都是sch233开头的tags的话，虽然卸载的时候有移除但估计没有移除完这个大概可以用全局替换搞完但tag有点多所以就算了而且实际上留在玩家身上的tag也不多\n\n\n\n\nS[693G%EN115E1)50@~OF`J.png (18.32 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-17 23:20 上传\n\n\n\n\n====版本问题====    可以发现各个数据包的版本不尽相同，而且可能有些混乱，，因为我的版本号有些问题，不过最新的内容是不会冲突的(反正都放在一块\n\n\n\n====更新日志====\n4.0.3 - 加入了简陋的视线追踪，在没有前置的情况下运行4.1.0 - 加入了控制是否启用前置的设置以及视线距离的自定义4.1.1 - 加上了上一个忘记初始化的设定4.1.2 - 修复了第一次加载显示不出来以及uid错误的致命问题4.1.3 - 修复了强加载区块位置的问题，现在是forceload 0 04.1.4 - 修复了在虚空世界使用load_location会奔溃的问题，但是同时登录将不会有绝对不掉虚空的保证(去掉了spreadplayer，然而正常情况下都不会有用到的时候)4.1.5 - 修复了commands下的玩家物品和位置保存用不了的bug,,话说真的没人用这个功能的吗4.1.6 - 修复了commands下的物品保存需要手动清空storage的bug4.1.7 - 等等我更新了个啥？\n\n\n====旧版本====\n\n\n\nsch233的数据包_基本模块V3.0.3.zip\n(39.17 KB, 下载次数: 0)\n\n\n\n2020-11-19 16:49 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n\n\nsch233的数据包_血量上限突破V3.0.4.zip\n(173.56 KB, 下载次数: 1)\n\n\n\n2020-11-19 16:49 上传\n点击文件名下载附件\n\n\n\n\n\n支持极限模式，回血扣血闪烁，回血以及濒危抖动以及中毒凋零，护甲类型以及韧性显示，缺点是卡而且几乎不能维护，需要基本模块以及2个资源包，与4.0.0以上版本不兼容\n\n\n\nsch233的数据包_箱子锁V2.0.4.zip\n(33.78 KB, 下载次数: 1)\n\n\n\n2020-11-19 16:49 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n\nsch233的数据包_血量显示V2.0.11.zip\n(27.03 KB, 下载次数: 1)\n\n\n\n2020-11-19 16:50 上传\n点击文件名下载附件\n\n\n\n\n\n\n需要资源包以及前置资源包\n\n\n\n资源包_血量上限突破版V4.0.0.zip\n(56.88 KB, 下载次数: 0)\n\n\n\n2020-11-19 16:48 上传\n点击文件名下载附件\n\n\n\n\n\n\n负空格帖子里的链接[https://github.com/AmberWat/NegativeSpaceFont][附件链接https://www.mcbbs.net/forum.php? ... Dc0MDQ3OXwxMDUyMjU0]\n",
    "replies": [
        {
            "author": "Jokey_钥匙",
            "timestamp": 1597887180,
            "txt_content": " 本帖最后由 Jokey_钥匙 于 2020-8-20 09:38 编辑 \n\n锁箱子可以提供一个思路……大概\n锁…… 检测玩家打开箱子(用进度) 然后利用视线追踪确定坐标 之后原地clone使玩家强制关闭箱子\n\n还有 给个建议\n下载弄成压缩包(\n真的 下载列表多10+文件……"
        },
        {
            "author": "△＠←",
            "timestamp": 1598007060,
            "txt_content": "Jokey_钥匙 发表于 2020-8-20 09:33\n锁箱子可以提供一个思路……大概\n锁…… 检测玩家打开箱子(用进度) 然后利用视线追踪确定坐标 之后原地clon ...\n加上压缩包了"
        },
        {
            "author": "不忘吃心",
            "timestamp": 1598116860,
            "txt_content": "额 没看懂是叫干啥的"
        },
        {
            "author": "rudin123",
            "timestamp": 1601606100,
            "txt_content": "资瓷一下，还有很多开发空间呢"
        },
        {
            "author": "一鹿向前",
            "timestamp": 1601614380,
            "txt_content": "感谢楼主的分享 谢谢"
        },
        {
            "author": "Residual_Love",
            "timestamp": 1602157920,
            "txt_content": "欢迎新人！多看版规哦！"
        },
        {
            "author": "△＠←",
            "timestamp": 1602668340,
            "txt_content": "Residual_Love 发表于 2020-10-8 19:52\n欢迎新人！多看版规哦！\n在看了在看了"
        },
        {
            "author": "夕阳红熊猫",
            "timestamp": 1602937320,
            "txt_content": "如果是原版插件的话会比极简血量显示好，因为可以避免一些冲突"
        },
        {
            "author": "917hhhh",
            "timestamp": 1604875980,
            "txt_content": "感谢楼主分享，楼主加油"
        },
        {
            "author": "玉子吖",
            "timestamp": 1605407880,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽\n"
        }
    ]
}