{
    "title": "小白求教，关于Mod开发中的GUI和背包事件的问题",
    "author": "云闪",
    "replyCount": 6,
    "timestamp": 1442756520,
    "txt_content": " 本帖最后由 splt 于 2015-9-22 12:38 编辑 \n\n我想修改玩家生存背包的GUI，由于没有找到这类的教程（找到一个方块GUI的，不过用不到），只好自己反编译源码(主要是饰品mod的)参考= =但是做好之后出现很多奇奇怪怪的问题。。。。。。\nPS:版本是1.8的\n\n首先，做好后的图是长这样的（总觉得图挂了，我还是把图扔附件吧，那里似乎不会挂）\n\n\n\n\n\n然而还有一些很诡异的问题。。。。\n第一，红圈处其实并没有物品，但是不知道为什么会画出来\n而且画出来的物品一定是快捷栏最靠左的一个物品。。。\n\n\n第二，改了以后生存背包物品无法移动(或者说无法交互更像一点？)\n但是我canInteractWith()是只返回true的\n难道是一些监听器的问题？但是原版的ContainerPlayer类似乎也并没有监听器\n\n好像暂时只发现这两个问题\n\n\n\n\n\n以下是我的代码\n\n替换背包实例，应该很正常的一个方法吧\n\n    @SideOnly(Side.CLIENT)\n    @SubscribeEvent\n    public void GuiOpen(GuiOpenEvent event) {\n            if ((event.gui instanceof GuiInventory) && !(event.gui instanceof GuiInventoryExt)) {\n                 event.gui = new GuiInventoryExt(Minecraft.getMinecraft().thePlayer);\n            }\n    }复制代码\n\n\n自己做的背包GUI，因为继承GuiInventory不知道为什么改不了绘制的背景\n在继承GuiInventory的类\nthis.mc.getTextureManager().bindTexture(equipbackground);\n并没有什么卵用\n除了改了背景其它全是复制原版GuiInventory类，这里应该没问题\n\npackage com.splt.shenyue.gui;\n\nimport java.io.IOException;\n\nimport com.splt.shenyue.continer.InventoryExt;\n\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.gui.GuiButton;\nimport net.minecraft.client.gui.achievement.GuiAchievements;\nimport net.minecraft.client.gui.achievement.GuiStats;\nimport net.minecraft.client.gui.inventory.GuiContainerCreative;\nimport net.minecraft.client.gui.inventory.GuiInventory;\nimport net.minecraft.client.renderer.GlStateManager;\nimport net.minecraft.client.renderer.InventoryEffectRenderer;\nimport net.minecraft.client.renderer.OpenGlHelper;\nimport net.minecraft.client.renderer.RenderHelper;\nimport net.minecraft.client.renderer.entity.RenderManager;\nimport net.minecraft.client.resources.I18n;\nimport net.minecraft.entity.EntityLivingBase;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.Container;\nimport net.minecraft.util.ResourceLocation;\n\npublic class GuiInventoryExt extends InventoryEffectRenderer {\n    protected static final ResourceLocation equipbackground = new ResourceLocation(\"shenyue\",\n            \"textures/gui/inventory_ext.png\");\n/** The old x position of the mouse pointer */\n    private float oldMouseX;\n    /** The old y position of the mouse pointer */\n    private float oldMouseY;\n    private static final String __OBFID = \"CL_00000761\";\n\n    public GuiInventoryExt(EntityPlayer p_i1094_1_) {\n        super(new InventoryExt(p_i1094_1_.inventory, true, p_i1094_1_));\n\n        this.allowUserInput = true;\n    }\n\n    /**\n     * Called from the main game loop to update the screen.\n     */\n    public void updateScreen() {\n        \n        if (this.mc.playerController.isInCreativeMode()) {\n            this.mc.displayGuiScreen(new GuiContainerCreative(this.mc.thePlayer));\n        }\n\n        this.updateActivePotionEffects();\n    }\n\n    /**\n     * Adds the buttons (and other controls) to the screen in question.\n     */\n    public void initGui() {\n        \n        this.buttonList.clear();\n\n        if (this.mc.playerController.isInCreativeMode()) {\n            this.mc.displayGuiScreen(new GuiContainerCreative(this.mc.thePlayer));\n        } else {\n            super.initGui();\n        }\n    }\n\n    /**\n     * Draw the foreground layer for the GuiContainer (everything in front of\n     * the items). Args : mouseX, mouseY\n     */\n    protected void drawGuiContainerForegroundLayer(int mouseX, int mouseY) {\n        \n        // this.fontRendererObj.drawString(I18n.format(\"container.crafting\", new\n        // Object[0]), 86, 16, 4210752);\n    }\n\n    /**\n     * Draws the screen and all the components in it. Args : mouseX, mouseY,\n     * renderPartialTicks\n     */\n    public void drawScreen(int mouseX, int mouseY, float partialTicks) {\n        \n        super.drawScreen(mouseX, mouseY, partialTicks);\n        this.oldMouseX = (float) mouseX;\n        this.oldMouseY = (float) mouseY;\n    }\n\n    /**\n     * Args : renderPartialTicks, mouseX, mouseY\n     */\n    protected void drawGuiContainerBackgroundLayer(float partialTicks, int mouseX, int mouseY) {\n        \n        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);\n        this.mc.getTextureManager().bindTexture(equipbackground);\n        int k = this.guiLeft;\n        int l = this.guiTop;\n        this.drawTexturedModalRect(k, l, 0, 0, this.xSize, this.ySize);\n        drawEntityOnScreen(k + 51, l + 75, 30, (float) (k + 51) - this.oldMouseX,\n                (float) (l + 75 - 50) - this.oldMouseY, this.mc.thePlayer);\n    }\n\n    /**\n     * Draws the entity to the screen. Args: xPos, yPos, scale, mouseX, mouseY,\n     * entityLiving\n     */\n    public static void drawEntityOnScreen(int p_147046_0_, int p_147046_1_, int p_147046_2_, float p_147046_3_,\n            float p_147046_4_, EntityLivingBase p_147046_5_) {\n        GlStateManager.enableColorMaterial();\n        GlStateManager.pushMatrix();\n        GlStateManager.translate((float) p_147046_0_, (float) p_147046_1_, 50.0F);\n        GlStateManager.scale((float) (-p_147046_2_), (float) p_147046_2_, (float) p_147046_2_);\n        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);\n        float f2 = p_147046_5_.renderYawOffset;\n        float f3 = p_147046_5_.rotationYaw;\n        float f4 = p_147046_5_.rotationPitch;\n        float f5 = p_147046_5_.prevRotationYawHead;\n        float f6 = p_147046_5_.rotationYawHead;\n        GlStateManager.rotate(135.0F, 0.0F, 1.0F, 0.0F);\n        RenderHelper.enableStandardItemLighting();\n        GlStateManager.rotate(-135.0F, 0.0F, 1.0F, 0.0F);\n        GlStateManager.rotate(-((float) Math.atan((double) (p_147046_4_ / 40.0F))) * 20.0F, 1.0F, 0.0F, 0.0F);\n        p_147046_5_.renderYawOffset = (float) Math.atan((double) (p_147046_3_ / 40.0F)) * 20.0F;\n        p_147046_5_.rotationYaw = (float) Math.atan((double) (p_147046_3_ / 40.0F)) * 40.0F;\n        p_147046_5_.rotationPitch = -((float) Math.atan((double) (p_147046_4_ / 40.0F))) * 20.0F;\n        p_147046_5_.rotationYawHead = p_147046_5_.rotationYaw;\n        p_147046_5_.prevRotationYawHead = p_147046_5_.rotationYaw;\n        GlStateManager.translate(0.0F, 0.0F, 0.0F);\n        RenderManager rendermanager = Minecraft.getMinecraft().getRenderManager();\n        rendermanager.setPlayerViewY(180.0F);\n        rendermanager.setRenderShadow(false);\n        rendermanager.renderEntityWithPosYaw(p_147046_5_, 0.0D, 0.0D, 0.0D, 0.0F, 1.0F);\n        rendermanager.setRenderShadow(true);\n        p_147046_5_.renderYawOffset = f2;\n        p_147046_5_.rotationYaw = f3;\n        p_147046_5_.rotationPitch = f4;\n        p_147046_5_.prevRotationYawHead = f5;\n        p_147046_5_.rotationYawHead = f6;\n        GlStateManager.popMatrix();\n        RenderHelper.disableStandardItemLighting();\n        GlStateManager.disableRescaleNormal();\n        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);\n        GlStateManager.disableTexture2D();\n        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);\n        \n    }\n\n    protected void actionPerformed(GuiButton button) throws IOException {\n        if (button.id == 0) {\n            this.mc.displayGuiScreen(new GuiAchievements(this, this.mc.thePlayer.getStatFileWriter()));\n        }\n\n        if (button.id == 1) {\n            this.mc.displayGuiScreen(new GuiStats(this, this.mc.thePlayer.getStatFileWriter()));\n        }\n    }\n}复制代码\n\n\n然后是自己做的背包的类，继承InventoryEffectRenderer\n因为原版的ContainerPlayer类会加五个合成用的格子上去，我又没找到删除Slot的方法，只好重写这个类了\n基本上全是复制原版ContainerPlayer类，只是去掉那五个合成的格子以及所有合成的字段/方法(方法仍存在，只是和合成有关的部分注释掉了)，然后加了一个自己的格子，然后重写了canMergeSlot()方法而已\n\npackage com.splt.shenyue.continer;\n\nimport com.splt.shenyue.item.LunaChain;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.entity.player.InventoryPlayer;\nimport net.minecraft.inventory.Container;\nimport net.minecraft.inventory.IInventory;\nimport net.minecraft.inventory.InventoryCraftResult;\nimport net.minecraft.inventory.InventoryCrafting;\nimport net.minecraft.inventory.Slot;\nimport net.minecraft.inventory.SlotCrafting;\nimport net.minecraft.item.ItemArmor;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.item.crafting.CraftingManager;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\n\npublic class InventoryExt extends Container {\n\n    /** The crafting matrix inventory. */\n    public InventoryCrafting craftMatrix = new InventoryCrafting(this, 2, 2);\n    public IInventory craftResult = new InventoryCraftResult();\n    /** Determines if inventory manipulation should be handled. */\n    public boolean isLocalWorld;\n    private final EntityPlayer thePlayer;\n    private static final String __OBFID = \"CL_00001754\";\n\n    public InventoryExt(final InventoryPlayer playerInventory, boolean localWorld, EntityPlayer player) {\n        this.isLocalWorld = localWorld;\n        this.thePlayer = player;\n        // this.addSlotToContainer(new SlotCrafting(playerInventory.player,\n        // this.craftMatrix, this.craftResult, 0, 144, 36));\n        int i;\n        int j;\n        this.addSlotToContainer(new SlotEquip(playerInventory, EquipType.LUNA_CHAIN, 0, 115, 33));\n        /*\n         * for (i = 0; i < 2; ++i)\n         * {\n         * for (j = 0; j < 2; ++j)\n         * {\n         * this.addSlotToContainer(new Slot(this.craftMatrix, j + i * 2, 88 + j\n         * * 18, 26 + i * 18));\n         * }\n         * }\n         */\n\n        for (i = 0; i < 4; ++i) {\n            final int k = i;\n            this.addSlotToContainer(\n                    new Slot(playerInventory, playerInventory.getSizeInventory() - 1 - i, 8, 8 + i * 18) {\n                        private static final String __OBFID = \"CL_00001755\";\n\n                        /**\n                         * Returns the maximum stack size for a given slot\n                         * (usually the same as getInventoryStackLimit(), but 1\n                         * in the case of armor slots)\n                         */\n                        public int getSlotStackLimit() {\n                            return 1;\n                        }\n\n                        /**\n                         * Check if the stack is a valid item for this slot.\n                         * Always true beside for the armor slots.\n                         */\n                        public boolean isItemValid(ItemStack stack) {\n                            if (stack == null)\n                                return false;\n                            return stack.getItem().isValidArmor(stack, k, thePlayer);\n                        }\n\n                        @SideOnly(Side.CLIENT)\n                        public String getSlotTexture() {\n                            return ItemArmor.EMPTY_SLOT_NAMES[k];\n                        }\n                    });\n        }\n\n        for (i = 0; i < 3; ++i) {\n            for (j = 0; j < 9; ++j) {\n                this.addSlotToContainer(new Slot(playerInventory, j + (i + 1) * 9, 8 + j * 18, 84 + i * 18));\n            }\n        }\n\n        for (i = 0; i < 9; ++i) {\n            this.addSlotToContainer(new Slot(playerInventory, i, 8 + i * 18, 142));\n        }\n\n        // this.onCraftMatrixChanged(this.craftMatrix);\n    }\n\n    /**\n     * Callback for when the crafting matrix is changed.\n     */\n    public void onCraftMatrixChanged(IInventory inventoryIn) {\n        // this.craftResult.setInventorySlotContents(0,\n        // CraftingManager.getInstance().findMatchingRecipe(this.craftMatrix,\n        // this.thePlayer.worldObj));\n    }\n\n    /**\n     * Called when the container is closed.\n     */\n    public void onContainerClosed(EntityPlayer playerIn) {\n        super.onContainerClosed(playerIn);\n\n        /*\n         * for (int i = 0; i < 4; ++i) {\n         * ItemStack itemstack = this.craftMatrix.getStackInSlotOnClosing(i);\n         * \n         * if (itemstack != null) {\n         * playerIn.dropPlayerItemWithRandomChoice(itemstack, false);\n         * }\n         * }\n         * \n         * this.craftResult.setInventorySlotContents(0, (ItemStack) null);\n         */\n    }\n\n    public boolean canInteractWith(EntityPlayer playerIn) {\n        return true;\n    }\n\n    /**\n     * Take a stack from the specified inventory slot.\n     */\n    public ItemStack transferStackInSlot(EntityPlayer playerIn, int index) {\n        ItemStack itemstack = null;\n        Slot slot = (Slot) this.inventorySlots.get(index);\n\n        if (slot != null && slot.getHasStack()) {\n            ItemStack itemstack1 = slot.getStack();\n            itemstack = itemstack1.copy();\n\n            if (index == 0) {\n                if (!this.mergeItemStack(itemstack1, 9, 45, true)) {\n                    return null;\n                }\n\n                slot.onSlotChange(itemstack1, itemstack);\n            } else if (index >= 1 && index < 5) {\n                if (!this.mergeItemStack(itemstack1, 9, 45, false)) {\n                    return null;\n                }\n            } else if (index >= 5 && index < 9) {\n                if (!this.mergeItemStack(itemstack1, 9, 45, false)) {\n                    return null;\n                }\n            } else if (itemstack.getItem() instanceof ItemArmor\n                    && !((Slot) this.inventorySlots.get(5 + ((ItemArmor) itemstack.getItem()).armorType))\n                            .getHasStack()) {\n                int j = 5 + ((ItemArmor) itemstack.getItem()).armorType;\n\n                if (!this.mergeItemStack(itemstack1, j, j + 1, false)) {\n                    return null;\n                }\n            } else if (index >= 9 && index < 36) {\n                if (!this.mergeItemStack(itemstack1, 36, 45, false)) {\n                    return null;\n                }\n            } else if (index >= 36 && index < 45) {\n                if (!this.mergeItemStack(itemstack1, 9, 36, false)) {\n                    return null;\n                }\n            } else if (!this.mergeItemStack(itemstack1, 9, 45, false)) {\n                return null;\n            }\n\n            if (itemstack1.stackSize == 0) {\n                slot.putStack((ItemStack) null);\n            } else {\n                slot.onSlotChanged();\n            }\n\n            if (itemstack1.stackSize == itemstack.stackSize) {\n                return null;\n            }\n\n            slot.onPickupFromSlot(playerIn, itemstack1);\n        }\n\n        return itemstack;\n    }\n\n    /**\n     * Called to determine if the current slot is valid for the stack merging\n     * (double-click) code. The stack passed in\n     * is null for the initial slot that was double-clicked.\n     */\n    public boolean canMergeSlot(ItemStack p_94530_1_, Slot p_94530_2_) {\n        \n        return ((p_94530_1_ != null) && (p_94530_1_.getItem() != null) && (p_94530_1_.getItem() instanceof LunaChain)\n                && super.canMergeSlot(p_94530_1_, p_94530_2_));\n    }\n\n}\n复制代码\n\n\n然后是自己写的继承Slot的类，因为想要做的是装备，所以自己写了一个，仿造饰品mod(Baubles)做的\n\npackage com.splt.shenyue.continer;\n\nimport com.splt.shenyue.item.LunaChain;\n\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.inventory.IInventory;\nimport net.minecraft.inventory.Slot;\nimport net.minecraft.item.ItemStack;\n\npublic class SlotEquip extends Slot {\n\n    private EquipType type; //这是自己写的装备类型，避免原版的装备放到这个Slot中\n/**复制代码\n\n\n所有涉及到背包和GUI的类就这些了，希望大神们能给点意见QAQ 已经纠结了一天了QAQAQ{:10_503:}\n\n\n\n\n\n\n\n\nQQ截图20150920212255.jpg\n(71.34 KB, 下载次数: 7)\n\n\n\n\n下载附件\n\n\n2015-9-20 21:55 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQQ截图20150920212519.jpg\n(72.77 KB, 下载次数: 5)\n\n\n\n\n下载附件\n\n\n2015-9-20 21:52 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "qq332869722",
            "timestamp": 1443782880,
            "txt_content": " 你做的是什么MOD "
        },
        {
            "author": "SteveYE",
            "timestamp": 1444138020,
            "txt_content": "一起学java和研制我的世界服务器插件，可以的话加我的QQ446076082"
        },
        {
            "author": "饕餮魍魉枭蹀躞",
            "timestamp": 1444866120,
            "txt_content": "1.神ID请允许膜拜\n2.请问那个格子里被画错了的东西拿的出来吗?"
        },
        {
            "author": "康的世界",
            "timestamp": 1444883340,
            "txt_content": "嗯哼，来了！！！"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1444895820,
            "txt_content": "先把GuiContainer的逻辑理一下\n* IInventory在服务端端存储玩家的物品栏信息\n* Container负责处理当前打开GUI的用户（可能有很多个）对物品栏的操作和同步，以及进行一些附加的同步（e.g.进度条）\n* GuiContainer负责在客户端获取Container的内容，将它们渲染出来，并且处理玩家对物品栏的操作\n\n然后回答楼主的问题\n\n* 为了让Container和具体的IInventory接口建立联系，你需要正确的设置Slot把物品栏的信息和Gui上具体的位置联系起来。\nSlot的构造函数如下：（参数名经过手动反混淆）\npublic Slot(IInventory inventory, int slot, int x, int y);\n复制代码\n前两个参数确定对应哪个inventory的哪个slot，后两个参数确定这个slot在GUI中渲染的位置。\n所以第一个问题基本上就是加入的Slot有问题，检查一下吧\n\n* 楼主在替换GUI的时候是通过侦听OpenGui事件来进行GUI实例的替换。由于MC在内部维护了Container和GUI的同步，我不确定在这样进行替换以后，MC是否会维护与新GUI的同步（个人觉得很可能不会）。如果是这样，楼主可能需要另辟蹊径，比如覆盖MC本身打开物品栏的按键，直接从那里开始发个包到服务端，再按标准方法打开带Container的GUI。\n"
        },
        {
            "author": "云闪",
            "timestamp": 1445011920,
            "txt_content": "DeathWolf96 发表于 2015-10-15 15:57\n先把GuiContainer的逻辑理一下\n* IInventory在服务端端存储玩家的物品栏信息\n* Container负责处理当前打开G ...\n膜拜大神！！！\n唔你说的我这个周末试试吧"
        }
    ]
}