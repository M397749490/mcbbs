{
    "title": "10条命令实现实体分数排序",
    "author": "VCS-Official",
    "replyCount": 6,
    "timestamp": 1589848560,
    "txt_content": "我们有时遇到这样的问题：在竞技类小游戏中如何获取某位玩家分数的排名？为了解决这种问题，写一个排序函数是很有用的。\n\n摘自小豆数学库56号函数：scoreboard players add @e[tag=sort] scb 0\nscoreboard players set @e[tag=sort] sort 0\nexecute as @e[tag=sort] run summon area_effect_cloud ~ ~ ~ {Tags:[\"stmp\"]}\nscoreboard players set @e[tag=stmp] int -2147483648\nexecute as @e[tag=sort] run scoreboard players operation @e[tag=stmp,scores={int=-2147483648},limit=1] int = @s scb\nexecute as @e[tag=stmp] store result entity @s Pos[1] double 0.0000001 run scoreboard players get @s int\nscoreboard players set stemp int 0\nexecute positioned ~ -220 ~ as @e[tag=stmp,sort=nearest] store result score @s int run scoreboard players add stemp int 1\nexecute as @e[tag=stmp] run scoreboard players operation @e[tag=sort,scores={sort=0},limit=1] sort = @s int\nkill @e[tag=stmp]复制代码\n其中@e[tag=sort]为被排序实体，scb为储存实体分数的记分板，int是用法十分特殊的一个记分板（已被小豆用烂），这里可看作临时处理\n局限性：被排序分数不能有-2147483648\n\n基本原理：1.目标选择器若不加入sort参数，按实体出现时间顺序选择\n                2.利用execute store可将分数转为实体坐标\n                3.利用目标选择器sort=nearest，可按照实体坐标远近选择实体\n\n\n\n分步做法：1.分数初始化，add 0，序号初始化,  set 0 \n\n                2.召唤一批临时药水云，与被排序实体分数逐一对应，临时药水云将分数转为自己y轴坐标\n\n                3.临时分数赋值为0，按远近选择实体执行命令，每次执行利用add把临时分数累加，利用store存为自己的分数\n\n                4.所有的临时药水云按时间顺序，把未得到序号的实体（sort分数为0）的序号赋值为自己的分数\n                   依据原理1，此步骤的顺序与步骤2顺序相同，分数逐一对应关系保留。\n\n                5.清除所有临时药水云\n\n这种做法的本质是调用了目标选择器的sort参数内部排序算法，性能未知，但很方便。\n",
    "replies": [
        {
            "author": "7548854987",
            "timestamp": 1589849700,
            "txt_content": "eeeeeeeeeeeeeeee"
        },
        {
            "author": "xmdhs",
            "timestamp": 1589850720,
            "txt_content": "莫名想到面条排序（\n\n确实很方便简单。"
        },
        {
            "author": "maishurong",
            "timestamp": 1589851320,
            "txt_content": "棒棒哒，继续加油"
        },
        {
            "author": "⊙u⊙",
            "timestamp": 1589873820,
            "txt_content": " 本帖最后由 ⊙u⊙ 于 2020-5-18 21:51 编辑 \n\n有大佬说他用加分法就ok了，然后我写了一下，缺点是检测的实体坐标不能完全重合，当然多加几条命令可以解决\n\nscoreboard players set @e[scores={credit=-2147483648..2147483647}] rank 1\n\nexecute as @e[scores={credit=-2147483648..2147483647}] at @s at @e[distance=0.01..,scores={credit=-2147483648..2147483647}] if score @s credit > @e[scores={credit=-2147483648..2147483647},sort=nearest,limit=1] credit run scoreboard players add @e[scores={credit=-2147483648..2147483647},sort=nearest,limit=1] rank 1\n基本原理：\n1。让所有对象对比自己菜的对象顶一下\n2。被顶得最高的就是最菜对象\n3。由于最强的没人敢顶，因此开头(或结尾也可以)给所有对象顶一下。"
        },
        {
            "author": "VCS-Official",
            "timestamp": 1589874600,
            "txt_content": "⊙u⊙ 发表于 2020-5-19 15:37\n有大佬说他用加分法就ok了，然后我写了一下，缺点是检测的实体坐标不能完全重合，当然多加几条命令可以解决 ...\n嗯...简化一下就这样\n\nscoreboard players set @e rank 1\nexecute at @e as @e if score @s credit > @e[limit=1,sort=nearest] credit run scoreboard players add @e[limit=1,sort=nearest] rank 1\n\n如果解决不能重合的问题，大概要用到function了吧"
        },
        {
            "author": "ma_tao",
            "timestamp": 1590167700,
            "txt_content": "看不懂看不懂"
        }
    ]
}