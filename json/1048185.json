{
    "title": "JavaScript变量作用域问题",
    "author": "Zapic",
    "replyCount": 2,
    "timestamp": 1589726700,
    "txt_content": "RT,最近在学习JS,以用来写PAPI的脚本.\n然后遇到了一个很诡异的问题,我简化一下,大概是这样:\nlet a = {\n    get: () => {\n        console.log(\"outside\");\n    }\n}\na.get(); //\"outside\"\nlet mod = () => {\n    let str = \"inside mod\";\n    a.get = () => {\n        console.log(str);\n    }\n    str = \"inside mod & modify\";\n}\na.get(); //\"outside\"\nmod();\na.get(); //\"inside mod & modify\"复制代码对的,如你所见,mod函数里的str超过作用范围起作用了.\n这就很诡异了.\n我觉得可能是JS能判断哪个变量会被使用,哪个变量不会,于是我做了一个更极.端的例子:\nlet a = {\n    get: () => {\n        console.log(\"outside\");\n    }\n}\na.get(); //\"outside\"\nlet mod = () => {\n    let str1 = \"inside mod 1\";\n    let str2 = \"inside mod 2\";\n    a.get = (code) => {\n        eval(\"console.log(\" + code + \");\");\n    }\n    str1 = \"inside mod 1 & modify\";\n    str2 = \"inside mod 2 & modify\";\n}\na.get(\"str1\"); //\"outside\"\na.get(\"str2\"); //\"outside\"\nmod();\na.get(\"str1\"); //\"inside mod 1 & modify\"\na.get(\"str2\"); //\"inside mod 2 & modify\"复制代码这就更迷惑了.\n他竟然超过作用域不销毁,仍然可以被正常使用.\n有人能给萌新讲一下为什么么?",
    "replies": [
        {
            "author": "炫宙菌",
            "timestamp": 1589728140,
            "txt_content": " PAPI类问题自定义变量我问过 这里几乎没人可以回答"
        },
        {
            "author": "Zapic",
            "timestamp": 1589731260,
            "txt_content": " 本帖最后由 Zapic 于 2020-5-18 00:03 编辑 \n\n已自行解决.\nlet a = {\n    get: () => {\n        console.log(\"outside\");\n    }\n}\na.get(); //\"outside\"\nlet mod = () => {\n    let str1 = \"inside mod 1\";\n    let str2 = \"inside mod 2\";\n    a.get = (code) => {\n        eval(\"console.log(\" + code + \");\");\n    }\n    str1 = \"inside mod 1 & modify\";\n    str2 = \"inside mod 2 & modify\";\n}\na.get(\"str1\"); //\"outside\"\na.get(\"str2\"); //\"outside\"\nmod();\na.get(\"str1\"); //\"inside mod 1 & modify\"\na.get(\"str2\"); //\"inside mod 2 & modify\"复制代码在mod里重载a.get时,实际上就是对str1和str2的引用.\n因为在重载时,重载的函数上下文包括str1和str2,这就自然被重载后的函数所引用,因此不会被销毁,不会变得无法调用.\n\n一旦再次调用mod,a.get再次被重载,这时会丢弃原来的上下文,之前的str1和str2也就会因为失去引用而随之被销毁."
        }
    ]
}