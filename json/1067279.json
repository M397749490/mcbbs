{
    "title": "PVPIN教程RL--ItemStack NBT 与元数据理论基础（二）",
    "author": "William_Shi",
    "replyCount": 1,
    "timestamp": 1593064800,
    "txt_content": "本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引\n本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\n请先看https://www.mcbbs.net/thread-1024853-1-1.html\n\n在上一篇教程中我写了一些反射的操作，但是并没有仔细梳理过NBT的许多常用方法，现在利用本文重新梳理一遍\n首先要知道，Bukkit所封装的ItemStack本身并不能直接操作NBT\n而物品的大部分信息几乎都存储在NBT当中，Bukkit选择了“元数据”作为中间桥梁\n比如说我们所习惯的ItemStack#getItemMeta方法\n这个ItemMeta其实就代表了物品的NBT数据，只不过我们并没有直接操作NBT\n当你使用 ItemMeta#setDisplayName时，其实就是对着物品NBT的“display”数据键所对应的NBT数据包进行了操作\n那么就可以解释我之前解答的，一位开发者遇到的问题\n\n为什么我对着ItemStack对象，先取其元数据，再直接对着物品堆进行了附魔，之后setItemMeta，附魔消失了？\n原因很简单，附魔，也是通过NBT存储的，这点显而易见\n而ItemMeta呢？存储的也是NBT数据\n那就导致了，当你最开始取物品元数据的时候，读取到的数据是没有附魔的NBT数据，并且进行了copy\n而你对准物品堆对象进行了附魔时，相当于操作了物品堆本身的NBT进行附魔\n但是你获取的ItemMeta相当于是复制了一份物品的NBT，并没有这个附魔的数据，换句话说元数据没有记录这个附魔\n当你setItemMeta时，元数据的NBT数据覆盖了原有的，含有附魔的NBT，也就是说set之后，物品堆的NBT数据就不含附魔了\n这就导致了操作元数据再set回去后，覆盖了其间的，其他直接对着物品堆进行的一些操作\n\n同理，其实这点在Bukkit文档里面也有提及\nhttps://bukkit.windit.net/javado ... etDurability-short-\n\n@Deprecated\npublic void setDurability(short durability)\n已过时。 耐久度现在是 ItemMeta 的一部分. 为避免疑虑和误用, 请使用 getItemMeta(), setItemMeta(ItemMeta) 和 Damageable.setDamage(int). 这是因为在调用此方法之前创建的 ItemMeta 的后续变动将覆盖调用此方法设置的物品元数据.\n设置该物品的耐久度.\n\n这点，本质上，和我刚刚解释的附魔是一样的\n就是在于你对于元数据操作耐久度之后，再set会直接覆盖掉物品堆的NBT数据\n容许我稍稍得瑟一下自己对于开发文档的细致了解\n\n那么我们了解了元数据本质上都是操作了NBT，该怎么自己动手操作NBT呢？\n首先我们需要NMS物品堆，因为所有元数据既然都是Bukkit封装的\n想要底层操作就必须诉诸NMS\n况且NBT的所有类也全都是NMS下的\n此时我们采用的是OBC下的CraftItemStack的静态方法 asNMSCopy\n也就得到了NMS物品堆\n\n此时，请先去看我的上一篇理论基础部分，否则不一定能理解部分概念\nhasTag方法返回物品是否有NBT数据\ngetTag方法返回NBT混合数据包（最外层的）\nsetTag方法设置NBT数据包\n\n其实就和ItemMeta的逻辑差不多\n都是getItemMeta、操作完了之后setItemMeta\n但是你要注意一点，那就是Bukkit的hasItemMeta这个方法使用的概率很低\n因为你getItemMeta之后，如果物品没有ItemMeta，Bukkit会用工厂类帮你新建一个ItemMeta\n但是NBT就没有那么舒服了，你必须手动判断hasTag，如果是false，就必须自己新建NBT混合数据包\n\n比如说\nNBTTagCompound compound;\nif(nmsItem.hasTag()){\ncompound = nmsItem.getTag();\n} else{\ncompound = new NBTTagCompound();\n}\n\n这样，就得到了最外层的NBT数据包\n\n之后就按照前一篇文章所介绍的，我们可以使用一些public方法来避免版本之间混淆的差异\n如setInt，getInt，都不需要你去新建NBT数据包对象，可以直接传参int\n\n\n  public void setByte(String var0, byte var1) {\n    this.map.put(var0, NBTTagByte.a(var1));\n  }\n  \n  public void setShort(String var0, short var1) {\n    this.map.put(var0, NBTTagShort.a(var1));\n  }\n  \n  public void setInt(String var0, int var1) {\n    this.map.put(var0, NBTTagInt.a(var1));\n  }\n  \n  public void setLong(String var0, long var1) {\n    this.map.put(var0, NBTTagLong.a(var1));\n  }\n\n  \n  public void setFloat(String var0, float var1) {\n    this.map.put(var0, NBTTagFloat.a(var1));\n  }\n  \n  public void setDouble(String var0, double var1) {\n    this.map.put(var0, NBTTagDouble.a(var1));\n  }\n  \n  public void setString(String var0, String var1) {\n    this.map.put(var0, NBTTagString.a(var1));\n  }\n  \n  public void setByteArray(String var0, byte[] var1) {\n    this.map.put(var0, new NBTTagByteArray(var1));\n  }\n  \n  public void setIntArray(String var0, int[] var1) {\n    this.map.put(var0, new NBTTagIntArray(var1));\n  }\n  \n  public void setBoolean(String var0, boolean var1) {\n    this.map.put(var0, NBTTagByte.a(var1));\n  }\n  \n\n一共可以使用这些（getter、setter）\nbyte、short、int、long、float、double、string、int[]、byte[]、boolean\n其中boolean本质上就是通过byte的0和1进行的存储\n\n需要注意一点，NBTTagCompound这些\n都没有什么setCompound方法！请直接使用get、set方法去操作！\n因为get、set方法传参NBTBase，也就是说所有的NBT数据包都适用\n就不需要再有setCompound这类方法了\n\n最后进行了各种操作后你得到了一个NBT混合数据包，\n这就正如同是操作之后的ItemMeta\n还需要重新set回去\n使用ItemStack（NMS）#setTag方法\n之后我们得到了一个修改过的NMS物品堆\n再使用CraftItemStack的静态方法asBukkitCopy\n你就得到了一个设置完了NBT的物品堆\n\n具体的实例：\nhttps://www.mcbbs.net/thread-1049313-1-1.html\nhttps://www.mcbbs.net/forum.php?mod=viewthread&tid=1053819\n\n",
    "replies": [
        {
            "author": "小林最牛",
            "timestamp": 1593064860,
            "txt_content": "又出新教程了awa\n支持！~帮助不小\n"
        }
    ]
}