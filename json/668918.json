{
    "title": "MCmod制作 1.11(13.完善冰弹)",
    "author": "zkm00323",
    "replyCount": 0,
    "timestamp": 1485786240,
    "txt_content": " 本帖最后由 zkm00323 于 2017-1-31 14:22 编辑 \n\n我的索引贴已经关闭了\n应该是因为我和一位大佬在下面起了冲突\n我确实能力有限,可能有讲错的地方\n希望各位见谅,可以告诉我错误的地方\n我也不希望示范了错误的东西\n\n我写这些教程的初衷只是觉得\n国内中文的教程资源太少了\n虽然我也在学习阶段,没有做出过一个合格的mod\n但是我也希望在自己收集资料的过程中\n能够把一些东西分享出来,帮助有需要的人\n我的教程也不会讲太多深入的东西\n我只说遥控器则么用\n不说遥控器则么造,我也没这个能力\n\n\n////////////////////////////////////////////////////////////\n这一章我们要把这个冰弹给完成\n我要实现的点有这些\n1.在飞行时释放粒子特效\n2.击中目标后给予伤害\n//3.击中目标后附加一层冻伤效果\n\n1.修改EntityIcebullet\n我们直接把EntityThrowable内的所用东西复制到EntityIcebullet里\n并且不再继承他\npublic class EntityIcebullet extends Entity implements IProjectile\n\n把构造函数的名字全改为EntityThrowable\n\n\nprotected abstract void onImpact(RayTraceResult result);\n                                ↑改为↓\nprotected void onImpact(RayTraceResult result) {}\n\n\n//if(!net.minecraftforge.common.ForgeHooks.onThrowableImpact(this, raytraceresult))\n这一句直接删掉\n\n这样所有的报错应该就消除了\n\n我们在onUpdate()的开头加一句\nthis.worldObj.setEntityState(this, (byte)0);\n\n\n\n\nQQ截图20170130190645.png (2.63 KB, 下载次数: 0)\n\n下载附件\n\n2017-1-30 18:56 上传\n\n\n\n\n\n\n\nonUpdate()方法会在实体存在时的每一tick都执行一次\n换句话说就是冰弹飞行的时候会一直不断执行\n这里我们设置一个变量为0,等一下就知道目的了\n\n在onImpact()里面写上\n        protected void onImpact(RayTraceResult result) {\n                if (!this.worldObj.isRemote) {\n                this.playSound(new SoundEvent(new ResourceLocation(\"block.glass.break\")) ,0.2F, 4.0F);\n        //这里要加一条判断是否被击中者为投掷者,测试的时候发现近距离射出子弹反而会击中自己\n                        if (result.entityHit instanceof EntityLivingBase && result.entityHit != getThrower()) {\n                                //设置伤害来源为投掷物,伤害量为6点血\n                                 result.entityHit.attackEntityFrom(DamageSource.causeThrownDamage(this, this.getThrower()), 6.0F);\n                                //目前还没创建,通过自定义方法实现冻伤效果层数叠加\n                                //ModPotion.setFrostbite((EntityLivingBase) result.entityHit);\n                        }\n                        //设置实体状态为1,和上面设置飞行为0一样\n                        this.worldObj.setEntityState(this, (byte) 1);\n                        //实体死亡\n                        this.setDead();\n                }\n        }\n\n\nonImpact()会在冰弹击中实体或是方块时执\n所以只有执行一次\n\n接下来我们重写一个Entity的方法\n        @SideOnly(Side.CLIENT)\n                public void handleStatusUpdate(byte id) {\n                        switch (id) {\n                        case 0:\n                                ModParticle.Icesmoke(40, this, 0.5, 0.5, 0.5, 0.08, 0.08, 0.08);\n                                break;\n                        case 1:\n                                for (int i = 0; i < 10; ++i)this.worldObj.spawnParticle(EnumParticleTypes.BLOCK_CRACK, this.posX, this.posY, this.posZ,((double) this.rand.nextFloat() - 0.5D) * 0.08D,((double) this.rand.nextFloat() - 0.5D) * 0.08D,((double) this.rand.nextFloat() - 0.5D) * 0.08D, Block.getIdFromBlock(Blocks.ICE));\n                                //参数:x坐标,y坐标,z坐标,声音事件,声音类型(敌意的),音量,半径(单位为一格方块),声音是否有距离延迟\n                                this.worldObj.playSound(this.posX, this.posY, this.posZ, new SoundEvent(new ResourceLocation(\"block.glass.break\")), SoundCategory.HOSTILE, 0.2F, 4.0F, false);\n                                break;\n                        }\n                }\n\n当id为0(飞行时)释放icesmoke特效,这里我们还没创建会报错\n当id为1(击中目标)释放原版方块碎裂特效,这里特效参数为冰块,并且播放玻璃碎裂声音\n至于生成声音的方法,经过测试这一个是可行的,是用在客户端呼叫\n\n这是一个客户端单边方法\n生成粒子特效代码必须是客户端执行才会有效果\n服务端执行则无效\n但是对于实体的运算必定是服务端在做的\n所以把生成代码写到onImpact()里是没有效果的\nhandleStatusUpdate是个客户端单边方法,并且不断执行的方法\n通过获取实体的状态来决定显示什么东西\n原版MC通过这种方式让客户端够通过服务端的运算\n显示粒子特效\n\n我们到ModParticle把Icesmoke方法写出来\n        public static void Icesmoke(int amount,Entity entity,double deviationX,double deviationY,double deviationZ,double velocityX,double velocityY,double velocityZ){\n                for (int i = 0; i < amount; ++i){\n                        double posX = (new Random().nextDouble()-0.5)*deviationX+entity.posX;\n                        double posY = (new Random().nextDouble()-0.5)*deviationY+entity.posY;\n                        double PosZ= (new Random().nextDouble()-0.5)*deviationZ+entity.posZ;\n                        double velX = (new Random().nextDouble()-0.5)*velocityX;\n                        double velY = (new Random().nextDouble()-0.5)*velocityY;\n                        double velZ = (new Random().nextDouble()-0.5)*velocityZ;\n                        \n                        Minecraft.getMinecraft().effectRenderer.addEffect(new ParticleIcesmoke(entity.worldObj, posX, posY, PosZ, velX, velY, velZ));\n                }\n        }\n\n参数:\n1.粒子数量\n2.实体\n3.X轴生成位置随机量\n4.Y轴生成位置随机量\n5.Z轴生成位置随机量\n6.X轴向量随机量\n7.Y轴向量随机量\n8.Z轴向量随机量\n\n为了以后使用方便,我们把生成代码进行了这样的包装\n\n好现在我们可以进入游戏机关枪连射了!\n\n\n\n\n2017-01-30_20.22.09.png (153.47 KB, 下载次数: 0)\n\n下载附件\n\n2017-1-30 21:56 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsrc_教程13.rar\n\n\n2017-1-30 22:16 上传\n点击文件名下载附件\n\n\n\n\n45.56 KB, 下载次数: 60\n\n\n\n\n\n\n",
    "replies": []
}