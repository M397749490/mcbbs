{
    "title": "JMCCC使用教程——Java启动器类库，几行代码下载并启动MC",
    "author": "yushijinhun",
    "replyCount": 68,
    "timestamp": 1459859820,
    "txt_content": " 本帖最后由 yushijinhun 于 2016-4-8 21:55 编辑 \n\nJMCCC是由 @yushijinhun 和 @Darkyoooooo 开发的一个Java启动器核心，支持：\n启动Minecraft正版验证（以及Yggdrasil的其它API）下载Minecraft下载并安装Forge/Liteloader\n\n并且JMCCC是开源的（MIT许可证），JMCCC在GitHub上的项目：https://github.com/to2mbn/JMCCC\n\n本教程的适用人群：有一定经验的Java开发者\n\n目录\n环境搭建启动游戏正版登录下载游戏下载并安装Forge及Liteloader获取正版玩家的皮肤OS X下Dock相关配置忽略Forge的数字签名使用HttpAsyncClient来进行下载使用Ehcache缓存下载的文件修改Minecraft1.9中的version_type使用自定义的Yggdrasil API提供商\n\n\n点击下面的页码来跳到下一页。\n\n\n\n1. 环境搭建\nJMCCC由三个模块组成，分别为jmccc、jmccc-yggdrasil-authenticator、jmccc-mcdownloader，它们分别提供了启动Minecraft、正版登录、下载Minecraft的功能。您可以按需引用这三个模块。\n假如您使用Maven或者Gradle，您只需要加入如下的依赖即可（目前JMCCC最新版本为2.4）：\norg.to2mbn:jmccc:2.4\norg.to2mbn:jmccc-yggdrasil-authenticator:2.4\norg.to2mbn:jmccc-mcdownloader:2.4\n复制代码\n假如您不使用Maven/Gradle，您就需要手动导入jar包，上述jar可以在Maven中心仓库找到，并且还需要导入org.json和tukaani xz这两个依赖。\n\nJMCCC要求的Java最低版本为Java7。\n\n\n\n2. 启动游戏\n首先，您需要通过LauncherBuilder类来创建一个Launcher对象：\nLauncher launcher = LauncherBuilder.buildDefault();\n复制代码\nbuildDefault()方法会创建一个默认配置的Launcher。当然您也可以通过方法链来自定义Launcher的配置，比如：\nLauncher launcher = LauncherBuilder.create()\n    .setDebugPrintCommandline(true) // (1)\n    .setNativeFastCheck(true) // (2)\n    .build();\n复制代码\n方法意义setDebugPrintCommandline(boolean)（即上面的(1)）设置是否在启动时将启动参数输出到控制台以供调试，默认为false。setNativeFastCheck(boolean)（即上面的(2)）设置是否开启对Natives文件的快速检查，默认为false。\n假如没有开启该选项，jmccc在启动时会对Natives文件进行全文比较来判断文件是否完整，如果发现Natives文件内容不一致，则将文件替换。\n开启该选项后，jmccc仅会通过比较文件大小来判断文件是否完整，这样可以加快启动速度，但有可能造成某些问题。\n\n接着，您需要创建一个LaunchOption来描述启动设置，比如：\nLaunchOption option = new LaunchOption(\"1.9\", new OfflineAuthenticator(\"test_user\"), new MinecraftDirectory(\".minecraft\")); // (3)\n复制代码\n在上面的例子中，第一个参数为为要启动的Minecraft版本，这里为1.9。第二个参数为验证方式，这里用的是离线验证（即所谓盗版），用户名是test_user。第三个参数是.minecraft目录的位置，这里使用的是当前目录下的.minecraft目录。\n除此之外，您还可以对LaunchOption进行其它配置，下面列举了一些LaunchOption类的方法。\n方法意义setMaxMemory(int)设置最大内存（MB），默认为1024。如果为0则不会添加-Xmx参数（即让JVM自己决定）。setMinMemory(int)设置最小内存（MB），默认为0。如果为0则不会添加-Xms参数（即让JVM自己决定）。setServerInfo(ServerInfo)设置游戏启动后要自动进入的服务器，默认为null。\n例如 new ServerInfo(\"localhost\", 25565) 就描述了在localhost的25565端口上的服务器。\nsetWindowSize(WindowSize)设置游戏窗口大小，默认为null（不指定）。\n例如 WindowSize.fullscreen() 方法返回一个代表全屏的WindowSize对象；\nWindowSize.window(640, 480) 返回一个代表了窗口大小是640x480的WindowSize。\nsetExtraJvmArguments(List<String>)设置额外的JVM参数，默认为null。\n相关的用法可以跳读到7、8节。\nsetExtraMinecraftArguments(List<String>)设置额外的Minecraft参数，默认为null。这些参数将被添加到默认Minecraft启动参数的末尾。setCommandlineVariables(Map<String, String>)设置额外的命令行模板参数，通过该方法指定的参数可以覆盖默认的参数。version.json中的minecraftArguments是参数化的，其中${...}格式的字符串会被替换为对应变量的实际值。\n例如，minecraftArguments出现了${a}这样的字符串，并且通过该方法指定了\"a\" -> \"233\"，那么启动时${a}就会被替换为233。\n再例如，minecraftArguments中出现了${version_name}，则这段字符串在启动时将自动被Minecraft的版本号代替。但如果通过该方法指定了\"version_name\" -> \"abc\"，则${version_name}会被abc代替，而不是Minecraft版本号，因为\"version_name\" -> \"abc\"覆盖了默认的参数。\n为了帮助理解，下面给出一段Minecraft 1.8.9的minecraftArguments：\n--username ${auth_player_name} --version ${version_name} --gameDir ${game_directory} --assetsDir ${assets_root} --assetIndex ${assets_index_name} --uuid ${auth_uuid} --accessToken ${auth_access_token} --userProperties ${user_properties} --userType ${user_type}\n复制代码\n相关的使用可以跳读到第11节。\nsetRuntimeDirectory(MinecraftDirectory)设置Minecraft运行时使用的目录，默认和getMinecraftDirectory()一样（同上面(3)中构造方法的第三个参数）。这里指定的runtimeDirectory包含的是存档、资源包、截图等，而上面的minecraftDirectory包含的是游戏jar（versions）、库文件（libraries）、资源文件（assets）等。所以可以用这个方法来实现各版本独立。\n然后您就可以通过调用launch(LaunchOption)方法启动游戏了：\nlauncher.launch(option);复制代码假如启动失败则会抛出一个LaunchException，如果该LaunchException是一个MissingDependenciesException（MissingDependenciesException是LaunchException的子类），则代表有libraries缺失。\n\n如果您想获取Minecraft进程的控制台日志，则可以使用launch(LaunchOption, GameProcessListener)：\nlauncher.launch(option, new GameProcessListener() {\n\n    @Override\n    public void onLog(String log) {\n        System.out.println(log); // (4)\n    }\n\n    @Override\n    public void onErrorLog(String log) {\n        System.err.println(log); // (5)\n    }\n\n    @Override\n    public void onExit(int code) {\n        System.err.println(\"游戏进程退出，状态码：\" + code); // (6)\n    }\n});\n复制代码\n上面代码中(4)处的onLog(String)方法会在游戏进程的标准输出输出日志时调用，(5)处的onErrorLog(String)方法会在游戏进程的标准错误输出日志时调用，而(6)处的onExit(int)会在游戏进程结束时调用。上面这段代码把游戏进程的日志都输出到了自己的控制台，并且在游戏结束时还会输出 \"游戏进程退出，状态码：xxx\" 这样的字符串。\n\n下面给出一段演示代码：\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.auth.OfflineAuthenticator;\nimport org.to2mbn.jmccc.exec.GameProcessListener;\nimport org.to2mbn.jmccc.launch.Launcher;\nimport org.to2mbn.jmccc.launch.LauncherBuilder;\nimport org.to2mbn.jmccc.option.LaunchOption;\nimport org.to2mbn.jmccc.option.MinecraftDirectory;\n\npublic class JmcccTest {\n\n    public static void main(String[] args) throws Exception {\n        // 创建一个Launcher对象\n        Launcher launcher = LauncherBuilder.create()\n                .setDebugPrintCommandline(true) // 将启动命令打印到控制台以便调试\n                .build();\n\n        // 启动配置\n        LaunchOption option = new LaunchOption(\n                \"1.9\", // 游戏版本\n                new OfflineAuthenticator(\"test_user\"), // 使用离线验证，用户名test_user\n                new MinecraftDirectory(\"/home/yushijinhun/.minecraft\")); // .minecraft目录\n\n        // 最大内存2048M\n        option.setMaxMemory(2048);\n\n        // 启动游戏\n        launcher.launch(option, new GameProcessListener() {\n\n            @Override\n            public void onLog(String log) {\n                System.out.println(log); // 输出日志到控制台\n            }\n\n            @Override\n            public void onErrorLog(String log) {\n                System.err.println(log); // 输出日志到控制台（同上）\n            }\n\n            @Override\n            public void onExit(int code) {\n                System.err.println(\"游戏进程退出，状态码：\" + code); // 游戏结束时输出状态码\n            }\n        });\n    }\n\n}\n复制代码\n控制台输出：\njmccc:\n/usr/lib/jvm/jdk1.8.0_66/jre/bin/java\n-Xmx2048M\n-Djava.library.path=/home/yushijinhun/.minecraft/versions/1.9/1.9-natives\n-cp\n/home/yushijinhun/.minecraft/libraries/com/paulscode/soundsystem/20120107/soundsystem-20120107.jar:/home/yushijinhun/.minecraft/libraries/net/java/dev/jna/platform/3.4.0/platform-3.4.0.jar:/home/yushijinhun/.minecraft/libraries/com/google/guava/guava/17.0/guava-17.0.jar:/home/yushijinhun/.minecraft/libraries/commons-io/commons-io/2.4/commons-io-2.4.jar:/home/yushijinhun/.minecraft/libraries/org/apache/httpcomponents/httpcore/4.3.2/httpcore-4.3.2.jar:/home/yushijinhun/.minecraft/libraries/com/ibm/icu/icu4j-core-mojang/51.2/icu4j-core-mojang-51.2.jar:/home/yushijinhun/.minecraft/libraries/net/sf/jopt-simple/jopt-simple/4.6/jopt-simple-4.6.jar:/home/yushijinhun/.minecraft/libraries/commons-codec/commons-codec/1.9/commons-codec-1.9.jar:/home/yushijinhun/.minecraft/libraries/com/paulscode/codecjorbis/20101023/codecjorbis-20101023.jar:/home/yushijinhun/.minecraft/libraries/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/home/yushijinhun/.minecraft/libraries/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/home/yushijinhun/.minecraft/libraries/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/home/yushijinhun/.minecraft/libraries/com/paulscode/codecwav/20101023/codecwav-20101023.jar:/home/yushijinhun/.minecraft/libraries/com/paulscode/librarylwjglopenal/20100824/librarylwjglopenal-20100824.jar:/home/yushijinhun/.minecraft/libraries/org/apache/logging/log4j/log4j-api/2.0-beta9/log4j-api-2.0-beta9.jar:/home/yushijinhun/.minecraft/libraries/org/apache/logging/log4j/log4j-core/2.0-beta9/log4j-core-2.0-beta9.jar:/home/yushijinhun/.minecraft/libraries/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar:/home/yushijinhun/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl/2.9.4-nightly-20150209/lwjgl-2.9.4-nightly-20150209.jar:/home/yushijinhun/.minecraft/libraries/net/java/jutils/jutils/1.0.0/jutils-1.0.0.jar:/home/yushijinhun/.minecraft/libraries/com/mojang/realms/1.8.7/realms-1.8.7.jar:/home/yushijinhun/.minecraft/libraries/org/apache/commons/commons-compress/1.8.1/commons-compress-1.8.1.jar:/home/yushijinhun/.minecraft/libraries/oshi-project/oshi-core/1.1/oshi-core-1.1.jar:/home/yushijinhun/.minecraft/libraries/net/java/dev/jna/jna/3.4.0/jna-3.4.0.jar:/home/yushijinhun/.minecraft/libraries/org/lwjgl/lwjgl/lwjgl_util/2.9.4-nightly-20150209/lwjgl_util-2.9.4-nightly-20150209.jar:/home/yushijinhun/.minecraft/libraries/org/apache/httpcomponents/httpclient/4.3.3/httpclient-4.3.3.jar:/home/yushijinhun/.minecraft/libraries/net/java/jinput/jinput/2.0.5/jinput-2.0.5.jar:/home/yushijinhun/.minecraft/libraries/com/mojang/authlib/1.5.22/authlib-1.5.22.jar:/home/yushijinhun/.minecraft/libraries/com/paulscode/libraryjavasound/20101123/libraryjavasound-20101123.jar:/home/yushijinhun/.minecraft/versions/1.9/1.9.jar:\nnet.minecraft.client.main.Main\n--username\ntest_user\n--version\n1.9\n--gameDir\n/home/yushijinhun/.minecraft\n--assetsDir\n/home/yushijinhun/.minecraft/assets\n--assetIndex\n1.9\n--uuid\n109fb39758f23a9a92c15a21ac5113c2\n--accessToken\n5b54b31a68574518a71fdd7e9846f87d\n--userType\nmojang\n--versionType\nrelease\n\n[18:01:52] [Client thread/INFO]: Setting user: test_user\n[18:01:52] [Client thread/INFO]: (Session ID is token:5b54b31a68574518a71fdd7e9846f87d:109fb39758f23a9a92c15a21ac5113c2)\n[18:01:54] [Client thread/INFO]: LWJGL Version: 2.9.4\n[18:01:54] [Client thread/INFO]: Reloading ResourceManager: Default\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:block.note.pling\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.bat.loop\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.cat.hiss\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.ghast.scream\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.player.breath\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.small_slime.jump\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.snowman.ambient\n[18:01:54] [Client thread/WARN]: Missing sound for event: minecraft:entity.wolf.howl\n[18:01:54] [Sound Library Loader/INFO]: Starting up SoundSystem...\n[18:01:55] [Thread-5/INFO]: Initializing LWJGL OpenAL\n[18:01:55] [Thread-5/INFO]: (The LWJGL binding of OpenAL.  For more information, see http://www.lwjgl.org)\n[18:01:55] [Thread-5/INFO]: OpenAL initialized.\n[18:01:55] [Sound Library Loader/INFO]: Sound engine started\n[18:01:56] [Client thread/INFO]: Created: 1024x512 textures-atlas\n[18:02:02] [Realms Notification Availability checker #1/INFO]: Could not authorize you against Realms server: Invalid session id\n[18:02:03] [Client thread/INFO]: Stopping!\n[18:02:03] [Client thread/INFO]: SoundSystem shutting down...\n[18:02:03] [Client thread/WARN]: Author: Paul Lamb, www.paulscode.com\n游戏进程退出，状态码：0\n复制代码\n\n3. 正版登录\n正版登录是jmccc的一个可选功能，您必须确保您已经导入了jmccc-yggdrasil-authenticator这个依赖。\n\n（有必要解释一下yggdrasil的意思，yggdrasil就是mojang正版验证服务的代号）\n\n正版登录的功能由YggdrasilAuthenticator类提供。\n\nYggdrasilAuthenticator类存储了一个正版验证的session。当每次向正版验证服务器刷新session时，YggdrasilAuthenticator都会将新的session存储起来，以备下次使用。假如说因为某种原因session失效了（如长时间不使用），YggdrasilAuthenticator则会要求提供密码来重新登录。\n\n当使用YggdrasilAuthenticator时（即要求返回一个有效的session），流程如下：\n\n\n\n注：上面的逻辑就是auth()方法中的逻辑。\n\n如何创建一个YggdrasilAuthenticator？\n\nYggdrasilAuthenticator有两个工厂方法，分别是YggdrasilAuthenticator.password(String, String)和YggdrasilAuthenticator.token(String, String)。（这两个方法还有若干重载）\n方法意义password(String, String)创建一个YggdrasilAuthenticator，并用所给的密码初始化。token(String, String)创建一个YggdrasilAuthenticator，并用所给的token初始化。\n使用上面这两个方法创建的YggdrasilAuthenticator都已经存储着了一个有效的session，因此您可以直接将它们拿来使用：\n（举第2节中的例子）\nLaunchOption option = new LaunchOption(\"1.9\", YggdrasilAuthenticator.password(\"email@xxx.com\", \"password\"), new MinecraftDirectory(\".minecraft\"));\n复制代码\n\n需要注意的是YggdrasilAuthenticator有一个无参的构造方法。不同于上面的两个工厂方法，用这个构造方法创建出来的YggdrasilAuthenticator是不带有有效的session的。也就是说，new YggdrasilAuthenticator()创建出来的YggdrasilAuthenticator要刷新一次之后才能使用。\n\n如何刷新YggdrasilAuthenticator中的session？\nYggdrasilAuthenticator中session的刷新分为被动刷新和主动刷新。\n\n被动刷新就像本节一开始所说的，当要使用YggdrasilAuthenticator进行验证，但当前的session又无效时，就需要向用户询问密码来重新登录，用户此时是被动的。\nYggdrasilAuthenticator默认情况下是不允许被动刷新的（因为YggdrasilAuthenticator不知道如何与用户交互），此时您需要为YggdrasilAuthenticator编写子类来实现被动刷新，例如：\npackage yushijinhun.jmccc.test;\n\nimport java.util.Scanner;\nimport org.to2mbn.jmccc.auth.AuthenticationException;\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\n\npublic class MyYggdrasilAuthenticator extends YggdrasilAuthenticator {\n\n        // 下面两个构造方法并没有什么好看的\n        // 从超类生成过来的罢了\n        public MyYggdrasilAuthenticator() {\n                super();\n        }\n\n        public MyYggdrasilAuthenticator(AuthenticationService sessionService) {\n                super(sessionService);\n        }\n\n        @Override\n        protected PasswordProvider tryPasswordLogin() throws AuthenticationException {\n                // 这个方法会在进行被动刷新时调用\n\n                // 向用户询问邮箱与密码\n                Scanner scanner = new Scanner(System.in);\n                System.out.print(\"邮箱：\");\n                String email = scanner.nextLine();\n                System.out.print(\"密码：\");\n                String password = scanner.nextLine();\n\n                return YggdrasilAuthenticator.createPasswordProvider(email, password, null);\n        }\n\n}\n复制代码\n\n我们可以来测试一下：\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.auth.AuthenticationException;\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\n\npublic class AuthTest {\n\n        public static void main(String[] args) throws AuthenticationException {\n                // 用无参构造函数创建的YggdrasilAuthenticator是不带有session的。\n                // 所以在第一次使用YggdrasilAuthenticator时会触发一次被动刷新，\n                // 要求用户输入邮箱和密码。\n                YggdrasilAuthenticator authenticator = new MyYggdrasilAuthenticator();\n\n                // 循环十次要求提供登录信息\n                for (int i = 0; i < 10; i++)\n                        System.out.println(authenticator.auth());\n        }\n\n}\n复制代码\n控制台输出：\n邮箱：********@qq.com\n密码：********\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\n复制代码\n// 因为是个人敏感信息，所以我就无耻的打码了\n\n可以看到虽然调用了使用了十次YggdrasilAuthenticator（调用auth()），但只向用户询问了一次密码。这说明YggdrasilAuthenticator记住了之前的登录状态。\n\n\n主动刷新是指，程序主动要求YggdrasilAuthenticator刷新session。可以通过调用下面两个方法实现：\n方法意义refreshWithPassword(String, String)用邮箱和密码来刷新当前sessionrefreshWithToken(String, String)用token来刷新当前session\n我们来测试一下：\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.auth.AuthenticationException;\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\n\npublic class AuthTest {\n\n        public static void main(String[] args) {\n                // 这样创建的YggdrasilAuthenticator不带有有效session\n                // 并且我们也没有实现被动刷新\n                YggdrasilAuthenticator authenticator = new YggdrasilAuthenticator();\n\n                // 第一次使用YggdrasilAuthenticator\n                // 由于没有有效session，并且也无法进行被动刷新\n                // 所以会出错\n                try {\n                        System.out.println(authenticator.auth());\n                } catch (AuthenticationException e) {\n                        e.printStackTrace();\n                }\n\n                // 此时我们主动去刷新它\n                try {\n                        authenticator.refreshWithPassword(\"email@xxx.com\", \"password\");\n                } catch (AuthenticationException e) {\n                        e.printStackTrace();\n                }\n\n                // 第二次使用YggdrasilAuthenticator\n                // 由于经过主动刷新，已经有有效的session了\n                // 所以成功执行\n                try {\n                        System.out.println(authenticator.auth());\n                } catch (AuthenticationException e) {\n                        e.printStackTrace();\n                }\n        }\n\n}\n复制代码\n控制台输出：\norg.to2mbn.jmccc.auth.AuthenticationException: no more authentication methods to try\n        at org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator.refresh(YggdrasilAuthenticator.java:293)\n        at org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator.session(YggdrasilAuthenticator.java:265)\n        at org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator.auth(YggdrasilAuthenticator.java:236)\n        at yushijinhun.jmccc.test.AuthTest.main(AuthTest.java:17)\nAuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\n复制代码\n\n有一点要注意：在编写和用户交互的启动器时，使用被动刷新。尽量不用YggdrasilAuthenticator.password()和token()这些工厂方法，也尽量避免主动刷新。因为出现被动刷新只有在真的有必要要用密码登录时才会发生。\n\n\n如何保存登录信息？\n一般情况下我们的启动器都会有个“记住密码”的功能。但难道启动器真的保存了密码吗？这显然是不安全的。事实上启动器保存的是上次的session，到下一次再打开启动器时，便会加载上次的session。\n那么如何在jmccc中实现这个功能呢？答案有两个。\n\n第一种办法是直接序列化YggdrasilAuthenticator。此时YggdrasilAuthenticator中所含的session将一同被序列化。示例如下：\npackage yushijinhun.jmccc.test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport org.to2mbn.jmccc.auth.AuthenticationException;\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\n\npublic class AuthTest {\n\n        public static void main(String[] args) throws Exception {\n                // 找一个临时文件\n                File file = File.createTempFile(\"jmccc-test\", \".dat\");\n\n                saveAuth(file);\n                loadAuth(file);\n        }\n\n        /**\n         * 创建一个YggdrasilAuthenticator并把它序列化到文件里。\n         * \n         * @param file 要保存到的文件\n         * @throws AuthenticationException 假如出现验证错误\n         * @throws IOException 假如出现I/O异常\n         */\n        static void saveAuth(File file) throws AuthenticationException, IOException {\n                // 用密码创建一个包含有效session的YggdrasilAuthenticator\n                YggdrasilAuthenticator authenticator = YggdrasilAuthenticator.password(\"email@xxx.com\", \"password\");\n\n                try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file))) {\n                        // 序列化YggdrasilAuthenticator\n                        out.writeObject(authenticator);\n                }\n\n                System.out.printf(\"YggdrasilAuthenticator已保存到%s%n\", file);\n        }\n\n        /**\n         * 从文件里加载YggdrasilAuthenticator，并把它的session输出出来。\n         * \n         * @param file 要加载YggdrasilAuthenticator的文件\n         * @throws AuthenticationException 假如出现验证错误\n         * @throws IOException 假如出现I/O异常\n         * @throws ClassNotFoundException 假如类未找到（反序列化错误）\n         */\n        static void loadAuth(File file) throws AuthenticationException, IOException, ClassNotFoundException {\n                YggdrasilAuthenticator authenticator;\n                try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(file))) {\n                        // 反序列化YggdrasilAuthenticator\n                        authenticator = (YggdrasilAuthenticator) in.readObject();\n                }\n\n                System.out.printf(\"从%s中加载了一个YggdrasilAuthenticator%n\", file);\n                System.out.printf(\"调用YggdrasilAuthenticator的auth()：%s%n\", authenticator.auth());\n        }\n\n}\n复制代码\n控制台输出：\nYggdrasilAuthenticator已保存到/tmp/jmccc-test3142550737446373738.dat\n从/tmp/jmccc-test3142550737446373738.dat中加载了一个YggdrasilAuthenticator\n调用YggdrasilAuthenticator的auth()：AuthInfo [username=********, token=********, uuid=********, properties={}, userType=mojang]\n复制代码\n\n另一种方式是，调用getCurrentSession()返回当前的session（可能为null），然后将这个对象序列化。下一次时使用无参的构造方法创建YggdrasilAuthenticator，然后调用setCurrentSession(Session)将session设置回去。在此便不多叙述。\n\n\n如何实现角色的选择？\n对于这一段的小标题读者可能不大理解，什么叫角色选择呢？其实Yggdrasil允许一个账户拥有多个角色，这里的角色就可以相当于minecraft中的玩家。当然，mojang目前似乎还没开放这个功能。但可以通过使用第三方的Yggdrasil服务提供商体验一下（比如authlib-agent）。（好像有点扯远了）\n虽然mojang没有实现这个功能，但我们总得防范与未然吧，而且正版启动器以及HMCL等启动器都有实现这个功能。那么在jmccc中应该如何做到呢？\n首先要为CharacterSelector接口编写一个实现类。这个接口中定义了一个select(GameProfile[])方法，即从所给的角色中选择一个。（GameProfile即角色）\n下面给出一个例子：\npackage yushijinhun.jmccc.test;\n\nimport java.util.Scanner;\nimport org.to2mbn.jmccc.auth.yggdrasil.CharacterSelector;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.GameProfile;\n\npublic class MyCharacterSelector implements CharacterSelector {\n\n        @Override\n        public GameProfile select(GameProfile[] availableProfiles) {\n                // 与用户交互\n                for (int i = 0; i < availableProfiles.length; i++) {\n                        System.out.printf(\"[%d] %s%n\", i, availableProfiles[i].getName());\n                }\n                System.out.printf(\"请从上面的角色中选择一个（输入序号）：\");\n                Scanner scanner = new Scanner(System.in);\n                int index = scanner.nextInt();\n\n                // 返回要使用的角色\n                return availableProfiles[index];\n        }\n\n}\n复制代码\n\n上面我们知道了可以使用YggdrasilAuthenticator.password(String, String)这个工厂方法创建一个YggdrasilAuthenticator，也知道了可以用YggdrasilAuthenticator.refreshWithPassword(String, String)刷新当前session。\n如果说我们要进行角色选择，应该用什么方法来传递给YggdrasilAuthenticator一个CharacterSelector，让它知道在选择角色时通知我们呢？\n这就要使用YggdrasilAuthenticator.password(String, String, CharacterSelector)和YggdrasilAuthenticator.refreshWithPassword(String, String, CharacterSelector)。（两个重载方法）\n\n在进行登录时，假如需要对角色进行选择，则YggdrasilAuthenticator会调用CharacterSelector的select(GameProfile[])。\n（注：只有当可以进行角色选择时才会调用select(GameProfile[])）\n\n示例如下：\n（注：因为mojang不能有多个角色，所以我使用了authlib-agent自己建了个yggdrasil服务端，下面的代码和上面的会略有出入。关于jmccc自定义yggdrasil服务提供商，请见第12节）\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.AuthenticationService;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.yggdrasil.YggdrasilServiceBuilder;\n\npublic class AuthTest {\n\n        public static void main(String[] args) throws Exception {\n                AuthenticationService authenticationService = YggdrasilServiceBuilder.create()\n                                .setAPIProvider(new yushijinhunYggdrasilAPIProvider())\n                                .loadSessionPublicKey(\"/home/yushijinhun/yushijinhun_yggdrasil_pubkey.der\")\n                                .buildAuthenticationService();\n\n                // 用特定的AuthenticationService创建一个AuthenticationService\n                // 这样这个YggdrasilAuthenticator就会向我的Yggdrasil服务请求，而不是Mojang的\n                YggdrasilAuthenticator authenticator = new YggdrasilAuthenticator(authenticationService);\n\n                // 然后用密码登录\n                authenticator.refreshWithPassword(\"yushijinhun@gmail.com\", \"123456\", new MyCharacterSelector());\n\n                // 输出登录信息\n                System.out.println(authenticator.auth());\n        }\n\n}\n复制代码\n控制台输出：\n[0] test_player\n[1] yushijinhun\n请从上面的角色中选择一个（输入序号）：1\nAuthInfo [username=yushijinhun, token=9395d1cdc7cf40a9a9fcf728aabdd7e7, uuid=8faf6e06d9e147fa8f63b9a6c19c5d5b, properties={}, userType=mojang]\n复制代码\np.s. 因为这个yggdrasil服务端是我测试用的，在mojang服务器上并没有这个账号，所以不打码也无妨。\n\n除了在主动刷新时进行角色选择，在被动刷新时也可以进行角色选择。只需对上面的MyYggdrasilAuthenticator做一下修改。\n将tryPasswordLogin()中的return改为如下：\nreturn YggdrasilAuthenticator.createPasswordProvider(email, password, new MyCharacterSelector());\n复制代码\n可以看到第三个参数发生了变化。原来是null，代表使用默认的角色选择器。而现在是使用我们所指定的角色选择器。\n再编写代码测试一下：\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.AuthenticationService;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.yggdrasil.YggdrasilServiceBuilder;\n\npublic class AuthTest {\n\n        public static void main(String[] args) throws Exception {\n                AuthenticationService authenticationService = YggdrasilServiceBuilder.create()\n                                .setAPIProvider(new yushijinhunYggdrasilAPIProvider())\n                                .loadSessionPublicKey(\"/home/yushijinhun/yushijinhun_yggdrasil_pubkey.der\")\n                                .buildAuthenticationService();\n\n                // 用特定的AuthenticationService创建一个AuthenticationService\n                // 这样这个YggdrasilAuthenticator就会向我的Yggdrasil服务请求，而不是Mojang的\n                YggdrasilAuthenticator authenticator = new MyYggdrasilAuthenticator(authenticationService);\n\n                // 输出登录信息\n                System.out.println(authenticator.auth());\n        }\n\n}\n复制代码\n可以看到只是将上面例子里的refreshWithPassword删掉了，并且换成了MyYggdrasilAuthenticator（因为我们要处理被动刷新）。变主动刷新为被动刷新，不指定密码，让YggdrasilAuthenticator来询问我们密码。\n控制台输出：\n邮箱：yushijinhun@gmail.com\n密码：123456\n[0] test_player\n[1] yushijinhun\n请从上面的角色中选择一个（输入序号）：1\nAuthInfo [username=yushijinhun, token=889af3a4d0f04277aaf3431f0a48a38e, uuid=8faf6e06d9e147fa8f63b9a6c19c5d5b, properties={}, userType=mojang]\n复制代码\n\n\n\n第3节到此便结束了，内容可能不太好理解，但只要各位多写代码运行运行就没问题。\n\n\n\n4. 下载游戏\n游戏下载是jmccc的一个可选功能，您必须确保您已经导入了jmccc-mcdownloader这个依赖。\n\n先介绍一下jmccc-mcdownloader中几个比较重要的类：\nMinecraftDownloader - jmccc-mcdownloader中最为重要的类，提供了下载的接口方法。所有下载任务都是提供这个类提交上去的。\nMinecraftDownloaderBuilder - 用来配置及创建MinecraftDownloader的类。下载时的代理、超时时间、下载源，如何检查缺失文件，缓存策略等都是通过这个类配置的。\nCallback - 异步处理的回调接口。包含了done()，failed()，cancelled()三个回调方法，分别在任务成功完成、任务失败、任务被取消时调用。\nDownloadTask - 代表了一个下载任务。每一个下载任务都有一个明确的URL表明数据来源。\nDownloadCallback - 下载的异步处理的回调接口，继承自Callback。还包含了updateProgress()和retry()用来汇报下载时的进度和重试情况。\nCombinedDownloadTask - 由多个下载任务组合而成的组合任务。每一个CombinedDownloadTask都可以派生出若干个DownloadTask。\nCombinedDownloadCallback - 组合任务的异步处理的回调接口。还包含了taskStart()，在该CombinedDownloadTask派生出一个DownloadTask时会调用该方法。\n\n首先要搞清楚DownloadTask与CombinedDownloadTask的关系。DownloadTask是下载一个文件的任务，CombinedDownloadTask是由多个DownloadTask组合而成的任务。如下图：\n\n\n要下载Minecraft，首先要创建一个MinecraftDownloader对象，可以通过以下方式：\nMinecraftDownloader downloader = MinecraftDownloaderBuilder.buildDefault();\n复制代码\n\n然后便可以调用它的downloadIncrementally(MinecraftDirectory, String, CombinedDownloadCallback<Version>)方法来下载Minecraft了。\n其中第个一参数是.minecraft目录位置；第二个参数是版本名称，如\"1.9\"；第三个是回调接口，返回的是一个Version，代表实际下载到的Minecraft版本。\ndownloadIncrementally方法会自动检查缺失的文件（如libraries、assets），并下载。\nMinecraftDownloader中所有的downloadXXX方法都是异步的（当然也包括上面的downloadIncrementally）。调用之后会立即返回。任务完成后会通知回调。\n\n如下面的这段代码下载了Minecraft 1.9：\n（注：可以使用CallbackAdapter来避免接口内写重复的空方法，类似于swing的Adapter）\npackage yushijinhun.jmccc.test;\n\nimport org.to2mbn.jmccc.mcdownloader.MinecraftDownloader;\nimport org.to2mbn.jmccc.mcdownloader.MinecraftDownloaderBuilder;\nimport org.to2mbn.jmccc.mcdownloader.download.DownloadCallback;\nimport org.to2mbn.jmccc.mcdownloader.download.DownloadTask;\nimport org.to2mbn.jmccc.mcdownloader.download.concurrent.CallbackAdapter;\nimport org.to2mbn.jmccc.option.MinecraftDirectory;\nimport org.to2mbn.jmccc.version.Version;\n\npublic class DownloadTest {\n\n        public static void main(String[] args) {\n                // 下载位置（要下载到的.minecraft目录）\n                MinecraftDirectory dir = new MinecraftDirectory(\"/home/yushijinhun/.minecraft\");\n\n                // 创建MinecraftDownloader\n                MinecraftDownloader downloader = MinecraftDownloaderBuilder.create().build();\n\n                // 下载Minecraft1.9\n                downloader.downloadIncrementally(dir, \"1.9\", new CallbackAdapter<Version>() {\n\n                        @Override\n                        public void done(Version result) {\n                                // 当完成时调用\n                                // 参数代表实际下载到的Minecraft版本\n                                System.out.printf(\"下载完成，下载到的Minecraft版本：%s%n\", result);\n                        }\n\n                        @Override\n                        public void failed(Throwable e) {\n                                // 当失败时调用\n                                // 参数代表是由于哪个异常而失败的\n                                System.out.printf(\"下载失败%n\");\n                                e.printStackTrace();\n                        }\n\n                        @Override\n                        public void cancelled() {\n                                // 当被取消时调用\n                                System.out.printf(\"下载取消%n\");\n                        }\n\n                        @Override\n                        public <R> DownloadCallback<R> taskStart(DownloadTask<R> task) {\n                                // 当有一个下载任务被派生出来时调用\n                                // 在这里返回一个DownloadCallback就可以监听该下载任务的状态\n                                System.out.printf(\"开始下载：%s%n\", task.getURI());\n                                return new CallbackAdapter<R>() {\n\n                                        @Override\n                                        public void done(R result) {\n                                                // 当这个DownloadTask完成时调用\n                                                System.out.printf(\"子任务完成：%s%n\", task.getURI());\n                                        }\n\n                                        @Override\n                                        public void failed(Throwable e) {\n                                                // 当这个DownloadTask失败时调用\n                                                System.out.printf(\"子任务失败：%s。原因：%s%n\", task.getURI(), e);\n                                        }\n\n                                        @Override\n                                        public void cancelled() {\n                                                // 当这个DownloadTask被取消时调用\n                                                System.out.printf(\"子任务取消：%s%n\", task.getURI());\n                                        }\n\n                                        @Override\n                                        public void retry(Throwable e, int current, int max) {\n                                                // 当这个DownloadTask因出错而重试时调用\n                                                // 重试不代表着失败\n                                                // 也就是说，一个DownloadTask可以重试若干次，\n                                                // 每次决定要进行一次重试时就会调用这个方法\n                                                // 当最后一次重试失败，这个任务也将失败了，failed()才会被调用\n                                                // 所以调用顺序就是这样：\n                                                // retry()->retry()->...->failed()\n                                                System.out.printf(\"子任务重试[%d/%d]：%s。原因：%s%n\", current, max, task.getURI(), e);\n                                        }\n                                };\n                        }\n                });\n        }\n\n}\n复制代码\n当下载成功时控制台输出：\n开始下载：https://launchermeta.mojang.com/mc/game/version_manifest.json\n子任务完成：https://launchermeta.mojang.com/mc/game/version_manifest.json\n开始下载：https://launchermeta.mojang.com/mc/game/6768033e216468247bd031a0a2d9876d79818f8f/1.9.json\n子任务完成：https://launchermeta.mojang.com/mc/game/6768033e216468247bd031a0a2d9876d79818f8f/1.9.json\n开始下载：https://launchermeta.mojang.com/mc-staging/assets/1.9/092c59b361816c7fa7f000587caa977c515b179c/1.9.json\n开始下载：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar\n开始下载：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar\n子任务完成：https://launchermeta.mojang.com/mc-staging/assets/1.9/092c59b361816c7fa7f000587caa977c515b179c/1.9.json\n开始下载：http://resources.download.minecraft.net/4b/4b90ff3a9b1486642bc0f15da0045d83a91df82e\n子任务完成：http://resources.download.minecraft.net/4b/4b90ff3a9b1486642bc0f15da0045d83a91df82e\n子任务完成：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar\n下载完成，下载到的Minecraft版本：1.9\n子任务完成：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar\n复制代码\n当下载失败时（通过拔网线实现）控制台输出：\n开始下载：https://launchermeta.mojang.com/mc/game/version_manifest.json\n开始下载：https://launchermeta.mojang.com/mc/game/6768033e216468247bd031a0a2d9876d79818f8f/1.9.json\n子任务完成：https://launchermeta.mojang.com/mc/game/version_manifest.json\n子任务完成：https://launchermeta.mojang.com/mc/game/6768033e216468247bd031a0a2d9876d79818f8f/1.9.json\n开始下载：https://launchermeta.mojang.com/mc-staging/assets/1.9/092c59b361816c7fa7f000587caa977c515b179c/1.9.json\n开始下载：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar\n开始下载：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar\n子任务重试[1/3]：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar。原因：java.net.UnknownHostException: launcher.mojang.com: unknown error\n子任务重试[2/3]：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar。原因：java.net.UnknownHostException: launcher.mojang.com\n子任务失败：https://launcher.mojang.com/mc/game/1.9/client/2f67dfe8953299440d1902f9124f0f2c3a2c940f/client.jar。原因：java.net.UnknownHostException: launcher.mojang.com\n子任务重试[1/3]：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar。原因：java.net.UnknownHostException: libraries.minecraft.net: unknown error\n子任务重试[2/3]：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar。原因：java.net.UnknownHostException: libraries.minecraft.net\n子任务失败：https://libraries.minecraft.net/com/mojang/authlib/1.5.22/authlib-1.5.22.jar。原因：java.net.UnknownHostException: libraries.minecraft.net\n子任务取消：https://launchermeta.mojang.com/mc-staging/assets/1.9/092c59b361816c7fa7f000587caa977c515b179c/1.9.json\n下载失败\njava.net.UnknownHostException: launcher.mojang.com\n        at java.net.InetAddress.getAllByName0(InetAddress.java:1280)\n......// 此处省略\n复制代码\n\n如果说要下载Minecraft版本列表，则需要调用fetchRemoteVersionList(CombinedDownloadCallback<RemoteVersionList>)方法。如下：\ndownloader.fetchRemoteVersionList(new CallbackAdapter<RemoteVersionList>() {\n\n        @Override\n        public void done(RemoteVersionList result) {\n                System.out.printf(\"版本列表下载完成：%s%n\", result);\n        }\n        \n        // ............省略其它方法\n});复制代码\n控制台输出如下：\n版本列表下载完成：[latestSnapshot=1.RV-Pre1, latestRelease=1.9.2, versions={16w05b=RemoteVersion [version=16w05b, ............\n复制代码\n注：如果说要在下载完后启动Minecraft的话，可以直接将Version对象传进LaunchOption的构造函数中。另外实际下载到的Minecraft的version id可能会与downloadIncrementally指定的不同，一般出现在下载forge时（下一节会有介绍）。\n\n当使用MinecraftDownloaderBuilder创建MinecraftDownloader时，可以通过方法链来自定义配置。下面是MinecraftDownloaderBuilder里的一些方法：\n方法意义setMaxConnections(int)设置下载时的最大链接数setMaxConnectionsPerRouter(int)设置NIO下每个I/O Dispatcher线程的最大链接数setConnectTimeout(int)设置连接超时的毫秒数setSoTimeout(int)设置Socket超时的毫秒数setBaseProvider(MinecraftDownloadProvider)设置下载源appendProvider(MinecraftDownloadProvider)将一个拓展下载源添加到解析链中setPoolMaxThreads(int)设置线程池的最大线程数setPoolThreadLivingTime(long)设置线程池里线程在不使用后最大的存活时间（毫秒）setDefaultTries(int)设置下载失败后最大的尝试次数（默认为3，不宜过大）setUseVersionDownloadInfo(boolean)设置是否从json中指定的url下载（即1.9的新json格式，默认true）setCheckAssetsHash(boolean)设置是否通过计算assets的hash来判断完整性（默认true）setCheckLibrariesHash(boolean)设置是否通过计算libraries的hash来判断完整性（默认false，文件hash会与1.9新json中指定的hash值比较）\n\n关于如何使用自定义的下载源，下面以BMCL API为例：\npackage org.to2mbn.jmccc.mcdownloader.wiki.provider;\n\nimport org.to2mbn.jmccc.mcdownloader.provider.DefaultLayoutProvider;\n\npublic class BmclApiProvider extends DefaultLayoutProvider {\n\n        @Override\n        protected String getLibraryBaseURL() {\n                return \"http://bmclapi2.bangbang93.com/libraries/\";\n        }\n\n        @Override\n        protected String getVersionBaseURL() {\n                return \"http://bmclapi2.bangbang93.com/versions/\";\n        }\n\n        @Override\n        protected String getAssetIndexBaseURL() {\n                return \"http://bmclapi2.bangbang93.com/indexes/\";\n        }\n\n        @Override\n        protected String getVersionListURL() {\n                return \"http://bmclapi2.bangbang93.com/mc/game/version_manifest.json\";\n        }\n\n        @Override\n        protected String getAssetBaseURL() {\n                return \"http://bmclapi2.bangbang93.com/assets/\";\n        }\n\n}\n复制代码\n然后只要在创建MinecraftDownloader时，调用setBaseProvider即可：\nMinecraftDownloader downloader = MinecraftDownloaderBuilder.create()\n        .setBaseProvider(new BmclApiProvider())\n        .build();\n复制代码\n\n最后，您必须手动关闭MinecraftDownloader，否则MinecraftDownloader占用的资源将不会释放（如缓存、线程等）：\ndownloader.shutdown();复制代码\n要注意的是，MinecraftDownloader是一个重量级对象，创建和销毁都会消耗大量的系统资源。所以在一般情况下推荐启动器使用一个MinecraftDownloader对象。\n\n\n\n5. 下载并安装Forge及Liteloader\n\n本节将介绍Forge、Liteloader版本列表的获取，以及Forge、Liteloader的下载安装。\n\n我们知道，Forge和Liteloader的版本在1.6（新.minecraft目录格式）之后，在versions目录中都是单独算一个版本的，比如1.7.10-LiteLoader1.7.10、1.8.9-forge1.8.9-11.15.1.1757。在jmccc也是这样，1.7.10-LiteLoader1.7.10、1.8.9-forge1.8.9-11.15.1.1757它们都是一个Minecraft版本，与1.9、1.7.10这样的版本是同等地位的，所以这些Forge、Liteloader版本可以像正常的Minecraft版本一样下载、启动。\n要支持Forge和Liteloader，首先要创建一个ForgeDownloadProvider和LiteloaderDownloadProvider。它们提供了对Forge、Liteloader的解析。然后通过MinecraftDownloaderBuilder的appendProvider方法将它们添加到MinecraftDownloader的解析链中：\nForgeDownloadProvider forgeProvider = new ForgeDownloadProvider();\nLiteloaderDownloadProvider liteloaderProvider = new LiteloaderDownloadProvider();\nMinecraftDownloader downloader = MinecraftDownloaderBuilder.create()\n        .appendProvider(forgeProvider)\n        .appendProvider(liteloaderProvider)\n        .build();\n复制代码\n注意：appendProvider(liteloaderProvider)需要在appendProvider(forgeProvider)之后调用，否则将不能下载同时Forge、Liteloader并存的版本。\n这样，这个MinecraftDownloader就具备了下载Forge、Liteloader的能力。\n\n要下载Forge或Liteloader，首先要获取它们的版本列表，如下：\ndownloader.download(forgeProvider.forgeVersionList(), new CallbackAdapter<ForgeVersionList>() {...});\ndownloader.download(liteloaderProvider.liteloaderVersionList(), new CallbackAdapter<LiteloaderVersionList>() {...});\n复制代码\np.s. 上面省略了Callback中的方法\n\n对于ForgeVersionList，有以下方法：\n方法意义getVersions()获取所有的ForgeVersion。返回一个Map，key为build number。getLatests()获取所有标记为latest的版本，即每个Minecraft版本所对应的最新的ForgeVersion。返回一个Map，key为minecraft版本，value是此minecraft版本对应的最新的ForgeVersion。getRecommendeds()获取所有标记为recommended的版本，即每个Minecraft版本所对应的推荐的ForgeVersion。返回一个Map，key为minecraft版本，value是此minecraft版本对应的推荐的ForgeVersion。getLatest()获取最最新的ForgeVersion。不考虑minecraft版本。getLatest(String)获取给定的minecraft版本最新的ForgeVersion。getRecommended()获取最新的推荐的ForgeVersion。不考虑minecraft版本。getRecommended(String)获取给定的minecraft版本推荐的ForgeVersion。\n\n对于LiteloaderVersionList，有以下方法:\n方法意义getLatests()获取每个minecraft版本对应的最新的LiteloaderVersion。返回的是Map，key为minecraft版本，value为该版本对应的最新的LiteloaderVersion。getLatest(String)获取给定的minecraft版本最新的LiteloaderVersion。\n注意：因为Liteloader开发者所提供的api过于变态，因此不支持snapshot版本，并且只能下载某个minecraft版本对应的最新的liteloader。\n\n在获取到要下载的ForgeVersion或LiteloaderVersion后就可以正常下载了，比如：\n// 这里的forgeVersion即要下载的forge版本\ndownloader.downloadIncrementally(dir, forgeVersion.getVersionName(), new CallbackAdapter<Version>() {......});\n复制代码\n可以看到和上文下载官方的minecraft版本并没有什么区别，只是使用了ForgeVersion的getVersionName()来作为要下载的minecraft的版本号罢了。要下载LiteloaderVersion如法炮制即可。\n\n如果说要下载一个Forge和Liteloader并存的minecraft该怎么办呢？\n假如我已经挑选好了ForgeVersion和LiteloaderVersion（forge和liteloader对应的minecraft版本要一致，不然肯定不能启动），那么只要将downloadIncrementally中的版本号替换为：\nliteloaderVersion.customize(forgeVersion.getVersionName()).getVersionName()复制代码\n至此，Forge、Liteloader相关内容就讲解完了。\n\n\n\n6. 获取正版玩家的皮肤\n从本节开始，我们就将开始介绍jmccc的高级用法。一般来说，听不懂是正常的。;(手动斜眼\n\n第3节中，我们学到了YggdrasilAuthenticator。事实上，YggdrasilAuthenticator的底层是YggdrasilService，YggdrasilService提供了一组访问Yggdrasil服务的接口。而与YggdrasilService并行的就是ProfileService，提供了和游戏角色相关的接口。\n我们可以通过下面的方法来创建一个ProfileService：\nProfileService profileService = YggdrasilServiceBuilder.defaultProfileService();复制代码\nProfileService中有三个方法，它们分别是：\n方法意义lookupUUIDByName(String)查询与玩家游戏中的名称对应的UUID。getGameProfile(UUID)查询给定UUID的角色的信息。getTextures(GameProfile)从给定的角色信息中获取皮肤（等）。\n注意：上面这三个方法都是要访问网络的，并且会阻塞，所以千万别脑残在UI线程之类的里面调用。\n\n下面给出一个例子：\npackage yushijinhun.jmccc.test;\n\nimport java.util.UUID;\nimport org.to2mbn.jmccc.auth.AuthenticationException;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.GameProfile;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.PlayerTextures;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.ProfileService;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.yggdrasil.YggdrasilServiceBuilder;\n\npublic class ProfileServiceTest {\n\n        public static void main(String[] args) throws AuthenticationException {\n                ProfileService profileService = YggdrasilServiceBuilder.defaultProfileService();\n\n                // 查询ztcjohn的uuid\n                UUID uuid = profileService.lookupUUIDByName(\"ztcjohn\");\n                System.out.println(uuid);\n\n                // 根据uuid获取GameProfile\n                // 注意啦！假如lookupUUIDByName没找到对应玩家就会返回null。我这里因为是演示所以偷懒不做判断，大家写的时候记得一定要判断一下\n                GameProfile profile = profileService.getGameProfile(uuid);\n\n                // 获取GameProfile的皮肤\n                // 同上，假如getGameProfile没找到对应玩家就会返回null。我这里是偷懒，大家写的时候千万不要学\n                PlayerTextures textures = profileService.getTextures(profile);\n                System.out.println(textures);\n        }\n\n}\n复制代码\n控制台输出：\n469aa369-6304-40d4-8b99-7e63199677ac\nPlayerTextures [skin=Texture [url=http://textures.minecraft.net/texture/2b28e73ff96914596963cb468da14fdb5e36217a6e327e8353efb44ec71, metadata=null], cape=Texture [url=http://textures.minecraft.net/texture/efd61c3c4ac88f1a3468fbdeef45cec89e5afb87b97a1a845bfb3c64fd0b883, metadata=null], elytra=null]\n复制代码\n可以看到ztcjohn不但有一个皮肤还有一个披风。getTextures方法返回的PlayerTextures包含了皮肤、披风、elytra（1.9新加的滑翔翼）。要注意的是，并不是每个角色都有这三个东西。\n（对不起咯～ztc喵）\nPlayerTextures只包含皮肤的url，具体图像需要再去下载。\n\n如果说要判断一个角色是Alex还是Steve，可以通过下面这个方法：\npublic static boolean isAlex(PlayerTextures textures) {\n        Texture skin = textures.getSkin();\n        if (skin != null) {\n                Map<String, String> metadata = skin.getMetadata();\n                if (metadata != null) {\n                        return \"slim\".equals(metadata.get(\"model\"));\n                }\n        }\n        return false;\n}\n复制代码\n\n\n7. OS X下Dock相关配置\n官方启动器在OSX下时，启动Minecraft的时候会添加一些和Dock相关的参数，用来设置Minecraft在Dock中的呈现。（貌似是这样）\n\n在jmccc中，您需要将ExtraArgumentsTemplates.OSX_DOCK_NAME和ExtraArgumentsTemplates.OSX_DOCK_ICON(MinecraftDirectory, Version)的返回值加进JVM参数中。在此之前，务必要检查当前系统是否为OSX，这两个参数只有在OSX下的JVM里才是有效的。\n比如：\nMinecraftDirectory dir = new MinecraftDirectory(\".minecraft\");\nLaunchOption option = new LaunchOption(\"1.9\", new OfflineAuthenticator(\"test_player\"), dir);\n\n// 一定要先判断是否为OSX\nif (Platform.CURRENT == Platform.OSX) {\n        option.setExtraJvmArguments(Arrays.asList(\n                        ExtraArgumentsTemplates.OSX_DOCK_NAME,\n                        ExtraArgumentsTemplates.OSX_DOCK_ICON(dir, option.getVersion())));\n}\n复制代码\n\n\n8. 忽略Forge的数字签名\n有些Forge版本要添加-Dfml.ignoreInvalidMinecraftCertificates=true和-Dfml.ignorePatchDiscrepancies=true这两项JVM参数才能正常启动。出现这种情况一般是往jar里塞了一些奇怪的东西，然后FML发现jar的数字签名损坏了。解决方法是往JVM参数列表里加上这两个参数（同前一节）。\n当然，jmccc是不会让您手动打这两项参数的。这两个参数都已经在ExtraArgumentsTemplates里面预定义好了，只需引用即可。\noption.setExtraJvmArguments(Arrays.asList(\n                ExtraArgumentsTemplates.FML_IGNORE_INVALID_MINECRAFT_CERTIFICATES,\n                ExtraArgumentsTemplates.FML_IGNORE_PATCH_DISCREPANCISE));\n复制代码\n\n\n9. 使用HttpAsyncClient来进行下载\n下载Minecraft时一般会下载大量文件（上千个），如果逐一下载效率固然很低，所以jmccc是允许多个任务同时下载的。默认情况下，jmccc用的是jdk自带的BIO（阻塞式I/O），会给每一个链接打开一个线程。当链接数很大时，便会造成系统资源的严重浪费。解决方法是切换到NIO（非阻塞式I/O），这样仅用数个线程便可以处理上万个链接，将下载速度最大化。\n如果说要在jmccc中使用NIO来下载，则需要添加Apache HttpAsyncClient这个依赖：\norg.apache.httpcomponents:httpasyncclient:4.1.1复制代码\njmccc在初始化时，如果发现classpath中存在HttpAsyncClient，则会自动使用HttpAsyncClient来下载。\n在将HttpAsyncClient添加到classpath中后，您便可以将最大链接数调到任意大了：\nMinecraftDownloader downloader = MinecraftDownloaderBuilder.create()\n        .setMaxConnections(4096)\n        .build();\n复制代码\n比如这样将MaxConnections调到了4096，那么最多可以同时下载4096个文件。\n\n如果说您不想使用HttpAsyncClient，您可以调用MinecraftDownloaderBuilder的disableApacheHttpAsyncClient()来禁用对HttpAsyncClient的支持。这样jmccc就只会使用BIO来下载文件。\n\n\n\n10. 使用Ehcache缓存下载的文件\njmccc有时候会多次下载同一个文件，这样就会造成不必要的网络I/O和等待时间。所以jmccc提供了对Ehcache的支持（Ehcache是最有名的一个轻量级Java缓存框架）。如果说要启用这个缓存功能的话首先要将Ehcache添加到依赖，需要注意的是jmccc使用的是Ehcache3，不是2。\norg.ehcache.modules:ehcache-impl:3.0.0.rc2复制代码\n注意：ehcache使用了slf4j作为logging框架，推荐您的项目中至少包含一个slf4j的实现。\n\n将ehcache添加到classpath之后，您便可以对缓存进行配置了。\nehcache提供了三种类型的缓存：\n堆上缓存（heap） - 存储在java堆上的缓存\n离堆缓存（offheap） - 存储在本地内存中的缓存，在java堆之外，不受jvm托管\n磁盘缓存（disk） - 存储在磁盘上的缓存\n\njmccc默认开启32MB的堆上缓存，不开启离堆缓存和磁盘缓存，缓存的有效时间是2小时。您可以使用下面的这些方法来设置缓存：\n方法意义setHeapCacheSize(long)设置Java堆上缓存的最大大小，0则不开启，单位：MB。setOffheapCacheSize(long)设置离堆缓存（本地内存）的最大大小，0则不开启，单位：MB。setDiskCacheSize(long)设置磁盘上缓存的最大大小，0则不开启，单位：MB。开启该功能后还需调用setDiskCacheDir(File)进行设置。setDiskCacheDir(File)设置磁盘上用于存储缓存的目录。setCacheLiveTime(long, TimeUnit)配置缓存的有效时间（TTL），超过该时间的缓存将被自动清除。\n\n比如下面这段代码，只将最大为128M的缓存存储在磁盘上，有效时间1天：\nMinecraftDownloader downloader = MinecraftDownloaderBuilder.create()\n        .setHeapCacheSize(0) // 关闭堆上缓存\n        .setOffheapCacheSize(0) // 关闭离堆缓存\n        .setDiskCacheSize(128) // 开启最大为128MB的磁盘缓存\n        .setDiskCacheDir(new File(\"/tmp/jmccc-cache\")) // 存储缓存的目录是/tmp/jmccc-cache\n        .setCacheLiveTime(1, TimeUnit.DAYS)// 缓冲有效时间1天\n        .build();\n复制代码\n\n如果说您不想使用缓存，那您可以调用MinecraftDownloaderBuilder的disableEhcache()方法来禁用对Ehcache的支持。\n\n\n\n11. 修改Minecraft1.9中的version_type\n大家用HMCL启动Minecraft1.9的时候可能会发现，Minecraft主界面下面有这样的东西：\n\n这是怎么实现的呢？\n可以打开1.9.json看看，发现其中有这样一段：\n\"minecraftArguments\": \"--username ${auth_player_name} --version ${version_name} --gameDir ${game_directory} --assetsDir ${assets_root} --assetIndex ${assets_index_name} --uuid ${auth_uuid} --accessToken ${auth_access_token} --userType ${user_type} --versionType ${version_type}\"复制代码\n不知大家有没有注意到${version_type}这一个字符串。官方启动器在启动时会自动用Minecraft版本的type来代替这段字符串，比如snapshot、release，这样在Minecraft底部就显示为Minecraft 1.9-pre2/snapshot，Minecraft 1.9/release。但HMCL则将它替换为了HMCL 2.4.1.41。\njmccc的行为默认和官方启动器一样，会将version_type指定为Version.getType()。但jmccc也提供了一个覆写该变量的方法，它就是第2节中介绍的setCommandlineVariables。\n\n我们可以手动指定version_type的值，如下：\npackage yushijinhun.jmccc.test;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.to2mbn.jmccc.auth.OfflineAuthenticator;\nimport org.to2mbn.jmccc.launch.Launcher;\nimport org.to2mbn.jmccc.launch.LauncherBuilder;\nimport org.to2mbn.jmccc.option.LaunchOption;\nimport org.to2mbn.jmccc.option.MinecraftDirectory;\n\npublic class JmcccTest {\n\n        public static void main(String[] args) throws Exception {\n                Launcher launcher = LauncherBuilder.buildDefault();\n                LaunchOption option = new LaunchOption(\"1.9\", new OfflineAuthenticator(\"test_user\"), new MinecraftDirectory(\"/home/yushijinhun/.minecraft\"));\n\n                // 重点：手动指定version_type\n                Map<String, String> vars = new HashMap<>();\n                vars.put(\"version_type\", \"JMCCC大法好！\");\n                option.setCommandlineVariables(vars);\n\n                launcher.launch(option);\n        }\n}\n复制代码\n运行效果：\n\n\n\n\n12. 使用自定义的Yggdrasil API提供商\np.s. 如果您没有深入了解过Yggdrasil服务，那么本节对您来说可能有些困难。\nwiki.vg上有一篇介绍Yggdrasil的条目（英文）：http://wiki.vg/Authentication\n\n正版验证（即Yggdrasil）是Mojang提供的服务，但这不一定必须由Mojang提供。也就是说，您可以创建一套和Mojang并行的Yggdrasil服务，相当于Yggdrasil私服。事实上，yushijinhun（我）的authlib-agent就已经成功通过字节码操纵实现了对Minecraft内Yggdrasil API的重定向，并给出了一个Yggdrasil服务的开源实现。（本节的部分内容曾在第3节中出现，所以对下面的代码您可能会感到有些眼熟？）\n\n在jmccc中，如果要手动指定Yggdrasil API提供商，就得先为YggdrasilAPIProvider编写一个子类，里面定义API的URL。\n我在本地用authlib-agent架设了一个yggdrasil服务端，给YggdrasilAPIProvider编写的子类如下：\npackage yushijinhun.jmccc.test;\n\nimport java.util.UUID;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.yggdrasil.YggdrasilAPIProvider;\nimport org.to2mbn.jmccc.util.UUIDUtils;\n\npublic class yushijinhunYggdrasilAPIProvider implements YggdrasilAPIProvider {\n\n        @Override\n        public String authenticate() {\n                return \"http://localhost:8080/yggdrasil/authenticate\";\n        }\n\n        @Override\n        public String refresh() {\n                return \"http://localhost:8080/yggdrasil/refresh\";\n        }\n\n        @Override\n        public String validate() {\n                return \"http://localhost:8080/yggdrasil/validate\";\n        }\n\n        @Override\n        public String invalidate() {\n                return \"http://localhost:8080/yggdrasil/invalidate\";\n        }\n\n        @Override\n        public String signout() {\n                return \"http://localhost:8080/yggdrasil/signout\";\n        }\n\n        @Override\n        public String profile(UUID profileUUID) {\n                return \"http://localhost:8080/yggdrasil/profiles/minecraft/\" + UUIDUtils.unsign(profileUUID);\n        }\n\n        @Override\n        public String profileLookup() {\n                return \"http://localhost:8080/yggdrasil/profilerepo/minecraft\";\n        }\n}\n复制代码\n然后您就可以用YggdrasilServiceBuilder来配置AuthenticationService和ProfileService了：\nYggdrasilServiceBuilder yggdrasilBuilder = YggdrasilServiceBuilder.create()\n        .setAPIProvider(new yushijinhunYggdrasilAPIProvider())\n        .loadSessionPublicKey(\"/home/yushijinhun/yushijinhun_yggdrasil_pubkey.der\"); //(1)\nProfileService profileService = yggdrasilBuilder.buildProfileService(); //(2)\nAuthenticationService authenticationService = yggdrasilBuilder.buildAuthenticationService(); //(3)\n复制代码\n上面代码中(1)代表从/home/yushijinhun/yushijinhun_yggdrasil_pubkey.der这个文件中加载Yggdrasil的数字签名公钥。该文件应是PKCS#8格式的RSA证书的SubjectPublicKeyInfo部分（与mojang authlib使用的密钥格式相同）。您也可以使用setSessionPublicKey(PublicKey)方法直接设置公钥。\n(2)代表用上面的YggdrasilServiceBuilder创建一个ProfileService。这个ProfileService是绑定到上面指定的Yggdrasil API上的，上面第6节有介绍。\n(3)代表用上面的YggdrasilServiceBuilder创建一个AuthenticationService。这个AuthenticationService是绑定到上面指定的Yggdrasil API上的。\n\n您可以通过new YggdrasilAuthenticator(authenticationService)来创建一个使用指定的AuthenticationService的YggdrasilAuthenticator。\n需要注意的是，如果您要序列化YggdrasilAuthenticator，请务必重写createAuthenticationServiceForDeserialization()方法。这个方法用来在反序列化过程中重新创建AuthenticationService。\npackage yushijinhun.jmccc.test;\n\nimport java.io.IOException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport org.to2mbn.jmccc.auth.yggdrasil.YggdrasilAuthenticator;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.AuthenticationService;\nimport org.to2mbn.jmccc.auth.yggdrasil.core.yggdrasil.YggdrasilServiceBuilder;\n\npublic class MyYggdrasilAuthenticator extends YggdrasilAuthenticator {\n\n        /**\n         * 创建一个我自定义的AuthenticationService。\n         * \n         * @return 我自定义的AuthenticationService\n         */\n        private static AuthenticationService createMyAuthenticationService() {\n                try {\n                        return YggdrasilServiceBuilder.create()\n                                        .setAPIProvider(new yushijinhunYggdrasilAPIProvider())\n                                        .loadSessionPublicKey(\"/home/yushijinhun/yushijinhun_yggdrasil_pubkey.der\")\n                                        .buildAuthenticationService();\n                } catch (NoSuchAlgorithmException | InvalidKeySpecException | IOException e) {\n                        throw new IllegalStateException(\"无法创建自定义的AuthenticationService！\", e);\n                }\n        }\n\n        public MyYggdrasilAuthenticator() {\n                // 使用自定义的AuthenticationService\n                super(createMyAuthenticationService());\n        }\n\n        @Override\n        protected AuthenticationService createAuthenticationServiceForDeserialization() {\n                // 在反序列化过程中重新创建我自定义的AuthenticationService\n                return createMyAuthenticationService();\n        }\n}\n复制代码\n\n题外话：由于某些原因（比如gfw），会导致国内有时候连不上Mojang的Yggdrasil服务，这时候可以用YggdrasilServiceBuilder的setProxy(Proxy)指定一个代理。\n\n\n\n后记\njmccc从2.3到2.4，中间经过了近5个月的开发，加入了大量新的功能，也进行了大量重构。jmccc 2.4将先前就在开发的下载功能并入了主干，并对Yggdrasil部分进行了重写，因此也难免有些bug。\n如果说您在使用过程中发现了jmccc的bug，欢迎将bug报告到GitHub Issues，我们将十分感谢。\n如果您有什么好点子，也欢迎您在Gitter上和我们交流。\n同时也欢迎您向jmccc PR代码。\n\njmccc提供了大量的API，因此本教程也难以面面俱到。如果说您发现教程中出现了错误，请将错误指出，我将万分感谢。\n如果您对本教程有什么建议，也欢迎提出。\n\n关于图床：本文的图片都是挂在to2mbn.github.io上的，考虑到国内部分地区封杀到github pages的https流量，所以都用了http协议。\n\n\n最后，感谢所有支持jmccc开发的人！",
    "replies": [
        {
            "author": "TanDan2016",
            "timestamp": 1460180820,
            "txt_content": "太好了，终于找到了JMCCC的教程了"
        },
        {
            "author": "TanDan2016",
            "timestamp": 1460251380,
            "txt_content": "LZ为什么我启动不了MC,这是我的代码\npublic class start_up\n{\n        ReadString readString=new ReadString();\n        public start_up()throws Exception\n        {\n                String gameMemory = ReadString.readFileContent(\"\",\"gameMemory.TD\");\n                String gameName = ReadString.readFileContent(\"\", \"gameName.TD\");\n                String gamePath = ReadString.readFileContent(\"\", \"gamePath.TD\");\n                String gameVersion = ReadString.readFileContent(\"\", \"gameVersion.TD\");\n                 int a = Integer.parseInt(gameMemory);\n                 System.out.print(\"gameMemory  \"+a+\"  gameName  \"+gameName+\"  gamePath  \"+gamePath+\"  gameVersion\"+gameVersion);\n                 Launcher launcher = LauncherBuilder.buildDefault();\n                 LaunchOption option = new LaunchOption(gameVersion, new OfflineAuthenticator(gameName), new MinecraftDirectory(gamePath));\n                 \n                 option.setMaxMemory(a);\n                 \n                 launcher.launch(option);\n        }\n}复制代码"
        },
        {
            "author": "Darkyoooooo",
            "timestamp": 1460256000,
            "txt_content": "TanDan2016 发表于 2016-4-10 09:23\nLZ为什么我启动不了MC,这是我的代码\nstderror有没有输出什么"
        },
        {
            "author": "TanDan2016",
            "timestamp": 1460724180,
            "txt_content": "Darkyoooooo 发表于 2016-4-10 10:40\nstderror有没有输出什么\n空指针错误,不过我自己也经解决了"
        },
        {
            "author": "懒虫哥",
            "timestamp": 1461036960,
            "txt_content": "好复杂...这是自己做启动器吗..."
        },
        {
            "author": "18278869354",
            "timestamp": 1461418260,
            "txt_content": "空指针错误,不过我自己也经解决了"
        },
        {
            "author": "lizhaohan001",
            "timestamp": 1461420840,
            "txt_content": "非常好用！！正在用。"
        },
        {
            "author": "hhttll",
            "timestamp": 1461797820,
            "txt_content": "看到 Callback 就一定要吐槽了...\nLZ 一定是 JS症患者2333\n\n顺便感谢下这个库"
        },
        {
            "author": "yuanzhihang1",
            "timestamp": 1461933720,
            "txt_content": "感谢分享！！！非常重要"
        },
        {
            "author": "YDDonald",
            "timestamp": 1462107180,
            "txt_content": "好赞，我的阅读恐惧症又犯了"
        },
        {
            "author": "_Ⅲ儿_",
            "timestamp": 1462197780,
            "txt_content": "教程一出，赌450，java启动器要炸"
        },
        {
            "author": "qq1748997604",
            "timestamp": 1462320240,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "Ziang39",
            "timestamp": 1462331280,
            "txt_content": "赞赞赞，很棒的作品！！赞赞赞，很棒的作品！！赞赞赞，很棒的作品！！赞赞赞，很棒的作品！！赞赞赞，很棒的作品！！赞赞赞，很棒的作品！！"
        },
        {
            "author": "GTA守护使者",
            "timestamp": 1464255600,
            "txt_content": "为什么报错，这是什么原因！\n环境：\njava version \"1.7.0_80\"\nJava(TM) SE Runtime Environment (build 1.7.0_80-b15)\nJava HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)\nWindows 7 64位 8G内存 i5CPU\n\n\n调试信息：\nException in thread \"main\" java.lang.NullPointerException\n        at java.util.Objects.requireNonNull(Unknown Source)\n        at org.to2mbn.jmccc.option.LaunchOption.<init>(LaunchOption.java:121)\n        at org.to2mbn.jmccc.option.LaunchOption.<init>(LaunchOption.java:96)\n        at mcgui.Mcgui.mc(Mcgui.java:34)\n        at mcgui.Main.main(Main.java:12)\n\n\n\n类一：\npackage mcgui;\n\npublic class Main {\n        public static void main(String[] args) throws Exception {\n                Mcgui mc = new Mcgui();\n                mc.logs = true; // 启动调试  boolean\n                mc.charm = true; // 开启对Natives文件的快速检查  boolean\n                mc.version = \"1.8\"; // 游戏版本  String\n                mc.user = \"test_user\"; // 使用离线验证，用户名  String  \n                mc.mineurl = \"D:/Program Files (x86)/Minecraft 1.8-forge/.minecraft\"; // .minecraft目录  String\n                mc.mem = 512; // 最大内存512M  int\n                mc.mc(); \n                \n                /*\n                 * mc.logs                        boolean\n                 * mc.charm                        boolean\n                 * mc.version                String\n                 * mc.user                        String\n                 * mc.mineurl                String\n                 * mc.mem                        int\n                 * \n                 */\n        }\n}复制代码\n类二：\npackage mcgui;\n\nimport org.json.*;\nimport org.tukaani.xz.*;\nimport org.to2mbn.jmccc.auth.OfflineAuthenticator;\nimport org.to2mbn.jmccc.exec.GameProcessListener;\nimport org.to2mbn.jmccc.launch.Launcher;\nimport org.to2mbn.jmccc.launch.LauncherBuilder;\nimport org.to2mbn.jmccc.option.LaunchOption;\nimport org.to2mbn.jmccc.option.MinecraftDirectory;\n\npublic class Mcgui {\n        boolean logs ; // 启动调试\n        boolean charm ; // 开启对Natives文件的快速检查\n        String version ; // 游戏版本\n        String user ; // 使用离线验证，用户名\n        String mineurl ; // .minecraft目录\n        int mem ; // 最大内存512M\n        \n        \n        public void mc() throws Exception {\n                \n        // 创建一个Launcher对象\n                System.out.println(\"创建一个Launcher对象\");\n                Launcher launcher = LauncherBuilder.create()\n                            .setDebugPrintCommandline(logs) // 设置是否在启动时将启动参数输出到控制台以供调试，默认为false。\n                            .setNativeFastCheck(charm) // 设置是否开启对Natives文件的快速检查，默认为false。\n                            //开启该选项后，jmccc仅会通过比较文件大小来判断文件是否完整，这样可以加快启动速度，但有可能造成某些问题。\n                            .build();\n        System.out.println(\"创建对象成功\");\n        \n        // 启动配置\n        System.out.println(\"启动配置\");\n        LaunchOption option = new LaunchOption(\n                        version, // 游戏版本\n                new OfflineAuthenticator(user), // 使用离线验证，用户名\n                new MinecraftDirectory(mineurl) // .minecraft目录\n        ); \n        System.out.println(\"启动成功！\");\n        \n        // 最大内存512M\n        System.out.println(mem);\n        option.setMaxMemory(mem);\n        \n        // 启动游戏\n        System.out.println(\"启动游戏！\");\n        \n        launcher.launch(option, new GameProcessListener() {\n \n            @Override\n            public void onLog(String log) {\n                System.out.println(log); // 输出日志到控制台\n            }\n\n            @Override\n            public void onErrorLog(String log) {\n                System.err.println(log); // 输出日志到控制台（同上）\n            }\n\n            @Override\n            public void onExit(int code) {\n                System.err.println(\"游戏进程退出，状态码：\" + code); // 游戏结束时输出状态码\n            }\n        });\n        System.out.println(\"游戏启动成功！\");\n    }\n}复制代码\n\n\n"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1464265020,
            "txt_content": "GTA守护使者 发表于 2016-5-26 17:40\n为什么报错，这是什么原因！\n环境：\njava version \"1.7.0_80\"\n这是因为指定的Minecraft版本不存在。\n你可以用Versions.getVersions(MinecraftDirectory)来获取某个.minecraft目录下的所有版本。\n这里抛出NullPointerException确实不是特别好，在2.5中（未发布）已经改成了IllegalArgumentException: Version not found: xxx了。"
        },
        {
            "author": "tt36999",
            "timestamp": 1464278820,
            "txt_content": " 本帖最后由 tt36999 于 2016-5-27 00:09 编辑 \n\n顶LZ，确实好用简单易行，不过我在使用你的JMCCC之后如果启动的时候mods文件夹内有mcheli（直升机MOD）时游戏就会提示\nForge Mod Loder has found a problem with your minecraft installation You have mod sources that are duplicate within your system Mod Id : File name\n mcheli : minecraft\n mcheli : mcheli不过同样的整合包和forge使用HMCL启动器不会出现类似的问题\n请问你知道这是什么原因么？或者这个是由于MOD本身的BUG造成的不兼容？这个MOD是一个文件夹放在Mods目录内而不是jar包是否有影响？"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1464279480,
            "txt_content": "tt36999 发表于 2016-5-27 00:07\n顶LZ，确实好用简单易行，不过我在使用你的JMCCC之后如果启动的时候mods文件夹内有mcheli（直升机MOD）时游 ...\n具体我也不大清楚，也许你可以把debugPrintCommandline开出来然后对比一下启动命令行？"
        },
        {
            "author": "照烧鸡腿饭",
            "timestamp": 1464281520,
            "txt_content": "mark下，考完试慢慢研究{:10_492:}"
        },
        {
            "author": "tt36999",
            "timestamp": 1464307440,
            "txt_content": "yushijinhun 发表于 2016-5-27 00:18\n具体我也不大清楚，也许你可以把debugPrintCommandline开出来然后对比一下启动命令行？ ...\n好吧……"
        },
        {
            "author": "jkaa13579",
            "timestamp": 1464575580,
            "txt_content": "好东西，楼主造"
        },
        {
            "author": "深海鲸鱼座",
            "timestamp": 1465465320,
            "txt_content": " 本帖最后由 lj2000lj 于 2016-6-9 17:49 编辑 \n\n无法启动安装了mcheli的1.7.10客户端，不知道是不是吾辈操作有误\nJmccc调用代码与本帖中所示一致\nForge日志文件显示如下：\n[时间] [Client thread/ERROR]: Found a duplicate mod mcheli at [路径\\.minecraft, 路径\\.minecraft\\mods\\mcheli]\n之前有显示mcheli加载了两次，一次不能找到mcmod.info，第二次可以找到。\n如果将mcheli放入mods下的1.7.10文件夹，forge会多识别出一个mcheli，并且依旧不能找到mcmod.info\n其他启动器正常，MinecraftForum上有提到一款名为FTB Launcher的启动器存在同样的问题\n\n才发现新版换人开发惹= ="
        },
        {
            "author": "yushijinhun",
            "timestamp": 1465566240,
            "txt_content": "tt36999 发表于 2016-5-27 00:07\n顶LZ，确实好用简单易行，不过我在使用你的JMCCC之后如果启动的时候mods文件夹内有mcheli（直升机MOD）时游 ...\n你所述的这个bug已经在2.5-SNAPSHOT中修复了。具体见 https://github.com/to2mbn/JMCCC/issues/19 。"
        },
        {
            "author": "officeyutong",
            "timestamp": 1471347780,
            "txt_content": "启动时 客户端一直卡在Finishing up 但是用其他启动器启动时没有问题\n以下为启动命令行\nC:\\Program Files\\Java\\jdk1.7.0_51\\jre\\bin\\java.exe\n-Xmx2048M\n-Djava.library.path=J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\versions\\1.7.10\\1.7.10-natives\n-cp\nJ:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\google\\code\\gson\\gson\\2.2.4\\gson-2.2.4.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\google\\guava\\guava\\17.0\\guava-17.0.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\ibm\\icu\\icu4j-core-mojang\\51.2\\icu4j-core-mojang-51.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\mojang\\authlib\\1.5.21\\authlib-1.5.21.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\mojang\\realms\\1.3.5\\realms-1.3.5.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\mumfrey\\liteloader\\1.7.10\\liteloader-1.7.10.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\paulscode\\codecjorbis\\20101023\\codecjorbis-20101023.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\paulscode\\codecwav\\20101023\\codecwav-20101023.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\paulscode\\libraryjavasound\\20101123\\libraryjavasound-20101123.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\paulscode\\librarylwjglopenal\\20100824\\librarylwjglopenal-20100824.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\paulscode\\soundsystem\\20120107\\soundsystem-20120107.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\typesafe\\akka\\akka-actor_2.11\\2.3.3\\akka-actor_2.11-2.3.3.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\com\\typesafe\\config\\1.2.1\\config-1.2.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\commons-codec\\commons-codec\\1.9\\commons-codec-1.9.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\commons-io\\commons-io\\2.4\\commons-io-2.4.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\commons-logging\\commons-logging\\1.1.3\\commons-logging-1.1.3.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\io\\netty\\netty-all\\4.0.10.Final\\netty-all-4.0.10.Final.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\java3d\\vecmath\\1.3.1\\vecmath-1.3.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\lzma\\lzma\\0.0.1\\lzma-0.0.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\java\\jinput\\jinput\\2.0.5\\jinput-2.0.5.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\java\\jutils\\jutils\\1.0.0\\jutils-1.0.0.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\minecraft\\launchwrapper\\1.12\\launchwrapper-1.12.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\minecraftforge\\forge\\1.7.10-10.13.4.1614-1.7.10\\forge-1.7.10-10.13.4.1614-1.7.10.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\sf\\jopt-simple\\jopt-simple\\4.5\\jopt-simple-4.5.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\net\\sf\\trove4j\\trove4j\\3.0.3\\trove4j-3.0.3.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\commons\\commons-compress\\1.8.1\\commons-compress-1.8.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\commons\\commons-lang3\\3.3.2\\commons-lang3-3.3.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\httpcomponents\\httpclient\\4.3.3\\httpclient-4.3.3.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\httpcomponents\\httpcore\\4.3.2\\httpcore-4.3.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\logging\\log4j\\log4j-api\\2.0-beta9\\log4j-api-2.0-beta9.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\apache\\logging\\log4j\\log4j-core\\2.0-beta9\\log4j-core-2.0-beta9.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\lwjgl\\lwjgl\\lwjgl\\2.9.1\\lwjgl-2.9.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\lwjgl\\lwjgl\\lwjgl_util\\2.9.1\\lwjgl_util-2.9.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\ow2\\asm\\asm-all\\5.0.3\\asm-all-5.0.3.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\plugins\\scala-continuations-library_2.11\\1.0.2\\scala-continuations-library_2.11-1.0.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\plugins\\scala-continuations-plugin_2.11.1\\1.0.2\\scala-continuations-plugin_2.11.1-1.0.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-actors-migration_2.11\\1.1.0\\scala-actors-migration_2.11-1.1.0.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-compiler\\2.11.1\\scala-compiler-2.11.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-library\\2.11.1\\scala-library-2.11.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-parser-combinators_2.11\\1.0.1\\scala-parser-combinators_2.11-1.0.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-reflect\\2.11.1\\scala-reflect-2.11.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-swing_2.11\\1.0.1\\scala-swing_2.11-1.0.1.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\org\\scala-lang\\scala-xml_2.11\\1.0.2\\scala-xml_2.11-1.0.2.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\libraries\\tv\\twitch\\twitch\\5.16\\twitch-5.16.jar;J:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\versions\\1.7.10\\1.7.10.jar\nnet.minecraft.launchwrapper.Launch\n--username\nServer_crashed\n--version\n1.7.10-Forge10.13.4.1614-1.7.10\n--gameDir\nJ:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\n--assetsDir\nJ:\\mc\\LifeCraftX6V1.0\\LCX6V2.5\\.minecraft\\assets\n--assetIndex\n1.7.10\n--uuid\n375b37e9a31b3d34be69788c60644134\n--accessToken\nfb6aa3588e6744bcbf831f2aa360d48a\n--userProperties\n{}\n--userType\nmojang\n--tweakClass\ncpw.mods.fml.common.launcher.FMLTweaker"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1471352700,
            "txt_content": "officeyutong 发表于 2016-8-16 19:43\n启动时 客户端一直卡在Finishing up 但是用其他启动器启动时没有问题\n以下为启动命令行\nC:\\Program Files\\J ...\n感谢您的反馈。您可不可以将其它启动器的启动参数发上来供我们对比？或者您也可以将.minecraft发到 yushijinhun@gmail.com 来帮助我们重现bug。"
        },
        {
            "author": "officeyutong",
            "timestamp": 1471357920,
            "txt_content": "yushijinhun 发表于 2016-8-16 21:05\n感谢您的反馈。您可不可以将其它启动器的启动参数发上来供我们对比？或者您也可以将.minecraft发到  来帮 ...\n已经解决了 用的java7 同时因为PermSize太小导致内存溢出 换了java8好了"
        },
        {
            "author": "officeyutong",
            "timestamp": 1471357980,
            "txt_content": "yushijinhun 发表于 2016-8-16 21:05\n感谢您的反馈。您可不可以将其它启动器的启动参数发上来供我们对比？或者您也可以将.minecraft发到  来帮 ...\n以及另一个问题 JMCCC不能指定PermSize"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1471363800,
            "txt_content": "officeyutong 发表于 2016-8-16 22:33\n以及另一个问题 JMCCC不能指定PermSize\n可以通过LaunchOption.extraJVMArguments()指定"
        },
        {
            "author": "jinyigeng",
            "timestamp": 1471693980,
            "txt_content": "楼主你好，提几个问题，谢谢1.为什么下载Minecraft总是被取消？\n下面是源代码\nMain.java\n\n\npackage xyz.jinyigeng.CMCL;\n\nimport java.io.IOException;\nimport org.to2mbn.jmccc.launch.LaunchException;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStreamReader;\npublic class Main {\n    public static void main(String[] args) throws IOException, LaunchException{\n        File mainDir = new File(\".minecraft\");\n        File versionDir = new File(\".minecraft\" + File.separator + \"versions\");\n        if(!mainDir.isDirectory()){\n            mainDir.mkdir();\n        }\n        if(!mainDir.exists()){\n            mainDir.mkdir();\n        }\n        if(!versionDir.exists()){\n            versionDir.mkdir();\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        boolean isRestart = false;\n        do{\n        System.out.println(\"[启动器]如果需要启动游戏，请输入1\");\n        System.out.println(\"[启动器]如果需要下载游戏，请输入2\");\n        System.out.println(\"[启动器]如果输入其他数字程序将退出。\");\n        int chooseMenu = Integer.parseInt(reader.readLine());\n        switch(chooseMenu){\n            case 1:\n                Launch launch = new Launch();\n                launch.launch();\n                break;\n            case 2:\n                UseDownload download = new UseDownload();\n                download.download();\n                isRestart = true;\n                continue;\n            case 3:\n                System.out.println(\"[启动器]CMCL1.0b4更新记录\");\n                System.out.println(\"1.使用BMCLAPI\");\n                System.out.println(\"[启动器]按任意键返回上一层\");\n                reader.readLine();\n                isRestart = true;\n                continue;\n            default:\n                System.out.println(\"[启动器]按任意键退出。\");\n                reader.readLine();\n        }\n        }while(isRestart == true);\n    }\n}\n\n复制代码\n\n\nUseDownload.java\n\n\n\npackage xyz.jinyigeng.CMCL;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\npublic class UseDownload {\n    Download down = new Download();\n    public void download() throws IOException{\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"[启动器下载模块]欢迎您使用下载模块！\");\n        System.out.println(\"[启动器下载模块]请输入要下载的Minecraft版本\");\n        System.out.println(\"[启动器下载模块]如输入back，将回到主菜单\");\n        String version = reader.readLine();\n        if(\"back\".equals(version)){\n            return;\n        }\n        System.out.println(\"[启动器下载模块]是否想使用BMCLAPI加速服务？如要使用请输入1，其他则使用官方源\");\n        int isUseBMCLAPI = Integer.parseInt(reader.readLine());\n        if (isUseBMCLAPI == 1){\n            down.downloadMinecraftUseBMCLAPI(version);\n        }else{\n            down.downloadMinecraft(version);\n        }\n    }\n}\n\n复制代码\n\n\nDownload.java\n\n\npackage xyz.jinyigeng.CMCL;\n\nimport org.to2mbn.jmccc.mcdownloader.MinecraftDownloader;\nimport org.to2mbn.jmccc.mcdownloader.MinecraftDownloaderBuilder;\nimport org.to2mbn.jmccc.mcdownloader.download.DownloadCallback;\nimport org.to2mbn.jmccc.mcdownloader.download.DownloadTask;\nimport org.to2mbn.jmccc.mcdownloader.download.concurrent.CallbackAdapter;\nimport org.to2mbn.jmccc.option.MinecraftDirectory;\nimport org.to2mbn.jmccc.version.Version;\npublic class Download {\n    public void downloadMinecraft(String version){\n        MinecraftDirectory dir = new MinecraftDirectory(\".minecraft\");\n        MinecraftDownloader mcdownloader = MinecraftDownloaderBuilder\n                .create()\n                .build();\n        mcdownloader.downloadIncrementally(dir, version, new CallbackAdapter<Version>(){\n            @Override\n            public void done(Version result){\n                System.out.println(\"[启动器下载模块]下载完毕\");\n            }\n            @Override\n            public void failed(Throwable e){\n                System.out.println(\"[启动器下载模块]下载失败，下列为错误信息\");\n                e.printStackTrace();\n            }\n            @Override\n            public void cancelled(){\n                System.out.println(\"[启动器下载模块]下载被取消\");\n            }\n            @Override\n            public <R> DownloadCallback<R> taskStart(DownloadTask<R> task){\n                System.out.println(\"[启动器下载模块]正在下载：\"+ task.getURI());\n                return new CallbackAdapter<R>(){\n                    @Override\n                    public void done(R result){\n                        System.out.println(\"[启动器下载模块]子任务下载完成\" + task.getURI());\n                    }\n                    @Override\n                    public void failed(Throwable e){\n                        System.out.println(\"[启动器下载模块]下载失败。错误信息为\"+ task.getURI()+ e);\n                    }\n                    @Override\n                    public void cancelled(){\n                        System.out.println(\"[启动器下载模块]下载被取消\"+ task.getURI());\n                    }\n                    @Override\n                    public void retry(Throwable e, int current, int max){\n                        System.out.println(\"[启动器下载模块]正在重试下载:\"+task.getURI());\n                    }\n                };\n            }\n        });\n        mcdownloader.shutdown();\n        System.out.println(\"[启动器下载模块]模块结束，将回到主菜单\");\n    }\n    public void downloadMinecraftUseBMCLAPI(String version) {\n        MinecraftDirectory dir = new MinecraftDirectory(\".minecraft\");\n        MinecraftDownloader mcdownloader = MinecraftDownloaderBuilder\n                .create()\n                .setBaseProvider(new BmclAPIProvider())\n                .build();\n        mcdownloader.downloadIncrementally(dir, version, new CallbackAdapter<Version>(){\n            @Override\n            public void done(Version result){\n                System.out.println(\"[启动器下载模块]下载完毕\");\n            }\n            @Override\n            public void failed(Throwable e){\n                System.out.println(\"[启动器下载模块]下载失败，下列为错误信息\");\n                e.printStackTrace();\n            }\n            @Override\n            public void cancelled(){\n                System.out.println(\"[启动器下载模块]下载被取消\");\n            }\n            @Override\n            public <R> DownloadCallback<R> taskStart(DownloadTask<R> task){\n                System.out.println(\"[启动器下载模块]正在下载：\"+ task.getURI());\n                return new CallbackAdapter<R>(){\n                    @Override\n                    public void done(R result){\n                        System.out.println(\"[启动器下载模块]子任务下载完成\" + task.getURI());\n                    }\n                    @Override\n                    public void failed(Throwable e){\n                        System.out.println(\"[启动器下载模块]下载失败。错误信息为\"+ task.getURI()+ e);\n                    }\n                    @Override\n                    public void cancelled(){\n                        System.out.println(\"[启动器下载模块]下载被取消\"+ task.getURI());\n                    }\n                    @Override\n                    public void retry(Throwable e, int current, int max){\n                        System.out.println(\"[启动器下载模块]正在重试下载:\"+task.getURI());\n                    }\n                };\n            }\n        });\n        mcdownloader.shutdown();\n        System.out.println(\"[启动器下载模块]模块结束，将回到主菜单\");\n    }\n}\n\n复制代码\n\n\n\n2.麻烦告诉一下在什么情况下下载取消\n\n如neng"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1471699080,
            "txt_content": "jinyigeng 发表于 2016-8-20 19:53\n楼主你好，提几个问题，谢谢1.为什么下载Minecraft总是被取消？\n下面是源代码\nMain.java\ndownloadIncrementally是异步操作，调用后立即返回。你调用downloadIncrementally()之后就去shutdown()，会导致任务还没下载完就把downloader关了。\n\n正确做法是写callback里"
        },
        {
            "author": "1241892914",
            "timestamp": 1474544460,
            "txt_content": "启动原版可以启动 但是启动forge版本的话就一点反应也没有   "
        },
        {
            "author": "1241892914",
            "timestamp": 1474546320,
            "txt_content": "输入这个的时候\n                                option.setExtraJvmArguments(Arrays.asList(\n                                ExtraArgumentsTemplates.FML_IGNORE_INVALID_MINECRAFT_CERTIFICATES,\n                                ExtraArgumentsTemplates.FML_IGNORE_PATCH_DISCREPANCISE));\n\n\nsetExtraJvmArguments会报错   提示是The method setExtraJvmArguments(Arrays.asList(ExtraArgumentsTemplates.FML_IGNORE_INVALID_MINECRAFT_CERTIFICATES, ExtraArgumentsTemplates.FML_IGNORE_PATCH_DISCREPANCISE)) is undefined for the type LaunchOption\n\n\n怎么解决"
        },
        {
            "author": "qlaall",
            "timestamp": 1484037360,
            "txt_content": "mark一下  不记得之前又没有找到过了"
        },
        {
            "author": "zc2202",
            "timestamp": 1484200740,
            "txt_content": "我第二步就懵逼了完全不懂，能教一下吗？"
        },
        {
            "author": "122474363",
            "timestamp": 1494157800,
            "txt_content": "现在用JMCCC启动1.11.2没有声音"
        },
        {
            "author": "122474363",
            "timestamp": 1494160980,
            "txt_content": "发现了几个问题，\n第一 是1.11.2启动后有时候有声音 有时候没有声音的问题。-无法解决\n第二 是无法启动目录中带有中文的问题。-我已解决"
        },
        {
            "author": "yushijinhun",
            "timestamp": 1494342540,
            "txt_content": "122474363 发表于 2017-5-7 20:43\n发现了几个问题，\n第一 是1.11.2启动后有时候有声音 有时候没有声音的问题。-无法解决\n第二 是无法启动目录 ...\n你确定启动minecraft的时候，assets都下载全了吗？我这边没出现过这样的问题"
        },
        {
            "author": "122474363",
            "timestamp": 1494420180,
            "txt_content": "yushijinhun 发表于 2017-5-9 23:09\n你确定启动minecraft的时候，assets都下载全了吗？我这边没出现过这样的问题 ...\n当然是下载完了的 亲哥。"
        },
        {
            "author": "ーのものー",
            "timestamp": 1502345400,
            "txt_content": "如果可以的话，能否在『12. 使用自定义的 Yggdrasil API 提供商』章节中加上我这篇文章的链接呢？\n\n『又是一种 Minecraft 外置登录解决方案：自行实现 Yggdrasil API』\n\nhttps://blessing.studio/minecraf ... rty-implementation/"
        },
        {
            "author": "yy1426489531",
            "timestamp": 1502446140,
            "txt_content": "6666顶顶顶"
        },
        {
            "author": "Godpower",
            "timestamp": 1502594460,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "Viosin",
            "timestamp": 1527135000,
            "txt_content": "无法启动mc1.12.2......"
        },
        {
            "author": "wrf_PC",
            "timestamp": 1528982280,
            "txt_content": "Viosin 发表于 2018-5-24 12:10\n无法启动mc1.12.2......\n同。。。"
        },
        {
            "author": "南柯郡守",
            "timestamp": 1532667060,
            "txt_content": " 本帖最后由 969756790 于 2018-7-29 20:02 编辑 \n\n您好，我在编写过程中出现了如下问题\n\n游戏启动后 会出现游戏窗口\n但启动到一半就闪退\n\n控制台输出如下[12:49:14] [Client thread/INFO]: Setting user: username\n[12:49:15] [Client thread/WARN]: Skipping bad option: lastServer:\n[12:49:15] [Client thread/INFO]: LWJGL Version: 2.9.4\n[12:49:18] [Client thread/INFO]: Reloading ResourceManager: Default\n[12:49:19] [Sound Library Loader/INFO]: Starting up SoundSystem...\n[12:49:19] [Thread-3/INFO]: Initializing LWJGL OpenAL\n[12:49:19] [Thread-3/INFO]: (The LWJGL binding of OpenAL.  For more information, see http://www.lwjgl.org)\n[12:49:19] [Thread-3/INFO]: OpenAL initialized.\n[12:49:19] [Sound Library Loader/INFO]: Sound engine started\n[12:49:25] [Client thread/INFO]: Created: 1024x512 textures-atlas\n---- Minecraft Crash Report ----\n// Daisy, daisy...\n\nTime: 7/27/18 12:49 PM\nDescription: Initializing game\n\njava.lang.NoClassDefFoundError: com/mojang/text2speech/Narrator\n        at biv.<init>(SourceFile:15)\n        at biv.<clinit>(SourceFile:14)\n        at biq.<init>(SourceFile:127)\n        at bib.aq(SourceFile:557)\n        at bib.a(SourceFile:404)\n        at net.minecraft.client.main.Main.main(SourceFile:123)\nCaused by: java.lang.ClassNotFoundException: com.mojang.text2speech.Narrator\n        at java.net.URLClassLoader.findClass(Unknown Source)\n        at java.lang.ClassLoader.loadClass(Unknown Source)\n        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)\n        at java.lang.ClassLoader.loadClass(Unknown Source)\n        ... 6 more\n\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n---------------------------------------------------------------------------------------\n\n-- Head --\nThread: Client thread\nStacktrace:\n        at biv.<init>(SourceFile:15)\n        at biv.<clinit>(SourceFile:14)\n        at biq.<init>(SourceFile:127)\n        at bib.aq(SourceFile:557)\n\n-- Initialization --\nDetails:\nStacktrace:\n        at bib.a(SourceFile:404)\n        at net.minecraft.client.main.Main.main(SourceFile:123)\n\n-- System Details --\nDetails:\n        Minecraft Version: 1.12.2\n        Operating System: Windows 10 (amd64) version 10.0\n        Java Version: 1.8.0_181, Oracle Corporation\n        Java VM Version: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle Corporation\n        Memory: 110166544 bytes (105 MB) / 395313152 bytes (377 MB) up to 954728448 bytes (910 MB)\n        JVM Flags: 1 total; -Xmx1024M\n        IntCache: cache: 0, tcache: 0, allocated: 0, tallocated: 0\n        Launched Version: 1.12.2\n        LWJGL: 2.9.4\n        OpenGL: GeForce 940MX/PCIe/SSE2 GL version 4.5.0 NVIDIA 382.05, NVIDIA Corporation\n        GL Caps: Using GL 1.3 multitexturing.\nUsing GL 1.3 texture combiners.\nUsing framebuffer objects because OpenGL 3.0 is supported and separate blending is supported.\nShaders are available because OpenGL 2.1 is supported.\nVBOs are available because OpenGL 1.5 is supported.\n\n        Using VBOs: Yes\n        Is Modded: Probably not. Jar signature remains and client brand is untouched.\n        Type: Client (map_client.txt)\n        Resource Packs: \n        Current Language: 简体中文 (中国)\n        Profiler Position: N/A (disabled)\n        CPU: 4x Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz\n#@!@# Game crashed! Crash report saved to: #@!@# C:\\Users\\<span style='display: inline !important; float: none; background-color: transparent; color: rgb(68, 68, 68); font-family: Tahoma,\"Microsoft Yahei\",\"Simsun\"; font-size: 14px; font-style: normal; font-variant: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: left; text-decoration: none; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: normal; word-spacing: 0px; word-wrap: break-word;'>{中文内容}</span>\\Desktop\\3D\\.minecraft\\crash-reports\\crash-2018-07-27_12.49.27-client.txt\nAL lib: (EE) alc_cleanup: 1 device not closed\n游戏进程退出，状态码：-1\n复制代码启动类源码如下<div>public class GameLauncher {\n\n    public static void main(String[] args) throws Exception {\n            MinecraftDirectory dir = new MinecraftDirectory(\"C:\\\\Users\\\\{中文内容}\\\\Desktop\\\\3D\\\\.minecraft\");</div><div>            LaunchOption option = new LaunchOption(\"1.12.2\", new OfflineAuthenticator(\"username\"), dir); // (3)\n            Launcher launcher = LauncherBuilder.buildDefault();\n            option.setExtraJvmArguments(Arrays.asList(ExtraArgumentsTemplates.FML_IGNORE_INVALID_MINECRAFT_CERTIFICATES,ExtraArgumentsTemplates.FML_IGNORE_PATCH_DISCREPANCISE));\n            launcher.launch(option, new GameProcessListener() {\n\n            @Override\n            public void onLog(String log) {\n                System.out.println(log); // 输出日志到控制台\n            }\n\n            @Override\n            public void onErrorLog(String log) {\n                System.err.println(log); // 输出日志到控制台（同上）\n            }\n\n            @Override\n            public void onExit(int code) {\n                System.err.println(\"游戏进程退出，状态码：\" + code); // 游戏结束时输出状态码\n            }\n        });\n}</div>复制代码希望能给予解决方案，谢谢！\n\n\n"
        },
        {
            "author": "@TGL",
            "timestamp": 1550721240,
            "txt_content": " 本帖最后由 @TGL 于 2019-2-21 12:52 编辑 \n\n怎么启动forge，原版的可以启动成功\nException in thread \"main\" java.lang.ClassCastException: java.base/jdk.internal.loader.ClassLoaders$AppClassLoader cannot be cast to java.base/java.net.URLClassLoader\n        at net.minecraft.launchwrapper.Launch.<init>(Launch.java:34)\n        at net.minecraft.launchwrapper.Launch.main(Launch.java:28)\n游戏进程退出，状态码：1\n"
        },
        {
            "author": "ReinEchoes",
            "timestamp": 1553517180,
            "txt_content": "你好.我1.8.8版本能正常启动,1.12.2版本无法启动,也没有报错,请问这个情况怎么处理"
        },
        {
            "author": "MinecraftJasmi",
            "timestamp": 1554528660,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "tianxiaochengzi",
            "timestamp": 1555734480,
            "txt_content": "发生的fgsft"
        },
        {
            "author": "tianxiaochengzi",
            "timestamp": 1555734480,
            "txt_content": "呃呃呃具体已于噢谷uykiuhkhkjhllklk"
        },
        {
            "author": "ReinEchoes",
            "timestamp": 1563475320,
            "txt_content": "你好,JMCCC2.5beta版本添加自定义Yggdrasil API出现了问题,有一些类发生了改变,能不请教一下2.5版本如何添加Yggdrasil API"
        },
        {
            "author": "sulinly",
            "timestamp": 1564681740,
            "txt_content": "非常有用 谢谢"
        },
        {
            "author": "sulinly",
            "timestamp": 1565257800,
            "txt_content": "1.9能运行 1.13.2不能运行 咋办呢？"
        },
        {
            "author": "gooding300",
            "timestamp": 1565284620,
            "txt_content": "sulinly 发表于 2019-8-8 17:50\n1.9能运行 1.13.2不能运行 咋办呢？\nhttps://github.com/to2mbn/JMCCC/issues/30"
        },
        {
            "author": "sulinly",
            "timestamp": 1565321340,
            "txt_content": "gooding300 发表于 2019-8-9 01:17\nhttps://github.com/to2mbn/JMCCC/issues/30\n谢谢！这个好像没法直接gradle依赖？只有下源码？"
        },
        {
            "author": "gooding300",
            "timestamp": 1565334840,
            "txt_content": "sulinly 发表于 2019-8-9 11:29\n谢谢！这个好像没法直接gradle依赖？只有下源码？\n那个url是maven化的，加一个repo就行"
        },
        {
            "author": "还房贷好",
            "timestamp": 1565355960,
            "txt_content": "我太懒啦！"
        },
        {
            "author": "翔梦FD",
            "timestamp": 1567118880,
            "txt_content": "请问在哪能得到tukaani xz，百度木有啊"
        },
        {
            "author": "翔梦FD",
            "timestamp": 1567133220,
            "txt_content": "这个大佬又是什么神仙，这个实在是太厉害了！"
        },
        {
            "author": "sulinly",
            "timestamp": 1578031320,
            "txt_content": "没找到appendProvider方法呢？\n\n\n\n\n\n**图片_20200103135732.png\n(45.72 KB, 下载次数: 1)\n\n\n\n\n下载附件\n\n\n2020-1-3 13:59 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**图片_20200103140208.png\n(12.76 KB, 下载次数: 1)\n\n\n\n\n下载附件\n\n\n2020-1-3 14:02 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "author": "sulinly",
            "timestamp": 1578031680,
            "txt_content": "报错的，截图不对，重新截了个：\n\n\n\n\n\n\nqqq.png\n(13.01 KB, 下载次数: 0)\n\n\n\n\n下载附件\n\n\n2020-1-3 14:08 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "author": "翔梦FD",
            "timestamp": 1578709080,
            "txt_content": "能启动游戏,但是为什么启动完之后过一会游戏就自动退出了啊???"
        },
        {
            "author": "史丹安",
            "timestamp": 1578754260,
            "txt_content": "看起来很不错"
        },
        {
            "author": "Mo_xiaoxi",
            "timestamp": 1581772800,
            "txt_content": "666感谢大佬分享"
        },
        {
            "author": "Eerobrine_tan",
            "timestamp": 1584761100,
            "txt_content": "无法使用jmccc-yggdrasil-authenticator-2.5beta1与jmccc -2.5 -SNAPS配套，哪位大佬发一下配套的jmccc-yggdrasil-authenticator"
        },
        {
            "author": "忘了我是谁",
            "timestamp": 1586688600,
            "txt_content": "水回复***************"
        },
        {
            "author": "成品油",
            "timestamp": 1588506480,
            "txt_content": "不服不行！"
        },
        {
            "author": "liangcha2009",
            "timestamp": 1592098920,
            "txt_content": "懒癌患者表示不愿意写代码"
        },
        {
            "author": "德芙DakFu",
            "timestamp": 1597320180,
            "txt_content": "学习ing，谢谢指教噢"
        },
        {
            "author": "德芙DakFu",
            "timestamp": 1597320240,
            "txt_content": "感觉真的会很难啊"
        }
    ]
}