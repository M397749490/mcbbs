{
    "title": "[搬运+翻译][从零学编程]C++Ⅳ：函数",
    "author": "45gfg9",
    "replyCount": 2,
    "timestamp": 1584941040,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-26 22:21 编辑 \n\n\n索引贴\n答案帖\nPrev: C++Ⅲ：数据类型，数组，指针\nNext: C++Ⅴ：类与对象\n\n\n1 函数介绍\n\n1.1 函数（一）\n\n一个[ruby=function]函数[/ruby]是一套用于执行某个任务的语句集合。\n在C++中你可以定义自己的函数。\n\n使用函数会有许多优势，包括下面列举的：\n可以在函数内复用代码。可以容易地测试单独的函数。如果需要修改代码，可以只在某个函数中修改，而不用改变项目结构。可以对不同的输入使用同一函数。\n\n每个有效C++程序都包括至少一个函数——main()函数。\nPart题：\n每个C++程序都以什么函数开始？\nA. int()\nB. main\nC. #include\nD. my_function\n\n1.2 返回类型\n\nmain函数有如下的一般形式：\nint main()\n{\n  // 一些代码\n  return 0;\n}\n一个函数的[ruby=return type]返回类型[/ruby]在函数名前声明。上例中，返回类型是int，表示函数返回一个整型值。\n有时，函数在完成操作后不会返回值。这样的函数用void关键字定义。\nvoid是用来规定无值状态的基本数据类型。\nPart题：\n若一个函数没有返回值，我们该用什么关键字？\n\n1.3 定义函数（一）\n\n**函数的定义遵循下面的语法：\n返回类型 函数名( 形参列表 )\n{\n   函数体\n}\n返回类型：函数返回值的数据类型。\n函数名：函数的名称。\n[ruby=parameters]参数[/ruby]：当函数被调用时，你将值作为参数。这个值被叫做实际参数或实参。形参列表表明了一个函数的参数类型、顺序和数量。\n函数体：一套定义函数行为的语句。\n参数是可选的；意味着你可以创建没有参数的函数。\nPart题：\n一个C++函数的组成部分有：\nA. 只要返回类型\nB. 无函数体的名字\nC. 返回类型，函数名，形参，函数体\n\n1.4 定义函数（二）\n\n作为一个示例，我们来定义一个不返回值的函数，它只向屏幕输出一行文字：\nvoid printSomething() \n{\n  cout << \"Hi there!\";\n}\n我们的叫做printSomething的函数，返回void，且没有参数。\n现在，我们可以在main()中使用我们的函数了。\nint main() \n{\n   printSomething();\n\n   return 0;\n}\n要[ruby=call]调用[/ruby]一个函数，你只需函数名和所需参数。\nPart题：\n填空创建一个名为my_func，返回void，输出\"I am a function\"的函数。\n____ my_func()\n{\n  ____ << \"I am a function\" << endl;\n}\n\n\n1.5 函数（二）\n\n在调用函数前，必须先声明它。\n举例：\n#include <iostream>\nusing namespace std;\n\nvoid printSomething() {\n  cout << \"Hi there!\";\n}\n\nint main() {\n  printSomething();\n\n  return 0;\n}\n将声明放在main()函数之后会导致错误。\nPart题：\n一个函数必须在____声明。\nA. 调用之前\nB. 调用之后\n\n1.6 函数（三）\n\n一个函数的[ruby=declaration]声明[/ruby]，或称作[ruby=function prototype]函数原型[/ruby]，告诉编译器函数名和如何调用函数。实际的函数可以分开定义。\n举例\n#include <iostream>\nusing namespace std;\n\n//函数声明\nvoid printSomething();\n\nint main() {\n  printSomething();\n\n  return 0;\n}\n\n//函数定义\nvoid printSomething() {\n  cout << \"Hi there!\";\n}\n当你在一个源文件定义函数，在另一个源文件调用函数时，声明是必要的。这种情况下，你应在调用函数前声明函数。\nPart题：\n填空输出\"it works!\"到屏幕，在调用前先写上函数原型。\nvoid _________ ();\nint main()\n{\n  some_func();\n  return 0;\n}\n____ some_func() {\n  cout << \"it works!\" << endl;\n}\n\n\n\n2 函数参数\n\n2.1 函数参数（一）\n\n要让函数使用[ruby=arguments]实参[/ruby]，它必须先声明[ruby=parameters]形参[/ruby]，其为接受实参值的变量。\n\n举例：\nvoid printSomething(int x) \n{\n   cout << x;\n}\n这会定义一个接受一个整型参数并输出其值的函数。\n在函数内，形参与其他局部变量表现类似。它们在进入函数时创建，在离开函数时销毁。\nPart题：\n填空声明一个函数printValue()，接受一个参数名为x并输出其值。\nvoid printValue(int _ )\n{\n  cout << _ << endl;\n}\n\n\n2.2 函数参数（二）\n\n当函数被定义后，在调用函数时可以传递对应的实参。\n例：\n#include <iostream>\nusing namespace std;\n\nvoid printSomething(int x) {\n  cout << x;\n}\n\nint main() {\n  printSomething(42);\n}\n\n// 输出 42\n值42作为实参传递给函数，赋给函数的形参：x。\n对形参做出的修改不会影响实参。\nPart题：\n填空定义一个函数printValue，有一个类型为int的参数，并在main中将20作为参数传递给它。\nvoid printValue( ___ x) {\n  cout << x << endl;\n}\nint main()\n{\n  printVaue( __ );\n  return 0;\n}\n\n\n2.3 函数参数（三）\n\n你可以将不同的实参传递给同一个函数。\n举例：\nint timesTwo(int x) {\n   return x*2;\n}\n上面定义的函数以一个整型作为参数并返回其值乘2。\n\n接着我们可以用不同的参数调用函数了。\nint main() {\n  cout << timesTwo(8);\n  // 输出 16\n\n  cout <<timesTwo(5);\n  // 输出 10\n\n  cout <<timesTwo(42);\n  // 输出 84\n}\n\nPart题：\n在main中调用printValue函数三次，将值4、5、6传给它。\nint main()\n{\n  printValue( _ );\n  printValue( _ );\n  printValue( _ );\n  return 0;\n}\n\n\n\n3 多参函数\n\n3.1 多个形参（一）\n\n你可以定义你的函数需要的任意多参数，只需将参数以逗号分隔。\n\n这是一个简单的返回两数之和的函数。\nint addNumbers(int x, int y) {\n // 这里写代码\n}\n正如定义，addNumbers函数需要两个int参数，返回int。\n每个形参的数据类型和名称都要标明。\nPart题：\n填空定义一个函数hello，接受两个参数返回int。\n___ hello(int a _ int b)\n{\n  // 代码...\n}\n\n\n3.2 多个形参（二）\n\n接着我们计算两个参数的和并返回结果。\nint addNumbers(int x, int y) {\n  int result = x + y;\n  return result;\n}\n\nPart题：\n补全addNumbers函数，接受两个整型变量x和y并返回其和。和存储在answer变量中。\nint addNumbers(int x, ___ y)\n{\n  int answer = _ + y;\n  return ______;\n}\n\n\n3.3 多个形参（三）\n\n现在我们能调用了。\nint addNumbers(int x, int y) {\n  int result = x + y;\n  return result;\n}\n\nint main() {\n  cout << addNumbers(50, 25);\n  // 输出 75\n}\n你也可以将返回值赋给一个变量。\nint main() {\n  int x = addNumbers(35, 7);\n  cout << x;\n  // 输出 42\n}\n\nPart题：\n填空在main中调用addNumbers函数，参数是43和86。返回值存储在变量result中，并用cout输出到屏幕。\nint addNumbers(int x, int y) {\n  return x + _ ;\n}\nint main()\n{\n  int result = addNumbers(43, __ );\n  cout << ______ << endl;\n  return 0;\n}\n\n\n3.4 多个形参（四）\n\n一个函数可以有任意多个参数。\n例：\nint addNumbers(int x, int y, int z, int a) {\n  int result = x + y + z + a;\n  return result;\n}\n如果有多个形参，记住用逗号分隔，在声明时和传参时都要。\nPart题：\n一个函数能有多少参数？\nA. 一个\nB. 一或二\nC. 任意\n\n\n4 rand()函数\n\n4.1 随机数（一）\n\n在很多情况下，能生成[ruby=random]随机[/ruby]数是很有用的，包括创建游戏、统计模型程序、以及类似。\n\nC++标准库中，你能用到一个[ruby=pseudo]伪[/ruby]随机数生成器函数，叫做rand()。使用时，需要包含头文件<cstdlib>。\n#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nint main() {\n  cout << rand();\n}\n这会输出一个随机数。\nPart题：\n使用rand()函数需要哪个头文件？\nA. cstdlib\nB. clibstd\nC. crandhead\nD. iostream\n\n4.2 随机数（二）\n\n可以用for循环生成多个随机数。\nint main() {\n  for (int x = 1; x <= 10; x++) {\n    cout << rand() << endl;\n  }\n}\n\n/* 输出：\n41\n18467\n6334\n26500\n19169\n15724\n11478\n29358\n26962\n24464\n*/\n\nPart题：\n填空在for循环中调用rand()函数并输出其返回值13次。\n___ (int x = 0; x < 13; x++) {\n  cout << ____ () << endl;\n}\n\n\n4.3 随机数（三）\n\n用取模 (%) 运算符生成某个范围内的随机数。\n下面的例子生成1-6范围内的整数。\nint main () {\n  for (int x = 1; x <= 10; x++) {\n  cout << 1 + (rand() % 6) << endl;\n  }\n}\n\n/* 输出：\n6\n6\n5\n5\n6\n5\n1\n1\n5\n3\n*/\n然而，rand()函数只会返回伪随机数。这意味着每次代码运行时，它都会产生相同的数。\nPart题：\n填空输出1-9范围内的随机数。\ncout << 1 + (rand() _ 9) << endl;\n\n\n4.4 srand()函数\n\nsrand()函数用于生成[ruby=truly]真[/ruby]随机数。\n这个函数允许用其参数作为种子值，用于rand()函数的算法。\nint main () {\n  srand(98);\n\n  for (int x = 1; x <= 10; x++) {\n    cout << 1 + (rand() % 6) << endl;\n  }\n}\n改变种子值会改变rand()函数的输出。然而，相同的参数会有相同的输出。\nPart题：\nsrand()函数的作用是？\nA. 无\nB. 帮助生成真随机数\nC. 返回其参数之和\n\n4.5 真随机数\n\n一种生成真随机数的方法是使用当前时间作为srand()函数的种子。\n下面的例子利用time()函数获取你系统的当前秒数，并作为rand()种子（为此需要包含<ctime>头文件）：\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nint main () {\n  srand(time(0));\n\n  for (int x = 1; x <= 10; x++) {\n    cout << 1 + (rand() % 6) << endl;\n  }\n}\ntime(0)返回当前秒数，每次运行程序时使srand()函数为rand()函数设置不同的种子。\n使用种子会让程序每次运行都有不同输出。\nPart题：\n填空输出rand()函数生成的1-15范围内的真随机数。\n_____(time(0));\ncout << 1 + (rand() % __ ) << endl;\n\n\n\n5 默认参数\n\n5.1 形参默认值\n\n定义函数时，你可以对后面的形参指定默认值。如果调用时没有对应的实参，它会使用默认值。\n\n要这样做，用赋值运算符给函数定义中的参数赋值，如下例。\nint sum(int a, int b=42) {\n  int result = a + b;\n  return (result);\n}\n这会给形参b赋默认值42。如果调用时不给b传实参，就会使用默认值。\nint main() {\n  int x = 24;\n  int y = 36;\n\n  //两个参数调用\n  int result = sum(x, y);\n  cout << result << endl;\n  //输出 60\n\n  //没有b的调用\n  result = sum(x);\n  cout <<  result << endl;\n   //输出 66\n\n  return 0;\n}\n对函数第二次调用没有给第二个参数传值，则使用默认值42。\nPart题：\n填空给函数volume的参数赋默认值，假设a默认值2，b默认值3，c默认值5。\nint volume(int a = _ , int b _ 3, int c = 5)\n{\n  return a * b * c;\n}\n\n\n5.2 使用默认值\n\n再来一个例子：\nint volume(int l=1, int w=1, int h=1) {\n  return l*w*h;\n}\n\nint main() {\n  cout << volume() << endl;\n  cout << volume(5) << endl;\n  cout << volume(2, 3) << endl;\n  cout << volume(3, 7, 6) << endl;\n}\n\n/* 输出\n1\n5\n6\n126\n*/\n如你所见，默认参数值能用于在不同情况下调用同一参数，当一个或更多个参数没有用到时。\nPart题：\n下面代码的输出是？\nvoid printSum(int a, int b = 4)\n{\n  cout << a + b << endl;\n}\nint main()\n{\n  printSum(13);\n}\n\n\n\n6 函数重载\n\n6.1 重载\n\n函数的[ruby=overloading]重载[/ruby]允许创建多个同名函数，只要它们的参数不同。\n\n举例，你也许需要一个printNumber()函数输出其参数值。\nvoid printNumber(int a) { \n  cout << a;\n}\n但这只对整型有效。重载它能使它对其他类型，例如浮点数，也有效。\nvoid printNumber(float a) { \n  cout << a;\n}\n现在，相同名称的printNumber()函数对整型和浮点数都有效了。\nPart题：\n填空声明函数printNumber并重载它。声明一个printNumber接受一个整型参数；另一个printNumber接受一个浮点数参数。\nvoid printNumber( ___ x) {\n  cout << \"integer is \" << x << endl;\n}\nvoid printNumber( _____ x) {\n  cout << \"float is \" << x << endl;\n}\n\n\n6.2 函数重载（一）\n\n当重载函数时，不同函数的形参类型和/或形参数量必须不同。\n例：\nvoid printNumber(int x) {\n    cout << \"Prints an integer: \" << x << endl;\n}\nvoid printNumber(float x) {\n    cout << \"Prints a float: \" << x << endl;\n}\nint main() {\n  int a = 16;\n  float b = 54.541;\n  printNumber(a);\n  printNumber(b);\n}\n\n/* 输出：\nPrints an integer: 16\nPrints a float: 54.541\n*/\n如你所见，调用时不同函数的区别与提供的实参有关。一个整型实参会解释为调用接受整型形参的函数。一个浮点数实参会调用接受浮点数形参的函数。\nPart题：\n两个同名函数什么时候叫做重载？\nA. 有不同的名字\nB. 有不同的参数类型或数量\nC. 有不同的函数体体积\n\n6.3 函数重载（二）\n\n你不能仅通过返回类型不同而重载函数。\n下面的声明会导致错误。\nint printName(int a) { }\nfloat printName(int b) { }\ndouble printName(int c) { }\n尽管几个函数同名，但彼此的区别只有返回类型不同，是不允许的。\nPart题：\n填空重载函数sum，其接受两个数字参数并输出两数之和。对整型和浮点数重载sum函数。\nvoid sum(int a, ___ b) {\n  cout << a + b << endl;\n}\nvoid sum( _____ a, float b) {\n  cout << a + _ << endl;\n}\n\n\n\n7 递归\n\n7.1 递归（一）\n\nC++中的[ruby=recursive]递归[/ruby]函数指调用自己的函数。\n为防止递归无限运行下去，你必须写上中止条件。\nPart题：\n递归的思想是：\nA. 调用自己的函数\nB. 调用main的函数\nC. 声明两个变量的函数\n\n7.2 递归（二）\n\n要演示递归，我们来创建一个计算数字阶乘的程序。\n数学中，“阶乘”的意思是所有小于等于给定非负整数(n)的正整数的乘积。\n[ruby=Recursion is a method of solving a problem where the solution depends on the solutions to smaller instances of the same problem.]递归是一种解决某种解决方案依靠更小问题的解决方案的问题的方法。[/ruby]\nPart题：\n5的阶乘是什么？\nA. 5! 等于 5\nB. 5! 等于 0\nC. 5! 等于 5*4*3*2*1\n\n7.3 递归（三）\n\n来写代码吧：\nint factorial(int n) {\n  if (n==1) {\n    return 1;\n  }\n  else {\n    return n * factorial(n-1);\n  }\n}\nif语句定义了退出条件。本例中，当n等于一时，返回1（1! = 1）。\n我们将递归调用部分放在else语句中，返回n乘n-1的阶乘。\n举例，如果你用参数4调用factorial函数，会按照如下执行：\n返回4 * factorial(3)，即4 * 3 * factorial(2)，即4 * 3 * 2 * factorial(1)，即4 * 3 * 2 * 1。\nfactorial函数一直调用自身，直到参数等于1。\nPart题：\n填空定义一个递归函数，计算参数的阶乘。\nint fact(int x) {\n  if (x == 1) {\n    ______ 1;\n  } else {\n    return x * ____ (x - 1);\n  }\n}\n\n\n7.4 递归（四）\n\n现在我们可以调用factorial函数了。\nint factorial(int n) {\n  if (n==1) {\n    return 1;\n  }\n  else {\n    return n * factorial(n-1);\n  }\n}\nint main() {\n  cout << factorial(5);\n}\n\n//输出 120\n退出条件的另一个叫法是[ruby=base case]基本情况[/ruby]。\n记住对于真正的递归来说，基本情况是必要的。如果没有，递归会永远运行下去。\nPart题：\n一个真正的递归函数应有：\nA. 返回值\nB. 基本情况\nC. 空函数体\n\n\n8 函数传数组为参\n\n8.1 数组与函数（一）\n\n数组也可以作为实参传递给函数。\n声明函数时，形参应该用方括号定义为数组。\n例：\nvoid printArray(int arr[], int size) {\n  for(int x=0; x<size; x++) {\n    cout <<arr[x];\n  }\n}\n填空声明一个函数printArray，接受两个参数。第一个是一个整型数组，第二个是int类型的数组大小。\nvoid printArray(int arr __ , ___ size);\n\n\n8.2 数组与函数（二）\n\n我们可以在main()中使用我们的函数了，用一个示例数组：\nvoid printArray(int arr[], int size) {\n  for(int x=0; x<size; x++) {\n    cout <<arr[x]<< endl;\n  }\n}\nint main() {\n  int myArr[3]= {42, 33, 88};\n  printArray(myArr, 3);\n}\nprintArray函数接受数组为形参 (int arr[])，并用for循环迭代数组。\n我们在main()中调用函数，将myArr数组传递给函数，输出其元素。\n记住在将数组作为实参传递的时候不需要方括号。\nPart题：\n假设你有一个函数printArray，接受一个数组和其大小，并输出其元素。请补全代码，将一个叫做my_arr的数组传给函数。\nprintArray( ______ , 3); // 调用printArray\n\n\n\n9 通过指针引用传参\n\n9.1 函数实参\n\n调用函数时，有两种传值的方式。\n\n[ruby=value]值[/ruby]传参：此方法将实参的值复制给函数的形参。在函数内对形参的修改不会影响实参。\n\n[ruby=reference]引用[/ruby]传参：此方法将实参的引用复制给函数的形参。在函数内，引用用于访问实际调用函数的实参。这意味着对形参的修改会影响实参。\nC++默认使用值传参方法。\nPart题：\n两种不同传参方式是什么？\nA. 引用传参和名传参\nB. 引用传参和值传参\nC. 值传参和名传参\n\n9.2 值传参\n\n默认情况下，C++中的实参以值传参。\n当传递值时，实参的一份复制传给函数。\n\n例：\nvoid myFunc(int x) {\n  x = 100;\n}\n\nint main() {\n  int var = 20;\n  myFunc(var);\n  cout << var;\n}\n// 输出 20\n因为传递给函数的是实参的复制，所以原参数不会被函数修改。\nPart题：\n值传参意味着：\nA. 将变量地址作为参数传递\nB. 将变量的复制作为参数传递\nC. 将main函数作为参数传递\n\n9.3 引用传参\n\n引用传参将实参的地址传给函数形参。在函数内，用此地址访问实际的参数。这意味着对形参的修改会影响实参。\n要通过引用传参，将实参指针传递给函数。\nvoid myFunc(int *x) {\n  *x = 100;\n}\n\nint main() {\n  int var = 20;\n  myFunc(&var);\n  cout << var;\n}\n// 输出 100\n如你所见，我们将变量用取地址运算符&直接传给函数。\n函数声明说明了函数接受一个指针为形参（以* 运算符指定）。\n结果，函数通过指针访问，确实改变了实参的值。\nPart题：\n填空将变量arg以值传参方式传给passByValue函数。\nvoid passByValue(int x) {\n  x = 99;\n}\nint main()\n{\n  int arg = 13;\n  passByValue( ___ );\n  return 0;\n}\n\n\n9.4 总结\n\n值传参：此方法将实参的值复制给函数的形参。在函数内对形参的修改不会影响实参。\n\n引用传参：此方法将实参的引用复制给函数的形参。在函数内，引用用于访问实际调用函数的实参。这意味着对形参的修改会影响实参。\n一般来讲，值传递更快，效率更高。当你的函数需要修改实参，或需要传递一种占用大量内存且复制开销大的数据结构时引用传参。\nPart题：\n以引用作为形参的函数：\nA. 只接收到实参的复制\nB. 可以修改传给它的变量\nC. 是一个递归函数\n\n\n模块检测\n\n1. C++程序总是以哪个函数开始运行？\n\n2. 填空声明函数printIt，输出\"I love C++\"到屏幕。在main中调用printIt。\nvoid printIt()\n{\n  cout << \"I love C++\" << endl;\n}\n___ main()\n{\n  printIt __ ;\n  return 0;\n}\n\n3. 补全函数的形参类型，使其接受一个整型值并输出。\nvoid myFunction( ___ x)\n{\n  cout << x << endl;\n}\n\n4. 填空声明函数sum，接受三个双精度浮点值为参数并输出其和。在main中声明三个变量a，b和c并传递给sum函数。\ndouble sum(double x, ______ y, double z)\n{\n  return x + y + _;\n}\nint main()\n{\n  double a = 1.2;\n  double b = 2.3;\n  double 3 = 3.4;\n  cout << ___ (a, b, c);\n  return 0;\n}\n\n5. 填空声明函数myFunction，接受两个int形参，默认值分别为1和2，并输出其乘积。\nvoid myFunction(int a = 1, int b _ 2)\n{\n  cout << a _ b << endl;\n}\n\n6. 补全函数calcSum，接受一个数组和其大小为参数。该函数计算数组元素之和并输出。\nvoid calcSum(int arr[], int size)\n{\n  int sum = 0;\n  ___ (int x = 0; x < size; x++)\n  {\n    sum += arr[ _ ];\n  }\n  cout << sum << endl;\n}\n\n",
    "replies": [
        {
            "author": "ei_ming5",
            "timestamp": 1585157880,
            "txt_content": "好像懂了点，好帖"
        },
        {
            "author": "Garyjel",
            "timestamp": 1595771040,
            "txt_content": "原来这里也有交C++的啊，我省赛C++第二(有一题我用错了scanf)"
        }
    ]
}