{
    "title": "如何让我发射出去的火球去除破坏地形和火焰的效果",
    "author": "AK-47火麒麟",
    "replyCount": 15,
    "timestamp": 1403324340,
    "txt_content": "我一开始用的Fireball，发现破坏地形，然后换了smallFireball，但是还是会燃烧，我想让他碰到方块布燃烧但是碰到实体会燃烧，如何实现。\n目前代码：\n public class iron implements Listener\n {\n  @EventHandler\n  public void onRightClickFireBall(PlayerInteractEvent e)\n  {\n    try {\n      if ((e.getAction() == Action.RIGHT_CLICK_AIR) && (e.getPlayer().getItemInHand().getTypeId() == 402))\n      \n         \n          e.getPlayer().getWorld().spawn(e.getPlayer().getEyeLocation().add(e.getPlayer().getEyeLocation().getDirection().multiply(2).getX(), e.getPlayer().getEyeLocation().getDirection().multiply(2).getY(), e.getPlayer().getEyeLocation().getDirection().multiply(2).getZ()), SmallFireball.class);\n          \n          if (e.getPlayer().getItemInHand().getAmount() > 1) \n          {\n            e.getPlayer().setItemInHand(new ItemStack(402, e.getPlayer().getItemInHand().getAmount() - 1));\n          }\n          else\n            e.getPlayer().setItemInHand(null);\n    \n    }\n    catch (NullPointerException localNullPointerException)\n    {\n    }\n  }\n }复制代码\n\n",
    "replies": [
        {
            "author": "NaOcAn.",
            "timestamp": 1403324760,
            "txt_content": "看不懂大神的世界"
        },
        {
            "author": "AK-47火麒麟",
            "timestamp": 1403324940,
            "txt_content": "NaOcAn. 发表于 2014-6-21 12:26\n看不懂大神的世界\n以前就只会pascal，周三开始接触java的。。"
        },
        {
            "author": "AK-47火麒麟",
            "timestamp": 1403324940,
            "txt_content": "NaOcAn. 发表于 2014-6-21 12:26\n看不懂大神的世界\n所以我不是大神，很多都不懂的"
        },
        {
            "author": "AK-47火麒麟",
            "timestamp": 1403325000,
            "txt_content": "avshen 发表于 2014-6-21 12:30\nswalk3\n我去HEROBRINE"
        },
        {
            "author": "cyqsimon",
            "timestamp": 1403325420,
            "txt_content": "虽然不熟悉这些函数，但是我还是看得懂C的，所以也差不多看得懂java\n\n\n\n这一部分看下来，好像只是检测一下是否能发射，并且发射一个普通的火球，再从玩家手里扣除已使用的物品而已，具体决定发射火球种类的应该是这段代码\ne.getPlayer().getWorld().spawn(e.getPlayer().getEyeLocation().add(e.getPlayer().getEyeLocation().getDirection().multiply(2).getX(), e.getPlayer().getEyeLocation().getDirection().multiply(2).getY(), e.getPlayer().getEyeLocation().getDirection().multiply(2).getZ()), SmallFireball.class);\n虽然我不懂具体该怎么弄，但是应该是要给SmallFireball指定某种参数吧\n\n\n但也有可能没有“击中方块是否燃烧”的参数，那估计就需要新建一个新火球的class了。\n\n也就是说，基本复制SmallFireball的代码，去掉击中方块事件中开始燃烧的代码，然后在这里引用自己新建的class。\n\n\n当然，java我不懂，上面仅仅是思路，所以具体怎么弄还看你了"
        },
        {
            "author": "Johnny.R",
            "timestamp": 1403326200,
            "txt_content": " 本帖最后由 Johnny.R 于 2014-6-21 12:53 编辑 \n\n重写火球就比较麻烦了,所以我写插件的时候都是直接导入craftbukkit.jar包然后按照每一个Release版本更新了,你可以试试看其他的监听器，还有Entity包中的SmallFireball只是一个借口,如果要从此处重写不太可能,而原类是混淆过的,而且貌似没有什么接触方块时的动作的方法,这可能要对AABB碰撞盒有一定了解,我反编译研究过，只看懂了一部分"
        },
        {
            "author": "Johnny.R",
            "timestamp": 1403326680,
            "txt_content": "这是EntitySmallFireball的源码:\n而其中只重载了部分Entity类的源码,大部分Entity的源码我就不发了,我也小有研究过\npackage net.minecraft.server.v1_7_R1;\n\nimport org.bukkit.craftbukkit.v1_7_R1.CraftServer;\nimport org.bukkit.craftbukkit.v1_7_R1.event.CraftEventFactory;\nimport org.bukkit.entity.Projectile;\nimport org.bukkit.event.block.BlockIgniteEvent;\nimport org.bukkit.event.entity.EntityCombustByEntityEvent;\nimport org.bukkit.plugin.PluginManager;\n\n// Referenced classes of package net.minecraft.server.v1_7_R1:\n//            EntityFireball, World, MovingObjectPosition, Entity, \n//            DamageSource, Blocks, EntityLiving\n\npublic class EntitySmallFireball extends EntityFireball\n{\n\n    public EntitySmallFireball(World world)\n    {\n        super(world);\n        a(0.3125F, 0.3125F);\n    }\n\n    public EntitySmallFireball(World world, EntityLiving entityliving, double d0, double d1, double d2)\n    {\n        super(world, entityliving, d0, d1, d2);\n        a(0.3125F, 0.3125F);\n    }\n\n    public EntitySmallFireball(World world, double d0, double d1, double d2, \n            double d3, double d4, double d5)\n    {\n        super(world, d0, d1, d2, d3, d4, d5);\n        a(0.3125F, 0.3125F);\n    }\n\n    protected void a(MovingObjectPosition movingobjectposition)\n    {\n        if(!world.isStatic)\n        {\n            if(movingobjectposition.entity != null)\n            {\n                if(!movingobjectposition.entity.isFireproof() && movingobjectposition.entity.damageEntity(DamageSource.fireball(this, shooter), 5F))\n                {\n                    EntityCombustByEntityEvent event = new EntityCombustByEntityEvent((Projectile)getBukkitEntity(), movingobjectposition.entity.getBukkitEntity(), 5);\n                    movingobjectposition.entity.world.getServer().getPluginManager().callEvent(event);\n                    if(!event.isCancelled())\n                        movingobjectposition.entity.setOnFire(event.getDuration());\n                }\n            } else\n            {\n                int i = movingobjectposition.b;\n                int j = movingobjectposition.c;\n                int k = movingobjectposition.d;\n                switch(movingobjectposition.face)\n                {\n                case 0: // '\\0'\n                    j--;\n                    break;\n\n                case 1: // '\\001'\n                    j++;\n                    break;\n\n                case 2: // '\\002'\n                    k--;\n                    break;\n\n                case 3: // '\\003'\n                    k++;\n                    break;\n\n                case 4: // '\\004'\n                    i--;\n                    break;\n\n                case 5: // '\\005'\n                    i++;\n                    break;\n                }\n                if(world.isEmpty(i, j, k) && !CraftEventFactory.callBlockIgniteEvent(world, i, j, k, this).isCancelled())\n                    world.setTypeUpdate(i, j, k, Blocks.FIRE);\n            }\n            die();\n        }\n    }\n\n    public boolean R()\n    {\n        return false;\n    }\n\n    public boolean damageEntity(DamageSource damagesource, float f)\n    {\n        return false;\n    }\n}\n复制代码"
        },
        {
            "author": "NaOcAn.",
            "timestamp": 1403326800,
            "txt_content": "AK-47火麒麟 发表于 2014-6-21 12:29\n所以我不是大神，很多都不懂的\n同感哇= =  "
        },
        {
            "author": "Johnny.R",
            "timestamp": 1403326860,
            "txt_content": "public abstract class EntityFireball extends Entity\n{\n\n    public EntityFireball(World world)\n    {\n        super(world);\n        e = -1;\n        f = -1;\n        g = -1;\n        bukkitYield = 1.0F;\n        isIncendiary = true;\n        a(1.0F, 1.0F);\n    }\n\n    protected void c()\n    {\n    }\n\n    public EntityFireball(World world, double d0, double d1, double d2, \n            double d3, double d4, double d5)\n    {\n        super(world);\n        e = -1;\n        f = -1;\n        g = -1;\n        bukkitYield = 1.0F;\n        isIncendiary = true;\n        a(1.0F, 1.0F);\n        setPositionRotation(d0, d1, d2, yaw, pitch);\n        setPosition(d0, d1, d2);\n        double d6 = MathHelper.sqrt(d3 * d3 + d4 * d4 + d5 * d5);\n        dirX = (d3 / d6) * 0.10000000000000001D;\n        dirY = (d4 / d6) * 0.10000000000000001D;\n        dirZ = (d5 / d6) * 0.10000000000000001D;\n    }\n\n    public EntityFireball(World world, EntityLiving entityliving, double d0, double d1, double d2)\n    {\n        super(world);\n        e = -1;\n        f = -1;\n        g = -1;\n        bukkitYield = 1.0F;\n        isIncendiary = true;\n        shooter = entityliving;\n        a(1.0F, 1.0F);\n        setPositionRotation(entityliving.locX, entityliving.locY, entityliving.locZ, entityliving.yaw, entityliving.pitch);\n        setPosition(locX, locY, locZ);\n        height = 0.0F;\n        motX = motY = motZ = 0.0D;\n        setDirection(d0, d1, d2);\n    }\n\n    public void setDirection(double d0, double d1, double d2)\n    {\n        d0 += random.nextGaussian() * 0.40000000000000002D;\n        d1 += random.nextGaussian() * 0.40000000000000002D;\n        d2 += random.nextGaussian() * 0.40000000000000002D;\n        double d3 = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);\n        dirX = (d0 / d3) * 0.10000000000000001D;\n        dirY = (d1 / d3) * 0.10000000000000001D;\n        dirZ = (d2 / d3) * 0.10000000000000001D;\n    }\n\n    public void h()\n    {\n        if(!world.isStatic && (shooter != null && shooter.dead || !world.isLoaded((int)locX, (int)locY, (int)locZ)))\n        {\n            die();\n        } else\n        {\n            super.h();\n            setOnFire(1);\n            if(this.i)\n            {\n                if(world.getType(e, this.f, g) == h)\n                {\n                    this.j++;\n                    if(this.j == 600)\n                        die();\n                    return;\n                }\n                this.i = false;\n                motX *= random.nextFloat() * 0.2F;\n                motY *= random.nextFloat() * 0.2F;\n                motZ *= random.nextFloat() * 0.2F;\n                this.j = 0;\n                au = 0;\n            } else\n            {\n                au++;\n            }\n            Vec3D vec3d = world.getVec3DPool().create(locX, locY, locZ);\n            Vec3D vec3d1 = world.getVec3DPool().create(locX + motX, locY + motY, locZ + motZ);\n            MovingObjectPosition movingobjectposition = world.a(vec3d, vec3d1);\n            vec3d = world.getVec3DPool().create(locX, locY, locZ);\n            vec3d1 = world.getVec3DPool().create(locX + motX, locY + motY, locZ + motZ);\n            if(movingobjectposition != null)\n                vec3d1 = world.getVec3DPool().create(movingobjectposition.pos.c, movingobjectposition.pos.d, movingobjectposition.pos.e);\n            Entity entity = null;\n            List list = world.getEntities(this, boundingBox.a(motX, motY, motZ).grow(1.0D, 1.0D, 1.0D));\n            double d0 = 0.0D;\n            for(int i = 0; i < list.size(); i++)\n            {\n                Entity entity1 = (Entity)list.get(i);\n                if(!entity1.R() || entity1.h(shooter) && au < 25)\n                    continue;\n                float f = 0.3F;\n                AxisAlignedBB axisalignedbb = entity1.boundingBox.grow(f, f, f);\n                MovingObjectPosition movingobjectposition1 = axisalignedbb.a(vec3d, vec3d1);\n                if(movingobjectposition1 == null)\n                    continue;\n                double d1 = vec3d.distanceSquared(movingobjectposition1.pos);\n                if(d1 < d0 || d0 == 0.0D)\n                {\n                    entity = entity1;\n                    d0 = d1;\n                }\n            }\n\n            if(entity != null)\n                movingobjectposition = new MovingObjectPosition(entity);\n            if(movingobjectposition != null)\n            {\n                a(movingobjectposition);\n                if(dead)\n                    CraftEventFactory.callProjectileHitEvent(this);\n            }\n            locX += motX;\n            locY += motY;\n            locZ += motZ;\n            float f1 = MathHelper.sqrt(motX * motX + motZ * motZ);\n            yaw = (float)((Math.atan2(motZ, motX) * 180D) / 3.1415927410125732D) + 90F;\n            for(pitch = (float)((Math.atan2(f1, motY) * 180D) / 3.1415927410125732D) - 90F; pitch - lastPitch < -180F; lastPitch -= 360F);\n            for(; pitch - lastPitch >= 180F; lastPitch += 360F);\n            for(; yaw - lastYaw < -180F; lastYaw -= 360F);\n            for(; yaw - lastYaw >= 180F; lastYaw += 360F);\n            pitch = lastPitch + (pitch - lastPitch) * 0.2F;\n            yaw = lastYaw + (yaw - lastYaw) * 0.2F;\n            float f2 = e();\n            if(M())\n            {\n                for(int j = 0; j < 4; j++)\n                {\n                    float f3 = 0.25F;\n                    world.addParticle(\"bubble\", locX - motX * (double)f3, locY - motY * (double)f3, locZ - motZ * (double)f3, motX, motY, motZ);\n                }\n\n                f2 = 0.8F;\n            }\n            motX += dirX;\n            motY += dirY;\n            motZ += dirZ;\n            motX *= f2;\n            motY *= f2;\n            motZ *= f2;\n            world.addParticle(\"smoke\", locX, locY + 0.5D, locZ, 0.0D, 0.0D, 0.0D);\n            setPosition(locX, locY, locZ);\n        }\n    }\n\n    protected float e()\n    {\n        return 0.95F;\n    }\n\n    protected abstract void a(MovingObjectPosition movingobjectposition);\n\n    public void b(NBTTagCompound nbttagcompound)\n    {\n        nbttagcompound.setShort(\"xTile\", (short)e);\n        nbttagcompound.setShort(\"yTile\", (short)f);\n        nbttagcompound.setShort(\"zTile\", (short)g);\n        nbttagcompound.setByte(\"inTile\", (byte)Block.b(h));\n        nbttagcompound.setByte(\"inGround\", (byte)(i ? 1 : 0));\n        nbttagcompound.set(\"power\", a(new double[] {\n            dirX, dirY, dirZ\n        }));\n    }\n\n    public void a(NBTTagCompound nbttagcompound)\n    {\n        e = nbttagcompound.getShort(\"xTile\");\n        f = nbttagcompound.getShort(\"yTile\");\n        g = nbttagcompound.getShort(\"zTile\");\n        h = Block.e(nbttagcompound.getByte(\"inTile\") & 0xff);\n        i = nbttagcompound.getByte(\"inGround\") == 1;\n        if(nbttagcompound.hasKeyOfType(\"power\", 9))\n        {\n            NBTTagList nbttaglist = nbttagcompound.getList(\"power\", 6);\n            dirX = nbttaglist.d(0);\n            dirY = nbttaglist.d(1);\n            dirZ = nbttaglist.d(2);\n        } else\n        {\n            die();\n        }\n    }\n\n    public boolean R()\n    {\n        return true;\n    }\n\n    public float af()\n    {\n        return 1.0F;\n    }\n\n    public boolean damageEntity(DamageSource damagesource, float f)\n    {\n        if(isInvulnerable())\n            return false;\n        Q();\n        if(damagesource.getEntity() != null)\n        {\n            Vec3D vec3d = damagesource.getEntity().ag();\n            if(vec3d != null)\n            {\n                motX = vec3d.c;\n                motY = vec3d.d;\n                motZ = vec3d.e;\n                dirX = motX * 0.10000000000000001D;\n                dirY = motY * 0.10000000000000001D;\n                dirZ = motZ * 0.10000000000000001D;\n            }\n            if(damagesource.getEntity() instanceof EntityLiving)\n                shooter = (EntityLiving)damagesource.getEntity();\n            return true;\n        } else\n        {\n            return false;\n        }\n    }\n\n    public float d(float f)\n    {\n        return 1.0F;\n    }\n\n    private int e;\n    private int f;\n    private int g;\n    private Block h;\n    private boolean i;\n    public EntityLiving shooter;\n    private int j;\n    private int au;\n    public double dirX;\n    public double dirY;\n    public double dirZ;\n    public float bukkitYield;\n    public boolean isIncendiary;\n}\n复制代码"
        },
        {
            "author": "Johnny.R",
            "timestamp": 1403327340,
            "txt_content": "NaOcAn. 发表于 2014-6-21 13:00\n同感哇= =\n看不懂很正常哇,况且这还是经过了混淆的源码,我看了很久才有了一点点头绪"
        },
        {
            "author": "NaOcAn.",
            "timestamp": 1403327700,
            "txt_content": "Johnny.R 发表于 2014-6-21 13:09\n看不懂很正常哇,况且这还是经过了混淆的源码,我看了很久才有了一点点头绪 ...\n屌= =膜拜= ="
        },
        {
            "author": "SuperGameMaster",
            "timestamp": 1403327820,
            "txt_content": "大神的世界，我不懂！！！"
        },
        {
            "author": "Johnny.R",
            "timestamp": 1403328840,
            "txt_content": " 本帖最后由 Johnny.R 于 2014-6-21 13:37 编辑 \n\n对了，刚刚发现了,MovingObjectPosition有对于击中的Entity的信息,可以凭借此来达到击中控制对于玩家伤害的情况,然后a(MovingObjectPosition)这个方法貌似就是在击中实体的时候被调用的\n                if(world.isEmpty(i, j, k) && !CraftEventFactory.callBlockIgniteEvent(world, i, j, k, this).isCancelled())\n                    world.setTypeUpdate(i, j, k, Blocks.FIRE);复制代码\n这一句就是对于方块上file:///C:\\Users\\ding\\AppData\\Local\\Temp\\SGTpbq\\2328\\00A63D83.gif部的火焰的更新"
        },
        {
            "author": "ujkojll",
            "timestamp": 1403328960,
            "txt_content": "你可以去看下火焰附加的代码，虽然我不知道在那看"
        },
        {
            "author": "1076742624",
            "timestamp": 1403361180,
            "txt_content": "Johnny.R 发表于 2014-6-21 12:50\n重写火球就比较麻烦了,所以我写插件的时候都是直接导入craftbukkit.jar包然后按照每一个Release版本更新了, ...\n不用重写，有个事件可以拦截，所以我想楼主可以利用下事件监听这个功能~"
        }
    ]
}