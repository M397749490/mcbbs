{
    "title": "关于服务器里线程的问题",
    "author": "Hineven",
    "replyCount": 4,
    "timestamp": 1419905940,
    "txt_content": " 本帖最后由 胡晨晓 于 2015-2-8 10:57 编辑 \n\n自己的小游戏插件，\n写了一个开始倒计时实现runnable的内置类\n像这样：\n\nclass StartingThread implements Runnable {\n\n                Thread thread = new Thread(this);\n                boolean canStart = false;\n                Arena handleArena = null;\n\n                public StartingThread(Arena arena) {\n                        handleArena = arena;\n                        // thread.run();\n                }\n\n                @Override\n                public void run() {\n                        int seconds = 60;\n                        handleArena.message(Message.startingIn1Min);\n                        while (canStart && seconds > 0) {\n                                if(seconds == 30)\n                                        handleArena.message(ChatColor.RED + \"30\"\n                                                        + ChatColor.YELLOW\n                                                        + \" seconds until the game start!\");\n                                if (seconds <= 10)\n                                        handleArena.message(ChatColor.RED + \"\" + seconds\n                                                        + ChatColor.YELLOW\n                                                        + \" seconds until the game start!\");\n                                seconds--;\n                                try {\n                                        Thread.sleep(1000);\n                                } catch (InterruptedException e) {\n                                        e.printStackTrace();\n                                }\n                        }\n                        if (canStart) {\n                                handleArena.message(ChatColor.RED + \"Game started!\");\n                                handleArena.startGame();\n                        } else\n                                handleArena.message(ChatColor.RED + \"Start celled\");\n                }\n\n                synchronized public void setCanStart(boolean canStart) {\n                        this.canStart = canStart;\n                }\n\n                public void start() {\n                        thread.run();\n                }\n\n        }\n        @SuppressWarnings(\"deprecation\")\n        static public void endRound(Arena arena) {\n                arena.setStatus(ArenaStatus.Resetting);\n                arena.paintAllSigns();\n                int pn = arena.getPlayerCount();\n                for (int i = 0; i < pn; i++)\n                        arena.getPlayer(i).getPlayer().teleport(arena.getReturnLocation());\n                arena.clearAllPlayersInventory();\n                arena.clear();\n                arena.getGroundHandler().reset();\n                arena.setStatus(ArenaStatus.WaitForPlayer);\n                arena.paintAllSigns();\n        }\n\n        Speelf plugin;\n\n        Arena handleArena = null;\n\n        StartingThread insideThread = null;\n\n        public GameRuleHandler(Speelf speelf, Arena a) {\n                plugin = speelf;\n                handleArena = a;\n        }\n\n        public void endRound() {\n                handleArena.setStatus(ArenaStatus.Resetting);\n                handleArena.paintAllSigns();\n                for (PlayerData pd:handleArena.getPlayers())\n                        pd.getPlayer()\n                        .teleport(handleArena.getReturnLocation());\n                handleArena.clearAllPlayersInventory();\n                handleArena.clear();\n                handleArena.getGroundHandler().reset();\n                handleArena.setStatus(ArenaStatus.WaitForPlayer);\n                handleArena.paintAllSigns();\n        }\n\n        synchronized public void playerJoined(Player p) {\n                handleArena.message(ChatColor.RED + \"[\" + handleArena.getPlayerCount()\n                                + \"/\" + handleArena.getMaxPlayer() + \"] \" + ChatColor.YELLOW\n                                + p.getName() + ChatColor.YELLOW + \" joined the game.\");\n                p.getInventory().clear();\n                if (insideThread == null) {\n                        insideThread = new StartingThread(handleArena);\n                }\n                if (handleArena.getPlayerCount() >= 2) {\n                        insideThread.setCanStart(true);\n                        insideThread.run();\n                }\n                try {\n                        insideThread.thread.join();\n                } catch (InterruptedException e) {\n                        e.printStackTrace();\n                }\n                insideThread = null;\n        }\n\n        synchronized public void playerLeft(Player p) {\n                handleArena.message(ChatColor.RED + \"[\" + handleArena.getPlayerCount()\n                                + \"/\" + handleArena.getMaxPlayer() + \"] \" + ChatColor.YELLOW\n                                + p.getName() + ChatColor.YELLOW + \" left the game.\");\n                p.getInventory().clear();\n                if (insideThread != null && handleArena.getPlayerCount() < 2) {\n                        insideThread.setCanStart(false);\n                }\n        }//。。。。。\n复制代码\n\n\n但貌似不是异步的？\n已解决\n看向StartingThread.start()!\n应该是thread.start();\n",
    "replies": [
        {
            "author": "Hineven",
            "timestamp": 1419929580,
            "txt_content": "没人么。。"
        },
        {
            "author": "Hineven",
            "timestamp": 1420693740,
            "txt_content": "求人啊！"
        },
        {
            "author": "jiongjionger",
            "timestamp": 1421314380,
            "txt_content": "Bukkit的API自带异步，为何不用？\n例如runTaskTimerAsynchronously"
        },
        {
            "author": "Hineven",
            "timestamp": 1422701460,
            "txt_content": "jiongjionger 发表于 2015-1-15 17:33\nBukkit的API自带异步，为何不用？\n例如runTaskTimerAsynchronously\n复杂度差不多吧\n而且关服时貌似不能开线程。。"
        }
    ]
}