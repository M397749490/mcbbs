{
    "title": "[已解决]方块实体渲染不同步",
    "author": "ckg1302",
    "replyCount": 0,
    "timestamp": 1596467940,
    "txt_content": " 本帖最后由 ckg1302 于 2020-8-4 17:41 编辑 \n\n想做一个能显示内部物品的罐子，现在方块的onBlockActivated方法是没有问题的，NBT数据也正常保存，但是渲染器却无法渲染\n\n我的方块实体定义了一个Inventory，有对外部开放的getItem和setItem方法（全部没有static修饰）（目前发现用static修饰方块实体的Inventory可以正常渲染但是所有的方块渲染的都是一个东西），方块的onBlockActivated方法使用没有任何问题，但渲染器啥都没有（渲染器我单独拿出来测过没有任何问题，就是指定物品那种）\n现在推测是渲染方法和方块的onBlockActivated方法使用的不是同一个方块实体，想请教如何同步这两个方块实体\nForge 1.15.2-31.2.0\nMCP snapshot-20200514-1.15.1\n三个类的代码如下（部分隐私类名，变量名修改了）：\n方块类\npackage com.***.block;\n\nimport javax.annotation.Nullable;\n\nimport com.***.tilentity.ThisBlockTileEntity;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockState;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.ActionResultType;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.math.BlockRayTraceResult;\nimport net.minecraft.util.math.shapes.ISelectionContext;\nimport net.minecraft.util.math.shapes.VoxelShape;\nimport net.minecraft.util.math.shapes.VoxelShapes;\nimport net.minecraft.world.IBlockReader;\nimport net.minecraft.world.World;\n\npublic class BlockClass extends Block{\n        private static VoxelShape shape;\n        static {\n                VoxelShape *** = Block.makeCuboidShape(5, 0, 5, 11, 9, 11);\n                VoxelShape *** = Block.makeCuboidShape(6, 9, 6, 10, 10, 10);\n                VoxelShape *** = Block.makeCuboidShape(5, 10, 5, 11, 12, 11);\n                shape = VoxelShapes.or(***, ***, ***);\n        }\n        public BlockClass() {\n                super(Properties.create(Material.GLASS).hardnessAndResistance(2).notSolid());\n        }\n        @Override\n        public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context) {\n              return shape;\n        }\n        @Override\n        public ActionResultType onBlockActivated(BlockState state, World worldIn, BlockPos pos, PlayerEntity player, Hand handIn, BlockRayTraceResult hit) {\n                if(!worldIn.isRemote() && state.getBlock() instanceof BlockClass) {\n                        if(worldIn.getTileEntity(pos) instanceof TileEntityClass) {\n                                TileEntityClass te = (TileEntityClass)worldIn.getTileEntity(pos);\n                                ItemStack stack = player.getHeldItem(handIn);\n                                if(stack.isEmpty()) {\n                                        player.addItemStackToInventory(te.getItem());\n                                        te.setItem(ItemStack.EMPTY);\n                                }else if (sjarte.getItem().isEmpty()){\n                                        te.setItem(stack);\n                                        stack.shrink(1);\n                                }\n                        }\n                }\n                return ActionResultType.SUCCESS;\n        }\n        @Override\n        public boolean hasTileEntity(BlockState state) {\n                return true;\n        }\n        @Nullable\n        @Override\n        public TileEntity createTileEntity(BlockState state, IBlockReader world) {\n                return new TileEntityClass();\n        }\n}\n复制代码方块实体类\npackage com.***.tilentity;\n\nimport com.***.main.TEReg;\n\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.CompoundNBT;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.Direction;\nimport net.minecraftforge.common.util.LazyOptional;\nimport net.minecraftforge.items.ItemStackHandler;\nimport net.minecraft.inventory.Inventory;\n\npublic class TileEntityClass extends TileEntity{\n        private Inventory inventory = new Inventory(1);\n        public TileEntityClass() {\n                super(TEReg.TileEntityClass.get());\n        }\n        @Override\n           public <T> net.minecraftforge.common.util.LazyOptional<T> getCapability(net.minecraftforge.common.capabilities.Capability<T> cap, Direction side) {\n               if (cap == net.minecraftforge.items.CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n                  return LazyOptional.of(() -> {\n                          return new ItemStackHandler();\n                  }).cast();\n               }\n               return super.getCapability(cap);\n        }\n        public void setItem(ItemStack newItem) {\n                this.inventory.clear();\n                this.inventory.addItem(newItem);\n        }\n        public ItemStack getItem() {\n                return this.inventory.getStackInSlot(0);\n        }\n        public Inventory getInventory() {\n                return this.inventory;\n        }\n        @Override\n        public void read(CompoundNBT compound) {\n                this.inventory.addItem(ItemStack.read(compound.getCompound(\"DisplayItem\")));\n                super.read(compound);\n        }\n        @Override\n        public CompoundNBT write(CompoundNBT compound) {\n                ItemStack toStore = this.inventory.getStackInSlot(0).copy();\n                compound.put(\"DisplayItem\", toStore.serializeNBT());\n                return super.write(compound);\n        }\n}\n复制代码渲染类\npackage com.***.client.tileentityrender;\n\nimport javax.annotation.Nonnull;\n\nimport com.***.tilentity.TileEntityClass;\nimport com.mojang.blaze3d.matrix.MatrixStack;\n\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.renderer.IRenderTypeBuffer;\nimport net.minecraft.client.renderer.ItemRenderer;\nimport net.minecraft.client.renderer.Vector3f;\nimport net.minecraft.client.renderer.model.IBakedModel;\nimport net.minecraft.client.renderer.model.ItemCameraTransforms;\nimport net.minecraft.client.renderer.tileentity.TileEntityRenderer;\nimport net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;\nimport net.minecraft.item.ItemStack;\n\n@SuppressWarnings(\"deprecation\")\npublic class RendererClass extends TileEntityRenderer<TileEntityClass>{\n        private int degree = 0;\n        private float height = 0.2F;\n        private boolean isRising = false;\n        \n        public RendererClass(TileEntityRendererDispatcher rendererDispatcherIn) {\n                super(rendererDispatcherIn);\n        }\n\n        @Override\n        public void render(@Nonnull TileEntityClass tileEntityIn, float partialTicks, MatrixStack matrixStackIn, IRenderTypeBuffer bufferIn, int combinedLightIn, int combinedOverlayIn) {\n                ItemStack stack = tileEntityIn.getInventory().getStackInSlot(0);\n                if(degree == 360) { degree = 0; }\n                degree++;\n                if(isRising) {\n                        height = height + 0.001F;\n                }else {\n                        height = height - 0.001F;\n                }\n                if(height <= 0.5) {\n                        isRising = false;\n                }\n                if(height >= 0.2) {\n                        isRising = true;\n                }\n                matrixStackIn.push();\n                matrixStackIn.translate(0.5,height,0.5);\n                matrixStackIn.scale(0.6F, 0.6F, 0.6F);\n                matrixStackIn.rotate(Vector3f.YP.rotationDegrees(degree));\n                ItemRenderer renderer = Minecraft.getInstance().getItemRenderer();\n                IBakedModel model = renderer.getItemModelWithOverrides(stack, tileEntityIn.getWorld(), null);\n                renderer.renderItem(stack, ItemCameraTransforms.TransformType.FIXED, true, matrixStackIn, bufferIn, combinedLightIn, combinedOverlayIn, model);\n                matrixStackIn.pop();\n        }\n}\n复制代码初次写模组，代码写的比较乱请见谅\n",
    "replies": []
}