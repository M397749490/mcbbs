{
    "title": "[1.9]在MC中复刻N-Puzzle经典游戏",
    "author": "秋一",
    "replyCount": 6,
    "timestamp": 1447640880,
    "txt_content": " 本帖最后由 acordome 于 2015-11-17 10:10 编辑 \n\n　　大家好，我是秋一。今天想和大家分享一下用展示框+地图做的N-Puzzle√\n　　对CBL比较了解的盆友们应该知道小组第一个组坑就是PUZZLE。这实际上是一个非常经典的游戏，相信很多人也在手机上玩过~这里就不多做介绍了。\n　　但其实这个版本在发帖的早一些时候就已经有一个雏形了。灵感方案是在RCG（一个专注地图制作的新兴团队√）中诞生的，但那时并没有做出来相对成熟的版本。直到1.9快照对于CB的完善，这个东西才重新被拿出来制作。\n　　用了展示框+地图的方法，更加接近原版的手♂感，当然，由于本人比较懒，也没有把“步数”、“计时”等功能加进去。BUT~~~这并不影响游戏性对吧√\n\n　　\n\n\n 　　\n\n　　游戏的玩法很简单，就是右键点击“空白”四周的地图来互换，最终目的是复原拼图。存档晚点会发到作品区，这里就稍微讲讲这个游戏的原理吧\n\n　　原理请翻页√\n\n\n　　首先是移动拼图的核心功能，我想一说到展示框，很多人已经想到原理了。\n\n　　互换功能的思路：\n　　　1. 当一个图片被右击的时候，其NBT变为{ItemRotation:1b}，据此我们可以给这个拼图添加一个rot的tag；\n　　　2. 以 tag=rot 的展示框为执行体，往四个方向各偏移1格作为执行中心，探测r=0(该点)是否有空格（tag=air），这时候可能出现4种情况，即四个方向中其中一个有空格。如果成立，则调用相应的互换模块（调用模块通用方法见PCA关于无延迟逻辑框架的帖子：http://www.mcbbs.net/thread-522757-1-2.html）。互换当然只是简简单单的一个TP功能，最后要调用复原模块把 tag=rot 的展示框复原；\n　　　3. 但是还有额外的一种情况，即没有空格，那么此时应该直接调用复原模块。\n\n　　如图：\n　　\n\n　　首先是添加tag的核心——A\n/scoreboard players tag @e add rot {ItemRotation:1b}复制代码\n　　其中一路（以“上”路为例） \n/execute @e[tag=rot] ~ ~1 ~ execute @e[tag=air,r=0] ~ ~ ~ execute @e[name=up,type=ArmorStand] ~ ~ ~ blockdata ~ ~ ~ {auto:1}复制代码\n　　最后的execute 盔甲架（name=up，其实它还有个tag=auto）就是调用“上”位置的ICB: \n/tp @e[tag=rot] ~ ~1 ~复制代码\n\n　　按箭头顺序: \n/tp @e[tag=air] ~ ~-1 ~复制代码\n　　然后调用复原模块（“无”那一列）\n/execute @e[tag=rot] ~ ~ ~ execute @e[name=mid,type=ArmorStand] ~ ~ ~ blockdata ~ ~ ~ {auto:1}复制代码\n　　ICB(为 name=mid 所在处，同样，它也有一个tag=auto）\n/entitydata @e[tag=rot] {ItemRotation:0b}复制代码\n　　按箭头顺序（关闭被调用的模块以便下次调用，因此ICB处5个盔甲架都有tag=auto）: \n/execute @e[tag=auto] ~ ~ ~ blockdata ~ ~ ~ {auto:0}复制代码\n　　由于空间压缩，上面还有一个CCB，用于把tag=rot去掉: \n/scoreboard players tag @e[tag=rot] remove rot复制代码\n　　以上就是互换拼图的核心功能，当然可以用另一个思路（看完下一部分一定能想到√）来简化tp模块，只不过由于这是很早以前就做了的，也就懒得改了，有兴趣的朋友可以自己琢磨一下√\n\n\n　　接下来是另一个功能：打乱\n　　同样，打乱也是一个模块，用于调用该模块的AS，我给了它一个tag=daluan2（PCA一定会说：这什么鬼畜的命名√）\n\n　　于是牌子的指令就很简单了，首先调用打乱模块，然后把两个牌子替换成无内容的牌子以防误操作（BUG什么的最讨厌了），牌子JSON就不在这里讲了，本人的新键盘由于没有直接的方向键，写JSON想死……嗯……这里就讲打乱吧\n\n　　在讲打乱以前，我们要设计一个“可解”的概念。（该部分比较烧脑，不想看的直接跳到下面看指令部分）\n　　以3*3的拼图为例，把它排成一列并用自然数序列加以编号，共有9!种排列方法，其中只有一半是可解的——条件就是该排列的逆序对数为偶数。为什么呢？我们知道通过点击拼图来互换的时候，每互换一次，逆序对的奇偶性就发生一次变化。对于3*3拼图而已，完好的拼图应该是顺序的，即它的逆序对为0，属于偶数。此时进行一次互换，逆序对=1，再互换回来，逆序对=0……也就是说，无论你如何操作，从手动互换到复原，一定经过偶数次互换。那么问题的核心就是——我们选取非最大编号的地图进行随机互换的时候，次数一定要是偶数，否则打乱的拼图是无解的，也就是无法复原√\n\n　　所以这里需要一个for循环，虽然本人不懂编程，但是逻辑还是略知一二的。通俗地讲，当我们调用了打乱模块以后，要让“打乱一次”这个动作，执行一定次数，并且这个次数是偶数次。\n　　我在之前发过一个帖子讲无记分板进行短延时的方法，是个高度压缩空间但是非常麻烦的玩意儿，这个东西稍微改一下就可以拿来做成for循环。\n\n　　首先你需要一个ICB来提供信号，这个ICB的指令跟之前的不太一样。它是将一个指令对自身重复嵌套来达到多次发出信号的功能：\n/setblock ~ ~ ~ command_block X replace {auto:1,Command:}复制代码\n　　X改为相应的数字来使方向正确。在本帖的存档中，由于是朝北，因此X=2，将这个指令贴到Command:后面，包含主体在内贴20次，然后，你需要考虑模块复原，因此你可以在旁边放一个一模一样的，然后在指令剥皮到最后执行clone来使ICB复原，这里就略讲了，然后我们讲讲打乱。\n　　首先依然是思路：\n　　　1. 任意选中两个展示框，附加以tag=r1，并且这两个展示框不是编号最大的拼图，也不是空格（为此我把其他的展示框加上了tag=random）\n　　　2. 在tag=r1的拼图中任意选一个，附以tag=r2，并且对tag=r2的拼图，移除tag=r1；\n　　　3. 这个时候我们就随机抽取了两个不一样的拼图。然后，以tag=r1的拼图为执行体，生成一个辅助定位的盔甲架（tag=r3），需要注意的是，这个盔甲架的朝向（Rotation），必须要对应拼图的朝向。由于本帖的存档是朝南的，刚好就是默认的朝向，因此不用填写。\n　　　4. 接下来就是tp了：r1 --> r2, r2 --> r3\n　　　5. 互换完毕后，清理掉r3，并且把r1和r2的tag移除\n　　　6. 探测打乱是否已完成，如果完成，执行指令把木牌复原，同时显示提示文字\n\n　　指令是这样的（就不贴图了，因为压缩空间把CCB封在一个点不到的地方里了——囧，大家不要学我，很不方便修改的，几乎一次成型）：\n　　　按顺序/scoreboard players tag @r[type=ItemFrame,tag=random,c=2] add r1复制代码/scoreboard players tag @r[type=ItemFrame,tag=r1] add r2复制代码/scoreboard players tag @e[tag=r2] remove r1复制代码/execute @e[tag=r1] ~ ~ ~ summon ArmorStand ~ ~ ~ {NoGravity:1,Marker:1,Invisible:1,Tags:[\"r3\"]}复制代码/tp @e[tag=r1] @e[tag=r2]复制代码/tp @e[tag=r2] @e[tag=r3]复制代码/tp @e[tag=r3] ~ -100 ~复制代码/scoreboard players tag @e[tag=r1] remove r1复制代码/scoreboard players tag @e[tag=r2] remove r2复制代码\n　　以上就是打乱一次的程序。那么如何检测打乱已完成呢？\n　　假设tag=daluan2处的ICB，原朝向是向上的（Data:1），启动后是朝北的（Data:2），那么我们就可以检测这个位置的ICB是否是Data:1。那么可以这么来（紧接上一段程序，有cond:表示该CB为Conditional模式）\n　　补充说明：在“点击打乱”的牌子处有一个tag=daluan的盔甲架作为定位用，请区分tag=daluan和tag=daluan2！在“换图”的牌子处也有一个tag=huantu的盔甲架作为定位√/execute @e[tag=daluan2] ~ ~ ~ testforblock ~ ~ ~ commmand_block 1复制代码cond:/execute @e[tag=daluan] ~ ~ ~ blockdata ~ ~ ~ {Text1:……}复制代码cond:/execute @e[tag=huantu] ~ ~ ~ blockdata ~ ~ ~ {……}复制代码cond:/tellraw @a [提示文字]复制代码\n　　JSON在这里我就不写出来了，只是大致讲几点:\n　　　1. 倒数第二个（即execute huantu）的CCB处，有一个tag=huantu2的盔甲架，至于为什么，原因很简单。就是打乱的时候会把“换图”的牌子也给变成空牌子，而复原的时候，我们需要知道是第几张图对应的牌子。所以在换图模块执行的时候会顺带把这个CCB的内容更换掉√\n　　　2. 关于打乱功能的牌子，内部执行了这样三条指令：调用打乱模块 --> 把换图牌子变成空的牌子 --> 把自己编程空的牌子；注意第二步和第三步是不能弄反的，否则第三步将不能执行，具体为什么，自己想去吧（胜利的表情√）\n　　　3. 对于换图的牌子也是同理，首先调用换图模块，然后把打乱牌子变成空的，最后把自己变成空的。在后面讲换图模块的时候大家就会明白了。\n\n　　以上就是打乱模块的全部原理，有看不懂的可以尽管提问，嗯……\n\n\n\n　　最后一部分是换图的，我就挑其中一个来讲。另一个几乎是同样的，只是内容稍微变了变而已。\n　　如图：\n　　\n\n　　靠近镜头的那一组是第一张图的模块，后面则是第二张图的模块，楼主懒得想通用办法，就直接用了穷举编号法√\n　　同样，ICB处也有定位用的盔甲架，第一张图是tag=map1，第二张图是tag=map2\n　　当模块被调用后，首先挨个把展示框里的地图换掉，方法是用entitydata改filled_map的Damage，这里不做多讲了，至于选择器，楼主直接穷举编号了（囧）\n　　全都换好以后，要做两件事情：\n　　　1. 把tag=huantu2处的CCB里面的内容换掉（这里写JSON的时候那个转义简直了√），具体看第二部分讲打乱模块……\n　　　2. 调用打乱模块。\n\n　　为什么打乱一次呢？你总不希望玩家在两个图之间切来切去地玩吧……√\n\n　　&&…… 讲完了。\n\n　　感谢大家捧场，别忘了评分哟√\n\n\n\n\n\n[groupid=546]Command Block Logic[/groupid]\n\n\n\n\n\n\n\nN-Puzzle.zip\n\n\n2015-11-16 09:07 上传\n点击文件名下载附件\n\n\n\n\n174.47 KB, 下载次数: 35\n\n\nN-PUZZLE\n\n\n",
    "replies": [
        {
            "author": "simon3000",
            "timestamp": 1447645620,
            "txt_content": "做个吃豆人→_→"
        },
        {
            "author": "麦白",
            "timestamp": 1447648200,
            "txt_content": "这个好回忆。。"
        },
        {
            "author": "qws872465679",
            "timestamp": 1447649400,
            "txt_content": "来顶一顶"
        },
        {
            "author": "秋一",
            "timestamp": 1447667760,
            "txt_content": "simon3000 发表于 2015-11-16 11:47\n做个吃豆人→_→\n工作量会爆炸的"
        },
        {
            "author": "白天",
            "timestamp": 1447668120,
            "txt_content": "来支持下(?>ω<*?) 做的不错哦~ 秋一\n咱是CBL的白天"
        },
        {
            "author": "秋一",
            "timestamp": 1447668600,
            "txt_content": "白天 发表于 2015-11-16 18:02\n来支持下(?>ω\n召唤评分大军√"
        }
    ]
}