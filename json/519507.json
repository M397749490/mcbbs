{
    "title": "【万年坑】【本章完结】Java高手训练营第九章：异常处理",
    "author": "ufof",
    "replyCount": 10,
    "timestamp": 1446803400,
    "txt_content": " 本帖最后由 ufof 于 2015-12-11 03:21 编辑 \n\n\n9.1 Throwable体系\n\n\n9.1.1 Throwable类概述 \n\n无论技术多么精通的程序员永远都做不到让程序万无一失的。我们之前编程的过程中，程序总有编译不通过的时候。根据Java的面向对象规则，就算是错误/异常也是对象。java.lang.Throwable类是所有异常/错误的父类。Throwable的意思是“可抛出的”。在学习如何解决/抛出异常之前，我们先来学会这个体系。\n\n9.1.2 异常和错误\n\nThrowable类有两个直接子类：异常（Exception）和错误（Error）。从表面上来看，这两个词貌似没有什区别，但是在编程当中是必须要区分开的。\n\n总而言之，异常和错误的区别在于：错误一般是和虚拟机有关的问题，较为严重。例如找不到类、系统崩溃、虚拟机错误等。错误不能被程序员人为的解决/抛出。唯一的解决方式是改变源代码。\n\n异常没有错误那么的严重，一般是一些小的问题：例如除零、数组越界等。异常可以被程序员解决/抛出。本章的重点就是异常。\n\n9.1.3 虚拟机的默认处理Throwable方式\n\n我们人为的制造一个有异常的程序。\n\nimport java.util.Scanner;\n\nclass ExceptionDemo{\n    \n    public static void main(String[] args){\n        Scanner s = new Scanner(System.in);\n        System.out.println(\"请输入第一个数字：\");\n        int num1 = s.nextInt();\n        System.out.println(\"请输入第二个数字：\");\n        int num2 = s.nextInt();\n        \n        System.out.println(\"这两个数的商是：\"+num1/num2);   //打印两个数的商\n        System.out.println(\"感谢使用！\");\n    }\n}复制代码结果：\n\n\n\n\n\n\n\n在这个程序当中，用户键入的除数是0。根据数学常识，除零是不可接受的。因此，在计算num1/num2时，虚拟机发现num2为0，一个ArithmeticException（算数异常）实例被抛出。\n\n当虚拟机发现了一个Throwable时，会首先打印跟踪栈。跟踪栈是结果中最后的两行英文，主要的内容是Throwable的类型、Throwable的描述、出现Throwable的位置。\n\n程序在打印完商之后，也应当输出“感谢使用”。但是没有打印。所以说，出现Throwable时，程序立刻终止。\n\n程序员对于异常可以有两种处理方式：第一种是捕捉（也就是通过try、catch、finally），第二种是抛出。下一节当中，我们来学习第一种。\n\n本章小结\njava.lang.Throwable是一切错误/异常的父类错误是较为严重的问题，不可被捕捉以及抛出；异常可以被捕捉以及抛出虚拟机默认处理Throwable的方式是：打印跟踪栈，并终止程序\n\n\n\n\n9.2 try、catch、finally\n\n\n9.2.1 捕捉异常概述\n\n上一节中，我们提到了处理异常的两种方式：捕捉或抛出。当方法中知道如何解决这个异常，不需要让上级调用者解决，应当使用捕捉方法。Java为我们提供try、catch、finally这三个语句块来捕捉异常。\n\n9.2.2 语法\n\n三个语句块的使用方法如下：\ntry{}：有可能发生异常的语句块catch(异常类型 实例名){}：如果try中出现了指定的异常类型，进入该catch语句块（可以有若干个）finally{}：无论错误是否发生，都要执行的语句块\n\n捕捉异常后，异常便会被解决。虚拟机不再终止程序并打印跟踪栈。\n\n9.2.3  实例\n\n我们写一个实例：\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        int num1 = 10;\n        int num2 = 0;\n        try{\n            //运算num1/num2，有可能出现ArithmeticException\n            System.out.println(\"num1/num2=\"+divide(num1,num2));\n            System.out.println(\"运算完成。\");\n        }\n        catch(ArithmeticException e){        //捕捉ArithmeticException\n            System.out.println(\"发生数学异常\");\n        }\n        \n        System.out.println(\"程序结束。\");\n    }\n    \n    public static int divide(int a, int b){  //除法方法\n        return a/b;                             //返回a/b\n    }\n}复制代码结果：\n\n\n\n那么这个程序究竟是什么流程呢？\n\n这个程序当中的第七行代码，“divide(num1,num2)”中，程序就相当于执行了一个new ArithmeticException()。这个对象会赋给catch中的“ArithmeticException e”实例。就相当于是“ArithmeticException e = new ArithmeticException()”。 \n\n而且可以通过这个程序可以观察到两点：\ntry中还有一个打印“运算完成”的语句，其没有被执行【可观察到：当try中出现异常，立刻前往catch，后面语句不再执行】try和catch后面有一个打印“程序结束”的语句，其被执行了【可观察到：捕捉异常之后，程序继续顺利运行】\n\n9.2.4 获取异常信息\n\n\n在catch块当中，可以通过异常的实例来获取异常的信息。Throwable类中有三个方法供我们获取信息：\n\nString toString()                 //用于获取异常名以及附带的信息\nvoid printStackTrace()        //打印异常的跟踪栈\ngetMessage()                     //仅获取附带信息\n\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        int num1 = 10;\n        int num2 = 0;\n        try{\n            System.out.println(\"num1/num2=\"+divide(num1,num2));\n            System.out.println(\"运算完成。\");\n        }\n        catch(ArithmeticException e){\n            System.out.println(e.toString());    //打印异常的toString()\n        }\n        \n        System.out.println(\"程序结束。\");\n    }\n    \n    public static int divide(int a, int b){\n        return a/b;\n    }\n}复制代码结果：\n\n\n\n在这个程序当中，我在catch块中打印了e.toString()。结果是异常类名+信息。\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        int num1 = 10;\n        int num2 = 0;\n        try{\n            System.out.println(\"num1/num2=\"+divide(num1,num2));\n            System.out.println(\"运算完成。\");\n        }\n        catch(ArithmeticException e){\n            System.out.println(e.getMessage());    //打印异常的getMessage()\n        }\n        \n        System.out.println(\"程序结束。\");\n    }\n    \n    public static int divide(int a, int b){\n        return a/b;\n    }\n}复制代码结果：\n\n\n\n这次我打印的是e.getMessage()。可以看出来，仅仅有异常的信息，没有类型。\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        int num1 = 10;\n        int num2 = 0;\n        try{\n            System.out.println(\"num1/num2=\"+divide(num1,num2));\n            System.out.println(\"运算完成。\");\n        }\n        catch(ArithmeticException e){\n            e.printStackTrace();                     //打印跟踪栈\n        }\n        \n        System.out.println(\"程序结束。\");\n    }\n    \n   public static int divide(int a, int b){\n        return a/b;\n    }\n}复制代码结果：\n\n\n\n打印跟踪栈其实和之前我们演示的虚拟机默认处理Throwable的方式看上去一样。推荐大家使用打印跟踪栈的方式获取异常的信息，因为异常类、信息、出现地点应有尽有。较为详细。\n\n9.2.5 多个catch\n\n如果try中的语句块有可能会出现多个异常，需要使用多个catch块来进行处理。\n\n这里我们写一个程序：可以通过Scanner类获取用户的输入。输入两个数后进行除法运算。这个程序有两个潜在的异常：\n\nArithmeticExpcetion （用户有可能会除0，这个我们已经接触过了）InputMismatchException （用户输入的不是数字，或超出范围）\n\nps: InputMismatchException在java.util包下，所以说也需要导包。\n\n\n所以说，我们需要通过两个catch块进行处理。\n\nimport java.util.*;\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        Scanner s = new Scanner(System.in);\n        int num;\n        int num2;\n        try{\n            System.out.println(\"请输入第一个数字：\");\n            num = s.nextInt();\n            \n            System.out.println(\"请输入第二个数字：\");\n            num2 = s.nextInt();\n            \n            System.out.println(\"这两个数字的商是：\"+num/num2);\n        }\n        catch(ArithmeticException e){                 //捕捉运算异常\n            System.out.println(\"不能除以0\");\n        }\n        catch(InputMismatchException e){           //捕捉输入错误异常\n            System.out.println(\"输入有误\");\n        }\n    }\n}\n复制代码结果1（除0）：\n\n\n\n结果2（输入有误）：\n\n\n\n相信多个catch块不难理解。但是问题来了：要是我的try语句块中有可能出现的异常太多了，不可能一个一个的把所有catch列举出来，该怎么办呢？\n\n大家还记不记多态？\n\nimport java.util.*;\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        Scanner s = new Scanner(System.in);\n        int num;\n        int num2;\n        try{\n            System.out.println(\"请输入第一个数字：\");\n            num = s.nextInt();\n            \n            System.out.println(\"请输入第二个数字：\");\n            num2 = s.nextInt();\n            \n            System.out.println(\"这两个数字的商是：\"+num/num2);\n        }\n        catch(Exception e){            //捕捉Exception，凡是所有Exception类的子类都能被捕捉\n            System.out.println(\"出现异常\");\n        }\n    }\n}复制代码\n这次，我不再捕捉两个异常。我直接捕捉他们的父类：Exception。我们曾经提过，在try块中出现异常，会new出来一个异常对象，并赋给catch中的实例。如果发生了算数异常，就相当于“Exception e = new ArithmeticException()”，如果发生输入错误异常，相当于“Exception e = new InputMismatchException()”。这两个是不是面向对象特点中的多态？这真的是一个很方便的事情。\n\n但是一定要记住：先捕捉一些最有可能发生的小异常，最后再捕捉父类。虽说直接捕捉Exception方便，但是不清晰、具体。\n\n9.2.6 finally\n\nfinally语句块是可选的。其中的代码是无论出错与否都要执行的语句。\n\nimport java.util.*;\n\nclass TryCatchFinallyDemo{\n    public static void main(String[] args){\n        Scanner s = new Scanner(System.in);\n        int num;\n        int num2;\n        try{\n            System.out.println(\"请输入第一个数字：\");\n            num = s.nextInt();\n            \n            System.out.println(\"请输入第二个数字：\");\n            num2 = s.nextInt();\n            \n            System.out.println(\"这两个数字的商是：\"+num/num2);\n        }\n        catch(Exception e){\n            System.out.println(\"出现异常\");\n        }\n        finally{     //一定执行的语句\n            System.out.println(\"程序结束\");\n        }\n    }\n}复制代码结果：\n\n\n\nfinally语句块一般有什么用呢？一般适用于关闭资源、释放锁等。无论出现异常与否，都需要释放、关闭资源。finally在IO流技术中十分常用。然而在本章中并不是我们的重点。\n\n本章小结\ntry、catch、finally是通过捕捉的方式解决异常try中的语句块放置有可能会发生异常的代码catch中是如果发生指定异常就会执行的代码可以有多个catchtoString()、getMessage()、printStackTrace()是获取异常信息的三种方式\ncatch中如果捕捉的异常有子异常，所有子异常都可以被这个catch捕捉finally语句块是一定要被执行的语句块一般用于释放、关闭资源\n\n\n\n9.3 使用throws声明异常\n\n\n9.3.1 throws概述\n\n上一节中，我们学习了处理异常的第一种方式：捕捉。这种处理方式是在本方法中直到如何解决有可能发生的异常的情况下使用的。如果本方法不知道如何处理有可能发生的异常，需要由上一级调用者处理，需要声明异常。上一级调用者也一样，要么捕捉，要么接着往上声明。如果主方法也没有捕捉，声明给了虚拟机，虚拟机就会使用它的默认处理方式解决异常。\n\n9.3.2 语法\n\n如果一个方法需要声明异常，通过这个格式声明：\n\n若干个修饰符 返回值类型 方法名(参数列表) throws  有可能的异常,有可能的异常,...{\n   //若干代码\n}复制代码\n我们使用上一节中的除法方法来讲解：\n\nclass ThrowsDemo{\n    public static double divide(int a, int b) throws Exception{   //抛出异常\n        return a/b;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(divide(2,1));\n    }\n}复制代码结果：\n\n\n\n学生提问：为什么不抛出ArithmeticException，而是Exception？\n\n答：这是为了方便演示。ArithmeticException是RuntimeException的子类，这种特殊的异常即使不声明也可以。我们会讲解。为了让你们了解声明异常的本质，我先暂时抛出Exception。\n可以发现，虽说没有除零，但是这段程序是编译失败的。main()方法调用了divide()方法。divide()方法声明了一个异常。main()是divide()的上级调用者，所以说main()方法中必须要选择：①捕捉、②继续声明。\n\n我们演示一下捕捉：\n\nclass ThrowsDemo{\n    public static double divide(int a, int b) throws Exception{\n        return a/b;\n    }\n    \n    public static void main(String[] args){\n        try{\n            System.out.println(divide(1,0));   //由于divide()方法声明Exception，必须捕捉或声明\n        }\n        catch(Exception e){   //捕捉Exception\n            e.printStackTrace();\n        }\n        \n        System.out.println(\"程序结束。\");\n    }\n}复制代码结果：\n\n\n\ncatch块后面的“程序结束”被打印了，所以说异常被解决了，程序正常运行。\n\n如果main()方法也声明：\n\nclass ThrowsDemo{\n    public static double divide(int a, int b) throws Exception{\n        return a/b;\n    }\n    \n    public static void main(String[] args) throws Exception{  //主方法声明异常\n        System.out.println(divide(1,0));        \n        System.out.println(\"程序结束。\");\n    }\n}复制代码结果：\n\n\n\ncatch块后面的“程序结束”没有被打印。这是因为主方法的上级调用者是虚拟机。虚拟机一旦收到了异常，就会使用它的默认处理方式：打印跟踪栈并终止程序。所以说后面的字符串没有被打印。\n\n9.3.3 RuntimeException类\n\nRuntimeException类是Exception类的子类。其实我们之前的ArithmeticException是RuntimeException的子类。RuntimeException称为运行时异常。\n\n顾名思义，运行时异常仅在运行时发生。如果一个方法有可能发生运行时异常，这个方法不需要声明这种异常。\n而且，如果一个方法声明了运行时异常，其的上级调用者不需要进行捕捉或继续声明。\n\nclass ThrowsDemo{\n    public static double divide(int a, int b)throws ArithmeticException{\n        return a/b;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(divide(1,0));        //没有进行任何处理，但是编译通过        \n        System.out.println(\"程序结束。\");\n    }\n}复制代码\n那么这是为什么？我们之前写除法方法的时候，方法和代码没有任何问题。导致这个异常的原因是逻辑错误（无法除零）而非代码错误。由于不是代码出错而是逻辑出错，一般是用户在使用过程中出现了问题（也就是输入除零）。所以说这种异常不应当被程序员解决。应当将这个异常一直向上抛，抛到用户层当中作为提示。如果这种异常显示的在方法上throws，上一级调用者也就会显式的处理，这样就达不到抛给用户的需求了。\n\n本章小结\n当方法中有可能发生异常，而且不知道如何处理，需要由上级调用者处理，应当声明异常声明异常通过throws实现，放在方法后面，格式为：“throws 异常1,异常2,异常n”如果有异常声明的方法被调用，其的上一级调用者必须①捕捉、②继续声明主方法声明异常，等于把异常交给虚拟机，虚拟机会按照默认处理方式处理RuntimeException是Exception的子类，RuntimeException的子异常被称为运行时异常如果一个方法有可能发生运行时异常，这个方法不需要声明如果一个声明了运行时异常的方法被调用，上一级调用者不需要处理\n\n\n\n9.4 使用throw手动抛出异常\n\n\n9.4.1 throw概述\n\n我们之前在通过除零演示异常时，异常的抛出是有系统自己完成的。也就是只要除零，系统会自动抛出一个异常，我们不需要做任何事情。不过在实际开发当中，你自己定义的功能肯定有自己出错的方式，所以说Java为我们提供了手动抛出异常的语句：throw。我们学了自定义异常以后还可以通过throw抛出自己的异常。\n\n9.4.2 throw的使用\n\nthrow在方法中使用。格式如下：\n\nthrow 异常对象;复制代码\n我们需要自己实例化一个异常类。不过由于只需要使用一次，可以使用匿名对象的方式。实例化涉及到构造方法，我们简单的来学习一下Throwable类的常用两个构造方法：\n\nThrowable()                          //实例化一个没有信息的异常\nThrowable(String message)    //实例化一个有详细信息的异常\n\n好的，现在我们定义一个除法方法。如果除数为0，抛出ArithmeticException，并附上信息。\n\nclass ThrowDemo{\n    public static void main(String[] args){\n        System.out.println(divide(1,0));\n    }\n    \n    public static double divide(int a, int b){\n        if(b==0){        //如果除数为0\n             throw new ArithmeticException(\"不能除0！\");   //抛出异常\n        }\n        System.out.println(\"算数成功\");\n        return a/b;\n    }\n}\n复制代码结果：\n\n\n\n在divide()方法中，对参数b进行了是否等于0的判断。如果是，抛出一个ArithmeticException，这个对象有详细信息，可以在结果当中看到。\n\n而且，大家可以发现，后面的“算数成功”没有被打印，可以发现，当一个方法抛出一个异常时，该方法结束。\n\n此外，如果一个方法抛出的异常不是RuntimeException或其子类，方法上必须声明它抛出的异常。\n\nclass ThrowDemo{\n    public static void main(String[] args){\n        System.out.println(divide(1,0));\n    }\n    \n    public static double divide(int a, int b){\n        if(b==0){        //如果除数为0\n             throw new Exception(\"不能除0！\");    //仅抛出Exception，而非运行时的ArithmeticException\n        }\n        System.out.println(\"算数成功\");\n        return a/b;\n    }\n}复制代码结果：\n\n\n\n这次我仅仅抛出一个Exception，由于其是RuntimeException的父类而不是子类，在方法中抛出Exception必须要在这个方法上声明这个异常。\n\nclass ThrowDemo{\n    public static void main(String[] args){\n        System.out.println(divide(1,0));\n    }\n    \n    public static double divide(int a, int b) throws Exception{\n        if(b==0){        //如果除数为0\n             throw new Exception(\"不能除0！\");    //仅抛出Exception，而非运行时的ArithmeticException\n        }\n        System.out.println(\"算数成功\");\n        return a/b;\n    }\n}复制代码这次，我在divide()方法上声明了这个异常，编译才能通过。\n\n\n本章小结\nthrow用于在方法中手动抛出一个异常throw的语法是“throw 异常对象”\nThrowable类中有两个构造方法，其中一个是没有参数的，另外一个需求一个字符串，这个字符串是异常的信息当一个方法抛出异常时，该方法结束如果一个方法抛出的异常不是RuntimeException或其子类，必须要在方法上声明这个异常\n\n\n\n\n9.5 自定义异常\n\n\n9.5.1 自定义异常概述\n\n在实际的开发当中，光使用Java类库为我们提供的异常是远远不够的。有一些程序的异常是这个程序独有的，这个时候需要自定义异常。然而，自定义异常要是要起作用，必须要手动的使用throw抛出。自定义异常的捕捉、声明也和前面讲的一模一样。现在我们来开始学习如何自定义一个异常。\n\n9.5.2 自定义异常方式\n\n我们之前接触的ArithmeticException、InputMismatchException等，都是类，因为万物皆对象。想要自定义异常，也是要写一个类，让这个类继承Exception（如果想让它成为运行时异常，需要继承RuntimeException），然后就可以了。很简单。\n\nclass CustomizeExceptionDemo{\n    public static void main(String[] args)throws MyException{\n        throw new MyException();  //抛出这个异常\n    }\n}\n\nclass MyException extends Exception{}  //自定义异常：MyException复制代码结果：\n\n\n\n在主方法中抛出我们自定义的异常，可以在跟踪栈中看出，我们定义的这个异常的确是有效了。但是这个异常类还有一个问题：没有详细信息。\n\n我们在讲throw的时候讲过了，通过Throwable的构造方法来定义一个详细信息。在我们这个类中也要定义一个这样的构造方法。\n\nclass MyException extends Exception{\n    public MyException(String msg){  //有参数构造方法\n        \n    }\n    \n    public MyException(){                 //无参构造方法\n        \n    }\n}复制代码但是，在有参数的构造方法中，我们究竟如何让msg的参数作为异常的详细信息呢？我们知道，Throwable拥有这样的构造方法，而且Throwable是MyException的父类，所以说通过我们在面向对象中学过的super关键字将这个msg传入。\n\nclass MyException extends Exception{\n    public MyException(String msg){\n        super(msg);        //调用父类的构造方法，将msg传入\n    }\n    \n    public MyException(){\n        \n    }\n}复制代码\n现在这个异常类已经算是较为完善的了。我们用这个有参数的构造方法来throw一下看一看：\n\nclass CustomizeExceptionDemo{\n    public static void main(String[] args)throws MyException{\n        throw new MyException(\"这是异常的详细信息\");  //抛出时使用有参构造方法\n    }\n}\n\nclass MyException extends Exception{\n    public MyException(String msg){\n        super(msg);        //调用父类的构造方法，将msg传入\n    }\n    \n    public MyException(){\n        \n    }\n}复制代码结果：\n\n\n\n好的！现在我们已经了解了如何定义一个自己的异常类，相信十分简单。我们通过一个实例来巩固一下知识。\n\n9.5.3  实例\n\n在这个例子当中，我们要写一个除法方法。这个方法有两个潜在的异常：\n\nArithmeticException（算数异常，如果除0抛出）IllegalNumberException（这个需要自定义。在你的程序中，要求被除数和除数都在100以下，0以上，如果不是，抛出这个异常）\n\n大家会注意到，由于IllegalNumberException是由用户传入不当的参数造成的，不需要进行捕捉，所以说然这个类继承RuntimeException会更好。\n\nclass CustomizeExceptionDemo{\n    public static void main(String[] args){\n        System.out.println(divide(150,-3));\n    }\n    \n    public static double divide(int a, int b){\n        if(b==0){\n            throw new ArithmeticException(\"不能除零\");\n        }\n        if(a>100 || a<0 || b>100 || b<0){    //如果a>100 或 a<0 或 b>100 或 b<0\n            throw new IllegalNumberException(\"本程序要求：被除数和除数都在0到100之间\");\n            //抛出异常\n        }\n        \n        return a/b;\n    }\n}\n\nclass IllegalNumberException extends RuntimeException{    //自定义异常\n    public IllegalNumberException(){}\n    public IllegalNumberException(String msg){\n        super(msg);\n    }\n}复制代码结果：\n\n\n\n在这个程序当中，我自定义了一个运行时异常，IllegalNumberException。需求是当被除数或除数>100或<0时抛出。所以说我在divide()方法中进行了判断，如果被除数或除数>100或<0，那么就抛出我自定义的这个异常。\n\n这项技术在开发当中是十分常用的，希望大家可以熟悉。\n\n本章小结\n自定义异常可以使程序有自己的专门异常自定义异常的方式是：定义一个类，继承Exception或RuntimeException要在这个类当中添加一个接受String的构造方法，通过super传入这个自定的异常可以像之前的异常一样抛出、捕捉，或声明\n\n\n\n以下为Java中常见的Runtime异常以及其的描述：\n\n 异常类名 描述\n java.lang.ArithmeticException 当数学运算问题发生，该异常抛出。\n java.lang.ArrayStoreException\n 当运行时发现数组中的元素与其类型不匹配该异常抛出。\nObject[] arr = new int[5];\narr[0] = \"abc\"; //类型不匹配复制代码 java.lang.ClassCastException 当对对象进行向下转换时，发现类型不匹配，该异常抛出。\nObject obj = \"abc\";\nInteger i = (Integer)obj; //类型不匹配复制代码 java.lang.\nConcurrentModificationException 当一个集合正在被迭代器迭代时，此时若通过集合的方法修改集合的元素，会导致混乱和安全隐患，该异常抛出。\n java.lang.\nIllegalArgumentException 当方法不接收其传入的参数时，该异常抛出。\n java.lang.\nIndexOutOfBoundsException 当访问数组某个角标的元素时，该角标超出了数组的长度，该异常抛出。\nint[] arr = {1,2,3,4,5};\nSystem.out.println(arr[10]);  //arr没有第10个角标复制代码 java.lang.\nNegativeArraySizeException\n 当动态初始化一个数组时，其的长度被设置为负数，该异常抛出。\nint[] arr = new int[-1];复制代码java.lang.\nNoSuchElementException\n 当通过集合的方法或迭代器迭代的方式访问集合中的元素时，若集合没有这个元素，该异常抛出。\njava.lang.NullPointerException\n当使用一个值为null的实例调用方法/字段时，该异常抛出。 \n\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "duang2333",
            "timestamp": 1449489540,
            "txt_content": "这么好的教程居然没人"
        },
        {
            "author": "291837341",
            "timestamp": 1449567600,
            "txt_content": "楼主你好我想请问一下周目来获取 发射器里的东西"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1449719760,
            "txt_content": "\ntry {\nthrow new Throable();\n} catch(Throwable t) {\n}\n复制代码\n\n据说Throwable不能被捕捉……"
        },
        {
            "author": "辅助啊",
            "timestamp": 1449727440,
            "txt_content": "好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好\n好好好好好好好好好好好好好好好好好好好好好好好好讚讚讚讚讚讚讚讚讚好好好好  \n好好好好好好好好好好好好好好好好好好讚讚讚讚讚讚讚讚讚讚讚讚讚讚讚好好好好\n好好好好好好好好好好好好好好好讚讚讚讚讚讚讚讚讚讚讚讚讚讚讚讚讚讚好好好好\n好好好好好好好好好好好讚讚讚讚好讚讚讚讚讚讚讚讚讚讚讚好好好好好好好好好好\n好好好好好好好好讚讚讚讚讚讚讚好讚讚讚好好讚讚讚讚讚好好好好好好好好好好好\n好好好讚讚讚讚讚讚讚讚讚讚讚讚好好好好好好讚讚讚讚好好好好好好好好好好好好\n好讚讚讚讚讚讚讚讚讚讚讚讚讚讚好好好好好好讚讚讚讚好好好好好好好好好好好好\n好讚讚讚讚讚讚讚讚讚讚讚讚好好好好好好好讚讚讚讚讚讚讚讚讚讚讚好好好好好好\n好讚讚讚讚讚讚讚讚讚讚讚讚好好好好好好讚讚讚讚讚讚讚讚讚讚讚讚讚好好好好好\n好好讚讚讚讚讚讚讚讚讚讚好好好好好讚讚讚讚讚好好好讚讚讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好好讚讚讚讚好好好好好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好好讚讚好好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好好讚讚讚讚好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好好讚讚讚讚好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好好讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好好讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好讚讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好讚讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好讚讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚讚好讚讚讚讚好好讚讚讚讚讚好好好好好\n好好好好好好好好讚讚讚讚好好好好讚讚讚好好讚讚讚讚好好讚讚讚讚讚好好好好好\n好好讚讚好好好讚讚讚讚讚好好好好讚讚讚好好讚讚讚好好好讚讚讚讚讚好好好好好\n好好讚讚讚讚讚讚讚讚讚讚好好好好好讚讚好好讚讚好好好好讚讚讚讚讚好好好好好\n好好好讚讚讚讚讚讚讚讚讚好好好好好好好好讚讚讚好好好好讚讚讚讚好好好好好好\n好好好好好讚讚讚讚讚讚讚好好好好好好好好讚讚讚好讚讚讚讚好好好好好好好好好\n好好好好好好讚讚讚讚讚讚好好好好好好好讚讚讚讚好好讚讚讚讚讚好好好好好好好\n好好好好好好好好好讚讚讚好好好好好好讚讚讚讚讚好好好讚讚讚讚讚讚讚好好好好\n好好好好好好好好好好好好好好好好讚讚讚讚讚讚好好好好好讚讚讚讚讚讚好好好好\n好好好好好好好好好好好好好好好讚讚讚讚讚讚好好好好好好讚讚讚讚讚讚讚好好好\n好好好好好好好好好好好好好好讚讚讚讚讚好好好好好好好好好讚讚讚讚讚讚好好好\n好好好好好好好好好好好好好讚讚讚讚讚好好好好好好好好好好好讚讚讚讚好好好好\n好好好好好好好好好好好好讚讚讚好好好好好好好好好好好好好好好讚讚讚好好好好\n好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好好"
        },
        {
            "author": "zzzzzzzabczz",
            "timestamp": 1451998260,
            "txt_content": "幽浮早上好\n学习ing……\n啃了啃《Thinking in java》\n发现还是你这个更好懂{:10_522:}\n。\n如果我学完你这个是不是就能看懂那本书了？"
        },
        {
            "author": "ufof",
            "timestamp": 1452003960,
            "txt_content": "zzzzzzzabczz 发表于 2016-1-5 04:51\n幽浮早上好\n学习ing……\n啃了啃《Thinking in java》\n学完了我的这个的确还是有提高的空间。读书的话是会更加懂点。"
        },
        {
            "author": "947132885",
            "timestamp": 1453632720,
            "txt_content": "恩，我发现现在java8中，除数为0的话会得到infinity，就是无限的意思...."
        },
        {
            "author": "947132885",
            "timestamp": 1453633620,
            "txt_content": "947132885 发表于 2016-1-24 18:52\n恩，我发现现在java8中，除数为0的话会得到infinity，就是无限的意思....\n额，好吧，看来刚才是个巧合，换成int果然不行。"
        },
        {
            "author": "2478003816",
            "timestamp": 1454294040,
            "txt_content": "学不会这个是不是就对制作mod完全No way     说实话我这个菜鸟对这些还不是很了解   我还要去了解这里面讲的一些基础   Exception   Error我也是认为没什么区别，没想到有这么大区别。啊心累   不知道你学这些学了多久    我希望我自己不是三分钟热度！"
        },
        {
            "author": "ufof",
            "timestamp": 1454320260,
            "txt_content": "2478003816 发表于 2016-1-31 18:34\n学不会这个是不是就对制作mod完全No way     说实话我这个菜鸟对这些还不是很了解   我还要去了解这里面讲 ...\n关于数学其实要求不大，会四则运算就可以了，如果会二进制的话更好（可以了解底层运算机制）；英语词汇量能到初中水平就行，像什么关键字这些都是实实在在的单词。\n\n如果不想要半途而废的话可以找一些更有趣的方法来学习，本人推荐毕向东的Java视频，讲的幽默有趣，你可以去看看。"
        }
    ]
}