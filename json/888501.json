{
    "title": "【第二章】Scala从入门到入土 - 类、特质、单例、模式匹配及代数数据类型",
    "author": "yuxuanchiadm",
    "replyCount": 0,
    "timestamp": 1563626460,
    "txt_content": " 本帖最后由 yuxuanchiadm 于 2019-7-25 04:12 编辑 \n\n【索引贴】https://www.mcbbs.net/thread-887515-1-1.html\n\n模板\n\n[ruby=Class]类[/ruby]、[ruby=Trait]特质[/ruby]、[ruby=Object]单例[/ruby]，都是以称作[ruby=Template]模板[/ruby]的方式来进行定义的，语法如下例所示：\nAnyRef {}\nAnyRef {\n  val name: String\n}\nAnyRef\nEquals {\n  override def canEqual(that: Any): Boolean = this.getClass == that.getClass\n}\nAnyRef with Equals\nEnumeration(1) {\n  val Foo, Bar = Value\n}复制代码其中，模板头部为[ruby=Parent]父类[/ruby]及其[ruby=Constructor]构造器[/ruby]的调用，其后跟随零个或多个with关键字加上特质的引用，再之后的大括号内为[ruby=Template Body]模板体[/ruby]，包含零个或多个模板的[ruby=Member]成员[/ruby]\n\n子类型、继承及动态分配\n\nScala作为同时支持FP和OO范式的编程预言，拥有[ruby=Subtyping]子类型[/ruby]的概念。当类型T是类型U的[ruby=Subtype]子类[/ruby]时，任何T类型的值可以被安全的用于需要U类型的值的上下文内，其子类型关系写作：T <: U。[ruby=Inheritance]继承[/ruby]用于在子类型中重复使用使用父类型的定义，子类型可以[ruby=Override]覆盖[/ruby]父类型的定义，并提供新的定义。对用任何U类型的值，调用其成员函数会通过[ruby=Dynamic Dispatch]动态分配[/ruby]找到其实际的类型T，并从T中查找对应的成员函数。可以通过this关键字引用当前对象，super关键字引用实际父类的成员。\n\n修饰符\n\n[ruby=Modifier]修饰符[/ruby]可以决定模板内成员的可访问性以及其形式。其中访问修饰符有2种：\nprivate：只能在当前模板内或其[ruby=Companion Object]伴生对象[/ruby]内被访问。protected：只能在当前模板内或以其为父类的子类内，或上述类的伴生对象内被访问。\n其余的修饰符包括：override：当前成员必须覆盖父类成员。abstract：当前成员为抽象成员，用于此类成员的类无法被直接[ruby=instantiate]实例化[/ruby]，需要由父类覆盖实现。final：当前成员无法由父类覆盖，如果是类则无法被继承。sealed：当前类只能在当前源文件内被继承。lazy：当前成员的值将只在第一次被访问时才创建。\n\n类的定义\n\n类用于在Scala中定义新的数据类型，语法如下例所示：\nclass Foo\nclass Foo()\nclass Foo(name: String) {\n  def this() = this(\"\")\n}\nclass Foo(val name: String, var count: Int)\nclass Foo private (name: String)\nclass Foo extends AnyVal\nclass Foo(name: String) {\n  override def toString: String = name\n}\nclass Bar extends Foo(\"bar\")复制代码类可以有零个或多个构造器，其中在类的头部定义的构造器为[ruby=Primary Constructor]主构造器[/ruby]，可以用访问修饰符对其可见性进行修饰，其余定义在类的模板内用this关键字定义的构造器为[ruby=Additional Constructor]辅助构造器[/ruby]。\n\n特质的定义\n\n特质用于[ruby=Mixin]混入[/ruby]到其他类型之中，特质不能有构造参数，且不需要向父类的构造器传入参数，语法如下例所示：\ntrait Foo\ntrait Foo {\n  def foo: String\n}\ntrait Foo extends AnyRef\ntrait Bar extends Foo\ntrait Bar extends AnyRef with Foo\n复制代码特质实际的父类在其定义时是不知道的，只有在其混入实际的类型时才能决定，其trait内的super关键字指向的是实际的父类。\n\n单例的定义\n\n单例是Scala中通过模板定义的只有一个值的类型，当其有同名的其他类的定义时，叫做其伴生对象，语法如下例所示：\nobject Foo\nobject Foo extends AnyRef\nobject Foo {\n  def getName: String = \"Foo\"\n}\n复制代码\n模式匹配\n\n[ruby=Pattern Match]模式匹配[/ruby]用于测试类型T的值x是否符合定义的[ruby=Pattern]模式[/ruby]，并将模式内的变量绑定到匹配的值上。模式匹配可以对字面量、元组、值的类型、[ruby=Case Class]样例类[/ruby]的构造器等模式进行匹配，语法如下例所示：\n0 match {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case _ => \"nonzero\"\n}\n(\"foo\", 0) match {\n  case (name, count) => \"{name: \" ++ name ++ \", count: \" ++ count.toString ++ \"}\"\n}\n(1: AnyVal) match {\n  case _: Int => \"Int\"\n  case _: Float => \"Float\"\n  case _ => \"Other\"\n}\nOption(\"bar\") match {\n  case Some(name) => name\n  case None => \"\"\n}复制代码模式匹配也可以直接在匿名函数中进行，语法如下例所示：\nval foo: Int => String = {\n  case 0 => \"zero\"\n  case 1 => \"one\"\n  case _ => \"nonzero\"\n}复制代码\n代数数据类型\n\n[ruby=Algebraic Datatype]代数数据类型[/ruby]指以[ruby=Product Type]积类型[/ruby]与[ruby=Sum Type]和类型[/ruby]为基础的数据类型。在Scala中积类型是Tuple，和类型是Either，Unit作为[ruby=Unit Type]单元类型[/ruby]，Nothing作为[ruby=Bottom Type]底类型[/ruby]，构成了代数数据类型最基础的组件。其中单元类型可以看作是零元的积类型，底类型可以看作是零元的和类型，因为1是乘法的单位元，0是加法的单位元。习惯上，将积类型简写为A × B，和类型简写为A + B，单元类型简写为1，底类型简写为0。在Scala中可以通过样例类以及子类型来定义代数数据类型，习惯上是先定义和，再定义积，因为乘法的优先级高于加法，例如下面通过代数数据类型重新定义了布尔值类型：（Bool = 1 + 1）\nsealed abstract class Bool\ncase class True() extends Bool\ncase class False() extends Bool复制代码对于零元的积可以用单例类型来替代：\nsealed abstract class Bool\ncase object True extends Bool\ncase object False extends Bool复制代码代数数据类型可以被[ruby=Parameterize]参数化[/ruby]，关于[ruby=Parameterized Type]参数化类型[/ruby]以及[ruby=Type Constructor]类型构造器[/ruby]将在第三章讲解，例如：（Option(a) = 1 + a）\nsealed abstract class Option[A]\ncase class None[A]() extends Option[A]\ncase class Some[A](value: A) extends Option[A]复制代码和类型可以以如下方式定义，注意Bool实际上等价于Either[Unit, Unit]，Option[A]实际上等价于Either[Unit, A]，任意类型A实际上等价于Either[Bottom, A]：（Either(a, b) = a + b）\nsealed abstract class Either[A, B]\ncase class Left[A, B](left: A) extends Either[A, B]\ncase class Right[A, B](right: B) extends Either[A, B]复制代码甚至可以引用自身，这种数据类型叫做[ruby=Recursive Datatype]递归数据类型[/ruby]，例如：（List(a) = 1 + a × List(a)）\nsealed abstract class List[A]\ncase class Nil[A]() extends List[A]\ncase class Cons[A](head: A, tail: List[A])复制代码差点忘了传统，来用代数数据类型定义一个[ruby=Peano Number]皮亚诺数[/ruby]，注意Nat实际上等价于List[Unit]：（Nat = 1 + Nat）\nsealed abstract class Nat\ncase object Zero extends Nat\ncase class Succ(pred: Nat) extends Nat复制代码使用样例类定义代数数据类型可以：自动生成伴生对象的apply和unapply函数、方便进行模式匹配、自动生成equals、hashCode以及toString函数。需要注意的是Scala的底类型只能使用Nothing，因为Nothing类型的值因为Subtyping的原因，可以被[ruby=Coerce]转换[/ruby]为任意类型的值，等价于[ruby=PNC]无矛盾律[/ruby]，而在Scala中无法对没有子类的sealed类型的值进行模式匹配。\n",
    "replies": []
}