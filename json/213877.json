{
    "title": "[cpp/php/java][全集]  服务器实时状态获取（全部开源） by Sorta",
    "author": "Sorta",
    "replyCount": 29,
    "timestamp": 1388835840,
    "txt_content": " 本帖最后由 Sorta 于 2014-1-4 19:50 编辑 \n\n特别感谢：Sorta（我自己） 、 Brick（好基友）\nphp版本  经过BRICK的授权 转发了一下。。。\n               千万别直接调用 要定时socket存到数据库 然后读取数据库的 要不然会崩\n/***********************************\n      Copyright Sorta&Brick 2014\n***********************************/\n\nfunction QueryMinecraft( $IP, $Port = 25565, $Timeout = 2 )\n{\n$Socket = Socket_Create( AF_INET, SOCK_STREAM, SOL_TCP );\n\nSocket_Set_Option( $Socket, SOL_SOCKET, SO_SNDTIMEO, array( 'sec' => (int)$Timeout, 'usec' => 0 ) );\nSocket_Set_Option( $Socket, SOL_SOCKET, SO_RCVTIMEO, array( 'sec' => (int)$Timeout, 'usec' => 0 ) );\n\nif( $Socket === FALSE || @Socket_Connect( $Socket, $IP, (int)$Port ) === FALSE )\n{\nreturn FALSE;\n}\n\nSocket_Send( $Socket, \"\\xFE\\x01\", 2, 0 );\n$Len = Socket_Recv( $Socket, $Data, 512, 0 );\nSocket_Close( $Socket );\n\nif( $Len < 4 || $Data[ 0 ] !== \"\\xFF\" )\n{\nreturn FALSE;\n}\n\n$Data = SubStr( $Data, 3 );\n$Data = iconv( 'UTF-16BE', 'UTF-8', $Data );\n\nif( $Data[ 1 ] === \"\\xA7\" && $Data[ 2 ] === \"\\x31\" )\n{\n$Data = Explode( \"\\x00\", $Data );\nreturn Array(\n'HostName'   => $Data[ 3 ],\n'Players'    => IntVal( $Data[ 4 ] ),\n'MaxPlayers' => IntVal( $Data[ 5 ] ),\n'Protocol'   => IntVal( $Data[ 1 ] ),\n'Version'    => $Data[ 2 ],\n);\n}\n\n$Data = Explode( \"\\xA7\", $Data );\nreturn Array(\n'HostName'   => SubStr( $Data[ 0 ], 0, -1 ),\n'Players'    => isset( $Data[ 1 ] ) ? IntVal( $Data[ 1 ] ) : 0,\n'MaxPlayers' => isset( $Data[ 2 ] ) ? IntVal( $Data[ 2 ] ) : 0,\n'Protocol'   => 0,\n'Version'    => '1.3',\n);\n}复制代码\n\n接下来是使用方法    再不会用的话你就可以xx了\n\n$query = QueryMinecraft(\"ip\");\necho $query[HostName].'<br>';\necho $query[Players].'<br>';\necho $query[MaxPlayers].'<br>';\necho $query[Version];\n//不解释了 最基本的，，\n复制代码\n\nCPP版本  本人原创 请自行享用 dododoooo\n\nwin iconv lib\nhttp://download.csdn.net/detail/mxwtws/4310097复制代码\n.h\n#include \"winsock2.h\"  \n#pragma comment(lib, \"ws2_32.lib\")  \n\n#include \"iconv.h\"\n#pragma comment(lib, \"iconv.lib\") \n\nusing namespace std;  \n#include <iostream>复制代码class CCodeConverter\n{\n public:\n    CCodeConverter(const char * fromCode, const char * toCode)\n    {\n        hCodeConverter=iconv_open(toCode, fromCode);\n    }\n\n\n    ~CCodeConverter()\n    {\n        iconv_close(hCodeConverter);\n    }\n\n\n    //进行转换\n    int convert(char * srcBuf, int srcLen, char * destBuf, int destLen)\n    {\n        //返回转换的字符个数\n        int nConv=iconv(hCodeConverter, &srcBuf, (size_t *)&srcLen, &destBuf, (size_t *)&destLen);\n\n\n        //如果错误，则获取错误码\n        nErr=errno;\n\n\n        return nConv;\n    }\n\n\n    //获取错误信息\n    int getErrInfo()\n    {\n        switch(nErr)\n            {\n            case E2BIG:\n                {\n                    printf(\"errno:E2BGI（OutBuf空间不够）\\n\");\n                    break;\n                }\n            case EILSEQ:\n                {\n                    printf(\"errno:EILSEQ（InBuf多字节序无效）\\n\");\n                    break;\n                }\n            case EINVAL:\n                {\n                    printf(\"errno:EINVAL（有残留的字节未转换）\\n\");\n                    break;\n                }\n            default:\n                break;\n            }\n\n\n        return nErr;\n    }\n\n\n private:\n    //转换句柄\n    iconv_t hCodeConverter;\n    int nErr;\n};复制代码int _tmain(int argc, _TCHAR* argv[])\n{\n/***********************************\n      Copyright Sorta 2014\n    30分钟搞定 - 我真慢。。\n***********************************/\n        int err;\n        WORD versionRequired;\n        WSADATA wsaData;\n        versionRequired=MAKEWORD(1,1);\n        err=WSAStartup(versionRequired,&wsaData);//协议库的版本信息\n\n        if (!err)\n        {\n                printf(\"客户端嵌套字已经打开!\\n\");\n        }else{\n                printf(\"客户端的嵌套字打开失败!\\n\");\n                return 0;//结束\n        }\n\n        SOCKET clientSocket=socket(AF_INET,SOCK_STREAM,0);\n        SOCKADDR_IN clientsock_in;\n        clientsock_in.sin_addr.S_un.S_addr=inet_addr(\"116.255.228.131\");//自己看着改\n        clientsock_in.sin_family=AF_INET;\n        clientsock_in.sin_port=htons(25565);//自己看着改吧\n        \n        connect(clientSocket,(SOCKADDR*)&clientsock_in,sizeof(SOCKADDR));//开始连接\n        \n        send(clientSocket,\"\\xFE\\x01\",3,0);\n\n        char receiveBuf[512];\n        int len = recv(clientSocket,receiveBuf,513,0);//得到了\n        closesocket(clientSocket);\n        WSACleanup();\n        //关闭socket开始处理数据 哔哔哔\n\n        //这段看一下 比我想的做的时间要长。。\n        //浪费了10分钟。。\n        //printf(\"%s\\n\",receiveBuf);//打印不出来。。\n\n        if(len < 4 || receiveBuf[0] != '\\xFF')\n        {\n                printf(\"失败。。哔哔哔\\n\");\n                return FALSE;\n        }\n\n        for (int i = 3;i <512;i++)\n        {\n                receiveBuf[i-3] = receiveBuf[i];\n        }\n\n//困了 剩下的懒得写了，，恩，你们自己写完吧\n//用iconv转一下ma 分割一下 然后获取一下信息 ok.......\n\n        system(\"pause\");\n        return 0;  \n}复制代码\nJava 这个比c++省事多了 （喜欢~）  这个是github上的 和我无关 看起来应该可以使用\n使用方法\nimport query.*;\nMCQuery mcQuery = new MCQuery(\"my.server.domain\", 25565);\nQueryResponse response = mcQuery.basicStat();\nint players = response.getOnlinePlayers();复制代码MCQuery.javapackage query;\n\nimport java.net.*;\n\n/**\n * A class that handles Minecraft Query protocol requests\n * \n * @author Ryan McCann\n */\npublic class MCQuery\n{\n        final static byte HANDSHAKE = 9;\n        final static byte STAT = 0;\n        \n        String serverAddress = \"localhost\";\n        int queryPort = 25565; // the default minecraft query port\n        \n        int localPort = 25566; // the local port we're connected to the server on\n        \n        private DatagramSocket socket = null; //prevent socket already bound exception\n        private int token;\n        \n        public MCQuery(){} // for testing, defaults to \"localhost:25565\"\n        public MCQuery(String address)\n        {\n                this(address, 25565);\n        }\n        public MCQuery(String address, int port)\n        {\n                serverAddress = address;\n                queryPort = port;\n        }\n        \n        // used to get a session token\n        private void handshake()\n        {\n                QueryRequest req = new QueryRequest();\n                req.type = HANDSHAKE;\n                req.sessionID = generateSessionID();\n                \n                int val = 11 - req.toBytes().length; //should be 11 bytes total\n                byte[] input = ByteUtils.padArrayEnd(req.toBytes(), val);\n                byte[] result = sendUDP(input);\n                \n                token = Integer.parseInt(new String(result).trim());\n        }\n\n        /**\n         * Use this to get basic status information from the server.\n         * @return a <code>QueryResponse</code> object\n         */\n        public QueryResponse basicStat()\n        {\n                handshake(); //get the session token first\n\n                QueryRequest req = new QueryRequest(); //create a request\n                req.type = STAT;\n                req.sessionID = generateSessionID();\n                req.setPayload(token);\n                byte[] send = req.toBytes();\n                \n                byte[] result = sendUDP(send);\n                \n                QueryResponse res = new QueryResponse(result, false);\n                return res;\n        }\n        \n        /**\n         * Use this to get more information, including players, from the server.\n         * @return a <code>QueryResponse</code> object\n         */\n        public QueryResponse fullStat()\n        {\n//                basicStat() calls handshake()\n//                QueryResponse basicResp = this.basicStat();\n//                int numPlayers = basicResp.onlinePlayers; //TODO use to determine max length of full stat\n                \n                handshake();\n                \n                QueryRequest req = new QueryRequest();\n                req.type = STAT;\n                req.sessionID = generateSessionID();\n                req.setPayload(token);\n                req.payload = ByteUtils.padArrayEnd(req.payload, 4); //for full stat, pad the payload with 4 null bytes\n                \n                byte[] send = req.toBytes();\n                \n                byte[] result = sendUDP(send);\n                \n                /*\n                 * note: buffer size = base + #players(online) * 16(max username length)\n                 */\n                \n                QueryResponse res = new QueryResponse(result, true);\n                return res;\n        }\n        \n        private byte[] sendUDP(byte[] input)\n        {\n                try\n                {\n                        while(socket == null)\n                        {\n                                try {\n                                        socket = new DatagramSocket(localPort); //create the socket\n                                } catch (BindException e) {\n                                        ++localPort; // increment if port is already in use\n                                }\n                        }\n                        \n                        //create a packet from the input data and send it on the socket\n                        InetAddress address = InetAddress.getByName(serverAddress); //create InetAddress object from the address\n                        DatagramPacket packet1 = new DatagramPacket(input, input.length, address, queryPort);\n                        socket.send(packet1);\n                        \n                        //receive a response in a new packet\n                        byte[] out = new byte[1024]; //TODO guess at max size\n                        DatagramPacket packet = new DatagramPacket(out, out.length);\n                        socket.setSoTimeout(500); //one half second timeout\n                        socket.receive(packet);\n                        \n                        return packet.getData();\n                }\n                catch (SocketException e)\n                {\n                        e.printStackTrace();\n                }\n                catch (SocketTimeoutException e)\n                {\n                        System.err.println(\"Socket Timeout! Is the server offline?\");\n                        //System.exit(1);\n                        // throw exception\n                }\n                catch (UnknownHostException e)\n                {\n                        System.err.println(\"Unknown host!\");\n                        e.printStackTrace();\n                        //System.exit(1);\n                        // throw exception\n                }\n                catch (Exception e) //any other exceptions that may occur\n                {\n                        e.printStackTrace();\n                }\n                \n                return null;\n        }\n        \n        private int generateSessionID()\n        {\n                /*\n                 * Can be anything, so we'll just use 1 for now. Apparently it can be omitted altogether.\n                 * TODO: increment each time, or use a random int\n                 */\n                return 1;\n        }\n        \n        @Override\n        public void finalize()\n        {\n                socket.close();\n        }\n        \n        //debug\n        static void printBytes(byte[] arr)\n        {\n                for(byte b : arr) System.out.print(b + \" \");\n                System.out.println();\n        }\n        static void printHex(byte[] arr)\n        {\n                System.out.println(toHex(arr));\n        }\n        static String toHex(byte[] b)\n        {\n                String out = \"\";\n                for(byte bb : b)\n                {\n                        out += String.format(\"%02X \", bb);\n                }\n                return out;\n        }\n        \n        //Testing\n        public static void main(String args[])\n        {\n                MCQuery mc = new MCQuery();\n                \n                System.out.println(mc.basicStat().toString());\n                System.out.println(mc.basicStat().asJSON());\n                System.out.println(\"=====================\");\n                System.out.println(mc.fullStat().toString());\n                System.out.println(mc.fullStat().asJSON());\n        }\n}\n复制代码ByteUtils.java\npackage query;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.util.ArrayList;\n\n/**\n * Contains various utility methods for manipulating bytes and byte arrays\n * \n * @author Ryan McCann\n */\npublic class ByteUtils\n{\n        /**\n         * Creates and returns a new array with the values of the original from index <code>a</code> to index <code>b</code>\n         * and of size <code>(b-a)</code>.\n         * @param in input array\n         * @param a first index\n         * @param b last index\n         * @return a new array based on the desired range of the input\n         */\n        public static byte[] subarray(byte[] in, int a, int b)\n        {\n                if (b - a > in.length) return in;// TODO better error checking\n\n                byte[] out = new byte[(b - a) + 1];\n\n                for (int i = a; i <= b; i++)\n                {\n                        out[i - a] = in[i];\n                }\n                return out;\n        }\n        \n        /**\n         * Functions similarly to the standard java <code>String.trim()</code> method (except that null bytes (0x00),\n         * instead of whitespace, are stripped from the beginning and end). If the input array alread has no leading/trailing null bytes,\n         * is returned unmodified.\n         * \n         * @param arr the input array\n         * @return an array without any leading or trailing null bytes\n         */\n        public static byte[] trim(byte[] arr)\n        {\n                if(arr[0]!=0 && arr[arr.length]!=0) return arr; //return the input if it has no leading/trailing null bytes\n                \n                int begin=0, end=arr.length;\n                for(int i=0; i<arr.length; i++) // find the first non-null byte \n                {\n                        if(arr[i] != 0) {\n                                begin = i;\n                                break;\n                        }\n                }\n                for(int i=arr.length-1; i>=0; i--) //find the last non-null byte\n                {\n                        if(arr[i] != 0) {\n                                end = i;\n                                break;\n                        }\n                }\n                \n                return subarray(arr, begin, end);\n        }\n        \n        /**\n         * Spits the input array into separate byte arrays. Works similarly to <code>String.split()</code>, but always splits on a null byte (0x00).\n         * @param input the input array\n         * @return a new array of byte arrays\n         */\n        public static byte[][] split(byte[] input)\n        {\n                ByteBuffer buf; //TODO\n                ByteBuffer buf2;//TODO\n                \n                ArrayList<byte[]> temp = new ArrayList<byte[]>();\n                \n                byte[][] output; //TODO be more efficient here\n                output = new byte[input.length][input.length]; //excessively large, but this is the maximum size it can be (actually, less, but it's a good upper bound)\n                int out_index = 0;\n                \n                int index_cache = 0;\n                for(int i=0; i<input.length; i++)\n                {\n                        if(input[i] == 0x00)\n                        {\n//                                output[out_index++] = subarray(input, index_cache, i-1); //store the array from the last null byte to the current one\n                                byte[] b = subarray(input, index_cache, i-1);\n                                temp.add(b);\n                                index_cache = i+1;//note, this is the index *after* the null byte\n                        }\n                }\n                //get the remaining part\n                if(index_cache != 0) //prevent duplication if there are no null bytes\n                {\n//                        output[out_index] = subarray(input, index_cache, input.length-1);\n                        byte[] b = subarray(input, index_cache, input.length-1);\n                        temp.add(b);\n                }\n                \n                output = new byte[temp.size()][input.length];\n                for(int i=0; i<temp.size(); i++)\n                {\n                        output[i] = temp.get(i);\n                }\n                \n                return output;\n        }\n        \n        /**\n         * Creates an new array of length <code>arr+amount</code>, identical to the original, <code>arr</code>,\n         * except with <code>amount</code> null bytes (0x00) padding the end.\n         * @param arr the input array\n         * @param amount the amount of byte to pad\n         * @return a new array, identical to the original, with the desired padding\n         */\n        public static byte[] padArrayEnd(byte[] arr, int amount)\n        {\n                byte[] arr2 = new byte[arr.length+amount];\n                for(int i=0; i<arr.length; i++) {\n                        arr2[i] = arr[i];\n                }\n                for(int i=arr.length; i<arr2.length; i++) {\n                        arr2[i] = 0;\n                }\n                return arr2;\n        }\n        \n        public static short bytesToShort(byte[] b)\n        {\n                ByteBuffer buf = ByteBuffer.wrap(b, 0, 2);\n                buf.order(ByteOrder.LITTLE_ENDIAN);\n                return buf.getShort();\n        }\n        \n        //Big endian !!\n        public static byte[] intToBytes(int in)\n        {\n                byte[] b;\n                b=new byte[]\n                {\n                        (byte) (in >>> 24        & 0xFF),\n                        (byte) (in >>> 16        & 0xFF),\n                        (byte) (in >>> 8        & 0xFF),\n                        (byte) (in >>> 0        & 0xFF)\n                };\n                return b;\n        }\n        \n        public static int bytesToInt(byte[] in)\n        {\n                return ByteBuffer.wrap(in).getInt(); //note: big-endian by default\n        }\n        \n}\n复制代码QueryRequest.java\n\npackage query;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\n\npublic class QueryRequest\n{\n        private ByteArrayOutputStream byteStream;\n        private DataOutputStream dataStream;\n        \n        static byte[] MAGIC = {(byte) 0xFE, (byte) 0xFD};\n        byte type;\n        int sessionID;\n        byte[] payload;\n        \n        public QueryRequest()\n        {\n                int size = 1460;\n                byteStream = new ByteArrayOutputStream(size);\n                dataStream = new DataOutputStream(byteStream);\n        }\n        public QueryRequest(byte type)\n        {\n                this.type = type;\n                //TODO move static type variables to Request\n        }\n        \n        //convert the data in this request to a byte array to send to the server\n        byte[] toBytes()\n        {\n                byteStream.reset();\n                \n                try\n                {\n                        dataStream.write(MAGIC);\n                        dataStream.write(type);\n                        dataStream.writeInt(sessionID);\n                        dataStream.write(payloadBytes());\n                }\n                catch (IOException e)\n                {\n                        e.printStackTrace();\n                }\n                \n                return byteStream.toByteArray();\n        }\n        \n        private byte[] payloadBytes()\n        {\n                if(type == MCQuery.HANDSHAKE)\n                {\n                        return new byte[]{}; //return empty byte array\n                }\n                else //(type == MCQuery.STAT)\n                {\n                        return payload;\n                }\n        }\n        \n        protected void setPayload(int load)\n        {\n                this.payload = ByteUtils.intToBytes(load);\n        }\n}\n复制代码QueryResponse.java\npackage query;\n\nimport java.util.ArrayList;\n\npublic class QueryResponse\n{\n        static byte NULL = 00;\n        static byte SPACE = 20;\n        \n        private boolean fullstat;\n        \n        //for simple stat\n        private String motd, gameMode, mapName;\n        private int onlinePlayers, maxPlayers;\n        private short port;\n        private String hostname;\n        \n        //for full stat only\n        private String gameID;\n        private String version;\n        private String plugins;\n        private ArrayList<String> playerList;\n        \n        public QueryResponse(byte[] data, boolean fullstat)\n        {\n                this.fullstat = fullstat;\n                \n                data = ByteUtils.trim(data);\n                byte[][] temp = ByteUtils.split(data);\n                \n//                if(temp.length == 6) //short stat\n                if(!fullstat)\n                {\n                        motd                        = new String(ByteUtils.subarray(temp[0], 1, temp[0].length-1));\n                        gameMode                = new String(temp[1]);\n                        mapName                        = new String(temp[2]);\n                        onlinePlayers        = Integer.parseInt(new String(temp[3]));\n                        maxPlayers                = Integer.parseInt(new String(temp[4]));\n                        port                        = ByteUtils.bytesToShort(temp[5]);\n                        hostname                = new String(ByteUtils.subarray(temp[5], 2, temp[5].length-1));\n                }\n                else //full stat\n                {\n                        motd                        = new String(temp[3]);\n                        gameMode                = new String(temp[5]);\n                        mapName                        = new String(temp[13]);\n                        onlinePlayers        = Integer.parseInt(new String(temp[15]));\n                        maxPlayers                = Integer.parseInt(new String(temp[17]));\n                        port                        = Short.parseShort(new String(temp[19]));\n                        hostname                = new String(temp[21]);\n                        \n                        //only available with full stat:\n                        gameID = new String(temp[7]);\n                        version = new String(temp[9]);\n                        plugins = new String(temp[11]);\n                        \n                        playerList = new ArrayList<String>();\n                        for(int i=25; i<temp.length; i++)\n                        {\n                                playerList.add(new String(temp[i]));\n                        }\n                }\n        }\n        \n        /**\n         * Returns a JSON string representation of the data returned from the server, useful for JSP/servlet pages with javascript.\n         * @return a JSON string\n         */\n        public String asJSON()\n        {\n                StringBuilder json = new StringBuilder();\n                json.append(\"\\'{\");\n                        json.append(\"\"motd\":\");                                                        // \"motd\":\n                        json.append('\"').append(motd).append(\"\",\");                // \"A Minecraft Server\",\n                        \n                        json.append(\"\"gamemode\":\");                                                // \"gamemode\":\n                        json.append('\"').append(gameMode).append(\"\",\");        // \"SMP\",\n                        \n                        json.append(\"\"map\":\");                                                        // \"map\":\n                        json.append('\"').append(mapName).append(\"\",\");                // \"world1\",\n                        \n                        json.append(\"\"onlinePlayers\":\");                                        // \"onlinePlayers\":\n                        json.append(onlinePlayers).append(',');                                // 0,\n                        \n                        json.append(\"\"maxPlayers\":\");                                                // \"maxPlayers\":\n                        json.append(maxPlayers).append(',');                                // 20,\n                        \n                        json.append(\"\"port\":\");                                                        // \"port\":\n                        json.append(port).append(',');                                                // 25565,\n                        \n                        json.append(\"\"host\":\");                                                        // \"hostname\":\n                        json.append('\"').append(hostname).append('\"');                // \"0.0.0.0\",\n                        \n                        if(fullstat)\n                        {\n                                json.append(',');\n                                json.append(\"\"gameID\":\");                                                // \"gameID\":\n                                json.append('\"').append(gameID).append(\"\",\");        // \"MINECRAFT\",\n                                \n                                json.append(\"\"version\":\");                                        // \"version\":\n                                json.append('\"').append(version).append(\"\",\");        // \"1.2.5\",\n                                \n                                json.append(\"\"players\":\");\n                                json.append('[');\n                                for(String player : playerList)\n                                {\n                                        json.append(\"\"\"+player+\"\"\");\n                                        if(playerList.indexOf(player) != playerList.size()-1)\n                                        {\n                                                json.append(',');\n                                        }\n                                }\n                                json.append(']');\n                        }\n                        \n                json.append(\"}\\'\");\n                \n                return json.toString();\n        }\n        \n        public String toString()\n        {\n                String delimiter = \", \";\n                StringBuilder str = new StringBuilder();\n                str.append(motd);\n                str.append(delimiter);\n                str.append(gameMode);\n                str.append(delimiter);\n                str.append(mapName);\n                str.append(delimiter);\n                str.append(onlinePlayers);\n                str.append(delimiter);\n                str.append(maxPlayers);\n                str.append(delimiter);\n                str.append(port);\n                str.append(delimiter);\n                str.append(hostname);\n                \n                if(fullstat)\n                {\n                        str.append(delimiter);\n                        str.append(gameID);\n                        str.append(delimiter);\n                        str.append(version);\n                        \n                        //plugins for non-vanilla (eg. Bukkit) servers\n                        if(plugins.length() > 0)\n                        {\n                                str.append(delimiter);\n                                str.append(plugins);\n                        }\n                        \n                        // player list\n                        str.append(delimiter);\n                        str.append(\"Players: \");\n                        str.append('[');\n                        for(String player : playerList)\n                        {\n                                str.append(player);\n                                if(playerList.indexOf(player) != playerList.size()-1)\n                                {\n                                        str.append(',');\n                                }\n                        }\n                        str.append(']');\n                }\n                \n                return str.toString();\n        }\n\n        /**\n         * @return the MOTD, as displayed in the client\n         */\n        public String getMOTD()\n        {\n                return motd;\n        }\n        \n        public String getGameMode()\n        {\n                return gameMode;\n        }\n\n        public String getMapName()\n        {\n                return mapName;\n        }\n\n        public int getOnlinePlayers()\n        {\n                return onlinePlayers;\n        }\n\n        public int getMaxPlayers()\n        {\n                return maxPlayers;\n        }\n\n        /**\n         * Returns an <code>ArrayList</code> of strings containing the connected players' usernames.\n         * Note that this will return null for basic status requests.\n         * @return An <code>ArrayList</code> of player names\n         */\n        public ArrayList<String> getPlayerList()\n        {\n                return playerList;\n        }\n        \n        //TODO getPlayers return hashmap/array/arraylist\n}\n复制代码\n\n\n\n\n\n\n恩发完了\n至于易语言的那些 就懒得说了。。\n\n加分的加分    伸手党继续伸手吧\n\n有没有版主加亮一下 写了40多分钟！！\n帅帅的版主 酷酷的版主 你在哪？\n\n",
    "replies": [
        {
            "author": "韦溪",
            "timestamp": 1388836440,
            "txt_content": "AV_Brother到此一游{:10_521:}"
        },
        {
            "author": "尘曲",
            "timestamp": 1388891760,
            "txt_content": "java那个太臃肿了。。。"
        },
        {
            "author": "Sorta",
            "timestamp": 1388894760,
            "txt_content": "尘曲 发表于 2014-1-5 11:16 \njava那个太臃肿了。。。\n呵呵   但是人家结构清晰"
        },
        {
            "author": "hsk001ufo",
            "timestamp": 1390185420,
            "txt_content": "cpp是c++么=。=话说还有PHP真不错"
        },
        {
            "author": "Csgbshgf",
            "timestamp": 1391431980,
            "txt_content": "Java看晕"
        },
        {
            "author": "~~末影少女-_-",
            "timestamp": 1391475720,
            "txt_content": "表示三种都弄不懂= =我是vb.net党"
        },
        {
            "author": "799669332",
            "timestamp": 1391615580,
            "txt_content": "=A=\nLz球Go语言版"
        },
        {
            "author": "mcmny",
            "timestamp": 1391773620,
            "txt_content": "Mcbbs有你更精彩~"
        },
        {
            "author": "萌小猫",
            "timestamp": 1391941560,
            "txt_content": "PHP没看懂...\n是吧哪个放到数据库里...?"
        },
        {
            "author": "Rhythm",
            "timestamp": 1401793620,
            "txt_content": "Brick的原版我这里还有收藏 但是联系不上他了"
        },
        {
            "author": "xueyeyule",
            "timestamp": 1406314260,
            "txt_content": "完全看不懂 只能看易语言 {:10_492:}"
        },
        {
            "author": "mingtfarc",
            "timestamp": 1406335800,
            "txt_content": "我需要易语言的"
        },
        {
            "author": "mingtfarc",
            "timestamp": 1406335800,
            "txt_content": "我需要易语言的"
        },
        {
            "author": "hlrlqy",
            "timestamp": 1406381160,
            "txt_content": "大触求原理"
        },
        {
            "author": "Tribunny",
            "timestamp": 1406907840,
            "txt_content": "注释能不能再多一点"
        },
        {
            "author": "matts8008",
            "timestamp": 1436577780,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "桃渊林",
            "timestamp": 1438008840,
            "txt_content": "不错不错，写程序正好需要，改天试试"
        },
        {
            "author": "matts8008",
            "timestamp": 1465225560,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "CraftTime",
            "timestamp": 1465283520,
            "txt_content": "java的怎么这么长。。。。。"
        },
        {
            "author": "zmdoyouknow",
            "timestamp": 1465292520,
            "txt_content": "var n = $(\".player-count\");\n    var interval = 6000;   //多久之后再次连接\n    var refresh = function() {\n        $.getJSON(\"https://mcapi.ca/query/xxx.xx.x.x:25565/players\",function(json){ \n              if (json.status !== true) {\n            // 出错显示数据\n                        $(\"#players .p1\").text('版权所有 2015-2018 栖云居');\n                        $(\"#players .p2\").text('');\n                        $(\"#players .p3\").text('');\n                        $(\".player-count\").html('');\n                } else {\n                        // 成功写入数据\n                        $(\"#players .p1\").text('在线人数:');\n                        $(\".player-count\").html(json.players.online);\n                        $(\"#players .p2\").text('地址:');\n                        $(\"#players .p3\").text('xxx.xxx.com');\n                        setTimeout(function(){ $('.player-count').removeClass('').addClass('') }, 14350);                \n                        setTimeout(function(){ $('.player-count').removeClass('').addClass('') }, 0);        \n                }\n        });复制代码\n返还json数据\n{\n    \"status\": true,\n    \"players\": {\n        \"online\": 3,\n        \"max\": 50\n    },\n    \"cache\": 1465292709\n}复制代码"
        },
        {
            "author": "云闪",
            "timestamp": 1465298160,
            "txt_content": "Sorta 发表于 2014-1-5 12:06\n呵呵   但是人家结构清晰\n话说你发的Java的似乎是Query的，然而现在没几个服务器开了Query，发一个motd包获取多好(最多再发个1.6版本的motd包，这个包我还没见到有任何Motd插件修改了它的返回信息)"
        },
        {
            "author": "0611",
            "timestamp": 1484114520,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "Yaossg",
            "timestamp": 1484134980,
            "txt_content": "hsk001ufo 发表于 2014-1-20 10:37\ncpp是c++么=。=话说还有PHP真不错\ncplusplus简称cpp"
        },
        {
            "author": "碳酸钠",
            "timestamp": 1486551000,
            "txt_content": "我第八行报错，我是直接复制粘贴的报错为Fatal error: Call to undefined function socket_create() in D:\\phpStudy\\WWW\\text\\MC.PHP on line 8，麻烦帮我看一下"
        },
        {
            "author": "碳酸钠",
            "timestamp": 1486551000,
            "txt_content": "我第八行报错，我是直接复制粘贴的报错为Fatal error: Call to undefined function socket_create() in D:\\phpStudy\\WWW\\text\\MC.PHP on line 8，麻烦帮我看一下"
        },
        {
            "author": "jnworld",
            "timestamp": 1486553760,
            "txt_content": "java的三百行不知道你要说什么系列"
        },
        {
            "author": "cp666",
            "timestamp": 1554345600,
            "txt_content": "java的会报空指针"
        },
        {
            "author": "RainIFunS",
            "timestamp": 1554394680,
            "txt_content": "Csgbshgf 发表于 2014-2-3 09:53\nJava看晕\n+1\n粗粗的浏览一遍基本看不懂。。\n我这种萌新还是慢慢看吧。。"
        },
        {
            "author": "猿汐",
            "timestamp": 1554443700,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽\n"
        }
    ]
}