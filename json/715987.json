{
    "title": "论A+B解法的多元化",
    "author": "子德",
    "replyCount": 0,
    "timestamp": 1501930620,
    "txt_content": "测测你的算法水平。看看你会打哪几种？\n我本来做了半个小时，然后**论坛直接把帖子吞了，我*。放几个算了。\nDijkstra+STL优先队列\n\n#include <iostream>#include <cstdio>#include <cstdlib>#include <cmath>#include <cctype>#include <climits>#include <algorithm>#include <map>#include <queue>#include <vector>#include <ctime>#include <string>#include <cstring>using namespace std;const int N=405;struct Edge {    int v,w;};vector<Edge> edge[N*N];int n;int dis[N*N];bool vis[N*N];struct cmp {    bool operator()(int a,int b) {        return dis[a]>dis;    }};int Dijkstra(int start,int end){    priority_queue<int,vector<int>,cmp> dijQue;    memset(dis,-1,sizeof(dis));    memset(vis,0,sizeof(vis));    dijQue.push(start);    dis[start]=0;    while(!dijQue.empty()) {        int u=dijQue.top();        dijQue.pop();        vis=0;        if(u==end)            break;        for(int i=0; i<edge.size(); i++) {            int v=edge.v;            if(dis[v]==-1 || dis[v]>dis+edge.w) {                dis[v]=dis+edge.w;                if(!vis[v]) {                    vis[v]=true;                    dijQue.push(v);                }            }        }    }    return dis[end];}int main(){    int a,b;    scanf(\"%d%d\",&a,&b);    Edge Qpush;    Qpush.v=1;    Qpush.w=a;    edge[0].push_back(Qpush);    Qpush.v=2;    Qpush.w=b;    edge[1].push_back(Qpush);    printf(\"%d\",Dijkstra(0,2));    return 0;}\n\nLCA\n\n#include<cstdio>                                                  //头文件#define NI 2                                                          //从来不喜欢算log所以一般用常数 不知道算不算坏习惯 因为3个节点 所以log3(当然以2为底)上取整得2struct edge{    int to,next,data;                                              //分别表示边的终点，下一条边的编号和边的权值}e[30];                                                                     //邻接表，点少边少开30是为了浪啊int v[10],d[10],lca[10][NI+1],f[10][NI+1],tot=0;      //数组开到10依然为了浪//数组还解释嘛，v表示第一条边在邻接表中的编号，d是深度，lca[x]表示x向上跳2^i的节点，f[x]表示x向上跳2^i的距离和void build(int x,int y,int z)                                      //建边{    e[++tot].to=y; e[tot].data=z; e[tot].next=v[x]; v[x]=tot;    e[++tot].to=x; e[tot].data=z; e[tot].next=v[y]; v[y]=tot;}void dfs(int x)                                                        //递归建树{    for(int i=1;i<=NI;i++)                                   //懒，所以常数懒得优化        f[x]=f[x][i-1]+f[lca[x][i-1]][i-1],        lca[x]=lca[lca[x][i-1]][i-1];                   //建树的同时进行预处理    for(int i=v[x];i;i=e.next)                              //遍历每个连接的点    {        int y=e.to;        if(lca[x][0]==y) continue;        lca[y][0]=x;                                       //小技巧：lca[x][0]即为x的父亲~~（向上跳2^0=1不就是父节点嘛）        f[y][0]=e.data;        d[y]=d[x]+1;        dfs(y);                                            //再以这个节点为根建子树【这里真的用得到嘛？？】    }}int ask(int x,int y)                                             //询问，也是关键{                                                                            if(d[x]<d[y]) {int t=x;x=y;y=t;}                  //把x搞成深的点    int k=d[x]-d[y],ans=0;    for(int i=0;i<=NI;i++)        if(k&(1<<i))                                      //若能跳就把x跳一跳            ans+=f[x],                              //更新信息            x=lca[x];    for(int i=NI;i>=0;i--)                                  //不知道能不能正着循环，好像倒着优，反正记得倒着就好了        if(lca[x]!=lca[y])                            //如果x跳2^i和y跳2^j没跳到一起就让他们跳            ans+=f[x]+f[y],            x=lca[x],y=lca[y];    return ans+f[x][0]+f[y][0];                           //跳到LCA上去（每步跳的时候都要更新信息，而且要在跳之前更新信息哦~）}int main(){    int a,b;    scanf(\"%d%d\",&a,&b);    build(1,2,a);    build(1,3,b);                                                       //分别建1 2、1 3之间的边    dfs(1);                                                                //以1为根建树    printf(\"%d\",ask(2,3));                                         //求解2 3到它们的LCA的距离和并输出}\n\n压位高精度\n\n#include <cstdio>  #include <cstring>  #include <cstdlib>  #include <iostream>  #define p 8#define carry 100000000using namespace std;  const int Maxn=50001;  char s1[Maxn],s2[Maxn];  int a[Maxn],b[Maxn],ans[Maxn];  int change(char s[],int n[])   {      char temp[Maxn];       int len=strlen(s+1),cur=0;      while(len/p)    {          strncpy(temp,s+len-p+1,p);        n[++cur]=atoi(temp);         len-=p;    }      if(len)    {        memset(temp,0,sizeof(temp));          strncpy(temp,s+1,len);          n[++cur]=atoi(temp);       }      return cur;}  int add(int a[],int b[],int c[],int l1,int l2)  {      int x=0,l3=max(l1,l2);      for(int i=1;i<=l3;i++)    {          c=a+b+x;          x=c/carry;        c%=carry;      }      while(x>0){c[++l3]=x%10;x/=10;}      return l3;}  void print(int a[],int len)  {       printf(\"%d\",a[len]);    for(int i=len-1;i>=1;i--)printf(\"%0*d\",p,a);    printf(\"\\n\");  }  int main()  {    scanf(\"%s%s\",s1+1,s2+1);    int la=change(s1,a);    int lb=change(s2,b);    int len=add(a,b,ans,la,lb);        print(ans,len);}\n\n\n最短路径\n\n#include<cstdio>using namespace std;int n,m,a,b,op,head[200009],next[200009],dis[200009],len[200009],v[200009],l,r,team[200009],pd[100009],u,v1,e;int lt(int x,int y,int z){    op++,v[op]=y;    next[op]=head[x],head[x]=op,len[op]=z;}int SPFA(int s,int f)//SPFA……{    for(int i=1;i<=200009;i++){dis=999999999;}    l=0,r=1,team[1]=s,pd=1,dis=0;    while(l!=r)    {        l=(l+1)%90000,u=team[l],pd=0,e=head;        while(e!=0)        {            v1=v[e];            if(dis[v1]>dis+len[e])            {                dis[v1]=dis+len[e];                if(!pd[v1])                {                    r=(r+1)%90000,                    team[r]=v1,                    pd[v1]=1;                }            }            e=next[e];        }     }    return dis[f];}int main(){    scanf(\"%d%d\",&a,&b);    lt(1,2,a);lt(2,3,b);//1到2为a，2到3为b，1到3即为a+b……    printf(\"%d\",SPFA(1,3));    return 0;}\n\n\n资料源自自互联网，由本人收集，纯属娱乐。\n\n",
    "replies": []
}