{
    "title": "[Bone Studio] 简单算法入门教程 #2-1",
    "author": "107874017",
    "replyCount": 10,
    "timestamp": 1556323860,
    "txt_content": " 本帖最后由 107874017 于 2019-4-27 11:09 编辑 \n\n更好的阅读体验\n\n## 0x0C 数据结构\n\n数据结构指的是相互之间存在一种或多种关系的数据元素的集合和该集合中数据元素之间的关系        \n\n你可以抽象的理解为数据结构可以维护数据以及数据之间的关系\n\n这一部分会从比较简单的数据结构一直讲到一些比较困难的数据结构\n\n你需要注意的是 这里并不会讲到**红黑树**这一数据结构 \n\n所有数据结构的教程都会以一道题来作为引子\n\n这一部分默认$n$为输入数据规模\n\n### 0x0D 链表\n\n我并没有找到链表的题 于是链表没有引子\n\n\n\n链表是一种在内存中非连续非顺序的存储结构 它与数组类似 可以储存一个元素的集合\n\n对于链表中的每一个节点 我们会维护从这个节点向下一个节点的指针 此时这是一个**单向链表**\n\n如果我们再维护从这个节点向上一个节点的指针 那么这就是一个**双向链表**\n\n![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=0dfd76b003087bf469e15fbb93ba3c49/91ef76c6a7efce1b8d7e8131ae51f3deb58f65f7.jpg)\n\n如图所示的就是一个单向链表\n\n\n\n链表**不支持**随机访问 也就是说你并不可以按照$A[i]$的方式来访问链表中的第$i$个元素\n\n也就是说 如果你想要在链表中访问第$i$个元素 你就需要从链表头开始不断向前直到找到这个元素为止\n\n链表可以**快速**进行插入删除 当你需要在当前的节点之后加入元素时 你可以直接新建一个节点 \n然后令当前节点指向新建的这个节点 再将新建的这个节点指向原本当前节点指向的节点(a->b变成a->c->b) 删除同理\n\n链表的访问效率是$O(n)$ 在确定的位置插入删除元素的效率是$O(1)$\n\n数组的访问效率是$O(1)$ 在确定的位置插入删除元素的效率是$O(n)$ （因为你需要将这个位置后的所有元素向左移或向右移）\n\n\n\n之后给出单向链表的代码 同时给出插入元素的代码\n\n```cpp\nstruct Node{\n         int val,nxt;\n}list[n];\nint cnt = 0;//当前节点总数\nvoid insert(int i,int x){//在list[i]这个节点之后插入一个值为x的节点\n    ++cnt;\n    list[cnt].val = x;list[cnt].nxt = list[i].nxt;\n    list[i].nxt = cnt;\n}\n```\n\n### 0x0E 队列\n\n和链表相同的 队列我也并没有找到适合作为引子的题\n\n\n\n队列作为先进先出(FIFO)结构，支持三个操作\n\n- 在队列的尾部加入一个元素\n- 得到队列头部的值\n- 删除队列头\n\n举一个比较现实的例子 当一群人在排队\n\n- 新来的人要加到队伍的后面\n- 队伍最前面的人会第一个被服务\n- 只有队伍最前面的人会在服务结束后离开队伍\n\n那么这就是一个比较典型的队列了\n\n这里给出一种队列的链表实现（这里我们假设队列始终不会空）：\n\n```cpp\nstruct Node{\n         int val,nxt;\n}list[n];\nint cnt = 0;//当前节点总数\nint head=0,tail=0;//当前链表的头和尾\nvoid insert(int x){//向队列中加入元素\n    list[++cnt].val = x;\n    list[tail].nxt = cnt;\n    tail = cnt;\n    if(head == 0)head = cnt;\n}\nint front(){//查询队列头的值\n        return list[head].val;\n}\nvoid pop(){//删除队列头\n        head = list[head].nxt;\n}\n```\n\n### 0x0F 栈\n\n很明显 适合放在这里的题我也找不到\n\n\n\n栈就像货架一样，放在上面的东西先被拿出来，即后进先出(LIFO) 结构，因此只能删除栈尾的元素\n\n在维护栈的时候 一般数组比链表好写\n\n```cpp\nint stack[n],tail=0;//栈和栈尾的位置\nvoid insert(int x){\n    stack[++tail] = x;\n}\nint top(){//查询栈尾\n    return stack[tail];\n}\nvoid pop(){//删除栈尾\n    tail--;\n}\n```\n\n### 0x10 堆\n\n[【模板】堆](luogu.org/problemnew/show/P3378)\n\n题目大意：\n\n你需要支持以下几种操作：\n\n1. 向**可重集**内加入一个元素\n2. 查询集合内最小值\n3. 删除集合内最小值\n\n我们认为操作次数为$n$\n\n$n\\leq10^6$\n\n\n\n首先我们考虑一个暴力算法 每次加入元素时把元素扔到数组的最后面 每次询问时扫一遍数组 每次删除时将最小值所对应的元素设为一个很大的数$inf$\n\n```cpp\nint set[1000010];\nint main(){\n        int n,cnt=0;//cnt维护当前集合内元素个数\n        cin>>n;//cin是c++的一种读入方式\n    while(n--){\n        int op;cin>>op;\n        if(op == 1){\n            int x;cin>>x;\n            set[++cnt] = x;\n        }\n        if(op == 2){\n            int ans = inf;\n            for(int i=1;i<=cnt;i++)\n                ans = min(ans,set[i]);\n                   cout<<ans<<endl;//cout为c++的输出方式 endl表示换行        \n        }\n        if(op == 3){\n            int minVal = inf,pos = 0;//pos维护最小值的位置\n            for(int i=1;i<=cnt;i++)\n                if(minVal > set[i])\n                    minVal = set[i],pos = i;\n            set[i] = inf;\n        }\n    }\n}\n```\n\n\n\n但是我们都知道这样做效率太低了 复杂度可以达到$O(n^2)$ 所以我们要找一个比较优秀的数据结构来解决这个问题\n\n于是就有了堆这种数据结构\n\n\n\n堆首先是一颗二叉树 其中的每一个节点有两个儿子：左儿子和右儿子 其中的某个儿子可以为空 也可以两个儿子都为空\n\n当一个节点的两个儿子都为空的时候 这个节点称为**叶子节点**\n\n当一个节点没有父亲的时候 这个节点称为**根节点**\n\n同时堆还需要满足对于二叉树中的每一个节点 都需要令其的值小于其左右儿子的值 此时的堆称为**小根堆** 大根堆就是反过来 其他完全一样\n\n很显然根据堆的这一性质 堆中的最小值就是根\n\n在插入一个元素的时候 首先将它插入到堆的某个叶子结点之后\n\n之后不断将这个元素和它的父节点作比较 如果这个元素小于它的父节点 就交换这两个节点\n\n直到这个元素成为了根或者比父节点大为止\n\n删除元素时首先删除根 然后令一个叶子结点为根 此时我们称这个节点为当前节点\n\n之后不断将当前节点和其左儿子比较 进行和插入元素时类似的操作即可\n\n\n\n我并不打算在这里给出堆的代码 其一是堆的代码相对较长 其二是在库中已经有堆的实现了\n\n这个实现在c++下叫做$priority\\_queue$ 翻译为优先队列\n\n优先队列可以支持以上所提到的几种操作 其内部实现也是堆\n\n在java下 优先队列是PriorityQueue \n\n由于已经有了轮子 所以并不建议自己手写堆 毕竟这个东西有一定的几率写错\n\n### 0x11 单调队列&单调栈\n\n单调队列和单调栈首先是队列和栈\n\n之后它们满足队列或栈中的元素单调递增或单调递减\n\n这一性质可以让我们搞出来很多东西\n\n[滑动窗口](luogu.org/problemnew/show/P1886)\n\n题目大意：\n\n给定一个包含了$n$个数的数列和一个正整数$k$ 你需要求出$n-k+1$个区间$[l,l+k-1]$的最大值和最小值\n\n$n\\le 10^6$\n\n\n\n我们依然可以写出来一个十分简单的暴力算法：\n\n```cpp\nint arr[maxn],minAns[maxn],maxAns[maxn];//maxn = 1000000\nint main(){\n    int n,k;cin>>n>>k;\n    for(int i=1;i<=n;i++)\n        cin>>arr[i];\n    for(int i=1;i<=n-k+1;i++){\n        minAns[i]=inf,maxAns[i]=-inf;\n        for(int j=i;j<=i+k-1;j++)\n            minAns[i] = min(minAns[i],arr[j]),\n                maxAns[i] = max(maxAns[i],arr[j]);\n    }\n    for(int i=1;i<=n-k+1;i++)\n        cout<<minAns[i]<<\" \";\n           cout<<endl;\n    for(int i=1;i<=n-k+1;i++)\n        cout<<maxAns[i]<<\" \";\n}\n```\n\n然后你仔细一算复杂度 居然达到了$O(n^2)$级别 于是你觉得问题很大\n\n\n\n我们发现在我们计算每个区间最大最小值的时候 重复地考虑了许多元素\n\n那么假如我们记录下来每一个区间有可能成为最大最小值的元素的话 是否可以做到高效率解决问题？\n\n当然可以\n\n我们以求区间最小值为例\n\n我们维护一个单调队列 这个队列需要满足从队列头到队列尾单调上升\n\n当我们加入一个元素的时候 我们将队列尾部所有大于等于这个元素的元素全部删掉\n\n当我们删除一个元素的时候 只需要判断队列头是否为这个元素即可\n\n之后队列头就是这个区间的最小值\n\n很显然我们发现这个队列里面的元素是所有有可能作为区间最小值的元素 我们只需要考虑一下怎么证明当我们删除一个元素的时候只需要删除队列头\n\n于是我们对需要删除的元素分为两种情况讨论：\n\n- 需要删除的元素是队列头\n\n这种情况就直接删除了 没什么好说的\n\n- 需要删除的元素不是队列头\n\n假如说需要删除的元素不是队列头 那么队列头一定是一个比它小的数\n\n同时我们知道删除的元素是区间最左端还要往左的那个元素\n\n于是我们知道队列头一定是在这个数之后被加入单调队列的\n\n那么按照单调队列的加入方法 这个需要删除的元素早已在加入队列头的时候被删除了 于是不需要再去管他\n\n证毕\n\n\n\n```cpp\nint queue[maxn],s=1,t=0;//s t为队列头尾\nvoid add(int x){\n    while(t >= s && x < queue[t])t--;\n    queue[++t] = x;\n}\nint front(){\n    return queue[s];\n}\nvoid pop(int x){\n    if(queue[s] == x)s++;\n}\n```\n\n### 0x12 树状数组\n\n[【模板】树状数组 1](www.luogu.org/problemnew/show/P3374)\n\n题目大意：\n\n给出一个包含$n$个数的数列 同时你需要进行m次操作 操作有两种\n\n1. 将数列中的某个数加上$k$\n2. 查询数列中$[l,r]$的和\n\n$n,m\\le10^5$\n\n\n\n我们依然先写出暴力算法的代码\n\n```cpp\nint arr[maxn];\nint main(){\n    int n,m;cin>>n>>m;\n           for(int i=1;i<=n;i++)cin>>arr[i];\n    while(m--){\n        int op,x,y;cin>>op>>x>>y;\n        if(op == 1)arr[x] += y;\n        if(op == 2){\n            int ans = 0;\n            for(;x<=y;x++)ans += arr[x];\n            cout<<ans<<endl;\n        }\n    }\n}\n```\n\n显然的 这是一个$O(nm)$的算法\n\n\n\n在讨论更快的算法前我们需要首先定义一个函数$lowbit$\n\n$lowbit(n)$表示$n$的二进制表达下最低位的1的值\n\n比如说对于$n = 10 = (1010)_2$ 它的$lowbit(n)$就应当是$2$\n\n我们当然可以从最低位开始向上枚举判断当前位是否是1 但是很明显这样做的复杂度会是$O(logn)$的\n\n我们有一个更加简单的做法\n\n首先我们将$n$的二进制翻转（即0变1 1变0 在代码中的操作为$\\text{~}n$） 之后我们会发现翻转后的二进制表达中末尾的一串0会变为一串1 最低位的1会变成0\n\n于是我们将这个翻转后的数再加上1 那么原数中最低位的1这时还是1 原数中其他位置的值在新数中都被翻转了\n\n那么。。 我们就可以直接让这两个值做二进制的与（&）操作 得到的值即为lowbit的值\n\n也就是说 $lowbit(n) = n \\& (\\text~n+1)$\n\n我们还知道将一个数翻转后加一实际上就是求这个数的补码 而这个数的补码一般就是这个数的相反数\n\n所以$lowbit(n) = n\\&-n$\n\n\n\n那么它有什么用呢？ 我们找一张图过来\n\n![img](http://p0.so.qhimgs1.com/bdr/_240_/t01b3cd94b11782f024.png)\n\n对于一个数$i$ $C[i]$就表示了区间$[i-lowbit(i)+1,i]$这段区间的和\n\n我们称$i$被$j$直接管辖 当且仅当$j$为最小的$j$使得$i\\in[j-lowbit(j)+1,j]$\n\n我们会发现这个$C$数组很像一棵树 于是这个算法叫做树状数组\n\n\n\n之后我们分两种操作讨论\n\n第一是单点修改\n\n我们会发现一个点$i$被$i+lowbit(i)$ 管辖 那么也就是说当我们修改$i$的时候 要顺便把$i+lowbit(i)$修改掉\n\n我们又发现$i+lowbit(i)$也有可能会被另一个点管辖 于是我们还需要把另一个点修改掉\n\n显然每一个点都会被管辖 那么我们在当前修改的点的下标大于$n$的时候结束就好了\n\n```cpp\nvoid modify(int pos,int v){\n    A[pos] += v;\n    while(pos <= n){\n        C[pos] += v;\n        pos += lowbit(pos);\n    }\n}\n```\n\n\n\n每一次修改时$lowbit$的值都至少为上一次修改的$lowbit$值的二倍 所以这个过程最多进行$logn$次\n\n于是修改的时间复杂度是$O(logn)$\n\n第二是区间查询\n\n或许在你看到这个操作名称的时候你想到的是查询$[l,r]$的和\n\n但是事实上树状数组只能查询$[1,x]$的和 想要查询$[l,r]$的和需要用$[1,r] - [1,l-1]$\n\n\n\n那么我们怎么查询$[1,x]$呢？ 我们发现$x$代表了$[x-lowbit(x)+1,x]$的和 那么我们把这段累加入答案\n\n之后再求出$[1,x-lowbit(x)]$就好了 直到求的区间为$[1,0]$时结束这个过程\n\n```cpp\nint query(int x){\n    int ans = 0;\n    while(x){\n        ans += C[x];\n        x -= lowbit(x);\n    }\n    return ans;\n}\n```\n\n进行查询的次数实际上就是$x$中1的个数 而我们直到这个值一定在$logx$左右\n\n于是进行查询的时间复杂度也是$O(logn)$的\n\n\n\n之后我们就得到了一个修改和查询均为$O(logn)$复杂度的优秀算法\n\n那么对于这个题 这个做法的复杂度就是$O(mlogn)$ 可以过\n\n\n\n思考： 假如我的两个操作分别为将区间内所有元素加上$k$和查询某个点的值 该怎么做?\n\n题目连接[【模板】树状数组2](luogu.org/problemnew/show/P3368)\n\n\n\n### 0x13 线段树\n\n树状数组是个好东西 可以让我们完成一些对于数列的操作\n\n但是当我们需要进行的操作比较复杂时 树状数组就可能会变得难以使用\n\n[【模板】线段树1](luogu.org/problemnew/show/P3372)\n\n题目大意：\n\n$n$个数$m$个操作\n\n1. 将区间内的每个数加上$x$\n2. 求区间内所有数的和\n\n$n,m\\le 10^5$\n\n\n\n这题当然也可以用暴力来写一个$O(nm)$的做法 不过这里不再给出代码\n\n你也可以用树状数组把每个操作的区间中的每个数都暴力进行修改操作\n\n但是这样做的复杂度高达$O(mnlogn)$ 它比暴力还慢\n\n所以我们可以换一种做法做树状数组 使得它支持区间操作和区间求和\n\n但是这与线段树并没有什么关系 如果你想要了解这个做法可以参考[这篇博客](<https://www.cnblogs.com/lcf-2000/p/5866170.html>)\n\n这道题最简单的做法是线段树\n\n\n\n线段树是一种能够在比较高效的时间内解决区间问题的数据结构\n\n首先 线段树是一颗二叉树 每一个节点表示一个区间$[l,r]$\n\n我们定义$mid = \\left|\\frac{l+r}2\\right|$\n\n那么对于一个不是叶子结点的节点 其左儿子的区间为$[l,mid]$ 右儿子的区间为$[mid+1,r]$\n\n于是线段树的深度大约在$logn$左右\n\n每个节点可以维护这个区间对应的信息 在本题中就是这个区间的和\n\n如果我们将它表示成一张图 那么它就长成这个样子\n\n![img](http://p0.so.qhimgs1.com/bdr/_240_/t016b0d2e51e372bef0.png)\n\n\n\n当我们修改一个点$i$的时候 我们可以从根开始不断递归寻找区间为$[i,i]$的叶子结点 并将路径上的所有节点维护的信息修改掉\n\n当我们查询一个点$i$的时候 我们可以递归寻找这个叶子结点 这个叶子节点的值就是答案\n\n\n\n但是如果只拿线段树来做单点修改单点查询是非常没意义的事情\n\n我们来考虑怎么快速做区间修改和区间查询\n\n以上面这颗线段树为例 假如我们需要修改区间$[3,7]$ 那么我们实际上只需要找到所有包含了这几个点的区间做修改即可\n\n然后我们写出了一段代码\n\n```cpp\nint val[maxn*10],lson[maxn*10],rson[maxn*10];\n//val表示这个节点代表的区间的和 lson和rson分别代表这个节点的左右儿子\n//线段树上最多会有大概n*4个节点 这里开到n*10只是习惯问题\nvoid modify(int rt,int l,int r,int x,int y,int v){\n    //rt是当前节点在线段树上的编号 lr是这个节点的区间 xy是操作区间 v是操作数\n    if(l == r){val[rt] += v;return;}\n    // 如果已经递归到一个点了 直接修改值就可以结束递归了\n    int mid = (l+r)>>1;//(l+r)>>1 等价于 (l+r)/2\n    if(mid >= x)modify(lson[rt],l,mid,x,y,v);\n    //如果当前节点的左儿子含有操作区间的一部分 就去递归左儿子\n    if(mid < y)modify(rson[rt],mid+1,r,x,y,v);\n    //右儿子同理\n    val[rt] = val[lson[rt]] = val[rson[rt]];\n    //当前节点的值就应该是左儿子的值加上右儿子的值\n}\n```\n\n\n\n然后我们来考虑怎么求一个区间的和\n\n再以区间$[3,7]$为例 我们可以将里面每个数搞出来然后求和 但是这没有必要\n\n因为$[3,7] = [3,3] + [4,5] + [6,7]$\n\n于是我们只需要求出这些区间的值再求和就可以了\n\n所以我们又写出了一段代码\n\n```cpp\nint query(int rt,int l,int r,int x,int y){\n    if(x <= l && r <= y)return val[rt];\n    //如果当前节点被查询区间完全包含 可以直接返回当前节点的值\n    int mid = (l+r)>>1,ans = 0;\n    if(mid >= x)ans += query(lson[rt],l,mid,x,y);\n    if(mid < y)ans += query(rson[rt],mid+1,r,x,y);\n    return ans;\n}\n```\n\n\n\n现在我们只剩下了一个问题 如果我们有原数列$raw$ 我们怎么构建出这棵线段树？\n\n所以我们又写了一段代码\n\n```cpp\nint cnt = 0;//表示节点个数\nvoid build(int &rt,int l,int r){//&是c++中的传址\n    rt = ++cnt;\n    if(l == r){val[rt] = l;return;}\n    else{\n        int mid = (l+r)>>1;\n        build(lson[rt],l,mid);\n        build(rson[rt],mid+1,r);\n        val[rt] = val[lson[rt]] + val[rson[rt]];\n    }\n}\n```\n\n\n\n之后我们需要做的是分析复杂度\n\n从最简单的build开始分析 显然build会访问所有节点 而节点数大约在$4\\times n$左右 所以build是$O(n)$的\n\n然后是query 每个查询的区间总可以分解成大约$log(r-l+1)$个区间后求和 于是复杂度是$O(logn)$的\n\n最后是modify 我们会发现按照我们的写法modify会需要覆盖包含$[l,r]$中元素的所有节点 于是这个操作的复杂度可以达到$O(n)$\n\n\n\n然后我们就发现modify让我们的操作十分不爽 它太慢了\n\n我们需要考虑一种让modify和query一样优秀的做法 能不能像query一样把操作区间也分成$logn$个小区间然后只对这几个区间进行操作呢。。？\n\n我们最大的问题是 如果将一个节点修改以后就不再递归 那么它的儿子怎么办？\n\n但是。。 如果我们在一个节点上打上一个标记 表示这个节点的所有儿子都需要加上这个标记的话。。 是不是就可以得到一个高效的算法。。？\n\n可是如果打标记以后 我要查询的区间并不完全包含这个打标记的节点 就会导致query十分麻烦\n\n那么 我们将标记下传不就好了！\n\n于是你定义$tag$为标记数组 并写出了下传标记的函数\n\n```cpp\nvoid pushdown(int rt,int l,int r){\n    if(!tag[rt])return;//如果没有标记就不用下传了\n    tag[lson[rt]] += tag[rt];tag[rson[rt]] += tag[rt];//更新左右儿子的标记\n    int mid = (l+r)>>1;\n    val[lson[rt]] += tag[rt] * (mid-l+1);\n    val[rson[rt]] += tag[rt] * (r-mid);//维护左右儿子的区间和\n}\n```\n\n并且你将modify改成了这样\n\n```cpp\nvoid modify(int rt,int l,int r,int x,int y,int v){\n    if(x <= l && r <= y){\n        tag[rt] += v;val[rt] += (r-l+1)*v;\n        return;\n    }\n    //...\n}\n\n```\n\n\n\n然后问题就来了 你应当在什么时候下传标记？\n\n很明显的标记下传少了的话会导致答案出错 但是标记下传多了只是会让算法的常数大那么一丢丢丢\n\n所以你可以直接在modify和query函数的开头下传标记\n\n复杂度$O(logn)$达成！\n\n\n\n练习：[【模板】线段树2](www.luogu.org/problemnew/show/P3373)\n\n这道题十分深入的考验了做题人对于标记的理解\n\n相信如果能做对这道题会让你对线段树的了解更加深入\n\n复制代码\n\n\n\n\n#2-1.zip\n(7.94 KB, 下载次数: 0)\n\n\n\n2019-4-27 08:15 上传\n点击文件名下载附件\n\n\n\n\n",
    "replies": [
        {
            "author": "Ariy",
            "timestamp": 1556327160,
            "txt_content": "所有题目链接都挂了<a href=\"luogu.org/problemnew/show/P3378\">【模板】堆</a>复制代码引用外链要加https://"
        },
        {
            "author": "langyo",
            "timestamp": 1556327880,
            "txt_content": "好基础啊……\n\n你可以试试土球的 Markdown 转 UUB 的转换器：https://mm2bc.ustc-zzzz.net/\n\n（效果如下）\n0x0C 数据结构\n\n数据结构指的是相互之间存在一种或多种关系的数据元素的集合和该集合中数据元素之间的关系        \n\n你可以抽象的理解为数据结构可以维护数据以及数据之间的关系\n\n这一部分会从比较简单的数据结构一直讲到一些比较困难的数据结构\n\n你需要注意的是 这里并不会讲到红黑树这一数据结构 \n\n所有数据结构的教程都会以一道题来作为引子\n\n这一部分默认$n$为输入数据规模\n\n0x0D 链表\n\n我并没有找到链表的题 于是链表没有引子\n\n链表是一种在内存中非连续非顺序的存储结构 它与数组类似 可以储存一个元素的集合\n\n对于链表中的每一个节点 我们会维护从这个节点向下一个节点的指针 此时这是一个单向链表\n\n如果我们再维护从这个节点向上一个节点的指针 那么这就是一个双向链表\n\n\n\n如图所示的就是一个单向链表\n\n链表不支持随机访问 也就是说你并不可以按照$A$的方式来访问链表中的第$i$个元素\n\n也就是说 如果你想要在链表中访问第$i$个元素 你就需要从链表头开始不断向前直到找到这个元素为止\n\n链表可以快速进行插入删除 当你需要在当前的节点之后加入元素时 你可以直接新建一个节点  然后令当前节点指向新建的这个节点 再将新建的这个节点指向原本当前节点指向的节点(a->b变成a->c->b) 删除同理\n\n链表的访问效率是$O(n)$ 在确定的位置插入删除元素的效率是$O(1)$\n\n数组的访问效率是$O(1)$ 在确定的位置插入删除元素的效率是$O(n)$ （因为你需要将这个位置后的所有元素向左移或向右移）\n\n之后给出单向链表的代码 同时给出插入元素的代码\n\nstruct Node{\n         int val,nxt;\n}list[n];\nint cnt = 0;//当前节点总数\nvoid insert(int i,int x){//在list[i]这个节点之后插入一个值为x的节点\n    ++cnt;\n    list[cnt].val = x;list[cnt].nxt = list[i].nxt;\n    list[i].nxt = cnt;\n}复制代码\n0x0E 队列\n\n和链表相同的 队列我也并没有找到适合作为引子的题\n\n队列作为先进先出(FIFO)结构，支持三个操作\n\n在队列的尾部加入一个元素得到队列头部的值删除队列头\n\n举一个比较现实的例子 当一群人在排队\n\n新来的人要加到队伍的后面队伍最前面的人会第一个被服务只有队伍最前面的人会在服务结束后离开队伍\n\n那么这就是一个比较典型的队列了\n\n这里给出一种队列的链表实现（这里我们假设队列始终不会空）：\n\nstruct Node{\n         int val,nxt;\n}list[n];\nint cnt = 0;//当前节点总数\nint head=0,tail=0;//当前链表的头和尾\nvoid insert(int x){//向队列中加入元素\n    list[++cnt].val = x;\n    list[tail].nxt = cnt;\n    tail = cnt;\n    if(head == 0)head = cnt;\n}\nint front(){//查询队列头的值\n        return list[head].val;\n}\nvoid pop(){//删除队列头\n        head = list[head].nxt;\n}复制代码\n0x0F 栈\n\n很明显 适合放在这里的题我也找不到\n\n栈就像货架一样，放在上面的东西先被拿出来，即后进先出(LIFO) 结构，因此只能删除栈尾的元素\n\n在维护栈的时候 一般数组比链表好写\n\nint stack[n],tail=0;//栈和栈尾的位置\nvoid insert(int x){\n    stack[++tail] = x;\n}\nint top(){//查询栈尾\n    return stack[tail];\n}\nvoid pop(){//删除栈尾\n    tail--;\n}复制代码\n0x10 堆\n\n【模板】堆\n\n题目大意：\n\n你需要支持以下几种操作：\n\n向可重集内加入一个元素查询集合内最小值删除集合内最小值\n\n我们认为操作次数为$n$\n\n$n\\leq10^6$\n\n首先我们考虑一个暴力算法 每次加入元素时把元素扔到数组的最后面 每次询问时扫一遍数组 每次删除时将最小值所对应的元素设为一个很大的数$inf$\n\nint set[1000010];\nint main(){\n        int n,cnt=0;//cnt维护当前集合内元素个数\n        cin>>n;//cin是c++的一种读入方式\n    while(n--){\n        int op;cin>>op;\n        if(op == 1){\n            int x;cin>>x;\n            set[++cnt] = x;\n        }\n        if(op == 2){\n            int ans = inf;\n            for(int i=1;i<=cnt;i++)\n                ans = min(ans,set[i]);\n                   cout<<ans<<endl;//cout为c++的输出方式 endl表示换行        \n        }\n        if(op == 3){\n            int minVal = inf,pos = 0;//pos维护最小值的位置\n            for(int i=1;i<=cnt;i++)\n                if(minVal > set[i])\n                    minVal = set[i],pos = i;\n            set[i] = inf;\n        }\n    }\n}复制代码\n但是我们都知道这样做效率太低了 复杂度可以达到$O(n^2)$ 所以我们要找一个比较优秀的数据结构来解决这个问题\n\n于是就有了堆这种数据结构\n\n堆首先是一颗二叉树 其中的每一个节点有两个儿子：左儿子和右儿子 其中的某个儿子可以为空 也可以两个儿子都为空\n\n当一个节点的两个儿子都为空的时候 这个节点称为叶子节点\n\n当一个节点没有父亲的时候 这个节点称为根节点\n\n同时堆还需要满足对于二叉树中的每一个节点 都需要令其的值小于其左右儿子的值 此时的堆称为小根堆 大根堆就是反过来 其他完全一样\n\n很显然根据堆的这一性质 堆中的最小值就是根\n\n在插入一个元素的时候 首先将它插入到堆的某个叶子结点之后\n\n之后不断将这个元素和它的父节点作比较 如果这个元素小于它的父节点 就交换这两个节点\n\n直到这个元素成为了根或者比父节点大为止\n\n删除元素时首先删除根 然后令一个叶子结点为根 此时我们称这个节点为当前节点\n\n之后不断将当前节点和其左儿子比较 进行和插入元素时类似的操作即可\n\n我并不打算在这里给出堆的代码 其一是堆的代码相对较长 其二是在库中已经有堆的实现了\n\n这个实现在c++下叫做$priority_queue$ 翻译为优先队列\n\n优先队列可以支持以上所提到的几种操作 其内部实现也是堆\n\n在java下 优先队列是PriorityQueue \n\n由于已经有了轮子 所以并不建议自己手写堆 毕竟这个东西有一定的几率写错\n\n0x11 单调队列&单调栈\n\n单调队列和单调栈首先是队列和栈\n\n之后它们满足队列或栈中的元素单调递增或单调递减\n\n这一性质可以让我们搞出来很多东西\n\n滑动窗口\n\n题目大意：\n\n给定一个包含了$n$个数的数列和一个正整数$k$ 你需要求出$n-k+1$个区间$[l,l+k-1]$的最大值和最小值\n\n$n\\le 10^6$\n\n我们依然可以写出来一个十分简单的暴力算法：\n\nint arr[maxn],minAns[maxn],maxAns[maxn];//maxn = 1000000\nint main(){\n    int n,k;cin>>n>>k;\n    for(int i=1;i<=n;i++)\n        cin>>arr[i];\n    for(int i=1;i<=n-k+1;i++){\n        minAns[i]=inf,maxAns[i]=-inf;\n        for(int j=i;j<=i+k-1;j++)\n            minAns[i] = min(minAns[i],arr[j]),\n                maxAns[i] = max(maxAns[i],arr[j]);\n    }\n    for(int i=1;i<=n-k+1;i++)\n        cout<<minAns[i]<<\" \";\n           cout<<endl;\n    for(int i=1;i<=n-k+1;i++)\n        cout<<maxAns[i]<<\" \";\n}复制代码\n然后你仔细一算复杂度 居然达到了$O(n^2)$级别 于是你觉得问题很大\n\n我们发现在我们计算每个区间最大最小值的时候 重复地考虑了许多元素\n\n那么假如我们记录下来每一个区间有可能成为最大最小值的元素的话 是否可以做到高效率解决问题？\n\n当然可以\n\n我们以求区间最小值为例\n\n我们维护一个单调队列 这个队列需要满足从队列头到队列尾单调上升\n\n当我们加入一个元素的时候 我们将队列尾部所有大于等于这个元素的元素全部删掉\n\n当我们删除一个元素的时候 只需要判断队列头是否为这个元素即可\n\n之后队列头就是这个区间的最小值\n\n很显然我们发现这个队列里面的元素是所有有可能作为区间最小值的元素 我们只需要考虑一下怎么证明当我们删除一个元素的时候只需要删除队列头\n\n于是我们对需要删除的元素分为两种情况讨论：\n\n需要删除的元素是队列头\n\n这种情况就直接删除了 没什么好说的\n\n需要删除的元素不是队列头\n\n假如说需要删除的元素不是队列头 那么队列头一定是一个比它小的数\n\n同时我们知道删除的元素是区间最左端还要往左的那个元素\n\n于是我们知道队列头一定是在这个数之后被加入单调队列的\n\n那么按照单调队列的加入方法 这个需要删除的元素早已在加入队列头的时候被删除了 于是不需要再去管他\n\n证毕\n\nint queue[maxn],s=1,t=0;//s t为队列头尾\nvoid add(int x){\n    while(t >= s && x < queue[t])t--;\n    queue[++t] = x;\n}\nint front(){\n    return queue[s];\n}\nvoid pop(int x){\n    if(queue[s] == x)s++;\n}复制代码\n0x12 树状数组\n\n【模板】树状数组 1\n\n题目大意：\n\n给出一个包含$n$个数的数列 同时你需要进行m次操作 操作有两种\n\n将数列中的某个数加上$k$查询数列中$[l,r]$的和\n\n$n,m\\le10^5$\n\n我们依然先写出暴力算法的代码\n\nint arr[maxn];\nint main(){\n    int n,m;cin>>n>>m;\n           for(int i=1;i<=n;i++)cin>>arr[i];\n    while(m--){\n        int op,x,y;cin>>op>>x>>y;\n        if(op == 1)arr[x] += y;\n        if(op == 2){\n            int ans = 0;\n            for(;x<=y;x++)ans += arr[x];\n            cout<<ans<<endl;\n        }\n    }\n}复制代码\n显然的 这是一个$O(nm)$的算法\n\n在讨论更快的算法前我们需要首先定义一个函数$lowbit$\n\n$lowbit(n)$表示$n$的二进制表达下最低位的1的值\n\n比如说对于$n = 10 = (1010)_2$ 它的$lowbit(n)$就应当是$2$\n\n我们当然可以从最低位开始向上枚举判断当前位是否是1 但是很明显这样做的复杂度会是$O(logn)$的\n\n我们有一个更加简单的做法\n\n首先我们将$n$的二进制翻转（即0变1 1变0 在代码中的操作为$\\text{~}n$） 之后我们会发现翻转后的二进制表达中末尾的一串0会变为一串1 最低位的1会变成0\n\n于是我们将这个翻转后的数再加上1 那么原数中最低位的1这时还是1 原数中其他位置的值在新数中都被翻转了\n\n那么。。 我们就可以直接让这两个值做二进制的与（&）操作 得到的值即为lowbit的值\n\n也就是说 $lowbit(n) = n \\& (\\text~n+1)$\n\n我们还知道将一个数翻转后加一实际上就是求这个数的补码 而这个数的补码一般就是这个数的相反数\n\n所以$lowbit(n) = n\\&-n$\n\n那么它有什么用呢？ 我们找一张图过来\n\n\n\n对于一个数$i$ $C$就表示了区间$[i-lowbit(i)+1,i]$这段区间的和\n\n我们称$i$被$j$直接管辖 当且仅当$j$为最小的$j$使得$i\\in[j-lowbit(j)+1,j]$\n\n我们会发现这个$C$数组很像一棵树 于是这个算法叫做树状数组\n\n之后我们分两种操作讨论\n\n第一是单点修改\n\n我们会发现一个点$i$被$i+lowbit(i)$ 管辖 那么也就是说当我们修改$i$的时候 要顺便把$i+lowbit(i)$修改掉\n\n我们又发现$i+lowbit(i)$也有可能会被另一个点管辖 于是我们还需要把另一个点修改掉\n\n显然每一个点都会被管辖 那么我们在当前修改的点的下标大于$n$的时候结束就好了\n\nvoid modify(int pos,int v){\n    A[pos] += v;\n    while(pos <= n){\n        C[pos] += v;\n        pos += lowbit(pos);\n    }\n}复制代码\n每一次修改时$lowbit$的值都至少为上一次修改的$lowbit$值的二倍 所以这个过程最多进行$logn$次\n\n于是修改的时间复杂度是$O(logn)$\n\n第二是区间查询\n\n或许在你看到这个操作名称的时候你想到的是查询$[l,r]$的和\n\n但是事实上树状数组只能查询$[1,x]$的和 想要查询$[l,r]$的和需要用$[1,r] - [1,l-1]$\n\n那么我们怎么查询$[1,x]$呢？ 我们发现$x$代表了$[x-lowbit(x)+1,x]$的和 那么我们把这段累加入答案\n\n之后再求出$[1,x-lowbit(x)]$就好了 直到求的区间为$[1,0]$时结束这个过程\n\nint query(int x){\n    int ans = 0;\n    while(x){\n        ans += C[x];\n        x -= lowbit(x);\n    }\n    return ans;\n}复制代码\n进行查询的次数实际上就是$x$中1的个数 而我们直到这个值一定在$logx$左右\n\n于是进行查询的时间复杂度也是$O(logn)$的\n\n之后我们就得到了一个修改和查询均为$O(logn)$复杂度的优秀算法\n\n那么对于这个题 这个做法的复杂度就是$O(mlogn)$ 可以过\n\n思考： 假如我的两个操作分别为将区间内所有元素加上$k$和查询某个点的值 该怎么做?\n\n题目连接【模板】树状数组2\n\n0x13 线段树\n\n树状数组是个好东西 可以让我们完成一些对于数列的操作\n\n但是当我们需要进行的操作比较复杂时 树状数组就可能会变得难以使用\n\n【模板】线段树1\n\n题目大意：\n\n$n$个数$m$个操作\n\n将区间内的每个数加上$x$求区间内所有数的和\n\n$n,m\\le 10^5$\n\n这题当然也可以用暴力来写一个$O(nm)$的做法 不过这里不再给出代码\n\n你也可以用树状数组把每个操作的区间中的每个数都暴力进行修改操作\n\n但是这样做的复杂度高达$O(mnlogn)$ 它比暴力还慢\n\n所以我们可以换一种做法做树状数组 使得它支持区间操作和区间求和\n\n但是这与线段树并没有什么关系 如果你想要了解这个做法可以参考这篇博客\n\n这道题最简单的做法是线段树\n\n线段树是一种能够在比较高效的时间内解决区间问题的数据结构\n\n首先 线段树是一颗二叉树 每一个节点表示一个区间$[l,r]$\n\n我们定义$mid = \\left|\\frac{l+r}2\\right|$\n\n那么对于一个不是叶子结点的节点 其左儿子的区间为$[l,mid]$ 右儿子的区间为$[mid+1,r]$\n\n于是线段树的深度大约在$logn$左右\n\n每个节点可以维护这个区间对应的信息 在本题中就是这个区间的和\n\n如果我们将它表示成一张图 那么它就长成这个样子\n\n\n\n当我们修改一个点$i$的时候 我们可以从根开始不断递归寻找区间为$[i,i]$的叶子结点 并将路径上的所有节点维护的信息修改掉\n\n当我们查询一个点$i$的时候 我们可以递归寻找这个叶子结点 这个叶子节点的值就是答案\n\n但是如果只拿线段树来做单点修改单点查询是非常没意义的事情\n\n我们来考虑怎么快速做区间修改和区间查询\n\n以上面这颗线段树为例 假如我们需要修改区间$[3,7]$ 那么我们实际上只需要找到所有包含了这几个点的区间做修改即可\n\n然后我们写出了一段代码\n\nint val[maxn*10],lson[maxn*10],rson[maxn*10];\n//val表示这个节点代表的区间的和 lson和rson分别代表这个节点的左右儿子\n//线段树上最多会有大概n*4个节点 这里开到n*10只是习惯问题\nvoid modify(int rt,int l,int r,int x,int y,int v){\n    //rt是当前节点在线段树上的编号 lr是这个节点的区间 xy是操作区间 v是操作数\n    if(l == r){val[rt] += v;return;}\n    // 如果已经递归到一个点了 直接修改值就可以结束递归了\n    int mid = (l+r)>>1;//(l+r)>>1 等价于 (l+r)/2\n    if(mid >= x)modify(lson[rt],l,mid,x,y,v);\n    //如果当前节点的左儿子含有操作区间的一部分 就去递归左儿子\n    if(mid < y)modify(rson[rt],mid+1,r,x,y,v);\n    //右儿子同理\n    val[rt] = val[lson[rt]] = val[rson[rt]];\n    //当前节点的值就应该是左儿子的值加上右儿子的值\n}复制代码\n然后我们来考虑怎么求一个区间的和\n\n再以区间$[3,7]$为例 我们可以将里面每个数搞出来然后求和 但是这没有必要\n\n因为$[3,7] = [3,3] + [4,5] + [6,7]$\n\n于是我们只需要求出这些区间的值再求和就可以了\n\n所以我们又写出了一段代码\n\nint query(int rt,int l,int r,int x,int y){\n    if(x <= l && r <= y)return val[rt];\n    //如果当前节点被查询区间完全包含 可以直接返回当前节点的值\n    int mid = (l+r)>>1,ans = 0;\n    if(mid >= x)ans += query(lson[rt],l,mid,x,y);\n    if(mid < y)ans += query(rson[rt],mid+1,r,x,y);\n    return ans;\n}复制代码\n现在我们只剩下了一个问题 如果我们有原数列$raw$ 我们怎么构建出这棵线段树？\n\n所以我们又写了一段代码\n\nint cnt = 0;//表示节点个数\nvoid build(int &rt,int l,int r){//&是c++中的传址\n    rt = ++cnt;\n    if(l == r){val[rt] = l;return;}\n    else{\n        int mid = (l+r)>>1;\n        build(lson[rt],l,mid);\n        build(rson[rt],mid+1,r);\n        val[rt] = val[lson[rt]] + val[rson[rt]];\n    }\n}复制代码\n之后我们需要做的是分析复杂度\n\n从最简单的build开始分析 显然build会访问所有节点 而节点数大约在$4\\times n$左右 所以build是$O(n)$的\n\n然后是query 每个查询的区间总可以分解成大约$log(r-l+1)$个区间后求和 于是复杂度是$O(logn)$的\n\n最后是modify 我们会发现按照我们的写法modify会需要覆盖包含$[l,r]$中元素的所有节点 于是这个操作的复杂度可以达到$O(n)$\n\n然后我们就发现modify让我们的操作十分不爽 它太慢了\n\n我们需要考虑一种让modify和query一样优秀的做法 能不能像query一样把操作区间也分成$logn$个小区间然后只对这几个区间进行操作呢。。？\n\n我们最大的问题是 如果将一个节点修改以后就不再递归 那么它的儿子怎么办？\n\n但是。。 如果我们在一个节点上打上一个标记 表示这个节点的所有儿子都需要加上这个标记的话。。 是不是就可以得到一个高效的算法。。？\n\n可是如果打标记以后 我要查询的区间并不完全包含这个打标记的节点 就会导致query十分麻烦\n\n那么 我们将标记下传不就好了！\n\n于是你定义$tag$为标记数组 并写出了下传标记的函数\n\nvoid pushdown(int rt,int l,int r){\n    if(!tag[rt])return;//如果没有标记就不用下传了\n    tag[lson[rt]] += tag[rt];tag[rson[rt]] += tag[rt];//更新左右儿子的标记\n    int mid = (l+r)>>1;\n    val[lson[rt]] += tag[rt] * (mid-l+1);\n    val[rson[rt]] += tag[rt] * (r-mid);//维护左右儿子的区间和\n}复制代码\n并且你将modify改成了这样\n\nvoid modify(int rt,int l,int r,int x,int y,int v){\n    if(x <= l && r <= y){\n        tag[rt] += v;val[rt] += (r-l+1)*v;\n        return;\n    }\n    //...\n}\n复制代码\n然后问题就来了 你应当在什么时候下传标记？\n\n很明显的标记下传少了的话会导致答案出错 但是标记下传多了只是会让算法的常数大那么一丢丢丢\n\n所以你可以直接在modify和query函数的开头下传标记\n\n复杂度$O(logn)$达成！\n\n练习：【模板】线段树2\n\n这道题十分深入的考验了做题人对于标记的理解\n\n相信如果能做对这道题会让你对线段树的了解更加深入\n\n"
        },
        {
            "author": "107874017",
            "timestamp": 1556329020,
            "txt_content": "tian_wc 发表于 2019-4-27 09:06\n所有题目链接都挂了引用外链要加https://\n我考虑到了这个问题\n所以在帖子的最后我扔了一个原文件的压缩包"
        },
        {
            "author": "107874017",
            "timestamp": 1556329080,
            "txt_content": "langyo 发表于 2019-4-27 09:18\n好基础啊……\n\n你可以试试土球的 Markdown 转 UUB 的转换器：https://mm2bc.ustc-zzzz.net/\n你数学公式一个都加载不出来。。\n这个效果并不是我所想要的 \n我之前也考虑过这个方式 然后觉得并不够好"
        },
        {
            "author": "langyo",
            "timestamp": 1556414640,
            "txt_content": "107874017 发表于 2019-4-27 09:38\n你数学公式一个都加载不出来。。\n这个效果并不是我所想要的 \n我之前也考虑过这个方式 然后觉得并不够好 ...\n数学公式……我强烈建议转换成图片\n\n原因很简单，论坛自个没有能支持数学公式输入的 UUB 模板"
        },
        {
            "author": "107874017",
            "timestamp": 1556416320,
            "txt_content": "langyo 发表于 2019-4-28 09:24\n数学公式……我强烈建议转换成图片\n\n原因很简单，论坛自个没有能支持数学公式输入的 UUB 模板 ...\n那么我会累死。。\n那么多公式真的没法一个个导图片。。\n顺带一提 仅仅这一篇就有九十多个公式"
        },
        {
            "author": "langyo",
            "timestamp": 1556423640,
            "txt_content": "107874017 发表于 2019-4-28 09:52\n那么我会累死。。\n那么多公式真的没法一个个导图片。。\n顺带一提 仅仅这一篇就有九十多个公式\nhttps://langyo.gitbook.io/rsct/part1\n\n网上应该有批量生产工具来着……\n\n即使没有， 90 多个公式又不会费你太多时间，最多一个月就能全部完成……\n\n（我这个链接对应的各个竖式，全部用 Libre Office 的 Math 模块制作，每个平均也就用十五分钟）"
        },
        {
            "author": "NengLiang",
            "timestamp": 1556464200,
            "txt_content": "你这么教会出问题的 变量都不搞清就开始教System.out"
        },
        {
            "author": "107874017",
            "timestamp": 1556490960,
            "txt_content": "NengLiang 发表于 2019-4-28 23:10\n你这么教会出问题的 变量都不搞清就开始教System.out\n#1已经写了\n同时本教程默认所有读者都有充足的语言基础"
        },
        {
            "author": "107874017",
            "timestamp": 1556491020,
            "txt_content": "langyo 发表于 2019-4-28 11:54\nhttps://langyo.gitbook.io/rsct/part1\n\n网上应该有批量生产工具来着……\n数据结构这一部分就九十多个。。 后面还有数论\n总的数量感觉差不多要上千。。\n当然你也可以说让我自己转\n但我觉得对于放在mcbbs这种地方的教程实在是没必要了。。"
        }
    ]
}