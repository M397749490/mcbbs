{
    "title": "有关C++动态内存",
    "author": "langyo_v3",
    "replyCount": 59,
    "timestamp": 1491490320,
    "txt_content": "没错我是langyo= =\n怎么喂龙请去末地看申诉…\n\n最近,我那个压缩算法就要出炉了,但在写C++版的算法时遇到了问题,问题出在动态内存分配上。\n众所周知,要声明一个静态数组,其初始化下标必须是一个常量表达式。动态数组则比较有趣了,它需要你给个指针,然后new,动态开辟空间,用完后还得delete。\n现在的问题是,我的压缩算法需要能够动态调整的内存空间,但理论来讲数组下限如果用变量会满屏Error红灿灿。如何才能以new申请出我动态指定量的内存?\n别急着回复,我还没讲完。\n我使劲查了资料,发现其实大家都是可以这么玩的,以变量为下限来new。不过,我看见的都是诸如char p*=new bytes[i];这种玩意。所以,其它数据类型不行,但char可以喽?如果不行,那GCC又是怎么做的呢?怎么才能做到用new动态申请内存?\n\n最后,可能有人要我用malloc()和free(),也可能有人要我改用文件流替代数组,也可能有人建议我用链表、堆或向量…但我希望能用new,这个面向对象的产物,而不是一堆库,那太依赖系统了(不用反驳,库确实有一定依赖性,各系统GCC的实现不一样)。\n\n\n感谢你能抽出时间听我扯皮,也希望你能给我建设性的回复。",
    "replies": [
        {
            "author": "土球球",
            "timestamp": 1491501300,
            "txt_content": " 本帖最后由 ustc_zzzz 于 2017-4-7 02:06 编辑 \n\n希望不要出现v4\n楼主感兴趣的话可以看看C++程序的内存模型。\n\n通常而言，一个程序在运行的时候分为四个区：\n常量区，用于存放常量数据，包括字符串等数据区，用于存放全局变量等静态数据栈区，用于管理静态分配的内存，包括函数参数等堆区，用来管理动态分配的内存\n\n如果是诸如下面这样的类型声明时分配内存：\nchar c[450] = {0};复制代码那么相应的内存属于静态内存会被分配到栈区。\n如果是像楼主提到的那样的使用new申请内存：\nchar *c = new char[450];复制代码那么相应的内存属于动态内存会被分配到堆区。\n\n不过楼主似乎提到了变长数组？就像这样：\n#include <cstdlib>\nint i = std::rand() & 0xff;\nchar c[i];复制代码这种情况下，程序会按照给定的值自动在栈上分配相应长度的数组。\n不过，楼主你问的这玩意，真的和MC有关么。。。"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1491518880,
            "txt_content": " 本帖最后由 langyo_v3 于 2017-4-7 07:06 编辑 \nustc_zzzz 发表于 2017-4-7 01:55\n希望不要出现v4\n楼主感兴趣的话可以看看C++程序的内存模型。\n变长数组的格式究竟是怎样的?我总是搞混\n\n(跟MC有那么一丁点关系,因为我之前用命令方块实现了变长数组OOC)\n\n(我也不希望需要再注册,但有人抢注咋办XD)"
        },
        {
            "author": "qqabxiaojing",
            "timestamp": 1491531120,
            "txt_content": "讲真,我没听懂你在描述什么,不过从你的描述知道你是一个大新手,首先\n第一个问题,new/delete   malloc/free  这个你就没搞懂什么时候该用哪个, new 他内部除了调用malloc外还调了构造函数   而malloc就只是申请内存。所以如果你单单只是存储一些数据完全可以用malloc, new也可以随你选择没什么区别反正我boss要求我写c++代码不管做什么都用new。\n\n第二个问题  其实你没必要过多关注于数据类型,如果你只是想存储,那么你只需要知道你需要多少内存。比如我要申请12个字节内存 void*p = new char[12]; 或者  void *p = new int[3];   当然语法需要强转,这里我只是大概写一下。得到12个字节的p你可以往里面写任意的东西  比如写个对象进去写什么都可以,C++不是类型安全的  可以强转 取决于你想写什么进去"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1491538380,
            "txt_content": "qqabxiaojing 发表于 2017-4-7 10:12\n讲真,我没听懂你在描述什么,不过从你的描述知道你是一个大新手,首先\n第一个问题,new/delete   malloc/free  ...\n我主要还是用java比较熟练，c++只不过是用在算法考试的工具罢了\n\n其实malloc已经够用了，毕竟new更应当用在面向对象，它还能因为class的特性而支持构造和析构\n\n问题我已经自行解决了"
        },
        {
            "author": "Yaossg",
            "timestamp": 1491540000,
            "txt_content": "你讲的话非常不清楚，但是我可以明确告诉你几点\n1.不管是什么时候new都是c++最好选择\n2.最好不要自己动手操作指针，尤其是在c++中，可以考虑STL里提供的泛型类(STL是c++标准库的一部分)\n3.如果非要操作指针，切记销毁数组时用delete[]而不是delete\n4.显然你没有搞懂怎么使用new。。。那你最好参见第二条\n5.你在网上收集的资料明显略有偏颇，但更多是你自己的问题，参见第四条\n6.不要妄图使用可变长度的数组，那会把问题变复杂\n如果你想要更多了解c++，尤其是对上面建议不清楚的，或者想要我教你怎么解决你的问题\n可以私信我，这里因为篇幅原因就不详细说了。\n我也可以收个c++学徒什么的，反正学了这么久c++也是闲的慌"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1491542820,
            "txt_content": "姚氏帅哥 发表于 2017-4-7 12:40\n你讲的话非常不清楚，但是我可以明确告诉你几点\n1.不管是什么时候new都是c++最好选择\n2.最好不要自己动手操 ...\n我需要动态数组的原因,是为了动态实现分区块\nnew的基础格式,我只有这个疑惑,现在已经完美解决了(刚刚用学校电脑测试了,编译通过)\n至于你觉得我对new运算符理解得不够透彻…我更偏向java,但java里到处都是new,再怎么不会也得被这种环境整会了啊…\n其实,写算法时都不需要这动态数组,因为人家题目会给数据范围…\n\nc++学徒?…算了算了= =你倒不如跟我说说怎么在NOI突破到全国竞赛…"
        },
        {
            "author": "WA自动机",
            "timestamp": 1491625740,
            "txt_content": "langyo_v3 发表于 2017-4-7 13:27\n我需要动态数组的原因,是为了动态实现分区块\nnew的基础格式,我只有这个疑惑,现在已经完美解决了(刚刚用学 ...\nC++的new和java的new差别可不止一点，如果完全照搬java的思维可是会出事的。\n\n顺便orz 切NOI的dalao"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1491628080,
            "txt_content": "WA自动机 发表于 2017-4-8 12:29\nC++的new和java的new差别可不止一点，如果完全照搬java的思维可是会出事的。\n\n顺便orz 切NOI的dalao ...\nC++的类比java的放荡,多继承什么的,太可恶了XD\n而且new了必须自己delete,确实和java不同\n\n但照搬,就算想也做不到,因为C++可以直接操作指针,java则围绕类做了一堆事情\n\n至于NOI呐,说实话,原理不难,但编的时候难,因为要考虑最短时间复杂度XD"
        },
        {
            "author": "Smokey_Days",
            "timestamp": 1492335420,
            "txt_content": "langyo_v3 发表于 2017-4-8 13:08\nC++的类比java的放荡,多继承什么的,太可恶了XD\n而且new了必须自己delete,确实和java不同\n如果是java的话可以用集合然后集合←→数组互转即可\n但是C++有集合这个功能么？我不是很清楚，因为学C++同样是为了NOIP\n另：NOIP取消对JAVA的支持真是太可恶了\n另2：你是哪个省区的XD运气好说不定我们会碰面呢"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1492336680,
            "txt_content": "Smokey_Days 发表于 2017-4-16 17:37\n如果是java的话可以用集合然后集合←→数组互转即可\n但是C++有集合这个功能么？我不是很清楚，因为学C++ ...\n江苏的XD\n所以今年11月见?XD\n\njava比起C++,好用太多了,只是性能有所欠缺罢了\n我手里还有个java虚拟机规范的PDF文档,如果真的可能,拿这东西给自己的启动器实现内嵌虚拟机也不是不好XD"
        },
        {
            "author": "Yaossg",
            "timestamp": 1492337160,
            "txt_content": "langyo_v3 发表于 2017-4-16 18:20\n那个…C++那个不叫泛型…叫虚函数…\n你确定？你了解c++?c++用模板实现泛型好吗"
        },
        {
            "author": "Yaossg",
            "timestamp": 1492337400,
            "txt_content": "langyo_v3 发表于 2017-4-8 13:08\nC++的类比java的放荡,多继承什么的,太可恶了XD\n而且new了必须自己delete,确实和java不同\n你不用多继承不就不可恶了么\nnew的确需要自己delete\n但是c++程序员会利用构造函数new利用析构函数delete\n还可以加个计数器什么的灵活度速度都比java高\n加上泛型几乎和Java的差不多了"
        },
        {
            "author": "Yaossg",
            "timestamp": 1492337940,
            "txt_content": " 本帖最后由 姚氏帅哥 于 2017-4-16 18:23 编辑 \nSmokey_Days 发表于 2017-4-16 17:37\n如果是java的话可以用集合然后集合←→数组互转即可\n但是C++有集合这个功能么？我不是很清楚，因为学C++ ...\nc++的确有合集。。。我不可能详细的说\n但是最常用，最好用的是vector\n大概像这样\nstd::vector<int> v = {1,2,3};\nv.push_back(4);//在末尾插入4\nfor(int n : v)std::cout<<n;//它会输出1234\n当然还有map\nstd::map<std::string,int> m;\nm[\"hello\"]=4;//方括号里面是键，等号右面是值"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1492338000,
            "txt_content": "姚氏帅哥 发表于 2017-4-16 18:10\n你不用多继承不就不可恶了么\nnew的确需要自己delete\n但是c++程序员会利用构造函数new利用析构函数delete\n那个…C++那个不叫泛型…叫虚函数…"
        },
        {
            "author": "Yaossg",
            "timestamp": 1492350060,
            "txt_content": "langyo_v3 发表于 2017-4-16 18:20\n那个…C++那个不叫泛型…叫虚函数…\n你之前问关于c++动态内存的时候我就回答过你\n看得出来你非常迫切想要参加noip(其实我也想)\n但是，就目前而言，你用Java的方式理解c++\n相当的不好，最后你的脑袋会拧成麻花\n你对我进行指正，说泛型是虚函数\n然而这并不是Java中的伪泛型，不是靠的是语法糖\n不是靠把T换成Object等做法构成的“多态泛型”\nc++泛型与继承、多态、虚函数没有半毛钱关系\n所以你看到了c++泛型与Java的泛型是不能相提并论的\n还有，需要指出的是，Java除了静态方法之外\n其他方法都是虚函数，而c++不同需要手动指定"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1492350300,
            "txt_content": "姚氏帅哥 发表于 2017-4-16 21:41\n你之前问关于c++动态内存的时候我就回答过你\n看得出来你非常迫切想要参加noip(其实我也想)\n但是，就目前 ...\n额,NOI早着呢,隔一暑假急啥\n\njava的泛型是语法糖,编译时自动匹配数据类型,C++也是一样的么?"
        },
        {
            "author": "Yaossg",
            "timestamp": 1492351980,
            "txt_content": "langyo_v3 发表于 2017-4-16 21:45\n额,NOI早着呢,隔一暑假急啥\n\njava的泛型是语法糖,编译时自动匹配数据类型,C++也是一样的么? ...\nJava泛型最重要的一个环节就是“类型擦除”\n把所有涉及泛型的地方换成Object\n在加上一些强制类型转换，所以Java泛型不支持基本类型\n因为他们不能实现上述内容\n在这里不具体讲，你可以在论坛里找一下Java泛型研究\nc++不同，实际上c++的泛型是通过“模板”(template)实现的\ntemplate是一个巨坑，一般教程只教泛型这部分(甚至泛型都只讲这一部分)\n这里不想详细的说，其实你可以私信我的。。。那样交流顺畅些"
        },
        {
            "author": "hanhaochi",
            "timestamp": 1494224820,
            "txt_content": "参考STL库，比如动态数组去看看vector底层的实现，也算是比较权威的"
        },
        {
            "author": "zcm2005",
            "timestamp": 1494248040,
            "txt_content": "该运算符将返回一个指针，详情还请你去百度上查找资料。链表是依靠new和delete实现的。malloc()类似new，free()类似delete。"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1494250620,
            "txt_content": "zcm2005 发表于 2017-5-8 20:54\n该运算符将返回一个指针，详情还请你去百度上查找资料。链表是依靠new和delete实现的。malloc()类似new，fr ...\n链表同样可以通过malloc()与free()实现,只不过不是很方便罢了\n\nnew/delete与malloc()/free()最明显的不同,是new/delete在初始化class时自动帮你执行构造和析构,但malloc()/free()得你自己费事手动执行"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1494256200,
            "txt_content": "姚氏帅哥 发表于 2017-5-8 23:17\n本质上你说得对\n从概念上，注意我说的是概念，就是如何理解它\n你应该把malloc想成分配内存，干啥你随便\n基本类型的构造函数是怎样的?\n\n(请以知乎环境回答XD)"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494256620,
            "txt_content": "langyo_v3 发表于 2017-5-8 21:37\n链表同样可以通过malloc()与free()实现,只不过不是很方便罢了\n\nnew/delete与malloc()/free()最明显的不同 ...\n本质上你说得对\n从概念上，注意我说的是概念，就是如何理解它\n你应该把malloc想成分配内存，干啥你随便\nfree释放内存，之后啥都不干。。。\nnew创建对象，当然会调用构造函数\ndelete是销毁对象，自然析构函数少不了\n注意:基本类型构造自动初始化为0\n基本类型没有析构函数，即销毁时啥都不做\n并且基本类型只在特殊情况调用它的构造函数\n比如new，创建数组int a[20],静态变量等等"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494258840,
            "txt_content": "langyo_v3 发表于 2017-5-8 23:10\n基本类型的构造函数是怎样的?\n\n(请以知乎环境回答XD)\n知乎没用过，所以啥是知乎环境啊\n其实就是自动初始化为0而已(*this=0)，而且这个构造还不是像其他类那样，自动调用\n而是必须我前面提到的特殊情况，或者也可以显式调用\n如int() double(12) bool(ptr)\n等等，具体的今天太晚了，之后再说XD\n(说是构造函数，其实是什么你应该很清楚)"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1494460080,
            "txt_content": "这么说吧 malloc/free是函数，new/delete是操作符"
        },
        {
            "author": "Yaossg",
            "timestamp": 1494460860,
            "txt_content": "顶个热水袋 发表于 2017-5-11 07:48\n这么说吧 malloc/free是函数，new/delete是操作符\n同志你听说过operator new 和 operator delete 吗\n没错，你可以理解为操作符，但是本质上是函数\n(上述函数声明于<new>当中)\n虽然本质上是函数，操作符这种说法还是最优的\n尤其是你重载他们的时候\n不过你不说我还真没想起来这件事\n邀请围观:@langyo_v3 "
        },
        {
            "author": "langyo_v3",
            "timestamp": 1494475380,
            "txt_content": "顶个热水袋 发表于 2017-5-11 07:48\n这么说吧 malloc/free是函数，new/delete是操作符\n再准确点，\nmalloc/free是库函数\nnew/delete是实实在在的关键字"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1496147280,
            "txt_content": "姚氏帅哥 发表于 2017-5-11 08:01\n同志你听说过operator new 和 operator delete 吗\n没错，你可以理解为操作符，但是本质上是函数\n(上述函 ...\nnew/delete准确来说是关键字，operator new/opreator delete是标准库函数。\n\noperator new can be called explicitly as a regular function, but in C++, new is an operator with a very specific behavior: An expression with the new operator, first calls function operator new (i.e., this function) with the size of its type specifier as first argument, and if this is successful, it then automatically initializes or constructs the object (if needed). Finally, the expression evaluates as a pointer to the appropriate type.\n\n看下这段，来自www.cplusplus.com"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1496150640,
            "txt_content": "顶个热水袋 发表于 2017-5-30 20:28\nnew/delete准确来说是关键字，operator new/opreator delete是标准库函数。\n\noperator new can be called ...\n你的意思是说new和delete可以被重载?\n\n一口老血喷…"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496151240,
            "txt_content": "langyo_v3 发表于 2017-5-30 21:24\n你的意思是说new和delete可以被重载?\n\n一口老血喷…\n当然可以。。。小伙子，c++的坑有多深？谁也说不清"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496151720,
            "txt_content": "顶个热水袋 发表于 2017-5-30 20:28\nnew/delete准确来说是关键字，operator new/opreator delete是标准库函数。\n\noperator new can be called ...\n这个我倒是知道。。。，但是你这又把话题扯回来了。。"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1496220480,
            "txt_content": "langyo_v3 发表于 2017-5-30 21:24\n你的意思是说new和delete可以被重载?\n\n一口老血喷…\nnew/delete确实是不允许重载的，我的意思不是可以重载，只是说new/delete和operator new/opreator delete是两种东西，\nType* p=new Type;\n//这个调用分3步\n//1.调用operator new函数，分配未类型化的内存，保存指定类型的对象\n//2.运行对应类型的构造函数，初始化对象\n//3.返回指向对象的指针复制代码\n说到重载，其实可以在类中定义自己的new/delete成员/友元函数或者定义全局的函数，或者是new[]/delete[]函数，这个算是另一种意义的重载：void opreator new(void* p);\nvoid* operator new(size_t t);\nvoid operator new(size_t t,void* p);\n\nType* p=new Type; 复制代码\n如果还是要使用标准库给好的：\nType* p=::new Type; 复制代码\n其实纠结这么多也没用，先实现功能比较重要。"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1496232300,
            "txt_content": "顶个热水袋 发表于 2017-5-31 16:48\nnew/delete确实是不允许重载的，我的意思不是可以重载，只是说new/delete和operator new/opreator delete ...\n@姚氏帅哥 \n\nnew/delete很神奇,对吧\n\noperation是个很有趣的东西"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496236800,
            "txt_content": "langyo_v3 发表于 2017-5-31 20:05\n@姚氏帅哥 \n\nnew/delete很神奇,对吧\n他讲的很对。。。重载这两个运算符本质上只是对分配的内存做事，不是自定义如何分配内存"
        },
        {
            "author": "Lne",
            "timestamp": 1496717040,
            "txt_content": "\n（好吧忘记看时间了）"
        },
        {
            "author": "Lne",
            "timestamp": 1496717820,
            "txt_content": " 本帖最后由 Lne 于 2017-6-6 11:00 编辑 \n#include <vector>\n复制代码\n或者\n#include  <memory>//智能指针 想像java那样用new应该是用这玩意(但是不等同于垃圾回收)\n复制代码"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496718360,
            "txt_content": "Lne 发表于 2017-6-6 10:57\n或者\n虽然vector是最常用的，但是c++标准库还包含了\nlist deque forward_list stack queue等容器。。。\n以及一些较为特殊的像pair tuple initializer_list等容器\n至于智能指针，我只有一个建议——别用auto_ptr!\n@langyo_v3 ← 楼主"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1496725440,
            "txt_content": "姚氏帅哥 发表于 2017-6-6 11:06\n虽然vector是最常用的，但是c++标准库还包含了\nlist deque forward_list stack queue等容器。。。\n以及一 ...\n这帖沉不了,因为这帖讨论的是大家都津津乐道的语法…"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1496889480,
            "txt_content": "langyo_v3 发表于 2017-6-6 13:04\n这帖沉不了,因为这帖讨论的是大家都津津乐道的语法…\n为什么要津津乐道"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1496898840,
            "txt_content": "顶个热水袋 发表于 2017-6-8 10:38\n为什么要津津乐道\n因为只有语法这部分最容易与别人拉开距离"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1496907180,
            "txt_content": "langyo_v3 发表于 2017-6-8 13:14\n因为只有语法这部分最容易与别人拉开距离\n这样啊。。。"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496933640,
            "txt_content": "langyo_v3 发表于 2017-5-31 20:05\n@姚氏帅哥 \n\nnew/delete很神奇,对吧\n我再来给你看个大♂宝♂贝\nchar *p = new[sizeof(T)]\nnew (p) T(1,2,3);\n你猜猜是什么含义？\n我看了下很早之前你和4z的对话\n以及边长数组是C11的特性4z说的那个肯定不可能\n而且c11不被广泛支持与使用，比c++11惨一万倍\n非要数组边长就不断的new和delete就行了╭(╯3╰)╮\n如果你对标准库怨气有加，你可以自己编写容器/智能指针\n此外我还要说1.c++的容器从来都没有一个共同父类，所以Collection千万别来\n二的一个是迭代器，他是c++容器必备的\n三的一个就是泛型算法千万不要作为容器的成员"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1496934540,
            "txt_content": "姚氏帅哥 发表于 2017-6-8 22:54\n我再来给你看个大♂宝♂贝\nchar *p = new\nnew (p) T(1,2,3);\n含义没看出来,但C11很惨是真的"
        },
        {
            "author": "Yaossg",
            "timestamp": 1496983020,
            "txt_content": "顶个热水袋 发表于 2017-5-31 16:48\nnew/delete确实是不允许重载的，我的意思不是可以重载，只是说new/delete和operator new/opreator delete ...\n@顶个热水袋 \n你说operator new 和 new 不是同一个东西\n那我还可以说。operator+ 和 + 不是同一个东西呢//其实本来就不是\n但是强行区分没有意义，毕竟运算符重载本来就是语法糖，本来就是为了方便\n还有你说new分为3步\n//这个调用分3步\n//1.调用operator new函数，分配未类型化的内存，保存指定类型的对象\n//2.运行对应类型的构造函数，初始化对象\n//3.返回指向对象的指针\n其实只有第一步，因为构造函数本身就与new无关。。。构造函数根本不是new调用的。。。\n至于返回不是废话吗。。。\n所以其实new就只用一步:调用operator new\n@langyo_v3 "
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1496990400,
            "txt_content": "姚氏帅哥 发表于 2017-6-9 12:37\n@顶个热水袋 \n你说operator new 和 new 不是同一个东西\n那我还可以说。operator+ 和 + 不是同一个东西呢/ ...\n对于基本类型，只有一步。int* p=new int;\n00E54C44  push        4    \n00E54C46  call        operator new (0E51384h)    \n00E54C4B  add         esp,4复制代码复杂类型就是三步struct Object{};\nObject* o=new Object;\n00AD7EDD  push        4    \n00AD7EDF  call        operator new (0AD1384h)    \n00AD7EE4  add         esp,4    \n00AD7EE7  mov         dword ptr [ebp-0E0h],eax    \n00AD7EED  mov         dword ptr [ebp-4],0    \n00AD7EF4  cmp         dword ptr [ebp-0E0h],0    \n00AD7EFB  je          main+70h (0AD7F10h)    \n00AD7EFD  mov         ecx,dword ptr [ebp-0E0h]    \n00AD7F03  call        Object::Object (0AD1433h)        //在new的地址上调用构造函数  \n00AD7F08  mov         dword ptr [ebp-0F4h],eax    \n00AD7F0E  jmp         main+7Ah (0AD7F1Ah)    \n00AD7F10  mov         dword ptr [ebp-0F4h],0    \n00AD7F1A  mov         eax,dword ptr [ebp-0F4h]    \n00AD7F20  mov         dword ptr [ebp-0ECh],eax    \n00AD7F26  mov         dword ptr [ebp-4],0FFFFFFFFh    \n00AD7F2D  mov         ecx,dword ptr [ebp-0ECh]    \n00AD7F33  mov         dword ptr [p],ecx复制代码我区分开只是我觉得这样子让我理解起来容易，你要怎么理解是你的事。\n我前面说了，纠结这个没意义，这帖子本来就是楼主要实现一个东西，实现出来能跑为上。\n你要继续纠结，那你是对的。我甘拜下风。\n"
        },
        {
            "author": "Paindar",
            "timestamp": 1496996100,
            "txt_content": "既然是搞算法竞赛为啥要考虑动态内存。。有多少上多少啊！"
        },
        {
            "author": "Yaossg",
            "timestamp": 1497003180,
            "txt_content": "顶个热水袋 发表于 2017-6-9 14:40\n对于基本类型，只有一步。复杂类型就是三步我区分开只是我觉得这样子让我理解起来容易，你要怎么理解是你 ...\n不管是基本类型还是复杂类型，用的不都是operator new 和 new\n而你前面说的是“new和operator new的区别”\n不过把汇编翻出来也是挺厉害的。。。"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497007500,
            "txt_content": "Paindar 发表于 2017-6-9 16:15\n既然是搞算法竞赛为啥要考虑动态内存。。有多少上多少啊！\n我需要动态内存是因为一些变态的用途，它不是用来玩NOIP/NOI的\n\n比如说实现动态链表，vector就是这么玩的"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497007560,
            "txt_content": "顶个热水袋 发表于 2017-6-9 14:40\n对于基本类型，只有一步。复杂类型就是三步我区分开只是我觉得这样子让我理解起来容易，你要怎么理解是你 ...\n能把你用的解析汇编的软件发给我吗？"
        },
        {
            "author": "Yaossg",
            "timestamp": 1497015960,
            "txt_content": "langyo_v3 发表于 2017-6-9 19:25\n我需要动态内存是因为一些变态的用途，它不是用来玩NOIP/NOI的\n\n比如说实现动态链表，vector就是这么玩的 ...\n荒谬！谁跟你说vector是链表的\nvector明明是用数组实现的好吗\n链表是list和forward_list\n实现动态链表炒鸡简单的。。。(用Java会更简单\n但是明明有标准库的为什么你要自己写呢...."
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497016320,
            "txt_content": "姚氏帅哥 发表于 2017-6-9 21:46\n荒谬！谁跟你说vector是链表的\nvector明明是用数组实现的好吗\n链表是list和forward_list\nvector如果发现自己的缓冲区不够用，就会再开辟一个缓冲区，搞得跟链表似得\n\n还有，我偷偷在教室里写头文件已经2小时了，还是满屏报错，你帮我看看好吗\n（已经200行了，但只写了2个成员函数的实现TAT）\n\n/*\n        作者：langyo\n        协议：GPL 2.0\n        协议详情：https://choosealicense.com/licenses/gpl-2.0/ \n*/\n\n#include <iostream>\nnamespace memory{\n        using namespace std;\n        class memoryUnit{\n                unsigned char *_data;        //_data[0]算在内 \n                unsigned int _from;                //有效数据起点\n                unsigned int _to;                //有效数据终点\n                unsigned int _length;        //缓冲区总大小，_data[0]亦算在内\n                \n                //void _move(unsigned int form,unsigned int length,unsigned int to);\n                \n                public:\n                //删除指定一段数据\n                memoryUnit &del(unsigned int form,unsigned int to){\n                        //检查参数是否有效\n                        if(form>to){\n                                //不要吐槽这里，因为这里在经过编译器优化后是不占内存的！ \n                                unsigned int temp=form;\n                                form=to;\n                                to=temp;\n                        } \n                        if(form<_from || to>_to){\n                                //throw(error(this,\"del参数无效\"));\n                        } \n                        if(_data==0){\n                                //throw(error(this,\"未初始化\"));\n                        }\n                        //改写有效数据游标\n                        //情况1：从头开始删\n                        if(form==_form){\n                                _form=to++;\n                                return this;\n                        } \n                        //情况2：从最后开始删\n                        if(to==_to){\n                                _to=form--;\n                                return this;\n                        } \n                        //情况3：在中间删\n                        for(unsigned int i=to+1,j=form;i<=_to;i++,j++){\n                                _data[j]=_data[i];\n                        } \n                        _to=to; \n                        return this;\n                } \n                //在指定位置之后插入一段数据\n                memoryUnit &insert(unsigned int before,memoryUnit &data){\n                        //检查参数是否有效\n                        if(before>_to || before<_form || data==null){\n                                //throw(error(this,\"insert参数无效\"));\n                        }\n                        //情况1：这个memoryUnit有足够的预留空间放数据\n                        if(_length-_to+_form-1>=data.length() && _length-_to+_form!=0){\n                                //情况1：只要_to后就够了\n                                if(_length-_to>=data.length()){\n                                        //移开后头那部分，以插入data\n                                        for(unsigned int i=before+data.length(),j=_to+data.length()-1;\n                                                i>before;i--,j--){\n                                                _data[j]=_data[i];\n                                        }\n                                        //插入data\n                                        for(unsigned int i=before+1,j=0;\n                                                i<=before+data.length();i++,j++){\n                                                _data[i]=data[j];\n                                        } \n                                        return this;\n                                } \n                                //情况2：还需要_form前面的空间\n                                //先把_to后面移动完成\n                                for(unsigned int i=to,j=_length-1;i>before;i--,j--){\n                                        _data[j]=_data[i];\n                                }\n                                //再移动_form前面\n                                for(unsigned int i=_form,j=_form-(data.length()-(_length-_to));i<before;i++,j++){\n                                        _data[j]=_data[i];\n                                } \n                                //写入数据\n                                for(unsigned int i=before+1,j=0;j<data.length();i++,j++){\n                                        _data[i]=data[j];\n                                } \n                                //改变有效数据游标的位置\n                                _form-=data.length-(_length-_to); \n                                _to=_length-1;\n                                \n                                return this;\n                        }        \n                        //情况2：这个memoryUnit不够用，那就重新分配吧╭(╯3╰)╮\n                        memoryUnit ret(this.length()+data.length());\n                        //写入before以及之前的部分\n                        for(unsigned int i=_form;i<=before;i++)        data.add(_data[i]);\n                        //写入插入的数据\n                        for(unsigned int i=0;i<data.length();i++)        data.add(data[i]);\n                        //最后再写入before后头的部分\n                        for(unsigned int i=before+1;i<=_to;i++)        data.add(_data[i]);\n\n                        return ret;\n                }\n                //在末尾追加一段或一个数据\n                memoryUnit &add(memoryUnit &data);\n                memoryUnit &add(unsigned char data);\n                //提取一段数据，只返回，不删除\n                memoryUnit &cut(unsigned int form,unsigned int to);\n                \n                unsigned int length();                //return _to-_form+1;\n                unsigned int usingMemory();         //return _length;\n                \n                unsigned char operator[](unsigned int point);\n                template <typename T>        memoryUnit &operator=(T num);\n                memoryUnit &operator=(memoryUnit &num);\n                \n                memoryUnit();\n                memoryUnit(unsigned int size);\n        };\n        \n        union extraNum{\n                //这玩意是为避开处理器大小端处理造成的不兼容而设计的 \n                //不懂大小端是啥？自己谷歌/百度 \n                unsigned char chars[3];\n                int integer;\n                unsigned int unsignedInteger;\n                short shortInteger;\n                unsigned short unsignedShortInteger;\n                char singedChar;\n                unsigned char unsignedChar;\n        };\n        class bigInt{\n                memoryUnit data;\n                \n                public:\n                bigInt &operator+(bigInt &num);\n                bigInt &operator+=(bigInt &num);\n                bigInt &operator-(bigInt &num);\n                bigInt &operator-=(bigInt &num);\n                bigInt &operator*(bigInt &num);\n                bigInt &operator*=(bigInt &num);\n                bigInt &operator/(bigInt &num);\n                bigInt &operator/=(bigInt &num);\n                bigInt &operator%(bigInt &num);\n                bigInt &operator%=(bigInt &num);\n                \n                bigInt &operator~();\n                bigInt &operator-();        //取相反数 \n                bigInt &operator^(bigInt &num);\n                bigInt &operator^=(bigInt &num);\n                bigInt &operator&(bigInt &num);\n                bigInt &operator&=(bigInt &num);\n                bigInt &operator|(bigInt &num);\n                bigInt &operator|=(bigInt &num);\n                bigInt &operator<<(bigInt &num);\n                bigInt &operator<<=(bigInt &num);\n                bigInt &operator>>(bigInt &num);\n                bigInt &operator>>=(bigInt &num);\n                \n                bigInt &operator++();\n                bigInt &operator--();\n                \n                bool &operator>=(bigInt &num);\n                bool &operator<=(bigInt &num);\n                bool &operator>(bigInt &num);\n                bool &operator<(bigInt &num);\n                bool &operator==(bigInt &num);\n                bool &operator!=(bigInt &num);\n                \n                unsigned char operator[](unsigned int point);\n                \n                memoryUnit &getMemoryUnit();\n                bigInt *cut(unsigned int blockSize);\n                //用于切割存储的memoryUnit，如果最后还有余数则以零填补\n                \n                //friend &ostream &operator<<(ostream &stream,bigInt &data);\n                //friend &istream &operator>>(istream &stream,bigInt &data);\n                \n                bigInt();\n                bigInt(memoryUnit &data);\n                bigInt(bigInt &data);\n                template <typename T> bigInt(T data);                \n        };\n        template <typename T> void swap(T &a,T &b);\n}\nnamespace algorithm{\n        using namespace memory;\n        bool deal(istream &input,ostream &output);\n        bool redeal(istream &input,ostream &output);\n}\n复制代码\n"
        },
        {
            "author": "Yaossg",
            "timestamp": 1497018480,
            "txt_content": "langyo_v3 发表于 2017-6-9 21:52\nvector如果发现自己的缓冲区不够用，就会再开辟一个缓冲区，搞得跟链表似得\n\n还有，我偷偷在教室里写头文 ...\n哇。。。。看完这段代码，辣眼睛。。。。简直了，我感觉是在看Java代码\n首先_from=to--;这种代码真的不是为了混淆视听以及减慢速度的吗，_from=to才是正解，后面还有几处你也改改\n然后就是瞬间爆炸的return this，this明明是指向对象自己的指针呀。。。。\n接着要又看到了data==null我大概知道你为什么这么写了，错的有道理XD\n你至今不知道c++中指针与引用的区别。。。\nlength()add()operator[]你还没定义就去调用，编译器不报错才怪。。。\n最后我看到了我过去很早之前我犯过的错误在你的身上重演，我先不说，你自己慢慢找，就在insert函数里\n我要承认，我实战经验确实比较欠缺，但是语法是我的超级长项，尤其是一些问题是编译器不会报错的。。。(但是好的编译器会给你警告)"
        },
        {
            "author": "Paindar",
            "timestamp": 1497019440,
            "txt_content": "langyo_v3 发表于 2017-6-9 19:25\n我需要动态内存是因为一些变态的用途，它不是用来玩NOIP/NOI的\n\n比如说实现动态链表，vector就是这么玩的 ...\nvector是数组，内部地址是连续的，set和map才是链式结构。\n当内存不够的时候他会重新申请一块更大的内存，大小为原来的1.732还是2忘了\n\n建议你还是先看看STL源码再自己造轮子"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497020040,
            "txt_content": "姚氏帅哥 发表于 2017-6-9 22:28 哇。。。。看完这段代码，辣眼睛。。。。简直了，我感觉是在看Java代码 首先_from=to--;这种代码真的不是 ...\n哪来的_form=to--???…\n函数没实现我能理解…可编译器报的不是这个错啊…人家是说我的所有变量特么的全部超出作用域,但我的所有变量都在作用域内声明了啊…好坑…\n以及,毕竟这是头文件,你事先不先写好成员函数是没问题的,它不像cpp,必须是一旦定义就得实现,而且头文件编译之后不会产生.obj(亲测)\nreturn this是我的锅…但怎么做?…"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497020100,
            "txt_content": "Paindar 发表于 2017-6-9 22:44 vector是数组，内部地址是连续的，set和map才是链式结构。 当内存不够的时候他会重新申请一块更大的内存 ...\n很可惜,我几乎不用vector\n\nSTL源码没时间看,最近考试"
        },
        {
            "author": "Yaossg",
            "timestamp": 1497020580,
            "txt_content": "langyo_v3 发表于 2017-6-9 22:54\n哪来的_form=to--???…\n函数没实现我能理解…可编译器报的不是这个错啊…人家是说我的所有变量特么的全部 ...\n因为你把from全部写成form了。。。。\n                        //情况2：从最后开始删\n                        if(to==_to){\n                                _to=form--;\n                                return this;\n                        } \n_to=form--;应为_to=from-1;\n\n还有你的问题 return *this;不就行了吗\n还有data==null根本无意义，一个引用就是一个对象的别名，这么可能是null呢，以及引用不具有指针语意，也不是指针，c++也没有null这种东西\n还有我说了我留了一个小问题没跟你说，编译器不会报错，最多警告但是却相当致命\n就在insert函数里，你找找看，最好是自己找出来，我给个小提示吧:临时变量何时销毁？返回的类型又是什么？\n等你吧上述问题全部改完，就在发给我看看。。。希望会有好的结果"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1497022560,
            "txt_content": "姚氏帅哥 发表于 2017-6-9 23:03 因为你把from全部写成form了。。。。 _to=form--;应为_to=from-1; \n这是第一部分        memoryUnit&del(unsigned int from,unsigned int to){            //检查参数是否有效            if(from>to){                //不要吐槽这里，因为这里在经过编译器优化后是不占内存的！                unsigned int temp=from;                from=to;                to=temp;            }            if(from<_from || to>_to){                //throw(error(*this,\"del参数无效\"));            }            if(_data==(void*)0){                //throw(error(*this,\"未初始化\"));            }            //改写有效数据游标            //情况1：从头开始删            if(from==_from){                _from=to++;                return *this;            }            //情况2：从最后开始删            if(to==_to){                _to=from--;                return *this;            }            //情况3：在中间删            for(unsigned int i=to+1,j=from;i<=_to;i++,j++){                _data[j]=_data[i];            }            _to-=(to-from+1);            return *this;        }复制代码"
        },
        {
            "author": "Paindar",
            "timestamp": 1497072960,
            "txt_content": "langyo_v3 发表于 2017-6-9 22:55\n很可惜,我几乎不用vector\n\nSTL源码没时间看,最近考试\n不用vector用啥。。用数组吗。。。糟心了老哥"
        },
        {
            "author": "今生已封笔",
            "timestamp": 1497159060,
            "txt_content": "666666666666"
        },
        {
            "author": "顶个热水袋",
            "timestamp": 1497232560,
            "txt_content": "langyo_v3 发表于 2017-6-9 19:26\n能把你用的解析汇编的软件发给我吗？\nvs打断点，反汇编"
        }
    ]
}