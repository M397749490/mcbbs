{
    "title": "[1.9.4-1.9.3][AntiBlockRel——反服务器黑名单补丁]进入被拉黑服务器补丁[上古之石]",
    "author": "andylizi",
    "replyCount": 10,
    "timestamp": 1464054960,
    "txt_content": " 本帖最后由 1094822247 于 2016-5-30 20:34 编辑 \n\n咳咳。\n本来以为1.9.4把服务器黑名单取消了呢，结果没有，只是把代码的位置移到了一个新的库 com.mojang:netty:1.6 而已。白高兴一场。\n于是道高一尺魔高一丈，AntiBlock不能用了，机智的群众发明了AntiBlockRel。\n\n效果图：没有。机智的mojang在原先的blockedservers全部被破解后修改了其内容（也有可能是被拉黑的服务器与mojang谈人生表示立刻遵守eula，不过几率不大），新的几条规则仍未被破解，于是我找不到梨子做对比测试了。\n\n下载地址：\nhttp://pan.baidu.com/s/1eRKSR3k\n\n食用方法：\n把 netty-1.6.jar 替换进.minecraft\\libraries\\com\\mojang\\netty\\1.6\\复制代码文件夹 ，启动mc即可\n啊对了 记得要先关闭客户端。",
    "replies": [
        {
            "author": "andylizi",
            "timestamp": 1464055560,
            "txt_content": "ju哌y 发表于 2016-5-24 10:08\n嗯我们是可以进去服务器了...可是大部分国外群众还是一脸懵逼地卡在服务器菜单..\n如果有服务端解决措施就好 ...\n既然mojang是在客户端进行block的，服务端怎么解决呢"
        },
        {
            "author": "ju哌y",
            "timestamp": 1464055680,
            "txt_content": "嗯我们是可以进去服务器了...可是大部分国外群众还是一脸懵逼地卡在服务器菜单..\n如果有服务端解决措施就好了"
        },
        {
            "author": "3TUSK",
            "timestamp": 1464056580,
            "txt_content": "所以这就是一个修改版的netty？！"
        },
        {
            "author": "andylizi",
            "timestamp": 1464057240,
            "txt_content": "u.s.knowledge 发表于 2016-5-24 10:23\n所以这就是一个修改版的netty？！\n不不不\nmojang机智的注入了netty的引导类，在创建Channel前先检查地址。\n整个jar就一个类而已"
        },
        {
            "author": "贤者君",
            "timestamp": 1464066240,
            "txt_content": "233333新1.9反拉黑乱开服的时代来临"
        },
        {
            "author": "falsh_asan",
            "timestamp": 1464066420,
            "txt_content": "官方逼死mod\nmod反官方"
        },
        {
            "author": "呆瓜Domado",
            "timestamp": 1464066900,
            "txt_content": "Mojang未修改的文件代码是这样的：\npackage io.netty.bootstrap;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.hash.*;\nimport io.netty.channel.*;\nimport io.netty.util.Attribute;\nimport io.netty.util.AttributeKey;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport java.io.IOException;\nimport java.net.*;\nimport java.nio.charset.Charset;\nimport java.util.*;\nimport org.apache.commons.io.IOUtils;\n\n// Referenced classes of package io.netty.bootstrap:\n//                        AbstractBootstrap, ChannelFactory\n\npublic final class Bootstrap extends AbstractBootstrap\n{\n\n        private static final InternalLogger logger = InternalLoggerFactory.getInstance(io/netty/bootstrap/Bootstrap);\n        private volatile SocketAddress remoteAddress;\n        private static final Joiner DOT_JOINER = Joiner.on('.');\n        private static final Splitter DOT_SPLITTER = Splitter.on('.');\n        static final Set BLOCKED_SERVERS;\n\n        public Bootstrap()\n        {\n        }\n\n        private Bootstrap(Bootstrap bootstrap)\n        {\n                super(bootstrap);\n                remoteAddress = bootstrap.remoteAddress;\n        }\n\n        public Bootstrap remoteAddress(SocketAddress remoteAddress)\n        {\n                this.remoteAddress = remoteAddress;\n                return this;\n        }\n\n        public Bootstrap remoteAddress(String inetHost, int inetPort)\n        {\n                remoteAddress = new InetSocketAddress(inetHost, inetPort);\n                return this;\n        }\n\n        public Bootstrap remoteAddress(InetAddress inetHost, int inetPort)\n        {\n                remoteAddress = new InetSocketAddress(inetHost, inetPort);\n                return this;\n        }\n\n        public ChannelFuture connect()\n        {\n                validate();\n                SocketAddress remoteAddress = this.remoteAddress;\n                if (remoteAddress == null)\n                        throw new IllegalStateException(\"remoteAddress not set\");\n                else\n                        return doConnect(remoteAddress, localAddress());\n        }\n\n        public ChannelFuture connect(String inetHost, int inetPort)\n        {\n                return connect(((SocketAddress) (new InetSocketAddress(inetHost, inetPort))));\n        }\n\n        public ChannelFuture connect(InetAddress inetHost, int inetPort)\n        {\n                return connect(((SocketAddress) (new InetSocketAddress(inetHost, inetPort))));\n        }\n\n        public ChannelFuture connect(SocketAddress remoteAddress)\n        {\n                if (remoteAddress == null)\n                {\n                        throw new NullPointerException(\"remoteAddress\");\n                } else\n                {\n                        validate();\n                        return doConnect(remoteAddress, localAddress());\n                }\n        }\n\n        public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)\n        {\n                if (remoteAddress == null)\n                {\n                        throw new NullPointerException(\"remoteAddress\");\n                } else\n                {\n                        validate();\n                        return doConnect(remoteAddress, localAddress);\n                }\n        }\n\n        private ChannelFuture doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress)\n        {\n                ChannelFuture future = checkAddress(remoteAddress);\n                if (future != null)\n                        return future;\n                final ChannelFuture regFuture = initAndRegister();\n                final Channel channel = regFuture.channel();\n                if (regFuture.cause() != null)\n                        return regFuture;\n                final ChannelPromise promise = channel.newPromise();\n                if (regFuture.isDone())\n                        doConnect0(regFuture, channel, remoteAddress, localAddress, promise);\n                else\n                        regFuture.addListener(new ChannelFutureListener() {\n\n                                final ChannelFuture val$regFuture;\n                                final Channel val$channel;\n                                final SocketAddress val$remoteAddress;\n                                final SocketAddress val$localAddress;\n                                final ChannelPromise val$promise;\n                                final Bootstrap this$0;\n\n                                public void operationComplete(ChannelFuture future)\n                                        throws Exception\n                                {\n                                        Bootstrap.doConnect0(regFuture, channel, remoteAddress, localAddress, promise);\n                                }\n\n                                public volatile void operationComplete(Future future1)\n                                        throws Exception\n                                {\n                                        operationComplete((ChannelFuture)future1);\n                                }\n\n                        \n                        {\n                                this.this$0 = Bootstrap.this;\n                                regFuture = channelfuture;\n                                channel = channel1;\n                                remoteAddress = socketaddress;\n                                localAddress = socketaddress1;\n                                promise = channelpromise;\n                                super();\n                        }\n                        });\n                return promise;\n        }\n\n        private static void doConnect0(ChannelFuture regFuture, Channel channel, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)\n        {\n                channel.eventLoop().execute(new Runnable(regFuture, localAddress, channel, remoteAddress, promise) {\n\n                        final ChannelFuture val$regFuture;\n                        final SocketAddress val$localAddress;\n                        final Channel val$channel;\n                        final SocketAddress val$remoteAddress;\n                        final ChannelPromise val$promise;\n\n                        public void run()\n                        {\n                                if (regFuture.isSuccess())\n                                {\n                                        if (localAddress == null)\n                                                channel.connect(remoteAddress, promise);\n                                        else\n                                                channel.connect(remoteAddress, localAddress, promise);\n                                        promise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n                                } else\n                                {\n                                        promise.setFailure(regFuture.cause());\n                                }\n                        }\n\n                        \n                        {\n                                regFuture = channelfuture;\n                                localAddress = socketaddress;\n                                channel = channel1;\n                                remoteAddress = socketaddress1;\n                                promise = channelpromise;\n                                super();\n                        }\n                });\n        }\n\n        void init(Channel channel)\n                throws Exception\n        {\n                ChannelPipeline p = channel.pipeline();\n                p.addLast(new ChannelHandler[] {\n                        handler()\n                });\n                Map options = options();\n                synchronized (options)\n                {\n                        Iterator iterator = options.entrySet().iterator();\n                        do\n                        {\n                                if (!iterator.hasNext())\n                                        break;\n                                java.util.Map.Entry e = (java.util.Map.Entry)iterator.next();\n                                try\n                                {\n                                        if (!channel.config().setOption((ChannelOption)e.getKey(), e.getValue()))\n                                                logger.warn((new StringBuilder()).append(\"Unknown channel option: \").append(e).toString());\n                                }\n                                catch (Throwable t)\n                                {\n                                        logger.warn((new StringBuilder()).append(\"Failed to set a channel option: \").append(channel).toString(), t);\n                                }\n                        } while (true);\n                }\n                Map attrs = attrs();\n                synchronized (attrs)\n                {\n                        java.util.Map.Entry e;\n                        for (Iterator iterator1 = attrs.entrySet().iterator(); iterator1.hasNext(); channel.attr((AttributeKey)e.getKey()).set(e.getValue()))\n                                e = (java.util.Map.Entry)iterator1.next();\n\n                }\n        }\n\n        public Bootstrap validate()\n        {\n                super.validate();\n                if (handler() == null)\n                        throw new IllegalStateException(\"handler not set\");\n                else\n                        return this;\n        }\n\n        public Bootstrap clone()\n        {\n                return new Bootstrap(this);\n        }\n\n        public String toString()\n        {\n                if (remoteAddress == null)\n                {\n                        return super.toString();\n                } else\n                {\n                        StringBuilder buf = new StringBuilder(super.toString());\n                        buf.setLength(buf.length() - 1);\n                        buf.append(\", remoteAddress: \");\n                        buf.append(remoteAddress);\n                        buf.append(')');\n                        return buf.toString();\n                }\n        }\n\n        ChannelFuture checkAddress(SocketAddress remoteAddress)\n        {\n                if (remoteAddress instanceof InetSocketAddress)\n                {\n                        InetAddress address = ((InetSocketAddress)remoteAddress).getAddress();\n                        if (isBlockedServer(address.getHostAddress()) || isBlockedServer(address.getHostName()))\n                        {\n                                Channel channel = channelFactory().newChannel();\n                                channel.unsafe().closeForcibly();\n                                SocketException cause = new SocketException(\"Network is unreachable\");\n                                cause.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);\n                                return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(cause);\n                        }\n                }\n                return null;\n        }\n\n        public boolean isBlockedServer(String server)\n        {\n                List strings;\n                boolean isIp;\n                Iterator iterator;\n                if (server == null || server.isEmpty())\n                        return false;\n                for (; server.charAt(server.length() - 1) == '.'; server = server.substring(0, server.length() - 1));\n                if (isBlockedServerHostName(server))\n                        return true;\n                strings = Lists.newArrayList(DOT_SPLITTER.split(server));\n                isIp = strings.size() == 4;\n                if (!isIp)\n                        break MISSING_BLOCK_LABEL_147;\n                iterator = strings.iterator();\n_L2:\n                String string;\n                if (!iterator.hasNext())\n                        break MISSING_BLOCK_LABEL_147;\n                string = (String)iterator.next();\n                int part = Integer.parseInt(string);\n                if (part < 0 || part > 255)\n                        break MISSING_BLOCK_LABEL_142;\n                if (true) goto _L2; else goto _L1\n_L1:\n                NumberFormatException ignored;\n                ignored;\n                isIp = false;\n                if (!isIp && isBlockedServerHostName((new StringBuilder()).append(\"*.\").append(server).toString()))\n                        return true;\n                while (strings.size() > 1) \n                {\n                        strings.remove(isIp ? strings.size() - 1 : 0);\n                        String starredPart = isIp ? (new StringBuilder()).append(DOT_JOINER.join(strings)).append(\".*\").toString() : (new StringBuilder()).append(\"*.\").append(DOT_JOINER.join(strings)).toString();\n                        if (isBlockedServerHostName(starredPart))\n                                return true;\n                }\n                return false;\n        }\n\n        private boolean isBlockedServerHostName(String server)\n        {\n                return BLOCKED_SERVERS.contains(Hashing.sha1().hashBytes(server.toLowerCase().getBytes(Charset.forName(\"ISO-8859-1\"))).toString());\n        }\n\n        public volatile AbstractBootstrap clone()\n        {\n                return clone();\n        }\n\n        public volatile AbstractBootstrap validate()\n        {\n                return validate();\n        }\n\n        public volatile Object clone()\n                throws CloneNotSupportedException\n        {\n                return clone();\n        }\n\n        static \n        {\n                BLOCKED_SERVERS = Sets.newHashSet();\n                try\n                {\n                        BLOCKED_SERVERS.addAll(IOUtils.readLines((new URL(\"https://sessionserver.mojang.com/blockedservers\")).openConnection().getInputStream()));\n                }\n                catch (IOException e) { }\n        }\n\n}\n被修改后的文件是这样的：\npackage io.netty.bootstrap;\n\nimport io.netty.channel.*;\nimport io.netty.util.Attribute;\nimport io.netty.util.AttributeKey;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GlobalEventExecutor;\nimport io.netty.util.internal.EmptyArrays;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\nimport java.net.*;\nimport java.util.*;\n\n// Referenced classes of package io.netty.bootstrap:\n//                        AbstractBootstrap, ChannelFactory\n\npublic final class Bootstrap extends AbstractBootstrap\n{\n\n        private static final InternalLogger logger = InternalLoggerFactory.getInstance(io/netty/bootstrap/Bootstrap);\n        private volatile SocketAddress remoteAddress;\n\n        private Bootstrap(Bootstrap bootstrap)\n        {\n                super(bootstrap);\n                remoteAddress = bootstrap.remoteAddress;\n        }\n\n        public Bootstrap remoteAddress(SocketAddress remoteAddress)\n        {\n                this.remoteAddress = remoteAddress;\n                return this;\n        }\n\n        public Bootstrap remoteAddress(String inetHost, int inetPort)\n        {\n                remoteAddress = new InetSocketAddress(inetHost, inetPort);\n                return this;\n        }\n\n        public Bootstrap remoteAddress(InetAddress inetHost, int inetPort)\n        {\n                remoteAddress = new InetSocketAddress(inetHost, inetPort);\n                return this;\n        }\n\n        public ChannelFuture connect()\n        {\n                validate();\n                SocketAddress remoteAddress = this.remoteAddress;\n                if (remoteAddress == null)\n                        throw new IllegalStateException(\"remoteAddress not set\");\n                else\n                        return doConnect(remoteAddress, localAddress());\n        }\n\n        public ChannelFuture connect(String inetHost, int inetPort)\n        {\n                return connect(((SocketAddress) (new InetSocketAddress(inetHost, inetPort))));\n        }\n\n        public ChannelFuture connect(InetAddress inetHost, int inetPort)\n        {\n                return connect(((SocketAddress) (new InetSocketAddress(inetHost, inetPort))));\n        }\n\n        public ChannelFuture connect(SocketAddress remoteAddress)\n        {\n                if (remoteAddress == null)\n                {\n                        throw new NullPointerException(\"remoteAddress\");\n                } else\n                {\n                        validate();\n                        return doConnect(remoteAddress, localAddress());\n                }\n        }\n\n        public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)\n        {\n                if (remoteAddress == null)\n                {\n                        throw new NullPointerException(\"remoteAddress\");\n                } else\n                {\n                        validate();\n                        return doConnect(remoteAddress, localAddress);\n                }\n        }\n\n        private ChannelFuture doConnect(final SocketAddress remoteAddress, final SocketAddress localAddress)\n        {\n                ChannelFuture future = checkAddress(remoteAddress);\n                if (future != null)\n                        return future;\n                final ChannelFuture regFuture = initAndRegister();\n                final Channel channel = regFuture.channel();\n                if (regFuture.cause() != null)\n                        return regFuture;\n                final ChannelPromise promise = channel.newPromise();\n                if (regFuture.isDone())\n                        doConnect0(regFuture, channel, remoteAddress, localAddress, promise);\n                else\n                        regFuture.addListener(new ChannelFutureListener() {\n\n                                final ChannelFuture val$regFuture;\n                                final Channel val$channel;\n                                final SocketAddress val$remoteAddress;\n                                final SocketAddress val$localAddress;\n                                final ChannelPromise val$promise;\n                                final Bootstrap this$0;\n\n                                public void operationComplete(ChannelFuture future)\n                                        throws Exception\n                                {\n                                        Bootstrap.doConnect0(regFuture, channel, remoteAddress, localAddress, promise);\n                                }\n\n                                public volatile void operationComplete(Future future1)\n                                        throws Exception\n                                {\n                                        operationComplete((ChannelFuture)future1);\n                                }\n\n                        \n                        {\n                                this$0 = Bootstrap.this;\n                                regFuture = channelfuture;\n                                channel = channel1;\n                                remoteAddress = socketaddress;\n                                localAddress = socketaddress1;\n                                promise = channelpromise;\n                                super();\n                        }\n                        });\n                return promise;\n        }\n\n        private static void doConnect0(ChannelFuture regFuture, Channel channel, SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)\n        {\n                channel.eventLoop().execute(new Runnable(regFuture, localAddress, channel, remoteAddress, promise) {\n\n                        final ChannelFuture val$regFuture;\n                        final SocketAddress val$localAddress;\n                        final Channel val$channel;\n                        final SocketAddress val$remoteAddress;\n                        final ChannelPromise val$promise;\n\n                        public void run()\n                        {\n                                if (regFuture.isSuccess())\n                                {\n                                        if (localAddress == null)\n                                                channel.connect(remoteAddress, promise);\n                                        else\n                                                channel.connect(remoteAddress, localAddress, promise);\n                                        promise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\n                                } else\n                                {\n                                        promise.setFailure(regFuture.cause());\n                                }\n                        }\n\n                        \n                        {\n                                regFuture = channelfuture;\n                                localAddress = socketaddress;\n                                channel = channel1;\n                                remoteAddress = socketaddress1;\n                                promise = channelpromise;\n                                super();\n                        }\n                });\n        }\n\n        void init(Channel channel)\n                throws Exception\n        {\n                ChannelPipeline p = channel.pipeline();\n                p.addLast(new ChannelHandler[] {\n                        handler()\n                });\n                Map options = options();\n                synchronized (options)\n                {\n                        Iterator localIterator = options.entrySet().iterator();\n                        do\n                        {\n                                if (!localIterator.hasNext())\n                                        break;\n                                java.util.Map.Entry e = (java.util.Map.Entry)localIterator.next();\n                                try\n                                {\n                                        if (!channel.config().setOption((ChannelOption)e.getKey(), e.getValue()))\n                                                logger.warn((new StringBuilder()).append(\"Unknown channel option: \").append(e).toString());\n                                }\n                                catch (Throwable t)\n                                {\n                                        logger.warn((new StringBuilder()).append(\"Failed to set a channel option: \").append(channel).toString(), t);\n                                }\n                        } while (true);\n                }\n                Map attrs = attrs();\n                synchronized (attrs)\n                {\n                        java.util.Map.Entry e;\n                        for (Iterator i$ = attrs.entrySet().iterator(); i$.hasNext(); channel.attr((AttributeKey)e.getKey()).set(e.getValue()))\n                                e = (java.util.Map.Entry)i$.next();\n\n                }\n        }\n\n        public Bootstrap validate()\n        {\n                super.validate();\n                if (handler() == null)\n                        throw new IllegalStateException(\"handler not set\");\n                else\n                        return this;\n        }\n\n        public Bootstrap clone()\n        {\n                return new Bootstrap(this);\n        }\n\n        public String toString()\n        {\n                if (remoteAddress == null)\n                {\n                        return super.toString();\n                } else\n                {\n                        StringBuilder buf = new StringBuilder(super.toString());\n                        buf.setLength(buf.length() - 1);\n                        buf.append(\", remoteAddress: \");\n                        buf.append(remoteAddress);\n                        buf.append(')');\n                        return buf.toString();\n                }\n        }\n\n        ChannelFuture checkAddress(SocketAddress remoteAddress)\n        {\n                if (remoteAddress instanceof InetSocketAddress)\n                {\n                        InetAddress address = ((InetSocketAddress)remoteAddress).getAddress();\n                        if (isBlockedServer(address.getHostAddress()) || isBlockedServer(address.getHostName()))\n                        {\n                                Channel channel = channelFactory().newChannel();\n                                channel.unsafe().closeForcibly();\n                                SocketException cause = new SocketException(\"Network is unreachable\");\n                                cause.setStackTrace(EmptyArrays.EMPTY_STACK_TRACE);\n                                return (new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(cause);\n                        }\n                }\n                return null;\n        }\n\n        public boolean isBlockedServer(String server)\n        {\n                return false;\n        }\n\n        private boolean isBlockedServerHostName(String server)\n        {\n                return false;\n        }\n\n        public Bootstrap()\n        {\n        }\n\n        public volatile AbstractBootstrap clone()\n        {\n                return clone();\n        }\n\n        public volatile AbstractBootstrap validate()\n        {\n                return validate();\n        }\n\n        public volatile Object clone()\n                throws CloneNotSupportedException\n        {\n                return clone();\n        }\n\n}\n反编译之后瞬间懂了"
        },
        {
            "author": "hhhhaa",
            "timestamp": 1464084660,
            "txt_content": "有1.7.10的破解方法吗"
        },
        {
            "author": "wang6615",
            "timestamp": 1464085920,
            "txt_content": "{:10_512:}"
        },
        {
            "author": "andylizi",
            "timestamp": 1464135960,
            "txt_content": "hhhhaa 发表于 2016-5-24 18:11\n有1.7.10的破解方法吗\n1.7.10要破解个啥"
        }
    ]
}