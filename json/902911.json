{
    "title": "如何表示一个Float类型的值",
    "author": "鸭蛋只吃黄",
    "replyCount": 7,
    "timestamp": 1565860740,
    "txt_content": " 本帖最后由 凋灵兔子 于 2019-8-15 17:26 编辑 \n\n<Java虚拟机规范> 中给出的读取 Float 值的方式是:\n\n防挂: https://i.loli.net/2019/08/15/iQPtmCgBukpvqa3.png\n\n虽然说书中提到了 JVM 的表示方式和 IEEE 754 不太一样, 但是能看出来大部分是一样的, 都是 1 + 8 + 23 的储存方式, 但是为什么它指数为 0 要左移一位(乘以2)?\n\n计算底数 m 时 &7fffff 就已经将除底数区域以外的 9 个 bit 都清零了, 接下来完全可以直接在首位补 1, 然后就 s x m x 2^(e-150) 算出原值了...虽然我猜测右移一位也是为了补 1 , 但是...这是为啥啊, 莫名其妙就乘以二.\n",
    "replies": [
        {
            "author": "耗子",
            "timestamp": 1565863080,
            "txt_content": " 本帖最后由 耗子 于 2019-8-15 18:01 编辑 \n\n可以参考\nFloat.floatToRawIntBits();\nFloat.floatToIntBits();复制代码\n\n看错问题了，我滚了。"
        },
        {
            "author": "ijrys",
            "timestamp": 1565866320,
            "txt_content": "左移是因为底数的第一位能保证是1，这样这个1就可以省略了，能增加一丢丢的精度\n还有，java的浮点型就是ieee754标准\n你要做转换还是用自带默认方法吧，bug少并且速度快\n自己没事不要搞这些东西"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1565866500,
            "txt_content": " 本帖最后由 凋灵兔子 于 2019-8-15 19:04 编辑 \nijrys 发表于 2019-8-15 18:52\n左移是因为底数的第一位能保证是1，这样这个1就可以省略了，能增加一丢丢的精度\n还有，java的浮点型就是iee ...\ndalao能不能加个QQ..\n\n正是因为省略了首位的 1 所以不管指数如何, 补 1 是一定的, 为什么指数为 0 时就不补了呢?\n"
        },
        {
            "author": "gooding300",
            "timestamp": 1565870220,
            "txt_content": " 本帖最后由 gooding300 于 2019-8-15 20:14 编辑 \n\n我们假定不对e为0的情况进行判断：\nint s = ((bits >> 31) == 0) ? 1 : -1;\n int e = ((bits >> 23) & 0xff);\n int m = (bits & 0x7fffff) | 0x800000;复制代码接下来完全可以直接在首位补 1, 然后就 s * m * 2^(e-150) 算出原值了...\n请试着分析一下，按照这个流程，如何才能表示出0这个数字。\n\n我们会发现，s取值只有1和-1，不会是0，m取值由于首位补1了，也不会是0，2^(e-150)无论如何不会是0 。\n如果一个浮点数标准无法解决0这一个常见数字的表示方法，恐怕也难以成为主流标准广受使用至今，当e为0是非规约数（Denormalized numbers），此时不再补1，这样才可以准确表示0以及非常接近0的数字。\ne-150是e-127-23，其中127是标准规定的偏移值，23是小数点移位（例如1111B*2^(-3)=1.111B，3代表将整数变为小数点后有3个数字的小数）。\n左移1是因为，实际指数是e-127，而e为0时对应的实际指数是-126，而不是-127，因此需要在这里将m乘以2，才能使得s * m * 2 * 2^(-127)=s * m * 2^(-126)。\n\n如果我的回答对您的问题有所帮助，请给我最高的评分！"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1565885700,
            "txt_content": "gooding300 发表于 2019-8-15 19:57\n我们假定不对e为0的情况进行判断：\ndalao, 那浮点数的整数部分如果是 1, 那 e 是否也是 0 呢? 比如说 1.1, 这里就无需移位啊..."
        },
        {
            "author": "gooding300",
            "timestamp": 1565886360,
            "txt_content": "凋灵兔子 发表于 2019-8-16 00:15\ndalao, 那浮点数的整数部分如果是 1, 那 e 是否也是 0 呢? 比如说 1.1, 这里就无需移位啊... ...\n23的移位是必须的，e是0的时候代表这个数字不补1，而不是不移位，<<1是起到*2的作用。"
        },
        {
            "author": "ijrys",
            "timestamp": 1565926440,
            "txt_content": "凋灵兔子 发表于 2019-8-15 18:55\ndalao能不能加个QQ..\n\n正是因为省略了首位的 1 所以不管指数如何, 补 1 是一定的, 为什么指数为 0 时就不 ...\n指数为0并不代表指数值是0\n指数是用移码表示的，0是最小的数，全是1是最大的数\n比如float32指数是8位，那么1000 0000表示0，0000 0000是-128，1111 1111是127\n这样指数为0的时候这个值是很接近于0的，在ieee754标准来看这个值为0，这样就不需要正规化了\n\nhttps://www.jianshu.com/p/e5d72d764f2f\n\n你可以找找大学计组的课，都会讲这块内容\n\n还有，没事别自己搞这些东西，现在浮点数的内容都是靠硬件去跑的（相关指令集：x87），比你写这些乱七八糟的效率高多了，也标准\n"
        }
    ]
}