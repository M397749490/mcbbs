{
    "title": "【转载】Jimmy04creeper的forge教程",
    "author": "manageryzy",
    "replyCount": 10,
    "timestamp": 1391760060,
    "txt_content": " 本帖最后由 manageryzy 于 2014-2-7 16:01 编辑 \n\n来自minecraft forum （不知道怎么的这个帖子还要翻墙才能看，就搬运来了\nhttp://www.minecraftforum.net/topic/1797143-152-16-forge-dimension-tutorial-multi-biome-dimension-ore-gen-basic-house-gen-tree-gen-skyrenderer-githubsrc-code/\n\n这个教程包含了基本的方块到维度的创建的一系列的教程，教程以代码为主，少数的英文我就翻译了，代码的注释就不翻译了\n\n\n这个教程的所有内容将会针对 minecraft 1.5.2 使用forge 以及eclipse.\n我为了 1.5.1写了这个教程所以我升级它到1.5.2以便人们需要升级他们的mod.\n有些人在 1.6.2 使用了它并且回复说除了贴图部分需要修改其他的都能够工作.\n大多数的代码和以前一样,我在你需要修改的那些代码附近多增加了一些低吗，你不懂的直接问就好（po表示你应该去原帖去问啦，po是小白\n这个教程包含了自定义新的生物群系包含自定义的顶部以及填充方块，而且我也可以修改主要的填充方块（通常在55高度一下是石头，原文注）.\n生物群系也有一个可以非常容易实现的自定义水的颜色（就像是沼泽的水合海洋的水的颜色不一样，po注） \n我会发出来我的主要的mod文件来告诉你如何增加维度(dimension，就是指类似于主世界，下界，末地之类的)、如何增加或者注册方块以及如何增加生物群系以及如何添加名字.\n那么我们开始吧.\n下面是主要文件的代码\n\n主要的mod文件代码package dimension;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.item.Item;\nimport net.minecraft.world.biome.BiomeGenBase;\nimport net.minecraftforge.common.DimensionManager;\nimport cpw.mods.fml.common.Mod;\nimport cpw.mods.fml.common.event.FMLInitializationEvent;\nimport cpw.mods.fml.common.network.NetworkMod;\nimport cpw.mods.fml.common.registry.GameRegistry;\nimport cpw.mods.fml.common.registry.LanguageRegistry;\n@Mod(modid=\"Tutorial\", name=\"Tutorial\", version=\"1.0\")\n@NetworkMod(clientSideRequired=true, serverSideRequired=false)\npublic class Main\n{\n/** Dimension ID **/\npublic static int DimID = 2;\n\n/** Blocks **/\npublic static BlockTutorialFire TutorialFire = (BlockTutorialFire)new BlockTutorialFire(2008).setUnlocalizedName(\"Tuturial:Tutorialfire_0\");\npublic static BlockTutorialPortal TutorialPortal = (BlockTutorialPortal)new BlockTutorialPortal(2009).setUnlocalizedName(\"Tutorial:TutorialPortal\");\npublic static Block TutorialGrass = new BlockTutorialGrass(200).setUnlocalizedName(\"Tutorial:grassSide\");\npublic static Block TutorialDirt = new BlockTutorialDirt(201).setUnlocalizedName(\"Tutorial:Dirt\");\npublic static Block TutorialStone = new BlockTutorialStone(202).setUnlocalizedName(\"Tutorial:Stone\");\n/** Items **/\npublic static Item TutorialFlintAndSteel = new ItemTutorialFlintAndSteel(3047).setUnlocalizedName(\"Tutorial:TutorialFlintAndSteel\");\npublic static Item TutorialPortalPlacer = new ItemPortalPlacer(3048).setUnlocalizedName(\"Tutorial:TutorialPortalPlacer\");\n/** Biome's **/\npublic static final BiomeGenBase TutorialBiome = new BiomeGenTutorial(25);\n@Mod.Init\npublic void load(FMLInitializationEvent event)\n{\n/** Register Blocks **/\nGameRegistry.registerBlock(TutorialFire, \"TutorialFire\");\nGameRegistry.registerBlock(TutorialPortal, \"TutorialPortal\");\nGameRegistry.registerBlock(TutorialGrass, \"TutorialGrass\");\nGameRegistry.registerBlock(TutorialDirt, \"TutorialDirt\");\nGameRegistry.registerBlock(TutorialStone, \"TutorialStone\");\n/** Register Items **/\nGameRegistry.registerItem(TutorialFlintAndSteel, \"TutorialFlintAndSteel\");\nGameRegistry.registerItem(TutorialPortalPlacer, \"TutorialPortalPlacer\");\n/** Add In-Game Names **/\nLanguageRegistry.addName(TutorialGrass, \"Tutorial Grass\");\nLanguageRegistry.addName(TutorialDirt, \"Tutorial Dirt\");\nLanguageRegistry.addName(TutorialStone, \"Tutorial Stone\");\nLanguageRegistry.addName(TutorialFire, \"Tutorial Fire\");\nLanguageRegistry.addName(TutorialPortal, \"Tutorial Portal\");\nLanguageRegistry.addName(TutorialFlintAndSteel, \"Tutorial Lighter\");\nLanguageRegistry.addName(TutorialPortalPlacer, \"Portal Placer\");\n/**Register WorldProvider for Dimension **/\nDimensionManager.registerProviderType(DimID, WorldProviderTuorial.class, true);\nDimensionManager.registerDimension(DimID, DimID);\n}\n}复制代码方块以及实体\n现在我们先创建TutorialBlockFire（这名字一看就是一个方块的名字啦，下面的名字都是类似的，po就不翻译名字啦）\npackage dimension;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport java.util.Random;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockFire;\nimport net.minecraft.block.BlockHalfSlab;\nimport net.minecraft.block.BlockLeaves;\nimport net.minecraft.block.BlockTallGrass;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.client.renderer.texture.IconRegister;\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraft.util.Icon;\nimport net.minecraft.world.GameRules;\nimport net.minecraft.world.IBlockAccess;\nimport net.minecraft.world.World;\nimport net.minecraftforge.common.ForgeDirection;\npublic class BlockTutorialFire extends BlockFire\n{\nprivate int[] chanceToEncourageFire = new int[256];\nprivate int[] abilityToCatchFire = new int[256];\n@SideOnly(Side.CLIENT)\nprivate Icon[] iconArray;\npublic BlockTutorialFire(int par1)\n{\nsuper(par1);\nsetTickRandomly(true);\nsetCreativeTab(CreativeTabs.tabMaterials);\n}\npublic Icon getIcon(int par1, int par2)\n{\nreturn this.blockIcon;\n}\npublic void initializeBlock()\n{\nthis.abilityToCatchFire = Block.blockFlammability;\nthis.chanceToEncourageFire = Block.blockFireSpreadSpeed;\nsetBurnRate(Block.planks.blockID, 5, 20);\nsetBurnRate(Block.woodDoubleSlab.blockID, 5, 20);\nsetBurnRate(Block.woodSingleSlab.blockID, 5, 20);\nsetBurnRate(Block.fence.blockID, 5, 20);\nsetBurnRate(Block.stairsWoodOak.blockID, 5, 20);\nsetBurnRate(Block.stairsWoodBirch.blockID, 5, 20);\nsetBurnRate(Block.stairsWoodSpruce.blockID, 5, 20);\nsetBurnRate(Block.stairsWoodJungle.blockID, 5, 20);\nsetBurnRate(Block.wood.blockID, 5, 5);\nsetBurnRate(Block.leaves.blockID, 30, 60);\nsetBurnRate(Block.bookShelf.blockID, 30, 20);\nsetBurnRate(Block.tnt.blockID, 15, 100);\nsetBurnRate(Block.tallGrass.blockID, 60, 100);\nsetBurnRate(Block.cloth.blockID, 30, 60);\nsetBurnRate(Block.vine.blockID, 15, 100);\n}\nprivate void setBurnRate(int par1, int par2, int par3)\n{\nBlock.setBurnProperties(par1, par2, par3);\n}\npublic AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)\n{\nreturn null;\n}\npublic boolean isOpaqueCube()\n{\nreturn false;\n}\npublic boolean renderAsNormalBlock()\n{\nreturn false;\n}\npublic int getRenderType()\n{\nreturn 3;\n}\npublic int quantityDropped(Random par1Random)\n{\nreturn 0;\n}\npublic int tickRate(World par1World)\n{\nreturn 30;\n}\npublic void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)\n{\nif (par1World.getGameRules().getGameRuleBooleanValue(\"doFireTick\"))\n{\nBlock base = Block.blocksList[par1World.getBlockId(par2, par3 - 1, par4)];\nboolean flag = (base != null) && (base.isFireSource(par1World, par2, par3 - 1, par4, par1World.getBlockMetadata(par2, par3 - 1, par4), ForgeDirection.UP));\nif (!canPlaceBlockAt(par1World, par2, par3, par4))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nif ((!flag) && (par1World.isRaining()) && ((par1World.canLightningStrikeAt(par2, par3, par4)) || (par1World.canLightningStrikeAt(par2 - 1, par3, par4)) || (par1World.canLightningStrikeAt(par2 + 1, par3, par4)) || (par1World.canLightningStrikeAt(par2, par3, par4 - 1)) || (par1World.canLightningStrikeAt(par2, par3, par4 + 1))))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nelse\n{\nint l = par1World.getBlockMetadata(par2, par3, par4);\nif (l < 15)\n{\npar1World.setBlockMetadataWithNotify(par2, par3, par4, l + par5Random.nextInt(3) / 2, 4);\n}\npar1World.scheduleBlockUpdate(par2, par3, par4, this.blockID, tickRate(par1World) + par5Random.nextInt(10));\nif ((!flag) && (!canNeighborBurn(par1World, par2, par3, par4)))\n{\nif ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) || (l > 3))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\n}\nelse if ((!flag) && (!canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)) && (l == 15) && (par5Random.nextInt(4) == 0))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nelse\n{\nboolean flag1 = par1World.isBlockHighHumidity(par2, par3, par4);\nbyte b0 = 0;\nif (flag1)\n{\nb0 = -50;\n}\ntryToCatchBlockOnFire(par1World, par2 + 1, par3, par4, 300 + b0, par5Random, l, ForgeDirection.WEST);\ntryToCatchBlockOnFire(par1World, par2 - 1, par3, par4, 300 + b0, par5Random, l, ForgeDirection.EAST);\ntryToCatchBlockOnFire(par1World, par2, par3 - 1, par4, 250 + b0, par5Random, l, ForgeDirection.UP);\ntryToCatchBlockOnFire(par1World, par2, par3 + 1, par4, 250 + b0, par5Random, l, ForgeDirection.DOWN);\ntryToCatchBlockOnFire(par1World, par2, par3, par4 - 1, 300 + b0, par5Random, l, ForgeDirection.SOUTH);\ntryToCatchBlockOnFire(par1World, par2, par3, par4 + 1, 300 + b0, par5Random, l, ForgeDirection.NORTH);\nfor (int i1 = par2 - 1; i1 <= par2 + 1; i1++)\n{\nfor (int j1 = par4 - 1; j1 <= par4 + 1; j1++)\n{\nfor (int k1 = par3 - 1; k1 <= par3 + 4; k1++)\n{\nif ((i1 != par2) || (k1 != par3) || (j1 != par4))\n{\nint l1 = 100;\nif (k1 > par3 + 1)\n{\nl1 += (k1 - (par3 + 1)) * 100;\n}\nint i2 = getChanceOfNeighborsEncouragingFire(par1World, i1, k1, j1);\nif (i2 > 0)\n{\nint j2 = (i2 + 40 + par1World.difficultySetting * 7) / (l + 30);\nif (flag1)\n{\nj2 /= 2;\n}\nif ((j2 > 0) && (par5Random.nextInt(l1) <= j2) && ((!par1World.isRaining()) || (!par1World.canLightningStrikeAt(i1, k1, j1))) && (!par1World.canLightningStrikeAt(i1 - 1, k1, par4)) && (!par1World.canLightningStrikeAt(i1 + 1, k1, j1)) && (!par1World.canLightningStrikeAt(i1, k1, j1 - 1)) && (!par1World.canLightningStrikeAt(i1, k1, j1 + 1)))\n{\nint k2 = l + par5Random.nextInt(5) / 4;\nif (k2 > 15)\n{\nk2 = 15;\n}\npar1World.setBlock(i1, k1, j1, this.blockID, k2, 3);\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\npublic boolean func_82506_l() {\nreturn true;\n}\n@Deprecated\nprivate void tryToCatchBlockOnFire(World par1World, int par2, int par3, int par4, int par5, Random par6Random, int par7) {\ntryToCatchBlockOnFire(par1World, par2, par3, par4, par5, par6Random, par7, ForgeDirection.UP);\n}\nprivate void tryToCatchBlockOnFire(World par1World, int par2, int par3, int par4, int par5, Random par6Random, int par7, ForgeDirection face) {\nint j1 = 0;\nBlock block = Block.blocksList[par1World.getBlockId(par2, par3, par4)];\nif (block != null)\n{\nj1 = block.getFlammability(par1World, par2, par3, par4, par1World.getBlockMetadata(par2, par3, par4), face);\n}\nif (par6Random.nextInt(par5) < j1)\n{\nboolean flag = par1World.getBlockId(par2, par3, par4) == Block.tnt.blockID;\nif ((par6Random.nextInt(par7 + 10) < 5) && (!par1World.canLightningStrikeAt(par2, par3, par4)))\n{\nint k1 = par7 + par6Random.nextInt(5) / 4;\nif (k1 > 15)\n{\nk1 = 15;\n}\npar1World.setBlock(par2, par3, par4, this.blockID, k1, 3);\n}\nelse\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nif (flag)\n{\nBlock.tnt.onBlockDestroyedByPlayer(par1World, par2, par3, par4, 1);\n}\n}\n}\nprivate boolean canNeighborBurn(World par1World, int par2, int par3, int par4)\n{\nreturn (canBlockCatchFire(par1World, par2 + 1, par3, par4, ForgeDirection.WEST)) ||\n(canBlockCatchFire(par1World, par2 - 1, par3, par4, ForgeDirection.EAST)) ||\n(canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)) ||\n(canBlockCatchFire(par1World, par2, par3 + 1, par4, ForgeDirection.DOWN)) ||\n(canBlockCatchFire(par1World, par2, par3, par4 - 1, ForgeDirection.SOUTH)) ||\n(canBlockCatchFire(par1World, par2, par3, par4 + 1, ForgeDirection.NORTH));\n}\nprivate int getChanceOfNeighborsEncouragingFire(World par1World, int par2, int par3, int par4)\n{\nbyte b0 = 0;\nif (!par1World.isAirBlock(par2, par3, par4))\n{\nreturn 0;\n}\nint l = getChanceToEncourageFire(par1World, par2 + 1, par3, par4, b0, ForgeDirection.WEST);\nl = getChanceToEncourageFire(par1World, par2 - 1, par3, par4, l, ForgeDirection.EAST);\nl = getChanceToEncourageFire(par1World, par2, par3 - 1, par4, l, ForgeDirection.UP);\nl = getChanceToEncourageFire(par1World, par2, par3 + 1, par4, l, ForgeDirection.DOWN);\nl = getChanceToEncourageFire(par1World, par2, par3, par4 - 1, l, ForgeDirection.SOUTH);\nl = getChanceToEncourageFire(par1World, par2, par3, par4 + 1, l, ForgeDirection.NORTH);\nreturn l;\n}\npublic boolean isCollidable()\n{\nreturn false;\n}\n@Deprecated\npublic boolean canBlockCatchFire(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)\n{\nreturn canBlockCatchFire(par1IBlockAccess, par2, par3, par4, ForgeDirection.UP);\n}\n@Deprecated\npublic int getChanceToEncourageFire(World par1World, int par2, int par3, int par4, int par5)\n{\nreturn getChanceToEncourageFire(par1World, par2, par3, par4, par5, ForgeDirection.UP);\n}\npublic boolean canPlaceBlockAt(World par1World, int par2, int par3, int par4)\n{\nreturn (par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) || (canNeighborBurn(par1World, par2, par3, par4));\n}\npublic void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)\n{\nif ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!canNeighborBurn(par1World, par2, par3, par4)))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\n}\npublic void onBlockAdded(World par1World, int par2, int par3, int par4)\n{\n/** Change these to your portal frame and Portal block **/\nif ((par1World.getBlockId(par2, par3 - 1, par4) != Block.blockDiamond.blockID) || (!Main.TutorialPortal.tryToCreatePortal(par1World, par2, par3, par4)))\n{\nif ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!canNeighborBurn(par1World, par2, par3, par4)))\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nelse\n{\npar1World.scheduleBlockUpdate(par2, par3, par4, this.blockID, tickRate(par1World) + par1World.rand.nextInt(10));\n}\n}\n}\n@SideOnly(Side.CLIENT)\npublic void randomDisplayTick(World par1World, int par2, int par3, int par4, Random par5Random)\n{\nif (par5Random.nextInt(24) == 0)\n{\npar1World.playSound(par2 + 0.5F, par3 + 0.5F, par4 + 0.5F, \"fire.fire\", 1.0F + par5Random.nextFloat(), par5Random.nextFloat() * 0.7F + 0.3F, false);\n}\nif ((!par1World.doesBlockHaveSolidTopSurface(par2, par3 - 1, par4)) && (!Main.TutorialFire.canBlockCatchFire(par1World, par2, par3 - 1, par4, ForgeDirection.UP)))\n{\nif (Main.TutorialFire.canBlockCatchFire(par1World, par2 - 1, par3, par4, ForgeDirection.EAST))\n{\nfor (int l = 0; l < 2; l++)\n{\nfloat f = par2 + par5Random.nextFloat() * 0.1F;\nfloat f1 = par3 + par5Random.nextFloat();\nfloat f2 = par4 + par5Random.nextFloat();\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\nif (Main.TutorialFire.canBlockCatchFire(par1World, par2 + 1, par3, par4, ForgeDirection.WEST))\n{\nfor (int l = 0; l < 2; l++)\n{\nfloat f = par2 + 1 - par5Random.nextFloat() * 0.1F;\nfloat f1 = par3 + par5Random.nextFloat();\nfloat f2 = par4 + par5Random.nextFloat();\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\nif (Main.TutorialFire.canBlockCatchFire(par1World, par2, par3, par4 - 1, ForgeDirection.SOUTH))\n{\nfor (int l = 0; l < 2; l++)\n{\nfloat f = par2 + par5Random.nextFloat();\nfloat f1 = par3 + par5Random.nextFloat();\nfloat f2 = par4 + par5Random.nextFloat() * 0.1F;\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\nif (Main.TutorialFire.canBlockCatchFire(par1World, par2, par3, par4 + 1, ForgeDirection.NORTH))\n{\nfor (int l = 0; l < 2; l++)\n{\nfloat f = par2 + par5Random.nextFloat();\nfloat f1 = par3 + par5Random.nextFloat();\nfloat f2 = par4 + 1 - par5Random.nextFloat() * 0.1F;\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\nif (Main.TutorialFire.canBlockCatchFire(par1World, par2, par3 + 1, par4, ForgeDirection.DOWN))\n{\nfor (int l = 0; l < 2; l++)\n{\nfloat f = par2 + par5Random.nextFloat();\nfloat f1 = par3 + 1 - par5Random.nextFloat() * 0.1F;\nfloat f2 = par4 + par5Random.nextFloat();\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\n}\nelse\n{\nfor (int l = 0; l < 3; l++)\n{\nfloat f = par2 + par5Random.nextFloat();\nfloat f1 = par3 + par5Random.nextFloat() * 0.5F + 0.5F;\nfloat f2 = par4 + par5Random.nextFloat();\npar1World.spawnParticle(\"largesmoke\", f, f1, f2, 0.0D, 0.0D, 0.0D);\n}\n}\n}\npublic boolean canBlockCatchFire(IBlockAccess world, int x, int y, int z, ForgeDirection face)\n{\nBlock block = Block.blocksList[world.getBlockId(x, y, z)];\nif (block != null)\n{\nreturn block.isFlammable(world, x, y, z, world.getBlockMetadata(x, y, z), face);\n}\nreturn false;\n}\npublic int getChanceToEncourageFire(World world, int x, int y, int z, int oldChance, ForgeDirection face)\n{\nint newChance = 0;\nBlock block = Block.blocksList[world.getBlockId(x, y, z)];\nif (block != null)\n{\nnewChance = block.getFireSpreadSpeed(world, x, y, z, world.getBlockMetadata(x, y, z), face);\n}\nreturn newChance > oldChance ? newChance : oldChance;\n}\n/** registers Icons, set textures here **/\n@SideOnly(Side.CLIENT)\npublic void registerIcons(IconRegister par1IconRegister)\n{\nthis.iconArray = new Icon[] { par1IconRegister.registerIcon(\"Tutorial:Tutorialfire_0\"), par1IconRegister.registerIcon(\"Tutorial:Tutorialfire_1\") };\n}\n@SideOnly(Side.CLIENT)\npublic Icon func_94438_c(int par1) {\nreturn this.iconArray[par1];\n}\n@SideOnly(Side.CLIENT)\npublic Icon getBlockTextureFromSideAndMetadata(int par1, int par2)\n{\nreturn this.iconArray[0];\n}\n}复制代码下面我们创建Block Tutorial Portal（听名字就是传送门啦）\npackage dimension;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport java.util.Random;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockBreakable;\nimport net.minecraft.block.BlockPortal;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.player.EntityPlayerMP;\nimport net.minecraft.item.ItemMonsterPlacer;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraft.world.IBlockAccess;\nimport net.minecraft.world.World;\npublic class BlockTutorialPortal extends BlockBreakable\n{\npublic BlockTutorialPortal(int par1)\n{\nsuper(par1, \"Tutorial:TutorialPortal\", Material.portal, false);\nthis.setTickRandomly(true);\nthis.setHardness(-1.0F);\nthis.setStepSound(soundGlassFootstep);\nthis.setLightValue(0.75F);\n         this.setCreativeTab(CreativeTabs.tabBlock);\n}\n/**\n* Ticks the block if it's been scheduled\n*/\npublic void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)\n{\nsuper.updateTick(par1World, par2, par3, par4, par5Random);\nif (par1World.provider.isSurfaceWorld() && par5Random.nextInt(2000) < par1World.difficultySetting)\n{\nint l;\nfor (l = par3; !par1World.doesBlockHaveSolidTopSurface(par2, l, par4) && l > 0; --l)\n{\n;\n}\nif (l > 0 && !par1World.isBlockNormalCube(par2, l + 1, par4))\n{\nEntity entity = ItemMonsterPlacer.spawnCreature(par1World, 57, (double)par2 + 0.5D, (double)l + 1.1D, (double)par4 + 0.5D);\nif (entity != null)\n{\n         entity.timeUntilPortal = entity.getPortalCooldown();\n}\n}\n}\n}\n/**\n* Returns a bounding box from the pool of bounding boxes (this means this box can change after the pool has been\n* cleared to be reused)\n*/\npublic AxisAlignedBB getCollisionBoundingBoxFromPool(World par1World, int par2, int par3, int par4)\n{\nreturn null;\n}\n/**\n* Updates the blocks bounds based on its current state. Args: world, x, y, z\n*/\npublic void setBlockBoundsBasedOnState(IBlockAccess par1IBlockAccess, int par2, int par3, int par4)\n{\nfloat f;\nfloat f1;\nif (par1IBlockAccess.getBlockId(par2 - 1, par3, par4) != this.blockID && par1IBlockAccess.getBlockId(par2 + 1, par3, par4) != this.blockID)\n{\nf = 0.125F;\nf1 = 0.5F;\nthis.setBlockBounds(0.5F - f, 0.0F, 0.5F - f1, 0.5F + f, 1.0F, 0.5F + f1);\n}\nelse\n{\nf = 0.5F;\nf1 = 0.125F;\nthis.setBlockBounds(0.5F - f, 0.0F, 0.5F - f1, 0.5F + f, 1.0F, 0.5F + f1);\n}\n}\n/**\n* Is this block (a) opaque and (B) a full 1m cube? This determines whether or not to render the shared face of two\n* adjacent blocks and also whether the player can attach torches, redstone wire, etc to this block.\n*/\npublic boolean isOpaqueCube()\n{\nreturn false;\n}\n/**\n* If this block doesn't render as an ordinary block it will return False (examples: signs, buttons, stairs, etc)\n*/\n@Override\npublic boolean renderAsNormalBlock()\n{\nreturn false;\n}\n/**\n* Checks to see if this location is valid to create a portal and will return True if it does. Args: world, x, y, z\n*/\npublic boolean tryToCreatePortal(World par1World, int par2, int par3, int par4)\n{\nbyte b0 = 0;\nbyte b1 = 0;\nif (par1World.getBlockId(par2 - 1, par3, par4) == Block.blockDiamond.blockID || par1World.getBlockId(par2 + 1, par3, par4) == Block.blockDiamond.blockID)\n{\nb0 = 1;\n}\nif (par1World.getBlockId(par2, par3, par4 - 1) == Block.blockDiamond.blockID || par1World.getBlockId(par2, par3, par4 + 1) == Block.blockDiamond.blockID)\n{\nb1 = 1;\n}\nif (b0 == b1)\n{\nreturn false;\n}\nelse\n{\nif (par1World.getBlockId(par2 - b0, par3, par4 - b1) == 0)\n{\npar2 -= b0;\npar4 -= b1;\n}\nint l;\nint i1;\nfor (l = -1; l <= 2; ++l)\n{\nfor (i1 = -1; i1 <= 3; ++i1)\n{\n         boolean flag = l == -1 || l == 2 || i1 == -1 || i1 == 3;\n         if (l != -1 && l != 2 || i1 != -1 && i1 != 3)\n         {\n         int j1 = par1World.getBlockId(par2 + b0 * l, par3 + i1, par4 + b1 * l);\n         if (flag)\n         {\n         if (j1 != Block.blockDiamond.blockID)\n         {\n         return false;\n         }\n         }\n         else if (j1 != 0 && j1 != Main.TutorialFire.blockID)\n         {\n         return false;\n         }\n         }\n}\n}\nfor (l = 0; l < 2; ++l)\n{\nfor (i1 = 0; i1 < 3; ++i1)\n{\n         par1World.setBlock(par2 + b0 * l, par3 + i1, par4 + b1 * l, Main.TutorialPortal.blockID, 0, 2);\n}\n}\nreturn true;\n}\n}\n/**\n* Lets the block know when one of its neighbor changes. Doesn't know which neighbor changed (coordinates passed are\n* their own) Args: x, y, z, neighbor blockID\n*/\npublic void onNeighborBlockChange(World par1World, int par2, int par3, int par4, int par5)\n{\nbyte b0 = 0;\nbyte b1 = 1;\nif (par1World.getBlockId(par2 - 1, par3, par4) == this.blockID || par1World.getBlockId(par2 + 1, par3, par4) == this.blockID)\n{\nb0 = 1;\nb1 = 0;\n}\nint i1;\nfor (i1 = par3; par1World.getBlockId(par2, i1 - 1, par4) == this.blockID; --i1)\n{\n;\n}\nif (par1World.getBlockId(par2, i1 - 1, par4) != Block.blockDiamond.blockID)\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\nelse\n{\nint j1;\nfor (j1 = 1; j1 < 4 && par1World.getBlockId(par2, i1 + j1, par4) == this.blockID; ++j1)\n{\n;\n}\nif (j1 == 3 && par1World.getBlockId(par2, i1 + j1, par4) == Block.blockDiamond.blockID)\n{\nboolean flag = par1World.getBlockId(par2 - 1, par3, par4) == this.blockID || par1World.getBlockId(par2 + 1, par3, par4) == this.blockID;\nboolean flag1 = par1World.getBlockId(par2, par3, par4 - 1) == this.blockID || par1World.getBlockId(par2, par3, par4 + 1) == this.blockID;\nif (flag && flag1)\n{\n         par1World.setBlockToAir(par2, par3, par4);\n}\nelse\n{\n         if ((par1World.getBlockId(par2 + b0, par3, par4 + b1) != Block.blockDiamond.blockID || par1World.getBlockId(par2 - b0, par3, par4 - b1) != this.blockID) && (par1World.getBlockId(par2 - b0, par3, par4 - b1) != Block.blockDiamond.blockID || par1World.getBlockId(par2 + b0, par3, par4 + b1) != this.blockID))\n         {\n         par1World.setBlockToAir(par2, par3, par4);\n         }\n}\n}\nelse\n{\npar1World.setBlockToAir(par2, par3, par4);\n}\n}\n}\n@SideOnly(Side.CLIENT)\n/**\n* Returns true if the given side of this block type should be rendered, if the adjacent block is at the given\n* coordinates. Args: blockAccess, x, y, z, side\n*/\npublic boolean shouldSideBeRendered(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)\n{\nif (par1IBlockAccess.getBlockId(par2, par3, par4) == this.blockID)\n{\nreturn false;\n}\nelse\n{\nboolean flag = par1IBlockAccess.getBlockId(par2 - 1, par3, par4) == this.blockID && par1IBlockAccess.getBlockId(par2 - 2, par3, par4) != this.blockID;\nboolean flag1 = par1IBlockAccess.getBlockId(par2 + 1, par3, par4) == this.blockID && par1IBlockAccess.getBlockId(par2 + 2, par3, par4) != this.blockID;\nboolean flag2 = par1IBlockAccess.getBlockId(par2, par3, par4 - 1) == this.blockID && par1IBlockAccess.getBlockId(par2, par3, par4 - 2) != this.blockID;\nboolean flag3 = par1IBlockAccess.getBlockId(par2, par3, par4 + 1) == this.blockID && par1IBlockAccess.getBlockId(par2, par3, par4 + 2) != this.blockID;\nboolean flag4 = flag || flag1;\nboolean flag5 = flag2 || flag3;\nreturn flag4 && par5 == 4 ? true : (flag4 && par5 == 5 ? true : (flag5 && par5 == 2 ? true : flag5 && par5 == 3));\n}\n}\n/**\n* Returns the quantity of items to drop on block destruction.\n*/\npublic int quantityDropped(Random par1Random)\n{\nreturn 0;\n}\n/**\n* Triggered whenever an entity collides with this block (enters into the block). Args: world, x, y, z, entity\n*/\npublic void onEntityCollidedWithBlock(World par1World, int par2, int par3, int par4, Entity par5Entity)\n{\nif ((par5Entity.ridingEntity == null) && (par5Entity.riddenByEntity == null) && ((par5Entity instanceof EntityPlayerMP)))\n         {\n         EntityPlayerMP thePlayer = (EntityPlayerMP)par5Entity;\n         if (thePlayer.timeUntilPortal > 0)\n         {\n                 thePlayer.timeUntilPortal = 10;\n         }\n         else if (thePlayer.dimension != Main.DimID)\n         {\n                 thePlayer.timeUntilPortal = 10;\n                 thePlayer.mcServer.getConfigurationManager().transferPlayerToDimension(thePlayer, Main.DimID, new TutorialTeleporter(thePlayer.mcServer.worldServerForDimension(Main.DimID)));\n         }\n         else {\n                 thePlayer.timeUntilPortal = 10;\n                 thePlayer.mcServer.getConfigurationManager().transferPlayerToDimension(thePlayer, 0, new TutorialTeleporter(thePlayer.mcServer.worldServerForDimension(0)));\n         }\n         }\n}\n@SideOnly(Side.CLIENT)\n/**\n* Returns which pass should this block be rendered on. 0 for solids and 1 for alpha\n*/\npublic int getRenderBlockPass()\n{\nreturn 1;\n}\n@SideOnly(Side.CLIENT)\n/**\n* A randomly called display update to be able to add particles or other items for display\n*/\npublic void randomDisplayTick(World par1World, int par2, int par3, int par4, Random par5Random)\n{\nif (par5Random.nextInt(100) == 0)\n{\npar1World.playSound((double)par2 + 0.5D, (double)par3 + 0.5D, (double)par4 + 0.5D, \"portal.portal\", 0.5F, par5Random.nextFloat() * 0.4F + 0.8F, false);\n}\nfor (int l = 0; l < 4; ++l)\n{\ndouble d0 = (double)((float)par2 + par5Random.nextFloat());\ndouble d1 = (double)((float)par3 + par5Random.nextFloat());\ndouble d2 = (double)((float)par4 + par5Random.nextFloat());\ndouble d3 = 0.0D;\ndouble d4 = 0.0D;\ndouble d5 = 0.0D;\nint i1 = par5Random.nextInt(2) * 2 - 1;\nd3 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;\nd4 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;\nd5 = ((double)par5Random.nextFloat() - 0.5D) * 0.5D;\nif (par1World.getBlockId(par2 - 1, par3, par4) != this.blockID && par1World.getBlockId(par2 + 1, par3, par4) != this.blockID)\n{\nd0 = (double)par2 + 0.5D + 0.25D * (double)i1;\nd3 = (double)(par5Random.nextFloat() * 2.0F * (float)i1);\n}\nelse\n{\nd2 = (double)par4 + 0.5D + 0.25D * (double)i1;\nd5 = (double)(par5Random.nextFloat() * 2.0F * (float)i1);\n}\npar1World.spawnParticle(\"portal\", d0, d1, d2, d3, d4, d5);\n}\n}\n@SideOnly(Side.CLIENT)\n/**\n* only called by clickMiddleMouseButton , and passed to inventory.setCurrentItem (along with isCreative)\n*/\npublic int idPicked(World par1World, int par2, int par3, int par4)\n{\nreturn 0;\n}\n}复制代码现在我们会创建Tutorial Grass\n\n\npackage dimension;\n\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport java.util.Random;\n\nimport net.minecraft.block.Block;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.client.renderer.texture.IconRegister;\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.util.Icon;\nimport net.minecraft.world.ColorizerGrass;\nimport net.minecraft.world.IBlockAccess;\nimport net.minecraft.world.World;\n\npublic class BlockTutorialGrass extends Block\n{\n@SideOnly(Side.CLIENT)\nprivate Icon iconGrassTop;\n@SideOnly(Side.CLIENT)\nprivate Icon iconGrassBottom;\n@SideOnly(Side.CLIENT)\nprivate static Icon iconGrassSideOverlay;\n\nprotected BlockTutorialGrass(int par1)\n{\nsuper(par1, Material.grass);\nthis.setTickRandomly(true);\nthis.setCreativeTab(CreativeTabs.tabBlock);\n}\n\n@SideOnly(Side.CLIENT)\n\n/**\n* From the specified side and block metadata retrieves the blocks texture. Args: side, metadata\n*/\npublic Icon getIcon(int par1, int par2)\n{\nreturn par1 == 1 ? this.iconGrassTop : (par1 == 0 ? this.iconGrassBottom : this.blockIcon);\n}\n\n/**\n* Ticks the block if it's been scheduled\n*/\npublic void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)\n{\nif (!par1World.isRemote)\n{\nif (par1World.getBlockLightValue(par2, par3 + 1, par4) < 4 && par1World.getBlockLightOpacity(par2, par3 + 1, par4) > 2)\n{\npar1World.setBlock(par2, par3, par4, Block.dirt.blockID);\n}\nelse if (par1World.getBlockLightValue(par2, par3 + 1, par4) >= 9)\n{\nfor (int l = 0; l < 4; ++l)\n{\nint i1 = par2 + par5Random.nextInt(3) - 1;\nint j1 = par3 + par5Random.nextInt(5) - 3;\nint k1 = par4 + par5Random.nextInt(3) - 1;\nint l1 = par1World.getBlockId(i1, j1 + 1, k1);\n\nif (par1World.getBlockId(i1, j1, k1) == Block.dirt.blockID && par1World.getBlockLightValue(i1, j1 + 1, k1) >= 4 && par1World.getBlockLightOpacity(i1, j1 + 1, k1) <= 2)\n{\npar1World.setBlock(i1, j1, k1, Main.TutorialGrass.blockID);\n}\n}\n}\n}\n}\n\n/**\n* Returns the ID of the items to drop on destruction.\n*/\npublic int idDropped(int par1, Random par2Random, int par3)\n{\nreturn Block.dirt.idDropped(0, par2Random, par3);\n}\n\n@SideOnly(Side.CLIENT)\n\n/**\n* Retrieves the block texture to use based on the display side. Args: iBlockAccess, x, y, z, side\n*/\npublic Icon getBlockTexture(IBlockAccess par1IBlockAccess, int par2, int par3, int par4, int par5)\n{\nif (par5 == 1)\n{\nreturn this.iconGrassTop;\n}\nelse if (par5 == 0)\n{\nreturn this.iconGrassBottom;\n}\nelse\n{\n\nreturn this.blockIcon;\n}\n}\n\n@SideOnly(Side.CLIENT)\n\n/**\n* When this method is called, your block should register all the icons it needs with the given IconRegister. This\n* is the only chance you get to register icons.\n*/\npublic void registerIcons(IconRegister par1IconRegister)\n{\nthis.blockIcon = par1IconRegister.registerIcon(\"Tutorial:grassSide\");\nthis.iconGrassTop = par1IconRegister.registerIcon(\"Tutorial:grassTop\");\nthis.iconGrassBottom = par1IconRegister.registerIcon(\"Tutorial:grassBottom\");\nthis.iconGrassSideOverlay = par1IconRegister.registerIcon(\"Tutorial:grassSide\");\n}\n\n@SideOnly(Side.CLIENT)\npublic static Icon getIconSideOverlay()\n{\nreturn iconGrassSideOverlay;\n}\n}复制代码我不会接下来重写石头和泥土的代码了因为它们就是 Block.dirt 以及Block.stone的拷贝\n\n\n下面我们要做的是打火石，代码是从原版的打火石偷来的（开启传送门，po注）\npackage dimension;\nimport java.util.Random;\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.world.World;\npublic class ItemTutorialFlintAndSteel extends Item\n{\npublic ItemTutorialFlintAndSteel(int par1)\n{\nsuper(par1);\nthis.maxStackSize = 1;\nsetMaxDamage(64);\nsetCreativeTab(CreativeTabs.tabTools);\n}\npublic boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int par4, int par5, int par6, int par7, float par8, float par9, float par10)\n{\nif (par7 == 0)\n{\npar5--;\n}\nif (par7 == 1)\n{\npar5++;\n}\nif (par7 == 2)\n{\npar6--;\n}\nif (par7 == 3)\n{\npar6++;\n}\nif (par7 == 4)\n{\npar4--;\n}\nif (par7 == 5)\n{\npar4++;\n}\nif (!par2EntityPlayer.canPlayerEdit(par4, par5, par6, par7, par1ItemStack))\n{\nreturn false;\n}\nint i1 = par3World.getBlockId(par4, par5, par6);\nif (i1 == 0)\n{\npar3World.playSoundEffect(par4 + 0.5D, par5 + 0.5D, par6 + 0.5D, \"fire.ignite\", 1.0F, itemRand.nextFloat() * 0.4F + 0.8F);\n/** replace with your fire block **/\npar3World.setBlock(par4, par5, par6, Main.TutorialFire.blockID);\n}\npar1ItemStack.damageItem(1, par2EntityPlayer);\nreturn true;\n}\n}复制代码传送门放置器的代码\npackage dimension;\nimport net.minecraft.block.Block;\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.world.World;\npublic class ItemPortalPlacer extends Item\n{\npublic ItemPortalPlacer(int par1)\n{\nsuper(par1);\nsetCreativeTab(CreativeTabs.tabTools);\n}\npublic boolean onItemUse(ItemStack par1ItemStack, EntityPlayer par2EntityPlayer, World par3World, int X, int Y, int Z, int par7, float par8, float par9, float par10)\n{\nif (!par3World.isRemote)\n{\nint direction = MathHelper.floor_double(par2EntityPlayer.rotationYaw * 4.0F / 360.0F + 0.5D) & 0x3;\nif ((direction == 1) || (direction == 3))\n{\nfor (int y = 1; y < 5; y++)\n{\n         for (int z = -1; z < 2; z++)\n         {\n         if (par3World.getBlockId(X, Y + y, Z + z) != 0)\n         {\n         par2EntityPlayer.addChatMessage(\"No room for a portal.\");\n                 return false;\n         }\n         }\n}\npar3World.setBlock(X, Y + 1, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 1, Y + 1, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 2, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 1, Y + 2, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 2, Y + 2, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 1, Y + 2, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 3, Y + 3, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 3, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 3, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 3, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 3, Y + 4, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 4, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 4, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 4, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 3, Y + 5, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 5, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 5, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 5, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 2, Y + 6, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 1, Y + 6, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 7, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 1, Y + 7, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 6, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 1, Y + 6, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X, Y + 3, Z, Main.TutorialFire.blockID);\n}\nelse\n{\nfor (int y = 1; y < 5; y++)\n{\n         for (int x = -1; x < 2; x++)\n         {\n         if (par3World.getBlockId(X + x, Y + y, Z) != 0)\n         {\n         par2EntityPlayer.addChatMessage(\"No room for a portal.\");\n         return false;\n         }\n         }\n}\npar3World.setBlock(X, Y + 1, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 1, Y + 1, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 2, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 1, Y + 2, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 2, Y + 2, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 1, Y + 2, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 3, Y + 3, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 3, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 3, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 3, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 3, Y + 4, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 4, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 4, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 4, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 3, Y + 5, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 2, Y + 5, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 2, Y + 5, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X - 1, Y + 5, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 2, Y + 6, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X - 1, Y + 6, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 7, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X + 1, Y + 7, Z, Block.oreDiamond.blockID);\npar3World.setBlock(X, Y + 6, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X + 1, Y + 6, Z, Block.blockDiamond.blockID);\npar3World.setBlock(X, Y + 3, Z, Main.TutorialFire.blockID);\n}\nreturn true;\n}\nreturn true;\n}\n}复制代码生物群系生成代码package dimension;\nimport java.util.List;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.world.IBlockAccess;\nimport net.minecraft.world.biome.BiomeGenBase;\nimport net.minecraft.world.gen.feature.WorldGenerator;\npublic class BiomeGenTutorial extends BiomeGenBase\n{\nprivate WorldGenerator UnDeadworldGeneratorBigTree;\npublic final Material blockMaterial;\npublic BiomeGenTutorial(int par1)\n{\nsuper(par1);\nthis.blockMaterial = Material.water;\nthis.minHeight = 0.1F;\nthis.maxHeight = 0.6F;\nthis.spawnableMonsterList.clear();\nthis.spawnableCreatureList.clear();\nthis.topBlock = ((byte)Main.TutorialGrass.blockID);\nthis.fillerBlock = ((byte)Main.TutorialDirt.blockID);\nthis.setBiomeName(\"Tutorial\");\n\n/** this changes the water colour, its set to red now but ggole the java colours **/\nthis.waterColorMultiplier = 0xE42D17;\n}\n}复制代码区块生成代码package dimension;\nimport java.util.List;\nimport java.util.Random;\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.EnumCreatureType;\nimport net.minecraft.util.IProgressUpdate;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.world.ChunkPosition;\nimport net.minecraft.world.SpawnerAnimals;\nimport net.minecraft.world.World;\nimport net.minecraft.world.biome.BiomeGenBase;\nimport net.minecraft.world.biome.WorldChunkManager;\nimport net.minecraft.world.chunk.Chunk;\nimport net.minecraft.world.chunk.IChunkProvider;\nimport net.minecraft.world.gen.MapGenBase;\nimport net.minecraft.world.gen.MapGenCaves;\nimport net.minecraft.world.gen.MapGenRavine;\nimport net.minecraft.world.gen.NoiseGeneratorOctaves;\nimport net.minecraft.world.gen.feature.MapGenScatteredFeature;\nimport net.minecraft.world.gen.feature.WorldGenLakes;\nimport net.minecraft.world.gen.structure.MapGenMineshaft;\nimport net.minecraft.world.gen.structure.MapGenStronghold;\nimport net.minecraft.world.gen.structure.MapGenVillage;\npublic class ChunkProviderTutorial implements IChunkProvider\n{\nprivate Random rand;\nprivate NoiseGeneratorOctaves noiseGen1;\nprivate NoiseGeneratorOctaves noiseGen2;\nprivate NoiseGeneratorOctaves noiseGen3;\nprivate NoiseGeneratorOctaves noiseGen4;\npublic NoiseGeneratorOctaves noiseGen5;\npublic NoiseGeneratorOctaves noiseGen6;\npublic NoiseGeneratorOctaves mobSpawnerNoise;\nprivate World worldObj;\nprivate final boolean mapFeaturesEnabled;\nprivate double[] noiseArray;\nprivate double[] stoneNoise = new double[256];\nprivate MapGenBase caveGenerator = new MapGenCaves();\nprivate MapGenStronghold strongholdGenerator = new MapGenStronghold();\nprivate MapGenVillage villageGenerator = new MapGenVillage();\nprivate MapGenMineshaft mineshaftGenerator = new MapGenMineshaft();\nprivate MapGenScatteredFeature scatteredFeatureGenerator = new MapGenScatteredFeature();\nprivate MapGenBase ravineGenerator = new MapGenRavine();\nprivate BiomeGenBase[] biomesForGeneration;\ndouble[] noise3;\ndouble[] noise1;\ndouble[] noise2;\ndouble[] noise5;\ndouble[] noise6;\nfloat[] parabolicField;\nint[][] field_73219_j = new int[32][32];\npublic ChunkProviderTutorial(World par1World, long par2, boolean par4) {\nthis.worldObj = par1World;\nthis.mapFeaturesEnabled = par4;\nthis.rand = new Random(par2);\nthis.noiseGen1 = new NoiseGeneratorOctaves(this.rand, 16);\nthis.noiseGen2 = new NoiseGeneratorOctaves(this.rand, 16);\nthis.noiseGen3 = new NoiseGeneratorOctaves(this.rand, 8);\nthis.noiseGen4 = new NoiseGeneratorOctaves(this.rand, 4);\nthis.noiseGen5 = new NoiseGeneratorOctaves(this.rand, 10);\nthis.noiseGen6 = new NoiseGeneratorOctaves(this.rand, 16);\nthis.mobSpawnerNoise = new NoiseGeneratorOctaves(this.rand, 8);\n}\n/**\n* Generates the shape of the terrain for the chunk though its all stone though the water is frozen if the\n* temperature is low enough\n*/\npublic void generateTerrain(int par1, int par2, byte[] par3ArrayOfByte)\n{\nbyte b0 = 4;\nbyte b1 = 16;\nbyte b2 = 63;\nint k = b0 + 1;\nbyte b3 = 17;\nint l = b0 + 1;\nthis.biomesForGeneration = this.worldObj.getWorldChunkManager().getBiomesForGeneration(this.biomesForGeneration, par1 * 4 - 2, par2 * 4 - 2, k + 5, l + 5);\nthis.noiseArray = this.initializeNoiseField(this.noiseArray, par1 * b0, 0, par2 * b0, k, b3, l);\nfor (int i1 = 0; i1 < b0; ++i1)\n{\nfor (int j1 = 0; j1 < b0; ++j1)\n{\nfor (int k1 = 0; k1 < b1; ++k1)\n{\n         double d0 = 0.125D;\n         double d1 = this.noiseArray[((i1 + 0) * l + j1 + 0) * b3 + k1 + 0];\n         double d2 = this.noiseArray[((i1 + 0) * l + j1 + 1) * b3 + k1 + 0];\n         double d3 = this.noiseArray[((i1 + 1) * l + j1 + 0) * b3 + k1 + 0];\n         double d4 = this.noiseArray[((i1 + 1) * l + j1 + 1) * b3 + k1 + 0];\n         double d5 = (this.noiseArray[((i1 + 0) * l + j1 + 0) * b3 + k1 + 1] - d1) * d0;\n         double d6 = (this.noiseArray[((i1 + 0) * l + j1 + 1) * b3 + k1 + 1] - d2) * d0;\n         double d7 = (this.noiseArray[((i1 + 1) * l + j1 + 0) * b3 + k1 + 1] - d3) * d0;\n         double d8 = (this.noiseArray[((i1 + 1) * l + j1 + 1) * b3 + k1 + 1] - d4) * d0;\n         for (int l1 = 0; l1 < 8; ++l1)\n         {\n         double d9 = 0.25D;\n         double d10 = d1;\n         double d11 = d2;\n         double d12 = (d3 - d1) * d9;\n         double d13 = (d4 - d2) * d9;\n         for (int i2 = 0; i2 < 4; ++i2)\n         {\n         int j2 = i2 + i1 * 4 << 11 | 0 + j1 * 4 << 7 | k1 * 8 + l1;\n         short short1 = 128;\n         j2 -= short1;\n         double d14 = 0.25D;\n         double d15 = (d11 - d10) * d14;\n         double d16 = d10 - d15;\n         for (int k2 = 0; k2 < 4; ++k2)\n         {\n         if ((d16 += d15) > 0.0D)\n         {\n                 /** Main filler block fill's all the underground, replaces block stone **/\n                 par3ArrayOfByte[j2 += short1] = (byte)Main.TutorialStone.blockID;//\n         }\n         else if (k1 * 8 + l1 < b2)\n         {\n                 par3ArrayOfByte[j2 += short1] = (byte)Block.waterStill.blockID;\n         }\n         else\n         {\n                 par3ArrayOfByte[j2 += short1] = 0;\n         }\n         }\n         d10 += d12;\n         d11 += d13;\n         }\n         d1 += d5;\n         d2 += d6;\n         d3 += d7;\n         d4 += d8;\n         }\n}\n}\n}\n}\npublic void replaceBlocksForBiome(int par1, int par2, byte[] par3ArrayOfByte, BiomeGenBase[] par4ArrayOfBiomeGenBase)\n{\nbyte var5 = 63;\ndouble var6 = 0.03125D;\nthis.stoneNoise = this.noiseGen4.generateNoiseOctaves(this.stoneNoise, par1 * 16, par2 * 16, 0, 16, 16, 1, var6 * 2.0D, var6 * 2.0D, var6 * 2.0D);\nfor (int var8 = 0; var8 < 16; var8++)\n{\nfor (int var9 = 0; var9 < 16; var9++)\n{\nBiomeGenBase var10 = par4ArrayOfBiomeGenBase[(var9 + var8 * 16)];\nfloat var11 = var10.getFloatTemperature();\nint var12 = (int)(this.stoneNoise[(var8 + var9 * 16)] / 3.0D + 3.0D + this.rand.nextDouble() * 0.25D);\nint var13 = -1;\nbyte var14 = var10.topBlock;\nbyte var15 = var10.fillerBlock;\nfor (int var16 = 127; var16 >= 0; var16--)\n{\n         int var17 = (var9 * 16 + var8) * 128 + var16;\n         if (var16 <= 0 + this.rand.nextInt(5))\n         {\n         par3ArrayOfByte[var17] = ((byte)Block.bedrock.blockID);\n         }\n         else\n         {\n         byte var18 = par3ArrayOfByte[var17];\n         if (var18 == 0)\n         {\n         var13 = -1;\n         }\n         /** Main filler block fill's all the underground, replaces block stone **/\n         else if (var18 != Main.TutorialStone.blockID)\n         {\n         if (var13 == -1)\n         {\n         if (var12 == 0)\n         {\n                 var14 = 0;\n                \n                 /** change to custom dirt **/\n                 var15 = (byte)Main.TutorialDirt.blockID;//\n         }\n         else if ((var16 >= var5 - 4) && (var16 <= var5 + 1))\n         {\n                 var14 = var10.topBlock;\n                 var15 = var10.fillerBlock;\n         }\n         if ((var16 < var5) && (var14 == 0))\n         {\n                 if (var11 < 0.15F)\n                 {\n                 var14 = (byte)Block.ice.blockID;\n                 }\n                 else\n                 {\n                 var14 = (byte)Block.waterStill.blockID;\n                 }\n         }\n         var13 = var12;\n         if (var16 >= var5 - 1)\n         {\n                 par3ArrayOfByte[var17] = var14;\n         }\n         else\n         {\n                 par3ArrayOfByte[var17] = var15;\n         }\n         }\n         else if (var13 > 0)\n         {\n         var13--;\n         par3ArrayOfByte[var17] = var15;\n         if ((var13 == 0) && (var15 == Block.sand.blockID))\n         {\n                 var13 = this.rand.nextInt(4);\n                 var15 = (byte)Block.sandStone.blockID;\n         }\n         }\n         }\n         }\n}\n}\n}\n}\npublic Chunk loadChunk(int par1, int par2)\n{\nreturn provideChunk(par1, par2);\n}\npublic Chunk provideChunk(int par1, int par2)\n{\nthis.rand.setSeed(par1 * 341873128712L + par2 * 132897987541L);\nbyte[] var3 = new byte[32768];\ngenerateTerrain(par1, par2, var3);\nthis.biomesForGeneration = this.worldObj.getWorldChunkManager().loadBlockGeneratorData(this.biomesForGeneration, par1 * 16, par2 * 16, 16, 16);\nreplaceBlocksForBiome(par1, par2, var3, this.biomesForGeneration);\nthis.caveGenerator.generate(this, this.worldObj, par1, par2, var3);\nthis.ravineGenerator.generate(this, this.worldObj, par1, par2, var3);\nif (this.mapFeaturesEnabled)\n{\nthis.mineshaftGenerator.generate(this, this.worldObj, par1, par2, var3);\nthis.villageGenerator.generate(this, this.worldObj, par1, par2, var3);\nthis.strongholdGenerator.generate(this, this.worldObj, par1, par2, var3);\nthis.scatteredFeatureGenerator.generate(this, this.worldObj, par1, par2, var3);\n}\nChunk var4 = new Chunk(this.worldObj, var3, par1, par2);\nbyte[] var5 = var4.getBiomeArray();\nfor (int var6 = 0; var6 < var5.length; var6++)\n{\nvar5[var6] = ((byte)this.biomesForGeneration[var6].biomeID);\n}\nvar4.generateSkylightMap();\nreturn var4;\n}\nprivate double[] initializeNoiseField(double[] par1ArrayOfDouble, int par2, int par3, int par4, int par5, int par6, int par7)\n{\nif (par1ArrayOfDouble == null)\n{\npar1ArrayOfDouble = new double[par5 * par6 * par7];\n}\nif (this.parabolicField == null)\n{\nthis.parabolicField = new float[25];\nfor (int var8 = -2; var8 <= 2; var8++)\n{\nfor (int var9 = -2; var9 <= 2; var9++)\n{\n         float var10 = 10.0F / MathHelper.sqrt_float(var8 * var8 + var9 * var9 + 0.2F);\n         this.parabolicField[(var8 + 2 + (var9 + 2) * 5)] = var10;\n}\n}\n}\ndouble var44 = 684.41200000000003D;\ndouble var45 = 684.41200000000003D;\nthis.noise5 = this.noiseGen5.generateNoiseOctaves(this.noise5, par2, par4, par5, par7, 1.121D, 1.121D, 0.5D);\nthis.noise6 = this.noiseGen6.generateNoiseOctaves(this.noise6, par2, par4, par5, par7, 200.0D, 200.0D, 0.5D);\nthis.noise3 = this.noiseGen3.generateNoiseOctaves(this.noise3, par2, par3, par4, par5, par6, par7, var44 / 80.0D, var45 / 160.0D, var44 / 80.0D);\nthis.noise1 = this.noiseGen1.generateNoiseOctaves(this.noise1, par2, par3, par4, par5, par6, par7, var44, var45, var44);\nthis.noise2 = this.noiseGen2.generateNoiseOctaves(this.noise2, par2, par3, par4, par5, par6, par7, var44, var45, var44);\nboolean var43 = false;\nboolean var42 = false;\nint var12 = 0;\nint var13 = 0;\nfor (int var14 = 0; var14 < par5; var14++)\n{\nfor (int var15 = 0; var15 < par7; var15++)\n{\nfloat var16 = 0.0F;\nfloat var17 = 0.0F;\nfloat var18 = 0.0F;\nbyte var19 = 2;\nBiomeGenBase var20 = this.biomesForGeneration[(var14 + 2 + (var15 + 2) * (par5 + 5))];\nfor (int var21 = -var19; var21 <= var19; var21++)\n{\n         for (int var22 = -var19; var22 <= var19; var22++)\n         {\n         BiomeGenBase var23 = this.biomesForGeneration[(var14 + var21 + 2 + (var15 + var22 + 2) * (par5 + 5))];\n         float var24 = this.parabolicField[(var21 + 2 + (var22 + 2) * 5)] / (var23.minHeight + 2.0F);\n         if (var23.minHeight > var20.minHeight)\n         {\n         var24 /= 2.0F;\n         }\n         var16 += var23.maxHeight * var24;\n         var17 += var23.minHeight * var24;\n         var18 += var24;\n         }\n}\nvar16 /= var18;\nvar17 /= var18;\nvar16 = var16 * 0.9F + 0.1F;\nvar17 = (var17 * 4.0F - 1.0F) / 8.0F;\ndouble var47 = this.noise6[var13] / 8000.0D;\nif (var47 < 0.0D)\n{\n         var47 = -var47 * 0.3D;\n}\nvar47 = var47 * 3.0D - 2.0D;\nif (var47 < 0.0D)\n{\n         var47 /= 2.0D;\n         if (var47 < -1.0D)\n         {\n         var47 = -1.0D;\n         }\n         var47 /= 1.4D;\n         var47 /= 2.0D;\n}\nelse\n{\n         if (var47 > 1.0D)\n         {\n         var47 = 1.0D;\n         }\n         var47 /= 8.0D;\n}\nvar13++;\nfor (int var46 = 0; var46 < par6; var46++)\n{\n         double var48 = var17;\n         double var26 = var16;\n         var48 += var47 * 0.2D;\n         var48 = var48 * par6 / 16.0D;\n         double var28 = par6 / 2.0D + var48 * 4.0D;\n         double var30 = 0.0D;\n         double var32 = (var46 - var28) * 12.0D * 128.0D / 128.0D / var26;\n         if (var32 < 0.0D)\n         {\n         var32 *= 4.0D;\n         }\n         double var34 = this.noise1[var12] / 512.0D;\n         double var36 = this.noise2[var12] / 512.0D;\n         double var38 = (this.noise3[var12] / 10.0D + 1.0D) / 2.0D;\n         if (var38 < 0.0D)\n         {\n         var30 = var34;\n         }\n         else if (var38 > 1.0D)\n         {\n         var30 = var36;\n         }\n         else\n         {\n         var30 = var34 + (var36 - var34) * var38;\n         }\n         var30 -= var32;\n         if (var46 > par6 - 4)\n         {\n         double var40 = (var46 - (par6 - 4)) / 3.0F;\n         var30 = var30 * (1.0D - var40) + -10.0D * var40;\n         }\n         par1ArrayOfDouble[var12] = var30;\n         var12++;\n}\n}\n}\nreturn par1ArrayOfDouble;\n}\npublic boolean chunkExists(int par1, int par2)\n{\nreturn true;\n}\npublic void populate(IChunkProvider par1IChunkProvider, int par2, int par3)\n{\nnet.minecraft.block.BlockSand.fallInstantly = true;\nint var4 = par2 * 16;\nint var5 = par3 * 16;\nBiomeGenBase var6 = this.worldObj.getBiomeGenForCoords(var4 + 16, var5 + 16);\nthis.rand.setSeed(this.worldObj.getSeed());\nlong var7 = this.rand.nextLong() / 2L * 2L + 1L;\nlong var9 = this.rand.nextLong() / 2L * 2L + 1L;\nthis.rand.setSeed(par2 * var7 + par3 * var9 ^ this.worldObj.getSeed());\nboolean var11 = false;\nif (this.mapFeaturesEnabled)\n{\nthis.mineshaftGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);\nvar11 = this.villageGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);\nthis.strongholdGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);\nthis.scatteredFeatureGenerator.generateStructuresInChunk(this.worldObj, this.rand, par2, par3);\n}\nif ((!var11) && (this.rand.nextInt(4) == 0))\n{\nint var12 = var4 + this.rand.nextInt(16) + 8;\nint var13 = this.rand.nextInt(128);\nint var14 = var5 + this.rand.nextInt(16) + 8;\nnew WorldGenLakes(Block.waterStill.blockID).generate(this.worldObj, this.rand, var12, var13, var14);\n}\nvar6.decorate(this.worldObj, this.rand, var4, var5);\nSpawnerAnimals.performWorldGenSpawning(this.worldObj, var6, var4 + 8, var5 + 8, 16, 16, this.rand);\nvar4 += 8;\nvar5 += 8;\nfor (int var12 = 0; var12 < 16; var12++)\n{\nfor (int var13 = 0; var13 < 16; var13++)\n{\nint var14 = this.worldObj.getPrecipitationHeight(var4 + var12, var5 + var13);\nif (this.worldObj.isBlockFreezable(var12 + var4, var14 - 1, var13 + var5))\n{\n         this.worldObj.setBlock(var12 + var4, var14 - 1, var13 + var5, Block.ice.blockID);\n}\nif (this.worldObj.canSnowAt(var12 + var4, var14, var13 + var5))\n{\n         this.worldObj.setBlock(var12 + var4, var14, var13 + var5, Block.snow.blockID);\n}\n}\n}\nnet.minecraft.block.BlockSand.fallInstantly = false;\n}\npublic boolean saveChunks(boolean par1, IProgressUpdate par2IProgressUpdate)\n{\nreturn true;\n}\npublic boolean unload100OldestChunks()\n{\nreturn false;\n}\npublic boolean canSave()\n{\nreturn true;\n}\npublic String makeString()\n{\nreturn \"RandomLevelSource\";\n}\npublic List getPossibleCreatures(EnumCreatureType par1EnumCreatureType, int par2, int par3, int par4)\n{\nBiomeGenBase var5 = this.worldObj.getBiomeGenForCoords(par2, par4);\nreturn var5 == null ? null : var5.getSpawnableList(par1EnumCreatureType);\n}\npublic ChunkPosition findClosestStructure(World par1World, String par2Str, int par3, int par4, int par5)\n{\nreturn (\"Stronghold\".equals(par2Str)) && (this.strongholdGenerator != null) ? this.strongholdGenerator.getNearestInstance(par1World, par3, par4, par5) : null;\n}\npublic int getLoadedChunkCount() {\nreturn 0;\n}\npublic boolean unloadQueuedChunks()\n{\nreturn false;\n}\npublic void recreateStructures(int i, int j)\n{\n}\n@Override\npublic void func_104112_b() {\n// TODO Auto-generated method stub\n}\n}复制代码World Provider代码\n\n\n\npackage dimension;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport net.minecraft.util.ChunkCoordinates;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.util.Vec3;\nimport net.minecraft.util.Vec3Pool;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldProvider;\nimport net.minecraft.world.biome.WorldChunkManagerHell;\nimport net.minecraft.world.chunk.IChunkProvider;\npublic class WorldProviderTuorial extends WorldProvider\n{\nprivate float[] colorsSunriseSunset = new float[4];\npublic void registerWorldChunkManager()\n{\nthis.worldChunkMgr = new WorldChunkManagerHell(Main.TutorialBiome, this.dimensionId, this.dimensionId);\nthis.dimensionId = Main.DimID;\nthis.hasNoSky = false;\n}\npublic IChunkProvider createChunkGenerator()\n{\nreturn new ChunkProviderTutorial(this.worldObj, this.worldObj.getSeed(), false);\n}\npublic int getAverageGroundLevel()\n{\nreturn 0;\n}\n@SideOnly(Side.CLIENT)\npublic boolean doesXZShowFog(int par1, int par2)\n{\nreturn false;\n}\npublic String getDimensionName()\n{\nreturn \"UnDead\";\n}\npublic boolean renderStars()\n{\nreturn true;\n}\npublic float getStarBrightness(World world, float f)\n{\nreturn 10.0F;\n}\npublic boolean renderClouds()\n{\nreturn true;\n}\npublic boolean renderVoidFog()\n{\nreturn false;\n}\npublic boolean renderEndSky()\n{\nreturn false;\n}\npublic float setSunSize()\n{\nreturn 10.0F;\n}\npublic float setMoonSize()\n{\nreturn 8.0F;\n}\n@SideOnly(Side.CLIENT)\npublic boolean isSkyColored()\n{\nreturn true;\n}\npublic boolean canRespawnHere()\n{\nreturn false;\n}\npublic boolean isSurfaceWorld()\n{\nreturn true;\n}\n@SideOnly(Side.CLIENT)\npublic float getCloudHeight()\n{\nreturn 128.0F;\n}\n@SideOnly(Side.CLIENT)\npublic String getSunTexture()\n{\nreturn \"/Main:TwinSuns.png\";\n}\npublic boolean canCoordinateBeSpawn(int par1, int par2)\n{\nreturn false;\n}\npublic ChunkCoordinates getEntrancePortalLocation()\n{\nreturn new ChunkCoordinates(50, 5, 0);\n}\nprotected void generateLightBrightnessTable()\n{\nfloat f = 12.0F;\nfor (int i = 0; i <= 15; i++)\n{\nfloat f1 = 12.0F - i / 15.0F;\nthis.lightBrightnessTable[i] = ((1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f);\n}\n}\n@SideOnly(Side.CLIENT)\npublic String getWelcomeMessage()\n{\nif ((this instanceof WorldProviderTuorial))\n{\nreturn \"Entering Tut Dimension\";\n}\nreturn null;\n}\n@SideOnly(Side.CLIENT)\npublic float[] calcSunriseSunsetColors(float par1, float par2)\n{\nfloat f2 = 0.4F;\nfloat f3 = MathHelper.cos(par1 * 3.141593F * 2.0F) - 0.0F;\nfloat f4 = -0.0F;\nif ((f3 >= f4 - f2) && (f3 <= f4 + f2))\n{\nfloat f5 = (f3 - f4) / f2 * 0.5F + 0.5F;\nfloat f6 = 1.0F - (1.0F - MathHelper.sin(f5 * 3.141593F)) * 0.99F;\nf6 *= f6;\nthis.colorsSunriseSunset[0] = (f5 * 0.3F + 0.7F);\nthis.colorsSunriseSunset[1] = (f5 * f5 * 0.7F + 0.2F);\nthis.colorsSunriseSunset[2] = (f5 * f5 * 0.0F + 0.2F);\nthis.colorsSunriseSunset[3] = f6;\nreturn this.colorsSunriseSunset;\n}\nreturn null;\n}\npublic float calculateCelestialAngle(long par1, float par3)\n{\nint j = (int)(par1 % 24000L);\nfloat f1 = (j + par3) / 24000.0F - 0.25F;\nif (f1 < 0.0F)\n{\nf1 += 1.0F;\n}\nif (f1 > 1.0F)\n{\nf1 -= 1.0F;\n}\nfloat f2 = f1;\nf1 = 1.0F - (float)((Math.cos(f1 * 3.141592653589793D) + 1.0D) / 2.0D);\nf1 = f2 + (f1 - f2) / 3.0F;\nreturn f1;\n}\n@SideOnly(Side.CLIENT)\npublic Vec3 getFogColor(float par1, float par2)\n{\nint i = 10518688;\nfloat f2 = MathHelper.cos(par1 * 3.141593F * 2.0F) * 2.0F + 0.5F;\nif (f2 < 0.0F)\n{\nf2 = 0.0F;\n}\nif (f2 > 1.0F)\n{\nf2 = 1.0F;\n}\nfloat f3 = (i >> 16 & 0xFF) / 255.0F;\nfloat f4 = (i >> 8 & 0xFF) / 255.0F;\nfloat f5 = (i & 0xFF) / 255.0F;\nf3 *= (f2 * 0.0F + 0.15F);\nf4 *= (f2 * 0.0F + 0.15F);\nf5 *= (f2 * 0.0F + 0.15F);\nreturn this.worldObj.getWorldVec3Pool().getVecFromPool(f3, f4, f5);\n}\n}复制代码自定义传送代码（在不同维度传输，po注）package dimension;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\nimport net.minecraft.block.Block;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.util.Direction;\nimport net.minecraft.util.LongHashMap;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.world.ChunkCoordIntPair;\nimport net.minecraft.world.PortalPosition;\nimport net.minecraft.world.Teleporter;\nimport net.minecraft.world.WorldServer;\npublic class TutorialTeleporter extends Teleporter\n{\nprivate final WorldServer worldServerInstance;\n/** A private Random() function in Teleporter */\nprivate final Random random;\n/** Stores successful portal placement locations for rapid lookup. */\nprivate final LongHashMap destinationCoordinateCache = new LongHashMap();\n/**\n         * A list of valid keys for the destinationCoordainteCache. These are based on the X & Z of the players initial\n         * location.\n         */\nprivate final List destinationCoordinateKeys = new ArrayList();\npublic TutorialTeleporter(WorldServer par1WorldServer)\n{\n         super(par1WorldServer);\n         this.worldServerInstance = par1WorldServer;\n         this.random = new Random(par1WorldServer.getSeed());\n}\n/**\n         * Place an entity in a nearby portal, creating one if necessary.\n         */\npublic void placeInPortal(Entity par1Entity, double par2, double par4, double par6, float par8)\n{\n         if (this.worldServerInstance.provider.dimensionId != 1)\n         {\n                 if (!this.placeInExistingPortal(par1Entity, par2, par4, par6, par8))\n                 {\n                         this.makePortal(par1Entity);\n                         this.placeInExistingPortal(par1Entity, par2, par4, par6, par8);\n                 }\n         }\n         else\n         {\n                 int i = MathHelper.floor_double(par1Entity.posX);\n                 int j = MathHelper.floor_double(par1Entity.posY) - 1;\n                 int k = MathHelper.floor_double(par1Entity.posZ);\n                 byte b0 = 1;\n                 byte b1 = 0;\n                 for (int l = -2; l <= 2; ++l)\n                 {\n                         for (int i1 = -2; i1 <= 2; ++i1)\n                         {\n                                 for (int j1 = -1; j1 < 3; ++j1)\n                                 {\n                                         int k1 = i + i1 * b0 + l * b1;\n                                         int l1 = j + j1;\n                                         int i2 = k + i1 * b1 - l * b0;\n                                         boolean flag = j1 < 0;\n                                        \n                                         /** change this block **/\n                                         this.worldServerInstance.setBlock(k1, l1, i2, flag ? Block.blockDiamond.blockID : 0);\n                                 }\n                         }\n                 }\n                 par1Entity.setLocationAndAngles((double)i, (double)j, (double)k, par1Entity.rotationYaw, 0.0F);\n                 par1Entity.motionX = par1Entity.motionY = par1Entity.motionZ = 0.0D;\n         }\n}\n/**\n         * Place an entity in a nearby portal which already exists.\n         */\npublic boolean placeInExistingPortal(Entity par1Entity, double par2, double par4, double par6, float par8)\n{\n         short short1 = 128;\n         double d3 = -1.0D;\n         int i = 0;\n         int j = 0;\n         int k = 0;\n         int l = MathHelper.floor_double(par1Entity.posX);\n         int i1 = MathHelper.floor_double(par1Entity.posZ);\n         long j1 = ChunkCoordIntPair.chunkXZ2Int(l, i1);\n         boolean flag = true;\n         double d4;\n         int k1;\n         if (this.destinationCoordinateCache.containsItem(j1))\n         {\n                 PortalPosition portalposition = (PortalPosition)this.destinationCoordinateCache.getValueByKey(j1);\n                 d3 = 0.0D;\n                 i = portalposition.posX;\n                 j = portalposition.posY;\n                 k = portalposition.posZ;\n                 portalposition.lastUpdateTime = this.worldServerInstance.getTotalWorldTime();\n                 flag = false;\n         }\n         else\n         {\n                 for (k1 = l - short1; k1 <= l + short1; ++k1)\n                 {\n                         double d5 = (double)k1 + 0.5D - par1Entity.posX;\n                         for (int l1 = i1 - short1; l1 <= i1 + short1; ++l1)\n                         {\n                                 double d6 = (double)l1 + 0.5D - par1Entity.posZ;\n                                 for (int i2 = this.worldServerInstance.getActualHeight() - 1; i2 >= 0; --i2)\n                                 {\n                                         /** change this block **/\n                                         if (this.worldServerInstance.getBlockId(k1, i2, l1) == Main.TutorialPortal.blockID)\n                                         {\n                                                 /** change this block **/\n                                                 while (this.worldServerInstance.getBlockId(k1, i2 - 1, l1) == Main.TutorialPortal.blockID)\n                                                 {\n                                                         --i2;\n                                                 }\n                                                 d4 = (double)i2 + 0.5D - par1Entity.posY;\n                                                 double d7 = d5 * d5 + d4 * d4 + d6 * d6;\n                                                 if (d3 < 0.0D || d7 < d3)\n                                                 {\n                                                         d3 = d7;\n                                                         i = k1;\n                                                         j = i2;\n                                                         k = l1;\n                                                 }\n                                         }\n                                 }\n                         }\n                 }\n         }\n         if (d3 >= 0.0D)\n         {\n                 if (flag)\n                 {\n                         this.destinationCoordinateCache.add(j1, new TutorialPortalPosition(this, i, j, k, this.worldServerInstance.getTotalWorldTime()));\n                         this.destinationCoordinateKeys.add(Long.valueOf(j1));\n                 }\n                 double d8 = (double)i + 0.5D;\n                 double d9 = (double)j + 0.5D;\n                 d4 = (double)k + 0.5D;\n                 int j2 = -1;\n                 /** change this block **/\n                 if (this.worldServerInstance.getBlockId(i - 1, j, k) == Main.TutorialPortal.blockID)\n                 {\n                         j2 = 2;\n                 }\n                 /** change this block **/\n                 if (this.worldServerInstance.getBlockId(i + 1, j, k) == Main.TutorialPortal.blockID)\n                 {\n                         j2 = 0;\n                 }\n                 /** change this block **/\n                 if (this.worldServerInstance.getBlockId(i, j, k - 1) == Main.TutorialPortal.blockID)\n                 {\n                         j2 = 3;\n                 }\n                 /** change this block **/\n                 if (this.worldServerInstance.getBlockId(i, j, k + 1) == Main.TutorialPortal.blockID)\n                 {\n                         j2 = 1;\n                 }\n                 int k2 = par1Entity.getTeleportDirection();\n                 if (j2 > -1)\n                 {\n                         int l2 = Direction.rotateLeft[j2];\n                         int i3 = Direction.offsetX[j2];\n                         int j3 = Direction.offsetZ[j2];\n                         int k3 = Direction.offsetX[l2];\n                         int l3 = Direction.offsetZ[l2];\n                         boolean flag1 = !this.worldServerInstance.isAirBlock(i + i3 + k3, j, k + j3 + l3) || !this.worldServerInstance.isAirBlock(i + i3 + k3, j + 1, k + j3 + l3);\n                         boolean flag2 = !this.worldServerInstance.isAirBlock(i + i3, j, k + j3) || !this.worldServerInstance.isAirBlock(i + i3, j + 1, k + j3);\n                         if (flag1 && flag2)\n                         {\n                                 j2 = Direction.rotateOpposite[j2];\n                                 l2 = Direction.rotateOpposite[l2];\n                                 i3 = Direction.offsetX[j2];\n                                 j3 = Direction.offsetZ[j2];\n                                 k3 = Direction.offsetX[l2];\n                                 l3 = Direction.offsetZ[l2];\n                                 k1 = i - k3;\n                                 d8 -= (double)k3;\n                                 int i4 = k - l3;\n                                 d4 -= (double)l3;\n                                 flag1 = !this.worldServerInstance.isAirBlock(k1 + i3 + k3, j, i4 + j3 + l3) || !this.worldServerInstance.isAirBlock(k1 + i3 + k3, j + 1, i4 + j3 + l3);\n                                 flag2 = !this.worldServerInstance.isAirBlock(k1 + i3, j, i4 + j3) || !this.worldServerInstance.isAirBlock(k1 + i3, j + 1, i4 + j3);\n                         }\n                         float f1 = 0.5F;\n                         float f2 = 0.5F;\n                         if (!flag1 && flag2)\n                         {\n                                 f1 = 1.0F;\n                         }\n                         else if (flag1 && !flag2)\n                         {\n                                 f1 = 0.0F;\n                         }\n                         else if (flag1 && flag2)\n                         {\n                                 f2 = 0.0F;\n                         }\n                         d8 += (double)((float)k3 * f1 + f2 * (float)i3);\n                         d4 += (double)((float)l3 * f1 + f2 * (float)j3);\n                         float f3 = 0.0F;\n                         float f4 = 0.0F;\n                         float f5 = 0.0F;\n                         float f6 = 0.0F;\n                         if (j2 == k2)\n                         {\n                                 f3 = 1.0F;\n                                 f4 = 1.0F;\n                         }\n                         else if (j2 == Direction.rotateOpposite[k2])\n                         {\n                                 f3 = -1.0F;\n                                 f4 = -1.0F;\n                         }\n                         else if (j2 == Direction.rotateRight[k2])\n                         {\n                                 f5 = 1.0F;\n                                 f6 = -1.0F;\n                         }\n                         else\n                         {\n                                 f5 = -1.0F;\n                                 f6 = 1.0F;\n                         }\n                         double d10 = par1Entity.motionX;\n                         double d11 = par1Entity.motionZ;\n                         par1Entity.motionX = d10 * (double)f3 + d11 * (double)f6;\n                         par1Entity.motionZ = d10 * (double)f5 + d11 * (double)f4;\n                         par1Entity.rotationYaw = par8 - (float)(k2 * 90) + (float)(j2 * 90);\n                 }\n                 else\n                 {\n                         par1Entity.motionX = par1Entity.motionY = par1Entity.motionZ = 0.0D;\n                 }\n                 par1Entity.setLocationAndAngles(d8, d9, d4, par1Entity.rotationYaw, par1Entity.rotationPitch);\n                 return true;\n         }\n         else\n         {\n                 return false;\n         }\n}\npublic boolean makePortal(Entity par1Entity)\n{\n         byte b0 = 16;\n         double d0 = -1.0D;\n         int i = MathHelper.floor_double(par1Entity.posX);\n         int j = MathHelper.floor_double(par1Entity.posY);\n         int k = MathHelper.floor_double(par1Entity.posZ);\n         int l = i;\n         int i1 = j;\n         int j1 = k;\n         int k1 = 0;\n         int l1 = this.random.nextInt(4);\n         int i2;\n         double d1;\n         double d2;\n         int j2;\n         int k2;\n         int l2;\n         int i3;\n         int j3;\n         int k3;\n         int l3;\n         int i4;\n         int j4;\n         int k4;\n         double d3;\n         double d4;\n         for (i2 = i - b0; i2 <= i + b0; ++i2)\n         {\n                 d1 = (double)i2 + 0.5D - par1Entity.posX;\n                 for (j2 = k - b0; j2 <= k + b0; ++j2)\n                 {\n                         d2 = (double)j2 + 0.5D - par1Entity.posZ;\n                         label274:\n                         for (k2 = this.worldServerInstance.getActualHeight() - 1; k2 >= 0; --k2)\n                         {\n                                 if (this.worldServerInstance.isAirBlock(i2, k2, j2))\n                                 {\n                                         while (k2 > 0 && this.worldServerInstance.isAirBlock(i2, k2 - 1, j2))\n                                         {\n                                                 --k2;\n                                         }\n                                         for (i3 = l1; i3 < l1 + 4; ++i3)\n                                         {\n                                                 l2 = i3 % 2;\n                                                 k3 = 1 - l2;\n                                                 if (i3 % 4 >= 2)\n                                                 {\n                                                         l2 = -l2;\n                                                         k3 = -k3;\n                                                 }\n                                                 for (j3 = 0; j3 < 3; ++j3)\n                                                 {\n                                                         for (i4 = 0; i4 < 4; ++i4)\n                                                         {\n                                                                 for (l3 = -1; l3 < 4; ++l3)\n                                                                 {\n                                                                         k4 = i2 + (i4 - 1) * l2 + j3 * k3;\n                                                                         j4 = k2 + l3;\n                                                                         int l4 = j2 + (i4 - 1) * k3 - j3 * l2;\n                                                                         if (l3 < 0 && !this.worldServerInstance.getBlockMaterial(k4, j4, l4).isSolid() || l3 >= 0 && !this.worldServerInstance.isAirBlock(k4, j4, l4))\n                                                                         {\n                                                                                 continue label274;\n                                                                         }\n                                                                 }\n                                                         }\n                                                 }\n                                                 d4 = (double)k2 + 0.5D - par1Entity.posY;\n                                                 d3 = d1 * d1 + d4 * d4 + d2 * d2;\n                                                 if (d0 < 0.0D || d3 < d0)\n                                                 {\n                                                         d0 = d3;\n                                                         l = i2;\n                                                         i1 = k2;\n                                                         j1 = j2;\n                                                         k1 = i3 % 4;\n                                                 }\n                                         }\n                                 }\n                         }\n                 }\n         }\n         if (d0 < 0.0D)\n         {\n                 for (i2 = i - b0; i2 <= i + b0; ++i2)\n                 {\n                         d1 = (double)i2 + 0.5D - par1Entity.posX;\n                         for (j2 = k - b0; j2 <= k + b0; ++j2)\n                         {\n                                 d2 = (double)j2 + 0.5D - par1Entity.posZ;\n                                 label222:\n                                 for (k2 = this.worldServerInstance.getActualHeight() - 1; k2 >= 0; --k2)\n                                 {\n                                         if (this.worldServerInstance.isAirBlock(i2, k2, j2))\n                                         {\n                                                 while (k2 > 0 && this.worldServerInstance.isAirBlock(i2, k2 - 1, j2))\n                                                 {\n                                                         --k2;\n                                                 }\n                                                 for (i3 = l1; i3 < l1 + 2; ++i3)\n                                                 {\n                                                         l2 = i3 % 2;\n                                                         k3 = 1 - l2;\n                                                         for (j3 = 0; j3 < 4; ++j3)\n                                                         {\n                                                                 for (i4 = -1; i4 < 4; ++i4)\n                                                                 {\n                                                                         l3 = i2 + (j3 - 1) * l2;\n                                                                         k4 = k2 + i4;\n                                                                         j4 = j2 + (j3 - 1) * k3;\n                                                                         if (i4 < 0 && !this.worldServerInstance.getBlockMaterial(l3, k4, j4).isSolid() || i4 >= 0 && !this.worldServerInstance.isAirBlock(l3, k4, j4))\n                                                                         {\n                                                                                 continue label222;\n                                                                         }\n                                                                 }\n                                                         }\n                                                         d4 = (double)k2 + 0.5D - par1Entity.posY;\n                                                         d3 = d1 * d1 + d4 * d4 + d2 * d2;\n                                                         if (d0 < 0.0D || d3 < d0)\n                                                         {\n                                                                 d0 = d3;\n                                                                 l = i2;\n                                                                 i1 = k2;\n                                                                 j1 = j2;\n                                                                 k1 = i3 % 2;\n                                                         }\n                                                 }\n                                         }\n                                 }\n                         }\n                 }\n         }\n         int i5 = l;\n         int j5 = i1;\n         j2 = j1;\n         int k5 = k1 % 2;\n         int l5 = 1 - k5;\n         if (k1 % 4 >= 2)\n         {\n                 k5 = -k5;\n                 l5 = -l5;\n         }\n         boolean flag;\n         if (d0 < 0.0D)\n         {\n                 if (i1 < 70)\n                 {\n                         i1 = 70;\n                 }\n                 if (i1 > this.worldServerInstance.getActualHeight() - 10)\n                 {\n                         i1 = this.worldServerInstance.getActualHeight() - 10;\n                 }\n                 j5 = i1;\n                 for (k2 = -1; k2 <= 1; ++k2)\n                 {\n                         for (i3 = 1; i3 < 3; ++i3)\n                         {\n                                 for (l2 = -1; l2 < 3; ++l2)\n                                 {\n                                         k3 = i5 + (i3 - 1) * k5 + k2 * l5;\n                                         j3 = j5 + l2;\n                                         i4 = j2 + (i3 - 1) * l5 - k2 * k5;\n                                         flag = l2 < 0;\n                                        \n                                         /** change this block **/\n                                         this.worldServerInstance.setBlock(k3, j3, i4, flag ? Block.blockDiamond.blockID : 0);\n                                 }\n                         }\n                 }\n         }\n         for (k2 = 0; k2 < 4; ++k2)\n         {\n                 for (i3 = 0; i3 < 4; ++i3)\n                 {\n                         for (l2 = -1; l2 < 4; ++l2)\n                         {\n                                 k3 = i5 + (i3 - 1) * k5;\n                                 j3 = j5 + l2;\n                                 i4 = j2 + (i3 - 1) * l5;\n                                 flag = i3 == 0 || i3 == 3 || l2 == -1 || l2 == 3;\n                                \n                                 /** change these blocks **/\n                                 this.worldServerInstance.setBlock(k3, j3, i4, flag ? Block.blockDiamond.blockID : Main.TutorialPortal.blockID, 0, 2);\n                         }\n                 }\n                 for (i3 = 0; i3 < 4; ++i3)\n                 {\n                         for (l2 = -1; l2 < 4; ++l2)\n                         {\n                                 k3 = i5 + (i3 - 1) * k5;\n                                 j3 = j5 + l2;\n                                 i4 = j2 + (i3 - 1) * l5;\n                                 this.worldServerInstance.notifyBlocksOfNeighborChange(k3, j3, i4, this.worldServerInstance.getBlockId(k3, j3, i4));\n                         }\n                 }\n         }\n         return true;\n}\n/**\n         * called periodically to remove out-of-date portal locations from the cache list. Argument par1 is a\n         * WorldServer.getTotalWorldTime() value.\n         */\npublic void removeStalePortalLocations(long par1)\n{\n         if (par1 % 100L == 0L)\n         {\n                 Iterator iterator = this.destinationCoordinateKeys.iterator();\n                 long j = par1 - 600L;\n                 while (iterator.hasNext())\n                 {\n                         Long olong = (Long)iterator.next();\n                         PortalPosition portalposition = (PortalPosition)this.destinationCoordinateCache.getValueByKey(olong.longValue());\n                         if (portalposition == null || portalposition.lastUpdateTime < j)\n                         {\n                                 iterator.remove();\n                                 this.destinationCoordinateCache.remove(olong.longValue());\n                         }\n                 }\n         }\n}\n}复制代码传送门坐标代码package dimension;\nimport net.minecraft.util.ChunkCoordinates;\npublic class TutorialPortalPosition extends ChunkCoordinates\n{\npublic long field_85087_d;\nfinal TutorialTeleporter field_85088_e;\npublic TutorialPortalPosition(TutorialTeleporter tutorialTeleporter, int par2, int par3, int par4, long par5)\n{\nsuper(par2, par3, par4);\nthis.field_85088_e = tutorialTeleporter;\nthis.field_85087_d = par5;\n}\n}复制代码下面还有一些和贴图相关的外部文件，po就不搬运了\n\n以及原作者的代码在这里：https://github.com/Jimmy04Creeper/Tutorial-GutHub\n\n\n以上教程只搬运了一部分，剩下的又时间再搬运",
    "replies": [
        {
            "author": "杰·天行者",
            "timestamp": 1391760180,
            "txt_content": "这真的只是教程而不是代码分享帖？= ="
        },
        {
            "author": "wq57",
            "timestamp": 1391760180,
            "txt_content": "哇  翻机了啊！"
        },
        {
            "author": "01186",
            "timestamp": 1391760300,
            "txt_content": "表示没看懂你写的翻译...我还是去看原帖吧..."
        },
        {
            "author": "Tzi君",
            "timestamp": 1391760300,
            "txt_content": "翻墙辛苦！"
        },
        {
            "author": "manageryzy",
            "timestamp": 1391782860,
            "txt_content": "01186 发表于 2014-2-7 16:05\n表示没看懂你写的翻译...我还是去看原帖吧...\n难道是我语死早的过……"
        },
        {
            "author": "manageryzy",
            "timestamp": 1391783100,
            "txt_content": "杰·天行者 发表于 2014-2-7 16:03\n这真的只是教程而不是代码分享帖？= =\n当成是代码分享也好啦，反正原文写的是教程，我也就在搬运的时候说是教程了\n\n不过这是为数不多的能找到的介绍添加维度的帖子，似乎连minecraftforge 的wiki或者forum都没有"
        },
        {
            "author": "manageryzy",
            "timestamp": 1391783340,
            "txt_content": "01186 发表于 2014-2-7 16:05\n表示没看懂你写的翻译...我还是去看原帖吧...\n另外论坛的代码不能语法高亮好不爽……还是直接去github下载源代码来研究比较靠谱\n原帖里面没怎么讲解这些啦，倒是原帖的作者的回复里面有一些"
        },
        {
            "author": "manageryzy",
            "timestamp": 1391783400,
            "txt_content": "wq57 发表于 2014-2-7 16:03\n哇  翻机了啊！\n什么意思，没明白"
        },
        {
            "author": "wq57",
            "timestamp": 1391820000,
            "txt_content": "manageryzy 发表于 2014-2-7 22:30\n什么意思，没明白\n用翻译（谷歌 有道）翻译的  "
        },
        {
            "author": "manageryzy",
            "timestamp": 1391825880,
            "txt_content": "wq57 发表于 2014-2-8 08:40\n用翻译（谷歌 有道）翻译的\n全是我自己翻译的……如果非要说看的看不懂，只能说，我语死早啦"
        }
    ]
}