{
    "title": "Forge关于如何让自己实体在水中自然生成的问题",
    "author": "zvvzxzko2006",
    "replyCount": 7,
    "timestamp": 1431265020,
    "txt_content": " 本帖最后由 zvvzxzko2006 于 2015-5-10 21:40 编辑 \n\n最近在做一个MOD，里面的食人鱼已经做好，不过实测发现，EntityRegistry.addSpawn();\n\n这个方法不能像想象中的在水中生成食人鱼。食人鱼只能在岸边生成。\n研究了一下源代码。发现SpawnAnimals.canCreatureTypeSpawnAtLocation()这个函数为关键生成函数。\n贴一下代码：\n\npublic static boolean canCreatureTypeSpawnAtLocation(EntityLiving.SpawnPlacementType p_180267_0_, World worldIn, BlockPos pos)\n    {\n        if (!worldIn.getWorldBorder().contains(pos))\n        {\n            return false;\n        }\n        else\n        {\n            Block block = worldIn.getBlockState(pos).getBlock();\n            //此句为生物可以在水中生成的关键代码！\n            if (p_180267_0_ == EntityLiving.SpawnPlacementType.IN_WATER)\n            {\n                return block.getMaterial().isLiquid() && worldIn.getBlockState(pos.down()).getBlock().getMaterial().isLiquid() && !worldIn.getBlockState(pos.up()).getBlock().isNormalCube();\n            }\n            //其余情况就如wiki中讲的了，水中无法生成生物。。。。。\n            else\n            {\n                BlockPos blockpos1 = pos.down();\n\n                if (!worldIn.getBlockState(blockpos1).getBlock().canCreatureSpawn(worldIn, blockpos1, p_180267_0_))\n                {\n                    return false;\n                }\n                else\n                {\n                    Block block1 = worldIn.getBlockState(blockpos1).getBlock();\n                    boolean flag = block1 != Blocks.bedrock && block1 != Blocks.barrier;\n                    return flag && !block.isNormalCube() && !block.getMaterial().isLiquid() && !worldIn.getBlockState(pos.up()).getBlock().isNormalCube();\n                }\n            }\n        }\n    }\n复制代码\n上面代码已经很明确的指出，本函数第一个参数要等于EntityLiving.SpawnPlacementType.IN_WATER这个量，才可以在水中生成生物。\n而EntityLiving.SpawnPlacementType.IN_WATER到底是什么东西？\n这里找到定义代码\n\n   public static enum SpawnPlacementType\n    {\n        ON_GROUND,\n        IN_AIR,\n        IN_WATER;\n\n        private static final String __OBFID = \"CL_00002255\";\n    }\n复制代码\n不需要过多解释，就是一个枚举类型，枚举了3个量，从字面意思可以明显看出有三种出生点类型：地面、空中、水中。\n\n相对来说，我们更关心哪里用到了这个枚举变量。查找调用，发现了关键代码\n\npublic class EntitySpawnPlacementRegistry\n{\n    //定义了一个哈希映射表，此表维护了各种官方的动物实体类及其生成点类型\n    private static final HashMap field_180110_a = Maps.newHashMap();\n    private static final String __OBFID = \"CL_00002254\";\n    //外部代码通过这个函数可以访问本类的哈希映射表中，某动物实体类对应的生成点类型\n    public static EntityLiving.SpawnPlacementType func_180109_a(Class p_180109_0_)\n    {\n        return (EntityLiving.SpawnPlacementType)field_180110_a.get(p_180109_0_);\n    }\n    //初始化了哈希映射表\n    static\n    {\n        field_180110_a.put(EntityBat.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityChicken.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityCow.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityHorse.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityMooshroom.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityOcelot.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityPig.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityRabbit.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySheep.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySnowman.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySquid.class, EntityLiving.SpawnPlacementType.IN_WATER);//水中生成的生物：乌贼\n        field_180110_a.put(EntityIronGolem.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityWolf.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityVillager.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityDragon.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityWither.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityBlaze.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityCaveSpider.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityCreeper.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityEnderman.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityEndermite.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityGhast.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityGiantZombie.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityGuardian.class, EntityLiving.SpawnPlacementType.IN_WATER);//水中生成的生物：海洋圣殿守护者\n        field_180110_a.put(EntityMagmaCube.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityPigZombie.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySilverfish.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySkeleton.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySlime.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntitySpider.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityWitch.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        field_180110_a.put(EntityZombie.class, EntityLiving.SpawnPlacementType.ON_GROUND);\n        //我自己加入的测试代码，发现加入这两句话后，我定义的食人鱼确实可以在水中生成了。\n        //field_180110_a.put(EntityPiranha.class, EntityLiving.SpawnPlacementType.IN_WATER);\n        //field_180110_a.put(EntityLivefish.class, EntityLiving.SpawnPlacementType.IN_WATER);\n    }\n}\n复制代码\n代码中的的EntitySpawnPlacementRegistry类正是保存官方原版生物的生成类型映射表。其中可以发现乌贼和海洋圣殿守护者的生成类型为EntityLiving.SpawnPlacementType.IN_WATER。\n\n最后，让我们来顺一下：\n主程序在生成生物的时候，会调用canCreatureTypeSpawnAtLocation()来判断当前位置是否适合生成该生物群系中的生物。而传入的参数1正是具体到某生物的生成地类型。这个生成地点类型，主程序会在之前的代码中通过调用EntityLiving.SpawnPlacementType func_180109_a()来确定。\n\n就拿乌贼举例：在生成生物的时候，主程序会调用EntityLiving.SpawnPlacementType func_180109_a()，获得乌贼的生成地点类型为EntityLiving.SpawnPlacementType.IN_WATER。然后将生成地点类型传入到canCreatureTypeSpawnAtLocation()中，以判断是否可以在某地点生成。其中关键判断语句为\n\nif (p_180267_0_ == EntityLiving.SpawnPlacementType.IN_WATER)\n            {\n                return block.getMaterial().isLiquid() && worldIn.getBlockState(pos.down()).getBlock().getMaterial().isLiquid() && !worldIn.getBlockState(pos.up()).getBlock().isNormalCube();\n            }\n复制代码\n在满足其他条件的情况下，乌贼就可以在水中生成了。\n\n\n\n\n了解了这些原理后，就发现一个严重的问题。对于moder来说，制作一个普通的陆地生物还好说，但是如果做一个水生生物的话就比较麻烦了，原因就在于moder不能往SpawnPlacementType 中的哈希映射表添加新的映射项。。。。。（ private static final HashMap field_180110_a = Maps.newHashMap();看到那个private了没有。。。）但是如果使用coremod的话或许可以克服这个问题吧。不过目前来说，感觉coremod比较难。\n另外，如果forge能更新出支持往上面那个类中的哈希表中添加映射项的函数，或许也可以解决这个问题。\n对于这个问题你有什么看法呢？",
    "replies": [
        {
            "author": "914554688wyt",
            "timestamp": 1431523020,
            "txt_content": "{:10_494:} 笨办法就是在下面生成一个方块后再召唤生物再去掉方块"
        },
        {
            "author": "zvvzxzko2006",
            "timestamp": 1431600000,
            "txt_content": " 本帖最后由 zvvzxzko2006 于 2015-5-14 18:41 编辑 \n914554688wyt 发表于 2015-5-13 21:17\n笨办法就是在下面生成一个方块后再召唤生物再去掉方块\n本主题讨论的是自然生成，而不是人为生成。所以。。。这个笨方法如何去实现还是蛮复杂的"
        },
        {
            "author": "914554688wyt",
            "timestamp": 1431601440,
            "txt_content": "zvvzxzko2006 发表于 2015-5-14 18:40\n本主题讨论的是自然生成，而不是人为生成。所以。。。这个笨方法如何去实现还是蛮复杂的 ...\n嗷呜{:10_493:} ..也对  不过似乎有可以无视修饰符的方法哦？ baidu一下？"
        },
        {
            "author": "GA_空人",
            "timestamp": 1432012500,
            "txt_content": "如果只是临时解决一下的话\nField fieldMap=EntitySpawnPlacementRegistry.getclass().getDeclaredField(\"field_180110_a\");\nfieldMap.setAccessible(true);\nHashMap spawnMap=(HashMap)fieldMap.get(null);//因为是静态的所以直接传入null\nspawnMap.put()\n这样就可以了？"
        },
        {
            "author": "yuxuanchiadm",
            "timestamp": 1432091940,
            "txt_content": "同意5楼意见，反射解决问题。另外你更新Forge版本了，至少forge1.8-11.14.1.1402可以直接添加\n    public static void setPlacementType(Class<? extends Entity> entityClass, EntityLiving.SpawnPlacementType placementType)\n    {\n        if(!field_180110_a.containsKey(entityClass))\n            field_180110_a.put(entityClass, placementType);\n    }复制代码"
        },
        {
            "author": "zvvzxzko2006",
            "timestamp": 1432129260,
            "txt_content": "GA_空人 发表于 2015-5-19 13:15\n如果只是临时解决一下的话\nField fieldMap=EntitySpawnPlacementRegistry.getclass().getDeclaredField(\"fi ...\n哦！涨姿势了！"
        },
        {
            "author": "zvvzxzko2006",
            "timestamp": 1432129380,
            "txt_content": "yuxuanchiadm 发表于 2015-5-20 11:19\n同意5楼意见，反射解决问题。另外你更新Forge版本了，至少forge1.8-11.14.1.1402可以直接添加\n ...\n涨姿势了！"
        }
    ]
}