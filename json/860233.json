{
    "title": "预留t",
    "author": "hmm1313133",
    "replyCount": 0,
    "timestamp": 1556198580,
    "txt_content": " 本帖最后由 hmm1313133 于 2019-4-28 22:19 编辑 % v% n* ~. j* v: G* v; n8 Z\n\n2 C2 [+ [( d5 f\n9 h/ E( Q4 L& s! |' {9 d; L\n% L) G1 l8 N8 U! b! k目录\n% G: k6 p5 D1 V0 B\n\" c\" V0 U) u4 n目录Redis简介及安装\n5 a, I2 P9 b( F: uRedis基础命令\n, g% h0 _' n. V' v, aRedis字符串5 y& z7 N; C$ c* d6 k\nRedis哈希\n+ b3 S! M% |$ z8 a5 FRedis列表( S- y4 c/ W5 v! K\nRedis集合; S. n3 @' P) n3 c' q& t\nJava操作Redis/ D# h0 T2 i1 E) P\n前言首先我们先介绍些Redis的基本概念，Redis是Nosql数据库，是一个key-value存储系统。虽然Redis是key-value的存储系统，但是Redis支持的value存储类型是非常的多，比如字符串、链表、集合、有序集合和哈希。同时Redis支持将数据存入内存，这极大的提高了Redis的数据存储性能，而在一个高负载的服务器中，我们必须思考如何让速度更快，此时将常用数据缓存将不失为一个良好的解决方案，在此，希望我的这篇Redis基础教程能给各位插件/MOD开发的大佬们带来一种新的数据存储思路及解决方案。请回复/评分一下，您的支持是我最大的支持与鼓励！\n. p9 v# s\" B4 D% h' O. G\n4 c/ b: c7 x( X* N+ VBone Studio9 r% l* r* a6 c- ?: I  a\n' p  Q7 v2 v1 z, ^0 A6 N* r\n\n9 X1 p+ {# R\" S) Z, q/ k, U; a: f+ a  n9 n7 @\" }\n\n6 H( h) U( h% ^7 d  \\# h- m8 A\n3 ]  w( T/ y3 }' V- G- ORedis简介及安装; v& q\" Y3 s4 d7 N( a5 W\n\n5 W, q+ @6 {0 i: ?/ a0 ]. s9 Q( Q\n& o. N$ c9 W4 V: e* b& i' R# d( [Redis 简介Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。0 P: `/ @\" ~$ I. }\" {5 g, D% B: g\nRedis 与其他 key - value 缓存产品有以下三个特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Redis支持数据的备份，即master-slave模式的数据备份。\n8 A, q0 _4 n, s2 _+ }* Q  Y1 y+ N/ w( f, l( L\n\n6 B1 @- q) O: h) fRedis 优势\n  N6 S\" O9 a' P- A; V. @性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。/ b+ I/ ]\" K# U\n& ]! X8 @6 Y/ ?' {: K/ u3 q\n\n% z. {/ W. }( k/ i- [+ HRedis 数据类型\n) O0 Y8 Y- W. C* C* _String（字符串）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。Hash（哈希）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。Set（集合）Redis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n! s3 p) p- f6 T& n9 h6 s! @; wRedis 安装Window 下安装下载地址：https://github.com/MSOpenTech/redis/releasesLinux 下安装下载地址：http://redis.io/download) |& B5 ~, W, B7 [\" T\" T\n: N1 y/ k( n5 E4 T\n\n6 p+ h) t7 W5 j( H  L+ U5 w  J% Q8 P! o\n7 M, W* o% W) E8 K/ V1 t( d\n\n7 ^- w* u1 L4 z# O\" w* r3 Q5 \\( f% s4 w\nRedis基础命令  r1 n7 N/ }5 _; ^5 b1 u\n\n) ~: [4 t$ S: F* s9 @全局命令  Q\" I! M3 V2 G2 o6 S) N+ x5 s\nRedis有五种数据结构，它们是键值对的值，对于键来说有一些通用的命令\n+ q2 ^0 q, \\  z0 p9 V\n. X4 _' R4 ~+ L# F- }\" n1. keys *\n9 f, ^; K. Z\" \\# A' k此命令用来查看所有键。下面使用set key value插入3对字符串类型的键值对127.0.0.1:6379> set key1 value1\n9 G2 w. h\" N# e- B7 IOK\n7 [8 ~1 E3 Q: M! z0 a  P127.0.0.1:6379> set key2 value2$ d2 J\" N* M' q: _$ q\nOK6 f0 ^\" X. e$ P9 `0 n\n127.0.0.1:6379> set key3 value3+ Q. p& c/ O& s1 }2 d\nOK复制代码keys *会将所有键输出127.0.0.1:6379> keys *\n: y* I/ r4 x5 U1) \"key3\"\n2 [3 ^* d5 `' ~2) \"key1\"\n$ r/ R3 B* Z\" l8 R$ j4 G  \\4 e3) \"key2\"复制代码\n' Y# c0 k% c- {2.dbsize此命令会返回当前数据库中键的总数127.0.0.1:6379> dbsize6 o7 n2 q# s0 F# g$ K\n(integer) 3\n( V+ q. S! @, k7 U复制代码\n, @+ c0 `7 V% i: V3 X8 Q! Y. d- j  q3.exist key检查键是否存在，如果存在则返回1，不存在则返回0，可配合设置键的生存时间或过期时间来保存各种临时性认证数据等\n0 o$ n6 O! j. ]# f( l  W4.del key [key ....]删除一个现有建，如果建不存在则返回0，如果成功则返回删除的个数127.0.0.1:6379> del key1\" y1 z% g\" w! ^$ u\n(integer) 1\n+ d$ ?) D- o9 s: s, O. ?4 u127.0.0.1:6379> del key16 h. n4 G( g2 O! |\n(integer) 0\n+ C8 y. d1 s1 K- Y& ^( X9 f127.0.0.1:6379> del key2 key33 B$ D$ Z: l8 `1 Y  S0 q* F\n(integer) 2复制代码\n) ]5 V) T7 k* K* Z5.expire key secondsRedis支持添加键值对过期时间，当超过过期时间后，会自动删除键值对9 v# S) g8 ]& K4 T\n同时可以使用ttl key查询键值对的剩余过期时间\n0 @. J\" @% H0 ]) N$ @% w127.0.0.1:6379> expire key1 10% G; \\! W& s& i! G\n(integer) 1\n5 b4 y) o& i) \\7 E\" F127.0.0.1:6379> ttl key1复制代码\n) O0 ~+ h; S\" @6.type key查询键值对的数据类型，如果键值对不存在则返回null127.0.0.1:6379> type key1, R8 X/ N6 S, A& o\nstring复制代码\n' b4 v8 m2 [* v3 ~; D( m1 w2 r: n- l. E# s' D/ Q: {: f\n0 a9 I& H0 |- s. Z) n: u, P5 z\n) o9 ~: ?# y2 V\n\n1 V% ~1 D% _( l# v\n2 Y\" R4 L9 j5 `; iRedis字符串7 l$ g; P% J# O7 k: _\n\n' m+ l, P4 t! [$ Q2 ]' M+ ~常用命令8 L5 Y: s; O$ \\) ?- \\( G% E8 Y\n1.set key value [ex seconds] [px milliseconds] [nx|xx]设置一个字符串类型的键值对\n9 ]& b; E' V4 \\3 o3 L% Fset命令有几个选项\n& A& m  B# f. D7 Y4 X: \\7 W. M/ a5 qex 设置秒级过期时间px 设置毫秒级过期时间nx 必须键不存在才可以设置成功xx 与nx相反，键必须存在才可设置成功\" U! _: F! v+ t4 O0 L$ I\n\n- n7 ^* B) ?  K. m$ s127.0.0.1:6379>  set key2 111 ex 10 nx\n& j% ?4 D% \\! j. j& JOK\n4 ^: Z; b  T$ m& W6 d- m127.0.0.1:6379> ttl key2\n& N; g- J. `, P(integer) 5复制代码2 a3 z  K4 R' d0 [, l8 c\n2.get key获取值，没啥好说的，也懒得演示\n. {9 I% D\" j0 l! k9 ~0 e1 o! d  H3 ~  `\" k) i- y+ r\n3.mset key value [key value ...]批量设置键值对127.0.0.1:6379> mset a 1 b 2 c 3 d 4\n6 h8 p% V, ^/ G% V, a9 z4 I( p+ iOK\n* M- P2 l, y5 e. i0 L4 G复制代码\n' b$ }; p9 A5 r9 I  o- a. e4.mget批量获取值，如果键值对不存在则返回nil\n8 J) t) e& j- u4 w5 b' i' L127.0.0.1:6379> mget a b c d e\n* `7 T4 j$ }/ J2 S1 j0 i, F1) \"1\"\n7 B8 t# o1 i7 m8 O5 r9 T2) \"2\"8 [# e; e! i. ^4 x$ U; j\n3) \"3\"' _# G/ U/ E, c7 P# t2 t3 H0 q! a\n4) \"4\"复制代码批量操作命令可以有效提高开发效率，避免多次执行同一命令\n4 W: k9 O) E6 y! e8 Z6 P9 y) u; z) @. \\8 @\n5.incr key5 Z\" Z1 @5 ?# g3 r\nincr命令用于对值做自增操作，返回结果分三种情况值不是整数，返回错误值是整数，返回自增后的结果建不存在，返回1\n\" G0 |) V  X% X+ x& z127.0.0.1:6379> exists zz* L1 G3 a' q# K\n(integer) 0\n& h\" R! Q7 R. }& A( y127.0.0.1:6379> incr zz\n3 @5 Z# V$ F; T* I! X(integer) 1\n3 u/ G$ E4 u# j1 T0 {) g( c7 J127.0.0.1:6379> incr zz\n. O6 [- ~' }3 G5 l' u5 t4 ^(integer) 2\n1 m! @5 r! h( f* K$ Y# t$ k复制代码\n) N: a1 b) p7 q不常用命令\n4 u1 `\" J+ E4 ~( \\8 g  A\n$ ~7 C& A  w3 x, {6 T7 y2 x: V7 i1.append key valueappend可以向字符串尾部追加值127.0.0.1:6379> set test hello% ~$ l% S7 B  e) v1 u. z# @\nOK\n6 c  [6 P& H- [0 }! z0 j127.0.0.1:6379> append test world\n4 S) F6 O1 t% v2 E(integer) 10- i9 E2 Z9 h+ O\n127.0.0.1:6379> get test\n4 V0 f2 f; P# d2 `\"helloworld\"复制代码\n3 `, a/ H3 {2 Z1 e( ]2.strlen ley返回字符串长度127.0.0.1:6379> strlen test\n4 ]& \\6 O8 }- d( t0 ^) k(integer) 10复制代码& m8 E0 P- @( D/ T6 x\" r\n3.getset key value返回当前值并设置一个新值\n; Q) C; j& y4 o( s127.0.0.1:6379> getset test \"hw\"3 P, [/ w, K. G# P\n\"helloworld\"* U3 L6 d7 Q1 |/ n! r0 U/ Z\n127.0.0.1:6379> get test2 z! I+ o1 f5 |1 g8 d3 T+ ?\" f\n\"hw\"\n  P# ?\" V5 C8 A; K* h' }复制代码\n$ |, A9 x& M* ]' H6 a$ W! K4.getrang key start end获取部分字符串，start为起始位置，end为结束位置，此处不做演示\n' i% x8 ]- i3 \\/ W\n( @2 @4 ], e) s- L9 s7 p使用场景缓存功能计数共享数据\n5 j6 ?& V) y$ ?) k\n# \\$ w\" p% S2 A\" n% i\n) ?3 l+ h6 `5 M) j; K9 g3 ^\n7 Q  h0 r& P\" e\n( F3 F3 O: P0 t5 X* L\n: x$ ^( C, z' @! |* g$ s0 n\n  O9 D$ S9 H; O; f; V; W7 S: D- }0 S6 V. J0 P: D! K\nRedis哈希\n  n3 }+ G3 u3 V/ I8 \\+ Q2 W4 `简介几乎所有编程语言都提供了哈希（hash）类型，它们的叫法可能是哈希，字典。关联数组等。在Redis中，哈希类型是指键值本身又是一个键值对结果，例如value={{filed1,value1},.....,{filedN,valueN}5 f2 q3 `- u6 H: M\" Q4 `\n命令\n% E3 G' x! Y2 \\9 c6 f3 u: B1.hset key filed value\n\" w) R! Z8 p4 U6 Z- b% i设置值，例如\n/ D# ]& u, }% L8 I& X: f127.0.0.1:6379> hset user:1 name tom3 c1 j5 L4 w: O% L\n(integer) 1\n* |1 ~( Q' s$ x6 y6 ?复制代码\n3 w' N3 \\: A% E! p  y% K$ m5 V6 l( V  E5 M/ H! a\n2.hget key filed+ _* \\6 I& W\" G& L\n获取值，例如' v% t7 _1 Q* w\n127.0.0.1:6379> hget user:1 name\n5 p# z\" g\" O( G; v! {6 _' v\"tom\"' r$ B0 T% q' E( i7 D\n复制代码\n+ p9 p\" q# V* X7 P9 R) m0 o\n/ X; m) k* C1 H0 o# j\" t! M1 {3.hdel key filed [filed ...]\n: y3 W  b\" R6 L: _; V删除值，可同时删除多个filed，返回删除数量  ?  Q, ^) o$ F\n127.0.0.1:6379> hdel user:1 name# `- V+ ^0 m& I\" _* [/ O$ Z\n(integer) 1\n' ]9 v3 T/ o8 q7 P复制代码$ @; d# U' C8 m, b1 _  [  E1 Q\n( a' A! E2 G5 F4 }) s\n4.hlen key\n, ?. x4 q0 T  B, g计算filed的个数- B  k) _; [9 [9 z- I4 Z% a\n127.0.0.1:6379>  hmset user:1 name tom age 12 city beijing\n* B3 b! B9 _6 n% f( w4 |OK\n. {  e6 F  z' q127.0.0.1:6379> hlen user:1\n: `- E1 y7 i. A' A- Z, ]' e(integer) 3& w0 ~' Q! }  C$ z\n复制代码9 }( ~. W2 x& u2 ^7 c\n\n3 O) b6 L2 g6 b0 x5.hmset key filed value [filed value ...]$ b% h& E9 _% ^6 X\n批量设置filed-value，用法见上\" D\" _+ B: B6 z! J+ ]\n\n8 ^8 ~8 z  J( E3 K$ [& v* X# N6.hmget key filed [filed ....]/ i. @5 i' p5 S8 E\n批量获取filed-value127.0.0.1:6379> hmget user:1 name age city\n7 q1 Q3 R9 a: ^4 b9 T7 }1) \"tom\"\n% N8 u7 T$ m4 y0 q2) \"12\"\n4 v! e+ [: E# r. Y! _3) \"beijing\"8 s/ v0 L  k9 m4 X2 `\n复制代码7 e2 Q+ c\" }8 Z\n7.hexists key filed判断filed是否存在，存在返回1，不存在返回07 h/ L& ]8 ]% e\n127.0.0.1:6379> hexists user:1 name% V6 M* j5 @; a7 H* b7 g! V; i\n(integer) 1\n. ]9 t( x5 K% g127.0.0.1:6379> hexists user:1 con\n$ c$ ?0 {. u4 Q( I) r$ c% k  z(integer) 0$ B+ M; {5 D* o+ w\n复制代码\n! Z0 Q. R5 }: c- r; `1 }8.hkeys key获取指定key的所有filed, v: w2 R# b* x. |% j) a1 \\\" w\n127.0.0.1:6379> hkeys user:1! ^1 O% f& n, n3 T1 {( `\n1) \"name\"( T/ I0 [# I/ A: A! F. k\n2) \"age\"  A  h1 N! [9 z. i0 m\n3) \"city\"\n/ @8 }- f( s1 S$ q; ?复制代码\n) v  H: h6 g; j  d9.hvals key获取所有value\n6 K0 ~, J0 S8 I% i127.0.0.1:6379> hvals user:1\n( O  ^1 M/ a( q! K% {; [\" l. [; m; ]1) \"tom\"\n0 R& K4 |3 l, e$ c' e2) \"12\"* i# o! N7 Q( x0 _. o\n3) \"beijing\"  B( u  `/ o) u\n复制代码\n& R# F% U# _; @1 x/ q) `10.hgetall key获取所有filed-value9 }% D; ~+ r, x# D, R) N\n127.0.0.1:6379> hgetall user:1\n+ L- t: B  Q7 S# x1) \"name\"\n, Z% N; D) z, M& N2) \"tom\"9 z7 a, A$ N( J- ?\" E5 Y1 b\n3) \"age\"4 _! k+ K. k5 w% q5 i2 O8 x2 `1 _\n4) \"12\"\n5 E* E  h+ i/ J/ ?% `. x6 F5) \"city\". R0 [/ C$ t5 u- R9 ]( \\9 F7 h\n6) \"beijing\"复制代码\n3 h2 s+ J+ n3 n8 O: R$ F% h使用场景缓存用户信息. Z5 [+ g* L; G: f. p\n5 [  {  Y: P% g  E' Z1 w\n( ^; J- K# K' @' u+ R( B4 J\n\n; r/ c5 T$ P. S\" o\n1 m- [2 `3 r9 x& H7 Y) r& X7 L5 S# p1 ~7 D3 x# o* m, z\n2 A0 a9 B/ C$ `9 \\1 _\nRedis列表4 \\* N7 J5 L0 z7 T% S8 ^\n\n6 x1 }  Z/ h( y$ x简介( T4 p' Z0 `2 [\" t5 @\" f9 M, Q; @\n列表是原来储存多个有序的字符串，列表中的每个字符串被称为元素，在Redis中可以对列表两端插入（push）和弹出（pop），因此它可以充当栈和队列的角色$ C( d+ K- B3 t% k\n添加命令% O, `. [0 a/ g/ t, p: a$ p\n9 k3 t2 b, V4 Y4 Z6 L\n1.rpush key value [value ...]\n+ Q  [9 `6 h- S\" I9 }! j从右边插入元素127.0.0.1:6379> rpush list a b d e  j$ ^; n- x* M# R8 Q  G\n(integer) 4\n7 h: v* I. a& S\" e- E复制代码/ ~' f4 R: }( `5 @* a\n2.lpush key value [value ...]从左边插入元素2 m- J( T; y4 N\" w( t' I\n3.linsert key before|after pivot value向某个元素前/后插入元素\n# f9 s8 K4 i, J* m- X127.0.0.1:6379> linsert list after b c3 }7 w0 n. \\, B\n(integer) 5\n. C! A) r/ z& Q7 m8 u7 Q复制代码\n' _2 n9 H$ _! |5 X. F/ A$ C4 P查找命令\n' P6 g3 v; p1 h. S8 I* O6 ~1.lrange key start end获取指定范围内的元素列表，注意，索引下标将从0开始. `4 Y3 ]8 @& T7 n3 B\n127.0.0.1:6379> lrange list 0 4\n6 |. g0 r: [0 n. q2 E8 O- n1) \"a\"\n) L. [' A\" V% l\" w\" _7 J2) \"b\"- l2 i8 V3 z2 r\n3) \"c\"  Z: }) n9 k& r$ L\n4) \"d\"+ H; b) q\" X7 [1 z\" A  s\n5) \"e\"7 C0 ^; }; G* ]: Z8 u0 t4 _\n复制代码\n' Y* I+ U3 A9 |# H0 _5 Y2.lindex key index获取指定下标的元素，索引同样将从0开始\n5 U6 ]' S- X1 H/ F: t\n6 E3 Z- _0 f0 d, o2 G3.llen key获取列表的长度\n9 _* ?: g0 G/ i: ?, y\n0 ?$ _  o: C: N( R删除命令& e- ]2 y7 E7 i$ g: B* {\n1.lpop key从左侧弹出元素\n  z$ G. L. A/ s' ^) }# b127.0.0.1:6379> lpop list\n# e1 y4 s, @7 H- D' I\"a\"\n/ v3 f! u: z5 q; ~9 F9 n! L复制代码\n5 W0 a) j; F5 S% `5 l  b2.rpop key从右侧弹出元素\n# K  l; s: H# {1 ]% D/ G5 |127.0.0.1:6379> rpop list\n  W: Q# {# n5 T/ e\"e\"\n& \\# k1 r6 S$ K\" b9 K9 _0 u127.0.0.1:6379> lrange list 0 2\n4 K1 [# {! v: R; f1) \"b\"! K( ^1 I7 z; Z4 E\n2) \"c\"\n8 Y7 b7 o; @, r: S- O3) \"d\"9 B% A% F: [5 X9 e2 Z8 a/ T\n复制代码* T- g! @- b+ m$ R\n3.lrem key count valueRedis Lrem 根据参数 COUNT 的值，移除列表中与参数 VALUE 相等的元素。\n: ^9 c5 K1 r1 vCOUNT 的值可以是以下几种： & e8 o8 ?  M4 S. i\ncount > 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT ) }$ Y2 ^% J/ T/ J, ?- ^# m\ncount < 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值 \n, f; E5 g1 `' \\1 \\6 O9 mcount = 0 : 移除表中所有与 VALUE 相等的值7 o7 z, ?9 n% i* ?4 t* j( O2 W\nredis> RPUSH mylist \"hello\"\n# n! I/ [4 V. g1 f$ H$ Q(integer) 1\n' N& [0 y. ?6 D2 l1 Z6 h! W( [2 Nredis> RPUSH mylist \"hello\"3 }- O+ M1 L% s* g$ d\n(integer) 2# {9 ?& x0 y/ _3 p* I\nredis> RPUSH mylist \"foo\") y3 a! W. S( o3 H1 O\n(integer) 36 U# \\8 z3 Q, Y; x\nredis> RPUSH mylist \"hello\"9 @0 {* c$ [& u7 ?\n(integer) 4\n8 u$ T6 g/ `( I) ^redis> LREM mylist -2 \"hello\"% D6 a* B, t6 v1 Q6 X\n(integer) 2- Q\" c$ ?  N& i! [\nredis> LRANGE mylist 0 -1\n( W2 G8 ]9 q* O; |) f1) \"hello\"\n( F- @3 J$ z% G' Z7 T2 z; Y2 ~2) \"foo\"复制代码\n$ i$ O/ p: i& v  ]: T. o- z* n* r4.ltrim key start end对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\n) Z/ @9 P9 A0 J  }7 k5 O; U+ nredis 127.0.0.1:6379> RPUSH mylist \"hello\"\n7 D$ b5 S$ \\' |! G\" F1 @' v* g6 o(integer) 1\n) i2 K. Z2 a5 C. B4 {9 E- Tredis 127.0.0.1:6379> RPUSH mylist \"hello\", N. A: k% v# I! T9 k3 [! ~\n(integer) 2\n% e' `' ]8 o& _* Zredis 127.0.0.1:6379> RPUSH mylist \"foo\"\n# H8 _3 L0 s8 j( q2 }/ P) J) e(integer) 37 s# Q/ K- m+ p* g: }' C+ e, I8 T6 _\nredis 127.0.0.1:6379> RPUSH mylist \"bar\"\n3 O' m# n9 I5 X4 y3 O2 k5 l, i(integer) 4. b  W: Z0 b+ `) r0 G1 I\nredis 127.0.0.1:6379> LTRIM mylist 1 -1\n- `6 q, f' [, x% c% SOK  S+ }1 ?' z/ O& y2 D  l\" A6 X- {; g& O\nredis 127.0.0.1:6379> LRANGE mylist 0 -15 F6 M3 I\" S. u2 m0 A\n1) \"hello\"\n) E3 P* k  T9 a) G* H5 h* h0 `9 d2) \"foo\"( T: B- }\" {( V& G; W\n3) \"bar\"复制代码\n! W: f) c8 X% n9 b6 z修改命令\n) m4 E( |3 u$ a: B\n* @' M7 G! t* B) F6 o9 A/ @  Q1.lset key index newValue6 {' l3 i5 W  i  O\n修改指定索引下标的元素, c3 {$ R6 c- ?# a\n\n# d& Y# c) F\" H- A0 Q, [阻塞命令阻塞命令会根据设置的阻塞时间，等待相应的时间后返回数据，这里不多加叙述，有兴趣的读者可以参考https://www.runoob.com/redis/lists-brpop.html2 a6 r, }; S2 L) O! f& v! `6 [# X0 S' W\n# y4 W: |4 E3 U: r1 t# P\n使用场景消息队列文章列表; }. G4 ^/ q3 v. u/ r8 X6 s\" g0 D4 q\n2 Y) J. t- C! R* M% ^\n\n, T\" q+ Q7 J2 D4 l\n4 |) q8 D8 P& V! V4 V\n1 O- O* Y6 @6 K. C\n2 k+ \\& Z8 ^$ J  U$ a# @& e4 t& C2 n5 ~5 @5 v\nRedis集合+ m5 |0 k1 v4 O# t\n\n7 \\  s4 M5 H2 \\/ m( D简介集合类型也是用来保存多个字符串类型的数据，但和列表不同的是，集合中不允许有重复元素，并且集合的元素是无序的\n; N  {$ v- l+ L\" x) J, G  @, u% c7 A4 a& R! K0 ?; H7 x' I5 }8 D\n集合内命令\n2 r* a, `+ C\" V% f9 c) X) D' b/ D' e7 h$ y\n5 v. U3 |: k. U2 G) J# q\n1.sadd key element [element ...]/ ^6 Q- C  p0 E4 T; n\n添加元素，返回结果为添加成功的元素个数127.0.0.1:6379> sadd set value1 value2 value3\n' `- V' G1 t: s) o) i' \\(integer) 3\n2 \\# K/ i$ C, r1 h\" u! p3 ^7 C( a复制代码\n& p& Z% [! x6 J2 S: W2.srem key element [element ...]删除元素，返回结果为删除成功的元素个数\n. Y8 @5 p' }+ M0 @! N6 [: `3 v2 f& J6 g: ^! O6 x+ p+ ?4 i\n3.scard key计算元素个数127.0.0.1:6379> scard set\n( e8 b* R- Y; \\: C# }/ M2 y, P\" t' x(integer) 3/ O' f7 _! l: H  J\n复制代码, z! \\7 n! }. [+ ~3 T\n4.sismember key value判断元素是否在集合中，是返回1，否返回0/ i. F. V0 n4 c8 V( J\n127.0.0.1:6379> sismember set value1/ ~( D: c0 E9 B, Q\n(integer) 1\n) V0 F* `% a* a+ T# h127.0.0.1:6379> sismember set value4$ Z9 R; _' o+ y\" \\$ ?\n(integer) 0\n; f) s9 S# K% J复制代码\n& Q* J5 }/ P, R9 q, D- j8 x5.srandmember key [count]随机从集合中返回count个元素\n4 h: D: i& \\, U127.0.0.1:6379> srandmember set 2: V, U3 {5 v0 q* V\n1) \"value1\"\n; z# z2 M3 E, d2) \"value2\"\n\" L: i% z. u5 ^( I127.0.0.1:6379> srandmember set 2\n$ N0 M: |# o: j0 p) j$ v1) \"value3\"  K+ N: U  |) k\n2) \"value2\". f0 Y' d; C* ]: D\" i1 j$ O6 u\n复制代码# X. l\" Q, X! B' Q9 F2 f\n6.spop key [count]随机从集合中返回count个元素并将返回的元素删除\n$ ?# E% K$ g. M% t. h8 w\n! U/ Q\" v5 g\" r! o6 C: G! q7.smembers key获取所有元素6 y/ B& b8 G\" h, e( e  B; y\n127.0.0.1:6379> smembers set\n8 o) O( [- G\" G1) \"value3\"\n4 i0 _% F9 P3 a& o' W( Y2) \"value1\"\n1 B5 l2 A; a5 G9 T* o% `3) \"value2\"\n- ~$ s9 w' V( U& H复制代码+ J# ]+ u6 W' j% x\n集合间命令0 l% F- x# @7 }( C/ b& c\n现在有两个集合user:1:follow和user:2:follow\n( O1 A\" \\: z8 |  s127.0.0.1:6379> sadd user1:follow it music his sports\n& R) w2 y7 e9 k. q$ E9 n* r(integer) 4$ f. B- i# |# Q% z- s5 F1 b\n127.0.0.1:6379> sadd user2:follow it news ent sports/ Y% h: I! v% G\" L  f\n(integer) 48 B, X$ W! L* A7 [! r0 ~\" K6 l\" Z0 \\\n复制代码\n5 C. U9 b& G# V. D1.sinter key [key ...]求多个集合的交集127.0.0.1:6379> sinter user1:follow user2:follow3 T1 H# x0 B+ ~\n1) \"sports\"\n5 W% f\" ?* H3 |; X+ K; y2) \"it\", T+ n# w. y, y\n复制代码\n8 S# t8 Y( U; q! u$ t2.sunion key [key ...]求多个集合的并集127.0.0.1:6379> sunion user1:follow user2:follow3 G4 H. \\8 K5 p& |1 m\n1) \"music\"1 b7 i8 R8 n, f# \\: C\n2) \"sports\"1 G+ u& e, [' X\n3) \"ent\"1 F0 r* W3 ^* N; I# J- w- X\n4) \"his\"\n# `6 L+ M( I( d/ P( t: y5) \"news\"\n0 m9 E8 d- e( r; G6 A7 ]# m& M+ K6) \"it\"4 K+ @( v# D- O! D1 l; m* q\n复制代码\n- |* H' y) c6 T* P3.sdiff key [key ...]求多个集合的差集\n. _; N& S6 o  B' Z  \\, c127.0.0.1:6379> sdiff user1:follow user2:follow\n& W, g4 R% h/ u0 i7 ]1 i1) \"music\"\" S, p! T: P' @( [5 G\n2) \"his\"; a7 h9 F; X; u# I# \\\n复制代码2 |/ w: [+ T: t\" t# W/ L  h\n使用场景标签\n) _, w, ~* L9 B* I+ g; O- G* C6 i: o) D  k( s1 E/ M* u\n\" T3 o; k\" D! Q1 W\n, o5 Y1 ]( W1 D8 a\n\n  E& c, H5 }; [: x( F, ]( }/ j' k( r5 e2 P\n* x3 S& _( s% L4 r1 d\n! H2 T# K* ?; k+ R\nJava操作Redis\n- ]$ T9 Q( s; P6 U4 V; W5 g! {5 H9 y) B5 b% s9 U3 S\n安装开始在 Java 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 Java redis 驱动，且你的机器上能正常使用 Java如何安装 Java redis 驱动？首先你需要下载驱动包 下载 jedis.jar，确保下载最新驱动包在你的 classpath 中包含该驱动包, b+ c+ _3 w3 r. I( z6 d. r( B\n连接到Redisimport redis.clients.jedis.Jedis;9 m- o9 d9 q9 I$ f2 l9 o) K\n \" m! t( X8 X, x\" J5 p\npublic class RedisJava {6 c) S% C% H  `6 a2 K\n          public static void main(String[] args) {  @! w( H' s4 K+ o\" T$ b/ t5 {\n          //连接本地的 Redis 服务6 X6 ~  B  V9 G4 ~7 p2 l\n          Jedis jedis = new Jedis(\"localhost\");\n) ~4 P* ?7 o/ O; S! F\" N: O          System.out.println(\"连接成功\");\n7 ^2 F# q2 A\" c& E          //查看服务是否运行\n+ m- x9 `\" j$ s; b. O$ a          System.out.println(\"服务正在运行: \"+jedis.ping());5 u% Q$ L% C  y\n          }+ E5 j8 q; |% Z  |/ e% B\n}复制代码\n& }$ f  X! o2 P& u: Q\n\" U! _1 L+ V6 e0 O4 g% q3 S. j0 iRedis Java String(字符串) 实例import redis.clients.jedis.Jedis;\n4 v1 h; n% x8 I( I* e \n' b: C# R( I\" V; s' F9 t7 ~8 v# I0 qpublic class RedisStringJava {( ^5 ]3 P7 o\" W7 F/ [4 W& U( z& R\n          public static void main(String[] args) {\n+ R( E$ R& l  g! [6 V2 O. n          //连接本地的 Redis 服务6 {) K8 Y9 C! Q( T- w; P\n          Jedis jedis = new Jedis(\"localhost\");\n  o% B* x# r5 L2 p; l5 M          System.out.println(\"连接成功\");\n1 r0 p% R* W- |7 f: [9 f0 Y5 {          //设置 redis 字符串数据5 M0 t4 d0 c: p, o, _& x2 N\n          jedis.set(\"hello\", \"redis\");\n: x6 |6 Y) e; P8 d( J          // 获取存储的数据并输出\" z$ U6 n- o* w5 i4 S) l# ?& y& V\n          System.out.println(\"redis 存储的字符串为: \"+ jedis.get(\"hello\"));+ T4 U8 q! S3 f: E% J/ m\n          }\n0 ^+ B0 H( c9 v4 ^\" }' W: Z}复制代码\n7 Y: X  X* ^$ m' A3 t# M5 J/ |\" mRedis Java List(列表) 实例import java.util.List;$ {! _( M# m! v/ d\nimport redis.clients.jedis.Jedis;\n. {0 p* J  [1 y  Q7 g ; U1 W! F# V( j; y! U* C! K7 f) ~6 f/ B\npublic class RedisListJava {% u( r+ ?/ I, q. Y  ]6 ]* E( W/ |\n    public static void main(String[] args) {, h& Z/ a9 I& j+ p# [* ~& o\n        //连接本地的 Redis 服务$ B5 p  ]. s7 r+ R% B7 W! O9 s1 F' H\n        Jedis jedis = new Jedis(\"localhost\");\" h. I/ O( H( x% _6 W8 n( I- _4 O) p\n        System.out.println(\"连接成功\");\n7 z6 y4 Q/ c+ j8 n' M5 d        //存储数据到列表中( Q7 ?6 V( R; U' q\n        jedis.lpush(\"site-list\", \"Baidu\");; N% ~1 d. Y\" A# Y- Y; q* O\n        jedis.lpush(\"site-list\", \"Google\");\n) Q2 P# W& V$ g- R6 k4 L        jedis.lpush(\"site-list\", \"Taobao\");\n6 Q; G7 G0 f* X* H/ ^        // 获取存储的数据并输出6 J2 r5 ]# }: r\n        List<String> list = jedis.lrange(\"site-list\", 0 ,2);3 ~/ q, l0 y2 a5 ]' U\" x\n        for(int i=0; i<list.size(); i++) {\n: C( k( g3 d* [            System.out.println(\"列表项为: \"+list.get(i));\n, Q' _1 Q( ]; x$ ~* n  ~        }! y$ ^+ `: `% J4 Q# B% Z: d3 w\n    }- Q( {7 v+ h7 \\, _% F' W  S$ S\n}复制代码\n# P7 z2 a% P- _\n0 K' M. V- w5 f3 P0 J\n1 t  O9 c* C0 v9 E6 W& @. e9 U) X% h4 p- H8 L\n\n' A- M& e) B* N% D4 S* s2 n$ U; H\n1 p8 {; F) k- |3 {3 K\n",
    "replies": []
}