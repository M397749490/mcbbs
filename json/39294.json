{
    "title": "利用Forge API开发联机MOD【基础篇】【第九章】",
    "author": "yuxuanchiadm",
    "replyCount": 8,
    "timestamp": 1344054900,
    "txt_content": " 本帖最后由 yuxuanchiadm 于 2013-8-4 16:58 编辑 \n\n利用Forge API开发联机MOD【基础篇】【第九章】\n为你的刷怪笼添加一个可操作的GUI\n作者：yuxuanchiadm\n\n索引贴地址：http://www.mcbbs.net/thread-38211-1-1.html\n\n请确定你已经阅读完成第八章的内容:\nhttp://www.mcbbs.net/thread-114901-1-1.html\n否则不要阅读此贴！\n\n序：\n在上一章里，我们完成了我们MOD的网络通信框架，现在，是时候阅读联机MOD篇的最后一章了：)，当你阅读完这一章时，你将得到一个完整的利用ForgeAPI制作的MOD！\n\n制作一个新的GUI：\n/**知识点：什么是GUI\nGUI指的是用户图形界面，在Minecraft里，所有的用户图形界面都继承自GUI类。在显示一个GUI时一般是通过调用Minecraft类里的displayGuiScreen()函数来显示一个继承自GuiScreen类的GUI，在通过调用这个函数打开GUI时会关闭其他通过这个函数打开的GUI。\n**/\n首先，制作一个刷怪笼设置面板GUI的背景：\n在myFirstMod/sprites下新建文件：SpawnerSettingGui.png\n然后乱涂成这样：)\n\n\n\n\nSpawnerSettingGui.png (3.41 KB, 下载次数: 25)\n\n下载附件\n\n2012-8-4 12:24 上传\n\n\n\n\n\n然后，打开BlockAdvancedMobSpawner，看到当时我们留下的// 以后会在这里添加代码复制代码由于我们想让我们的MOD能够支持联机，所以，我们需要先向服务端发送一个数据包，然后服务端返回实体的名称。\n在这里插入代码：myFristModPacket pak = new myFristModPacket();\n//我们要发送3个int数据，所以初始化数组大小为3\npak.dataInt = new int[3];\n//数据包ID为0\npak.packetType = 0;\n//方块X轴坐标\npak.dataInt[0] = par2;\n//方块Y轴坐标\npak.dataInt[1] = par3;\n//方块Z轴坐标\npak.dataInt[2] = par4;\n//发送数据包\nPacketDispatcher.sendPacketToPlayer(pak.toPacket(), (Player)par5EntityPlayer);复制代码此处我们发送数据包时还发送了方块坐标，虽然方块坐标对于获取实体列表没有用，但是为了保证以后修改方块时我们能得到方块坐标，所以这里也要连同方块坐标一起发出去。\n\n服务端发送数据包后，客户端需要接收和处理数据包，打开mod_myFirstMod类，找到handlePacketFromServer方法，写入以下内容：if(packet.packetType == 0)\n{\n    //等下会在这里添加代码\n}复制代码因为我们发送数据包时制定其ID为0，所以如果接收到的数据包ID为0则是方块右击事件发送的数据包。\n\n其次，我们需要创建自己的一个GUI。首先新建包myFirstMod.GUI，然后再在其中新建类GuiMobSpawnerSetting。\n然后，再让其继承自GuiScreen类：package myFirstMod.GUI;\nimport net.minecraft.client.gui.GuiScreen;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\n\n@SideOnly(Side.CLIENT)\npublic class GuiMobSpawnerSetting extends GuiScreen\n{\n    \n}复制代码我们在设置GUI的时候希望能获取到当前刷怪箱刷的怪物，和刷怪间隔，而不是从零开始，而且后面还要将刷怪箱的坐标连同所刷怪物和间隔一同发送到服务端，所以我们的构造函数需要3个参数，并将其记录到成员属性中，添加如下代码：public int SpawnerX;\npublic int SpawnerY;\npublic int SpawnerZ;\npublic GuiMobSpawnerSetting(int x, int y, int z)\n{\n    SpawnerX = x;\n    SpawnerY = y;\n    SpawnerZ = z;\n}复制代码其次，我们需要将所刷怪物的ID列表复制到我们的GUI中存起来：private ArrayList<Integer> mobList = new ArrayList<Integer>();\npublic void initGui()\n{\n    mobList.addAll(EntityList.entityEggs.keySet());\n}复制代码我们的GUI需要几个按钮：上一个、下一个、时间+100、+10、+1、-1、-10和-100，首先创建成员属性：private GuiButton prev;\nprivate GuiButton next;\nprivate GuiButton Cut1;\nprivate GuiButton Cut10;\nprivate GuiButton Cut100;\nprivate GuiButton Add1;\nprivate GuiButton Add10;\nprivate GuiButton Add100;复制代码然后我们还需要2个文本框，用于显示当前间隔和当前所刷怪物，创建成员属性：private GuiTextField MobNameTextBox;\nprivate GuiTextField SpawnDelayTextBox;复制代码然后在initGui方法中对其进行初始化，以上一个按钮为例：prev = new GuiButton(1, (width - 175) / 2 + 20, (height - 165) / 2 + 60, 40, 20, \"上一个\");\ncontrolList.add(prev);复制代码首先new一个GuiButton对象，第一个参数表示他的ID，在点击时可以用ID来判断是哪个按钮，第二个和第三个参数是X轴和Y轴坐标，第四个和第五个参数为长和宽，最后一个是显示的字符串。第二行添加这个按钮到控件（按钮）列表。\n继续初始化其他的按钮：next = new GuiButton(2, (width - 175) / 2 + 20, (height - 165) / 2 + 80, 40, 20, \"下一个\");\ncontrolList.add(next);\nCut100 = new GuiButton(3, (width - 175) / 2 + 10, (height - 165) / 2 + 137, 20, 20, \"-100\");\ncontrolList.add(Cut100);\nCut10 = new GuiButton(4, (width - 175) / 2 + 29, (height - 165) / 2 + 137, 20, 20, \"-10\");\ncontrolList.add(Cut10);\nCut1 = new GuiButton(5, (width - 175) / 2 + 48, (height - 165) / 2 + 137, 20, 20, \"-1\");\ncontrolList.add(Cut1);\nAdd1 = new GuiButton(6, (width - 175) / 2 + 108, (height - 165) / 2 + 137, 20, 20, \"+1\");\ncontrolList.add(Add1);\nAdd10 = new GuiButton(7, (width - 175) / 2 + 127, (height - 165) / 2 + 137, 20, 20, \"+10\");\ncontrolList.add(Add10);\nAdd100 = new GuiButton(8, (width - 175) / 2 + 146, (height - 165) / 2 + 137, 20, 20, \"+100\");\ncontrolList.add(Add100);复制代码接下来，我们需要获取当前刷怪笼的状态，并存储在GUI里以备用，新建成员属性：private int CurrentID;\nprivate int Delay;复制代码再在initGui方法中添加：TileEntity tileEntity = Minecraft.getMinecraft().theWorld.getBlockTileEntity(SpawnerX, SpawnerY, SpawnerZ);\nif(tileEntity instanceof TileEntityAdvancedMobSpawner)\n{\n    TileEntityAdvancedMobSpawner tileEntitySpawner = (TileEntityAdvancedMobSpawner)tileEntity;\n    Field stringToIDMapping = null;\n    Map strToIDMap = null;\n    try\n    {\n        stringToIDMapping = EntityList.class.getDeclaredField(\"stringToIDMapping\");\n        stringToIDMapping.setAccessible(true);\n        strToIDMap = (Map)stringToIDMapping.get(null);\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n    String mobName = tileEntitySpawner.getMobID();\n    CurrentID = mobList.indexOf(strToIDMap.get(mobName));\n    Delay = tileEntitySpawner.getSpawnDelay();\n}复制代码稍微运用了下反射来获取私有字段。\n然后根据按钮的mobList和CurrentID的状态来调整按钮的状态：if((mobList.size() - 1) == 0)\n{\n    prev.enabled = false;\n    next.enabled = false;\n}\nelse\n{\n    if(CurrentID > 0 && CurrentID < (mobList.size() - 1))\n    {\n        prev.enabled = true;\n        next.enabled = true;\n    }\n    if(CurrentID >= (mobList.size() - 1))\n    {\n        prev.enabled = true;\n        next.enabled = false;\n    }\n    if(CurrentID <= 0)\n    {\n        prev.enabled = false;\n        next.enabled = true;\n    }\n}复制代码最后初始化文本框：MobNameTextBox = new GuiTextField(fontRenderer, (width - 175) / 2 + 10, (height - 165) / 2 + 30, 150, 20);\nMobNameTextBox.setText(StatCollector.translateToLocal(\"entity.\" + EntityList.getStringFromID(mobList.get(CurrentID)) + \".name\"));\nSpawnDelayTextBox = new GuiTextField(fontRenderer, (width - 175) / 2 + 10, (height - 165) / 2 + 115, 150, 20);\nSpawnDelayTextBox.setText(Integer.toString(Delay));复制代码上面以刷怪名字为例，先new了个GuiTextField，然后第一个参数固定传入fontRenderer，然后是X轴和Y轴，其次是宽和高。\n然后，我们需要对我们的GUI进行绘制，重写方法drawScreen：public void drawScreen(int par1, int par2, float par3)\n{\n\n}复制代码第一步先绘制默认背景：drawDefaultBackground();复制代码其次弄出我们最先画的材质并修正颜色后绑定：int k = mc.renderEngine.getTexture(\"/myFirstMod/sprites/SpawnerSettingGui.png\");\nGL11.glColor3f(1.0F, 1.0F, 1.0F);\nmc.renderEngine.bindTexture(k);复制代码然后计算出绘制位置，并画矩形：int l = (width - 175) / 2;\nint i1 = (height - 165) / 2;drawTexturedModalRect(l, i1, 0, 0, 175, 165);复制代码然后画文本框：MobNameTextBox.drawTextBox();\nSpawnDelayTextBox.drawTextBox();复制代码然后让父类画各种按钮：super.drawScreen(par1,par2,par3);复制代码最后涂些字符串到GUI中：fontRenderer.drawString(\"刷怪笼设置面板\", (width - 175) / 2 + 6, (height - 165) / 2 + 6, 0x404040);\nfontRenderer.drawString(\"生成的怪物:\", (width - 175) / 2 + 10, (height - 165) / 2 + 18, 0x404040);\nfontRenderer.drawString(\"生成间隔:\", (width - 175) / 2 + 10, (height - 165) / 2 + 104, 0x404040);复制代码然后我们需要对按钮的事件进行处理（简单明了就不说啥了）：protected void actionPerformed(GuiButton par1GuiButton)\n{\n    if(par1GuiButton.id == 1)\n    {\n        CurrentID --;\n        if(CurrentID <= 0)\n        {\n            prev.enabled = false;\n        }\n        if(CurrentID < (mobList.size() - 1))\n        {\n            next.enabled = true;\n        }\n        MobNameTextBox.setText(StatCollector.translateToLocal(\"entity.\" + EntityList.getStringFromID(mobList.get(CurrentID)) + \".name\"));\n    }\n    if(par1GuiButton.id == 2)\n    {\n        CurrentID ++;\n        if(CurrentID >= (mobList.size() - 1))\n        {\n            next.enabled = false;\n        }\n        if(CurrentID > 0)\n        {\n            prev.enabled = true;\n        }\n        MobNameTextBox.setText(StatCollector.translateToLocal(\"entity.\" + EntityList.getStringFromID(mobList.get(CurrentID)) + \".name\"));\n    }\n    if(par1GuiButton.id == 3)\n    {\n        ChangeDelay(-100);\n    }\n    if(par1GuiButton.id == 4)\n    {\n        ChangeDelay(-10);\n    }\n    if(par1GuiButton.id == 5)\n    {\n        ChangeDelay(-1);\n    }\n    if(par1GuiButton.id == 6)\n    {\n        ChangeDelay(+1);\n    }\n    if(par1GuiButton.id == 7)\n    {\n        ChangeDelay(+10);\n    }\n    if(par1GuiButton.id == 8)\n    {\n        ChangeDelay(+100);\n    }\n}\npublic void ChangeDelay(int i)\n{\n    Delay += i;\n    if(Delay > 50000)\n    {\n        Delay = 50000;\n    }\n    if(Delay < 50)\n    {\n        Delay = 50;\n    }\n    SpawnDelayTextBox.setText(Integer.toString(Delay));\n}复制代码然后在关闭GUI时回发数据包：public void onGuiClosed()\n{\n    TileEntity tileEntity = Minecraft.getMinecraft().theWorld.getBlockTileEntity(SpawnerX, SpawnerY, SpawnerZ);\n    if(tileEntity instanceof TileEntityAdvancedMobSpawner)\n    {\n        TileEntityAdvancedMobSpawner tileEntitySpawner = (TileEntityAdvancedMobSpawner)tileEntity;\n        tileEntitySpawner.setMobID(EntityList.getStringFromID(mobList.get(CurrentID)));\n        tileEntitySpawner.setSpawnDelay(Delay);\n    }\n    myFristModPacket pak = new myFristModPacket();\n    //我们要发送4个int数据，所以初始化数组大小为4\n    pak.dataInt = new int[4];\n    //我们要发送1个String数据，所以初始化数组大小为1\n    pak.dataString = new String[1];\n    //数据包ID为1\n    pak.packetType = 1;\n    //方块X轴坐标\n    pak.dataInt[0] = SpawnerX;\n    //方块Y轴坐标\n    pak.dataInt[1] = SpawnerY;\n    //方块Z轴坐标\n    pak.dataInt[2] = SpawnerZ;\n    //刷怪间隔\n    pak.dataInt[3] = Delay;\n    //怪物名称\n    pak.dataString[0] = EntityList.getStringFromID(mobList.get(CurrentID));\n    //发送数据包\n    PacketDispatcher.sendPacketToServer(pak.toPacket());\n}复制代码最后，我不希望打开GUI时暂停游戏：public boolean doesGuiPauseGame()\n{\n    return false;\n}复制代码现在，我们再转到mod_myFirstMod，离成功还有一步之遥了，看到：if(packet.packetType == 0)\n{\n    //等下会在这里添加代码\n}复制代码添加代码：Minecraft.getMinecraft().displayGuiScreen(new GuiMobSpawnerSetting(packet.dataInt[0], packet.dataInt[1], packet.dataInt[2]));复制代码最后，看到handlePacketFromClient方法，在这个方法中对客户端GUI发回的消息进行处理：if(packet.packetType == 1)\n{\n    TileEntity tileEntity = player.worldObj.getBlockTileEntity(packet.dataInt[0], packet.dataInt[1], packet.dataInt[2]);\n    if(tileEntity instanceof TileEntityAdvancedMobSpawner)\n    {        TileEntityAdvancedMobSpawner tileEntitySpawner = (TileEntityAdvancedMobSpawner)tileEntity;\n        if(tileEntitySpawner != null)\n        {\n            tileEntitySpawner.setSpawnDelay(packet.dataInt[3]);\n            tileEntitySpawner.setMobID(packet.dataString[0]);\n        }\n    }\n}复制代码现在，你的刷怪笼已经可以通过蹲下右键打开GUI，并设置其属性了！\n总结：\n首先祝贺你已经完成了大部分联机MOD的制作学习，并且做出了一个属于你自己动手创作的MOD：)，你已经可以毫不犹豫的说：“我是一个Forge MOD的制作者！”。但是，此MOD仍然没有完成，只能在MCP下运行，在玩家手里就运行不能了。原因就是我们使用了反射，所以产生了反混淆问题，下一章我们将详细讨论如何解决这个问题。",
    "replies": [
        {
            "author": "819tierqusi",
            "timestamp": 1344055860,
            "txt_content": "制作刷怪笼的方法么"
        },
        {
            "author": "A-Kreedz",
            "timestamp": 1344056040,
            "txt_content": "好吧作者。\n你可以考虑把一些常用的插件的GUI都做出来。。。\n比如Ess。。ICo。。。SCS。。"
        },
        {
            "author": "A-Kreedz",
            "timestamp": 1344057060,
            "txt_content": "求别点评。。。\n其实人生就是要做一些惊悚的事情\n你还要更加努力一把"
        },
        {
            "author": "kuafuzhuguang",
            "timestamp": 1375714620,
            "txt_content": "成功实现，虽说一直只是在粘贴代码。但创造总得从模仿开始不是么。\n话说画界面的时候让我感觉果然这方面还得我大.net啊。"
        },
        {
            "author": "天空之夜丶",
            "timestamp": 1385370240,
            "txt_content": "kuafuzhuguang 发表于 2013-8-5 22:57 \n成功实现，虽说一直只是在粘贴代码。但创造总得从模仿开始不是么。\n话说画界面的时候让我感觉果然这方面还 ...\n我想问一个问题\n就是从gui 返回到游戏主界面的方法是哪个\n或者有什么方法实现这个么"
        },
        {
            "author": "phpair",
            "timestamp": 1405424400,
            "txt_content": "天空之夜丶 发表于 2013-11-25 17:04\n我想问一个问题\n就是从gui 返回到游戏主界面的方法是哪个\n或者有什么方法实现这个么 ...\n有。。参考ingamemenu就行"
        },
        {
            "author": "zbw001",
            "timestamp": 1406799900,
            "txt_content": "为什么不能返回？？？？？"
        },
        {
            "author": "zbw001",
            "timestamp": 1406800020,
            "txt_content": "zbw001 发表于 2014-7-31 17:45\n为什么不能返回？？？？？\n难道是我代码有错？"
        }
    ]
}