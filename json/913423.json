{
    "title": "高效数组",
    "author": "afjl",
    "replyCount": 3,
    "timestamp": 1568426760,
    "txt_content": " 本帖最后由 afjl 于 2019-9-14 10:06 编辑 \n\n注意：想完全理解本文需要相当的编程基础，不过使用不需要\n本文最后有成品，是一个数据包，导入地图，就可以运行示例代码，并且附带生成器，可以直接调用\n\n最近有点闲得没事干，就搞了个高效数组\n这里是别人发的一个O(n)数组\n可以看出，这种做法效率很低\n作为一个OIer，当然要想办法优化了QWQ\n\n注：测试时用的单独的服务端，客户端只负责查看输出\n\n前置知识：线段树\n\n线段树，就是用线段组成的树（逃\n这里是一道对应的题目，题解中有比较详细的介绍\n简单介绍一下原理：\n线段树实际是一个二叉树，每个节点维护一段区间\n当需要对一大段区间进行操作时，可以将操作分到若干个节点上，这样最多2log_2 n个节点\n而如果处理一个位置，可以从根节点出发找对应位置，最多经过log_2 n个节点\n\n\n基本思路\n\n在实现数组时，用的是类似线段树的思路\n首先，按照线段树的方法生成一堆函数\n其中函数的内容：\n如果这个点维护的不是一个位置，就根据所操作的下标大小，选择一侧继续处理，也就是调用对应函数\n如果维护的是一个位置，就对一个记分板项进行操作\n\n\n具体实现\n\n我写了一个生成器，会根据要求的数组名和数组大小自动生成相应函数，每个函数都有一个数字标号\n对于维护不止一个位置的函数，用execute命令判断询问的下标在哪个范围内，然后调用对应的函数\n对于维护一个位置的函数，就用记分板命令修改对应的值\n对于数组的每个位置，我用了一堆\"#a1\"之类的实体名，都用的\"mem\"记分板项\n另外，生成器还会自动创建读取/写入接口\n\n\n使用方法\n\n加载&卸载：\n将数据包加载后运行array:init函数以完成加载\n卸载数据包前运行array:unload清空数据并关闭功能\n\n生成数组：\n在array\\data\\array\\functions下找到make_arr.exe\n运行，依次输入<数组名> <数组大小> <附加参数>\n附加参数的含义在\"拓展\"部分有介绍\n如果你不知道附加参数的含义，请输入1\n这样就会自动生成一个数组\n你可以生成多个数组，只要数组名不同就行\n已知bug:如果已经有对应文件夹，就会导致显示文件夹已存在\n\n读取数组：\n参考代码如下\nscoreboard players set #arr_<数组名> index <下标>\nfunction array:arr_<数组名>/read\ntellraw @a {\"score\":{\"name\":\"#arr_<数组名>\",\"objective\":\"value\"}}\n\n写入数组：\n参考代码如下\nscoreboard players set #arr_<数组名> index <下标>\nscoreboard players set #arr_<数组名> value <数值>\nfunction array:arr_<数组名>/write\n\n使用时可以用其它方式读取/修改对应记分板项的值，效果一样\n\n\n然后我又写了两个示例代码\n\n代码1\n\nC++等价代码：\n\nfor(int i=1;i<=30;i++)a[i]=i*i;\nfor(int i=30;i>0;i--)cout<<a[i]<<endl;复制代码\n在array\\data\\array\\functions下找到io_try.exe\n这段代码会自动生成一个读/写数组的程序\n首先会将数组a的前30项赋值为i^2\n接下来会将这30项倒序输出，每个玩家都能看到\n\n这段代码展示了使用数组的基本方法\n\n\n代码2\n\n核心部分代码（参考了别人的代码）：\n\nfor( int i = 0; i < U; ++i ) cnt[i] = 0;\n        for( int i = 0; i < n; ++i ) ++cnt[getd(x[i],d)];\n        for( int i = 1; i < U; ++i ) cnt[i] += cnt[i-1];\n        for( int i = n-1; i >= 0; --i ) y[--cnt[getd(x[i],d)]] = x[i];复制代码\n在array\\data\\sort\\functions下有另一个示例程序\n其中io_try.cpp会生成2000个2^31-1范围的数\n然后运行sort:main函数，会将这2000个数排序后输出，每个玩家都能看到\n排序时使用了基数排序，这是一种O(n)排序算法，如果不会，可以上网搜一下\n\n由于MC自身特性，在实现时，每个循环单独弄了一个函数\n\n关于基数排序：base不要过大，不然清空cnt数组就会直接蹦端（1tick用时过长，自动蹦端）\n\n这段代码展示了循环和数组配合使用\n\n\n效率分析\n\n[08:55:54] [Client thread/INFO]: [CHAT] 2137195439\n[08:55:54] [Client thread/INFO]: [CHAT] 2137289645\n[08:55:54] [Client thread/INFO]: [CHAT] 2137856192\n[08:55:54] [Client thread/INFO]: [CHAT] 2139890557\n[08:55:54] [Client thread/INFO]: [CHAT] 2140236463\n[08:55:54] [Client thread/INFO]: [CHAT] 2141479738\n[08:55:54] [Client thread/INFO]: [CHAT] 2141605832\n[08:55:54] [Client thread/INFO]: [CHAT] 2143125235\n[08:55:54] [Client thread/INFO]: [CHAT] 2143173261\n[08:55:54] [Client thread/INFO]: [CHAT] 2143233270\n[08:55:54] [Client thread/INFO]: [CHAT] 2143489774\n[08:55:54] [Client thread/INFO]: [CHAT] 2144754454\n[08:55:54] [Client thread/INFO]: [CHAT] 2146723279\n[08:55:54] [Client thread/INFO]: [CHAT] 2146795414\n[08:55:54] [Client thread/INFO]: [CHAT] 2147319691\n[08:55:54] [Client thread/INFO]: [CHAT] [Server: 已执行函数sort:main中的2155596条命令]复制代码\n这是运行第二段示例代码的部分输出，排2000个数用时约5秒，完全可以在客户端超时断开连接前完成\n可以看出，效率很高\n\n警告：此类大规模操作极易导致客户端无响应，服务端执行可能会蹦端\n请不要轻易尝试此类操作\n另外，大量输出也可能会导致客户端短时间无响应\n\n利用线段树，可以做到每次O(log n)的读写操作\n对于大小2000的数组，读写一次大约用20次命令就可以完成了\n这样，用基数排序就能做到和快速排序一样的复杂度：O(n log n)\n但是实际mc运行命令非常慢（测试时平均0.02ms一条，实际速度还取决于命令种类）\n所以，效率还是不高（至少比暴力读写快多了）\n\n\n\n拓展内容\n\n拓展1：高维数组\n实现时有两种思路\n第一种：把数组读写操作改成调用另一个数组的接口\n第二种：使用一个一维数组，用乘法和加法确定位置（注意不要弄数组越界，会导致意料外的结果）\n\n拓展2：switch\n只要把数组读写操作改成要执行的代码段就行\n这样比直接暴力判断要快很多\n利用这个思路，也许能弄出一个卡牌显示系统\n\n拓展3：减少文件数量\n大量文件会拖慢MC和系统的速度，必要时应设法减少\n可以考虑每个函数多进行几次判断，这样一个文件可以维护多个位置\n例如，如果需要10^6这样大的数组，可以考虑每步判断100次，这样文件数就约10000个，而执行函数次数约300次\n在读写操作不太频繁时会更有用\n我在生成器中有类似的方法，不过中间的函数还是两个判断，到区间内没有太多位置时再用暴力判断每个位置\n对应的输入就是\"附加参数\"\n\n\n下载地址：\n链接：https://pan.baidu.com/s/1fE0kM3RZ3yeG5Gq57oI1Bw \n提取码：ie51 \n\n大小2.89MB，已经超过论坛的限制了QWQ\n\n\n\n",
    "replies": [
        {
            "author": "森林蝙蝠",
            "timestamp": 1568428980,
            "txt_content": "你是naizi？（指naive）"
        },
        {
            "author": "ruhuasiyu",
            "timestamp": 1568503800,
            "txt_content": "他那个虽然慢，但是可以在游戏内动态生成。\n\n你这个必须用exe指定好长度名称之类的……"
        },
        {
            "author": "afjl",
            "timestamp": 1569850260,
            "txt_content": "ruhuasiyu 发表于 2019-9-15 07:30\n他那个虽然慢，但是可以在游戏内动态生成。\n\n你这个必须用exe指定好长度名称之类的…… ...\n现在我想到了一个可以动态生成的做法，然而没时间做了QWQ"
        }
    ]
}