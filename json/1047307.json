{
    "title": "【1.15+】数据包免穷举实现以下功能",
    "author": "CR_019",
    "replyCount": 3,
    "timestamp": 1589640840,
    "txt_content": " 本帖最后由 CR_019 于 2020-5-17 06:36 编辑 \n\n版本：1.15及以上\n\n\n要实现：与图书管理员交易附魔书，图书管理员重置所有交易附魔书的交易项，即将其所有附魔书的交易售卖的附魔书属性重置为其他的附魔属性\n已实现部分：\n探测与图书管理员交易附魔书的进度；\n有关重置附魔书属性的战利品表和相关命令；\n\n要实现部分：\n图书管理员有多个附魔书交易项，且这些交易项在交易列表的位置不定，\n要实现每个项出现的附魔书属性随机，需要对其中每个项执行一次重置操作，\n如何实现上述操作？\n\n我的方案是：\n1、用execute store+if获取附魔书交易项的项数并存储在计分项中，记为计分项1；\n2、穷举每个交易项：\n     （1）通过计分项2检测在操作本项前是否已经进行过重置操作，若未进行则继续检测，若进行过则不进行任何操作，检测下一项（即直到检测完所有交易项不进行操作）\n     （2）若本项为附魔书，执行重置操作，将计分项1中的分数（表示还未进行过操作的项）减1，将计分项2加1，表示已进行过操作；\n     （3）若本项不为附魔书，则不进行任何操作；\n3、重置计分项2，递归，直至计分项1降至0\n\n\n以上可以解决问题，但工程量较大，我没有足够的时间和精力去完成而且我懒，所以想请教一下各路大佬，是否有更优化的方案，最好可以免穷举\n\n\n我居然忘记了删列表大法。。。\n",
    "replies": [
        {
            "author": "Chelover_C60",
            "timestamp": 1589640840,
            "txt_content": " 本帖最后由 Chelover_C60 于 2020-5-17 00:19 编辑 \n\n我尝试过使用自定义nbt标记进行过而未重置的附魔书交易项，不过后来发现如果同时进行了多个附魔书交易项的话，多个交易项会被设置成同一种交易，而要避免这种情况，就必须用不同的nbt对交易项进行标记，但是我似乎找不到除穷举外的方法。。。（好像穷举也比较难搞）\n\n于是我换了种思路，复制村民的交易nbt，使用递归逐个进行检查重置，最后直接替换掉村民的原交易项。大致思路如下：\n●使用data modify将村民的交易项复制到storage里（暂时称为目录A）\n●开始递归\n|●检查目录A的Recipes[0].id是否为附魔书，并进一步检测是否需要重置\n||●若是且需要重置，则对Recipes[0]进行重置\n||●若不是或不需要重置，则不进行任何操作\n|●将（可能修改过的）目录A的Recipes[0]使用data modify的append形式复制到另一个storage中或同一个storage的另一个目录中（暂时称为目录B）\n|●移除目录A的Recipes[0]。此时的Recipes[1] （若有）会自动变为Recipes[0]\n|●检测目录A中是否仍然存在Recipes[0]，若有则继续递归，若无则停止递归\n●此时的目录A内应该没有内容了，村民的所有交易信息都被存储到了目录B中且已经被编辑好，data modify村民的Offers.Recipes，并设置为 set from 目录B 即可\n\n\n只是这样可能在性能上面不如穷举\n"
        },
        {
            "author": "2723971430",
            "timestamp": 1589641860,
            "txt_content": "萌新表示看不懂"
        },
        {
            "author": "asd15622384176",
            "timestamp": 1589642400,
            "txt_content": "看不懂x2"
        }
    ]
}