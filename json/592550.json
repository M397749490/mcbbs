{
    "title": "拓展/更多玩家NBT——Capabilities食用教程[1.8+Mod开发]",
    "author": "SPE__HaiKuo",
    "replyCount": 5,
    "timestamp": 1465990140,
    "txt_content": "前言：\n说道MC中存储数据的方法，自然是NBT了，而NBT有3种存储方式：Capabilities、World Save Data以及Extended Entity Properties。但是World Save Data不适用于拓展玩家NBT，Extended Entity Properties又逐渐被取缔，Capabilities作为一种新式存储则有较好的优势。\nForgeDoc：https://mcforge.readthedocs.io/e ... orage/capabilities/\n\n一、创建你的Capability接口\n这个接口可以让你从外部访问Capability内部成员变量，这里用数据“Mana”为例。\npublic interface IManaCapability {\n        int getMana();\n        void setMana(int mana);\n}复制代码\n然后创建一个类运用这个接口。\npublic class ManaCapability implements IManaCapability {\n                protected int mana;\n                public ManaCapabiliy() {}\n                public int getMana() {\n                                return this.mana;\n                } //获取Mana\n                public void setMana(int mana) {\n                                this.mana = mana;\n                } //设置Mana\n}复制代码\n\n二、创建你的Storage存储NBT\npublic static class CapStorage implements Capability.IStorage<IManaCapability> {\n                        public static final CapStorage capStorge = new CapStorage();\n                        @Override\n                        public NBTBase writeNBT(Capability<IManaCapability> capability, IManaCapability instance, EnumFacing side) {\n                                                NBTTagCompound compound = new NBTTagCompound();\n                                                compound.setInteger(\"Mana\",  instance.getMana);\n                                                return compound;\n                        } //写入NBT\n                        @Override\n                        public void readNBT(Capability<IManaCapability> capability, IManaCapability instance, EnumFacing side, NBTBase nbt) {\n                                                instance.setMana((NBTTagCompound)nbt.getInteger(\"Mana\"));\n                        } //读取NBT\n}复制代码\n\n三、运用你的Capability\n前两道工序完成后，你还需要创建一个Provider直接运用他。\npublic class CapProvider implements ICapabilityProvider, INBTSerializable {\n\n    @CapabilityInject(IManaCapability.class)\n    public static Capability<IManaCapability> MANA_CAP = null; //声明Capability\n    private INepCapability manaCapability;\n\n    public CapProvider() {\n        manaCapability = new ManaCapability();\n    }\n\n    public CapProvider(IManaCapability manaCapability) {\n        this.manaCapability = manaCapability;\n    }\n\n    @Override\n    public boolean hasCapability(Capability<?> capability, EnumFacing facing) {\n        return MANA_CAP != null && capability == MANA_CAP;\n    } //判断玩家是否已经有Capability\n\n    @Override\n    public <T> T getCapability(Capability<T> capability, EnumFacing facing) {\n        if (MANA_CAP != null && capability == MANA_CAP) return (T)manaCapability;\n        return null;\n    } //获取玩家Capability\n\n    public static IManaCapability get(EntityPlayer player) {\n        return player.hasCapability(MANA_CAP, null)? player.getCapability(MANA_CAP, null): null;\n    } //获取玩家Capability\n\n    @Override\n    public NBTBase serializeNBT() {\n        return manaCapability.saveNBTData();\n    } //写入NBT\n\n    @Override\n    public void deserializeNBT(NBTBase nbt) {\n        manaCapability.loadNBTData((NBTTagCompound) nbt);\n    } //读取NBT\n}复制代码\n接着再在IManaCapability中添加\nvoid saveNBTData();\nvoid loadNBTData();复制代码\nManaCapability再导入方法，接着再添加\n@Override\n    public NBTTagCompound saveNBTData() {\n        return (NBTTagCompound) CapStorage.capStorge.writeNBT(CapProvider.MANA_CAP, this, null);\n    }\n\n    @Override\n    public void loadNBTData(NBTTagCompound compound) {\n        CapStorage.capStorge.readNBT(CapProvider.MANA_CAP, this, null, compound);\n    }复制代码\n到这里就能读取/存储Capability中的NBT了。\n最后，在CommonProxy中注册Capability。\npublic void preInit(FMLPreInitializationEvent event) {\n        CapabilityManager.INSTANCE.register(IManaCapability.class, CapStorage.capStorge, ManaCapability.class);\n}复制代码\n这时，你可以通过CapProvider.get(EntityPlayer)获取玩家的ManaCapability了。\n\n四、同步Capability数据\n你只完成了服务端的操作，对于客户端来说完全没有改动，需要发包同步服务端。\n创建MessageUpdateCap.class发包。\npublic class MessageUpdateCap implements IMessage {\n\n    private NBTTagCompound props;\n\n    public MessageUpdateCap() {}\n\n    public MessageUpdateCap(NBTTagCompound nbtTagCompound) {\n        this.props = nbtTagCompound;\n    }\n\n    @Override\n    public void fromBytes(ByteBuf buf) {\n        props = ByteBufUtils.readTag(buf);\n    }\n\n    @Override\n    public void toBytes(ByteBuf buf) {\n        ByteBufUtils.writeTag(buf, props);\n    }\n\n    public static class UpdateCapsHandler implements IMessageHandler<MessageUpdateCap, IMessage> {\n        @Override\n        public IMessage onMessage( final MessageUpdateCap message, final MessageContext ctx) {\n            IThreadListener mainThread = (ctx.side.isClient())? Minecraft.getMinecraft() : (WorldServer) ctx.getServerHandler().playerEntity.worldObj;\n            mainThread.addScheduledTask(new Runnable() {\n                @Override\n                public void run() {\n                    CapProvider.get(Minecraft.getMinecraft().thePlayer).loadNBTData(message.props);\n                }\n            });\n            return null;\n        }\n    }\n}复制代码\n在CommonProxy注册你的MessageUpdateCap。\npublic static SimpleNetworkWrapper network;\npublic void preInit(FMLPreInitializationEvent event) {\n        CapabilityManager.INSTANCE.register(IManaCapability.class, CapStorage.capStorge, ManaCapability.class);\n        registerMessenger();\n}\nprotected void registerMessenger() {\n        int messageCount = 0;\n        network = NetworkRegistry.INSTANCE.newSimpleChannel(\"neptunia_messenger\");\n        network.registerMessage(MessageUpdateCap.UpdateCapsHandler.class, MessageUpdateCap.class, messageCount++, Side.CLIENT);\n}复制代码\n再在IManaCapability中添加dataChanged方法同步S/C数据。\nvoid dataChanged(EntityPlayer player)复制代码\n在ManaCapability中导入方法。\n@Override\n    public void dataChanged(EntityPlayer player) {\n        if(player != null){\n            CommonProxy.network.sendTo(new MessageUpdateCap(saveNBTData()), (EntityPlayerMP) player);\n        }\n    }复制代码\n这一步，你已经可以同步数据了。\n\n五、事件中注册Capability\n注意！你必须需要分别在PlayerEvent.Clone、AttachCapabilitiesEvent.Entity、EntityJoinWorldEvent这三个事件中使用Capability，否则无效！\n在你的事件中添加。\n@SubscribeEvent\n    public void onClonePlayer(PlayerEvent.Clone event) {\n        if(event.wasDeath) {\n            CapProvider.get(event.entityPlayer).loadNBTData(CapProvider.get(event.original).saveNBTData());\n            CapProvider.get(event.entityPlayer).dataChanged(event.entityPlayer);\n        }\n    }\n\n    @SubscribeEvent\n    public void entityJoinWorld(EntityJoinWorldEvent event) {\n        if (event.entity instanceof EntityPlayer && !event.entity.worldObj.isRemote) {\n            CapProvider.get((EntityPlayer) event.entity).dataChanged((EntityPlayer) event.entity);\n        }\n    }\n\n    @SubscribeEvent\n    public void AttachCapability(AttachCapabilitiesEvent.Entity event)\n    {\n        if(!event.getEntity().hasCapability(CapProvider.MANA_CAP, null) && event.getEntity() instanceof EntityPlayer)\n            event.addCapability(new ResourceLocation(\"mana_epp\"), new CapProvider(new ManaCapability()));\n    }复制代码\n\n最后，你已经可以随心所欲地运用Capability了，只需要几行代码\nCapProvider.get(EntityPlayer player).getMana(); //获取Mana\n\nCapProvider.get(EntityPlayerMP player).setMana(int newMana); \nCapProvider.dataChanged(EntityPlayerMP player); //设置Mana，注意，必须是EntityPlayerMP，否则修改的只是客户端数据！复制代码\n\n后序：\n总算是把这篇教程肝出来了，想起来前几个月@ustc_zzzz 还有Mickey都说要把这篇坑出来，然后……然后他们俩没后续了=A =。当时还在用IEEP的我还没怎么习惯Capability，结果还是Capability好用，就分享一下经验。",
    "replies": [
        {
            "author": "907154475",
            "timestamp": 1465992540,
            "txt_content": "沙发    支持楼主"
        },
        {
            "author": "饕餮魍魉枭蹀躞",
            "timestamp": 1466134800,
            "txt_content": "1.7.10党已经哭瞎。\nIEEP绝对是最坑爹的东西"
        },
        {
            "author": "zkm00323",
            "timestamp": 1485939120,
            "txt_content": "CapProvider.get(EntityPlayerMP player).dataChanged(EntityPlayerMP player);"
        },
        {
            "author": "ac139178",
            "timestamp": 1498113420,
            "txt_content": "zkm00323 发表于 2017-2-1 16:52\nCapProvider.get(EntityPlayerMP player).dataChanged(EntityPlayerMP player);\nforge会在世界关闭时保存玩家的capability嘛？还是说需要我们手动创建一个配置文件为每个玩家保存属性？"
        },
        {
            "author": "zkm00323",
            "timestamp": 1498214640,
            "txt_content": "ac139178 发表于 2017-6-22 14:37\nforge会在世界关闭时保存玩家的capability嘛？还是说需要我们手动创建一个配置文件为每个玩家保存属性？ ...\n自动保存的"
        }
    ]
}