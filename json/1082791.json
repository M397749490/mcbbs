{
    "title": "PVPIN教程RL--NMS中的NBT数据读写",
    "author": "William_Shi",
    "replyCount": 1,
    "timestamp": 1595256960,
    "txt_content": "本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\nNMS（或者说Minecraft源码）中相关于某个实体对象的全部NBT数据的保存方式是什么？\n\n写NBT数据时，方法一般叫做save\n读NBT数据是，方法一般叫做load\n\n但是注意了：\nNMS中不是某个对象的全部数据就直接运用同一个NBTTagCompound去存储的\n如果你们期待一个这样的方法\n\npublic void load(NBTTagCompound nbt){\n        this.nbt = nbt;\n}\n复制代码\n那你们一定会失望的。。。\n因为在NMS的类当中，所有的属性都是分开存储的，也就是比如说NBT记录了实体的UUID和实体的位置坐标，那么实体类一定有两个实例变量，一个是UUID，一个是坐标，并不会把一堆数据放在一起\n而当你调用了save方法的时候，他会把数据拼凑在一起，如\n\npublic void save(NBTTagCompound nbt){\n        nbt.setFloat(\"Health\",this.health);\n        //不是真实的NMS代码，这是一个提炼出来的逻辑，假想了有一个设置血量的操作\n}\n复制代码\n当你有一堆这样的代码之后，你就可以拼凑出一个完整的NBT了\n比如说UUID、坐标、血量、装甲等等等等\n\n那么我们继续思考，\n血量、坐标等等这些，全都是一类实体所共有的属性\n那么此时，逻辑就抽离出来了\nNMS中，把这些NBT的保存都写在了接口里\n或者说，接口代表了一类 类的公有属性，那么显然就可以保存那些公有的属性\n所以NMS当中对NBT数据保存的另外一个重要特点就是：逐级保存\n也就是说，在保存了某个接口所特有的属性（比如说，可以长大的生物就要保存年龄）\n之后，会调用其super方法，再进行NBT保存（比如说，可以长大的生物一定是Insentient生物，那么此时，调用super的同名方法，就会保存Insentient生物的公有属性：有盔甲栏，也就是进行盔甲、手持物品的保存）\n这样子逐级调用（往往会调用很多次），就可以一点一点拼凑出完整的NBT了\n\n比如说海龟\n\n注：以上为MCP的反混淆，可自行查看NMS中的EntityTurtle类\n这个类是怎么写NBT数据的？\n当我们调用writeAdditional方法时，做了这么几件事\n注：把这个看作是save方法，它的notch名叫做b，也就是你们反编译nms得到的方法名\n\n\n  public void b(NBTTagCompound nbttagcompound) {\n    super.b(nbttagcompound);\n    nbttagcompound.setInt(\"HomePosX\", es().getX());\n    nbttagcompound.setInt(\"HomePosY\", es().getY());\n    nbttagcompound.setInt(\"HomePosZ\", es().getZ());\n    nbttagcompound.setBoolean(\"HasEgg\", eq());\n    nbttagcompound.setInt(\"TravelPosX\", et().getX());\n    nbttagcompound.setInt(\"TravelPosY\", et().getY());\n    nbttagcompound.setInt(\"TravelPosZ\", et().getZ());\n  }\n复制代码\n注：这些属性对应的意义参见\nhttps://wiki.biligame.com/mc/%E6 ... 0.E6.8D.AE.E5.80.BC\n\n它的父类是EntityAnimal，\n\n  public void b(NBTTagCompound nbttagcompound) {\n    super.b(nbttagcompound);\n    nbttagcompound.setInt(\"InLove\", this.loveTicks);\n    if (this.breedCause != null)\n      nbttagcompound.a(\"LoveCause\", this.breedCause); \n  }\n复制代码\n注：这些属性对应的意义参见\nhttps://wiki.biligame.com/mc/%E6 ... 0.E6.8D.AE.E5.80.BC\n\"可繁殖生物额外字段\"\n\nEntityAnimal的父类是EntityAgeable\n\n  public void b(NBTTagCompound nbttagcompound) {\n    super.b(nbttagcompound);\n    nbttagcompound.setInt(\"Age\", getAge());\n    nbttagcompound.setInt(\"ForcedAge\", this.c);\n    nbttagcompound.setBoolean(\"AgeLocked\", this.ageLocked);\n  }\n复制代码\n注：这些属性对应的意义参见\nhttps://wiki.biligame.com/mc/%E6 ... 0.E6.8D.AE.E5.80.BC\n\"可繁殖生物额外字段\"\n刚刚的Ageable和Animal加起来相当于是“可繁殖生物”\n\nEntityAnimal的父类是EntityInsentient\n\n\n  public void b(NBTTagCompound nbttagcompound) {\n    super.b(nbttagcompound);\n    nbttagcompound.setBoolean(\"CanPickUpLoot\", canPickupLoot());\n    nbttagcompound.setBoolean(\"PersistenceRequired\", this.persistent);\n    NBTTagList nbttaglist = new NBTTagList();\n    for (Iterator<ItemStack> iterator = this.by.iterator(); iterator.hasNext(); nbttaglist.add(nbttagcompound1)) {\n      ItemStack itemstack = iterator.next();\n      NBTTagCompound nbttagcompound1 = new NBTTagCompound();\n      if (!itemstack.isEmpty())\n        itemstack.save(nbttagcompound1); \n    } \n    nbttagcompound.set(\"ArmorItems\", nbttaglist);\n    NBTTagList nbttaglist1 = new NBTTagList();\n    for (Iterator<ItemStack> iterator1 = this.bx.iterator(); iterator1.hasNext(); nbttaglist1.add(nbttagcompound2)) {\n      ItemStack itemstack1 = iterator1.next();\n      NBTTagCompound nbttagcompound2 = new NBTTagCompound();\n      if (!itemstack1.isEmpty())\n        itemstack1.save(nbttagcompound2); \n    } \n    nbttagcompound.set(\"HandItems\", nbttaglist1);\n    NBTTagList nbttaglist2 = new NBTTagList();\n    float[] afloat = this.dropChanceArmor;\n    int i = afloat.length;\n    int j;\n    for (j = 0; j < i; j++) {\n      float f = afloat[j];\n      nbttaglist2.add(NBTTagFloat.a(f));\n    } \n    nbttagcompound.set(\"ArmorDropChances\", nbttaglist2);\n    NBTTagList nbttaglist3 = new NBTTagList();\n    float[] afloat1 = this.dropChanceHand;\n    j = afloat1.length;\n    for (int k = 0; k < j; k++) {\n      float f1 = afloat1[k];\n      nbttaglist3.add(NBTTagFloat.a(f1));\n    } \n    nbttagcompound.set(\"HandDropChances\", nbttaglist3);\n    if (this.leashHolder != null) {\n      NBTTagCompound nbttagcompound2 = new NBTTagCompound();\n      if (this.leashHolder instanceof EntityLiving) {\n        UUID uuid = this.leashHolder.getUniqueID();\n        nbttagcompound2.a(\"UUID\", uuid);\n      } else if (this.leashHolder instanceof EntityHanging) {\n        BlockPosition blockposition = ((EntityHanging)this.leashHolder).getBlockPosition();\n        nbttagcompound2.setInt(\"X\", blockposition.getX());\n        nbttagcompound2.setInt(\"Y\", blockposition.getY());\n        nbttagcompound2.setInt(\"Z\", blockposition.getZ());\n      } \n      nbttagcompound.set(\"Leash\", nbttagcompound2);\n    } else if (this.bG != null) {\n      nbttagcompound.set(\"Leash\", this.bG.clone());\n    } \n    nbttagcompound.setBoolean(\"LeftHanded\", isLeftHanded());\n    if (this.lootTableKey != null) {\n      nbttagcompound.setString(\"DeathLootTable\", this.lootTableKey.toString());\n      if (this.lootTableSeed != 0L)\n        nbttagcompound.setLong(\"DeathLootTableSeed\", this.lootTableSeed); \n    } \n    if (isNoAI())\n      nbttagcompound.setBoolean(\"NoAI\", isNoAI()); \n  }\n  \n复制代码\n\nEntityInsentient的父类是EntityLiving\n\n  public void b(NBTTagCompound nbttagcompound) {\n    nbttagcompound.setFloat(\"Health\", getHealth());\n    nbttagcompound.setShort(\"HurtTime\", (short)this.hurtTicks);\n    nbttagcompound.setInt(\"HurtByTimestamp\", this.hurtTimestamp);\n    nbttagcompound.setShort(\"DeathTime\", (short)this.deathTicks);\n    nbttagcompound.setFloat(\"AbsorptionAmount\", getAbsorptionHearts());\n    nbttagcompound.set(\"Attributes\", GenericAttributes.a(getAttributeMap()));\n    if (!this.effects.isEmpty()) {\n      NBTTagList nbttaglist = new NBTTagList();\n      Iterator<MobEffect> iterator = this.effects.values().iterator();\n      while (iterator.hasNext()) {\n        MobEffect mobeffect = iterator.next();\n        nbttaglist.add(mobeffect.a(new NBTTagCompound()));\n      } \n      nbttagcompound.set(\"ActiveEffects\", nbttaglist);\n    } \n    nbttagcompound.setBoolean(\"FallFlying\", isGliding());\n    getBedPosition().ifPresent(blockposition -> {\n          paramNBTTagCompound.setInt(\"SleepingX\", blockposition.getX());\n          paramNBTTagCompound.setInt(\"SleepingY\", blockposition.getY());\n          paramNBTTagCompound.setInt(\"SleepingZ\", blockposition.getZ());\n        });\n    nbttagcompound.set(\"Brain\", this.bo.<NBTBase>a(DynamicOpsNBT.a));\n  }\n  复制代码\n上述两个接口加起来拼出了“生物共同标签”\n\n上述均为实体NBT的一个小小的例子展示\n而物品NBT就简单很多，原因？\n原因就在于物品没有那么复杂的继承关系，属性也较少\n所以只需要记录下id、数量，之后就直接保存自定义NBT\n\n  public NBTTagCompound save(NBTTagCompound nbttagcompound) {\n    MinecraftKey minecraftkey = IRegistry.ITEM.getKey(getItem());\n    nbttagcompound.setString(\"id\", (minecraftkey == null) ? \"minecraft:air\" : minecraftkey.toString());\n    nbttagcompound.setByte(\"Count\", (byte)this.count);\n    if (this.tag != null)\n      nbttagcompound.set(\"tag\", this.tag.clone()); \n    return nbttagcompound;\n  }\n复制代码\n读到这里，我相信读者都理解了NBT的存储操作了\n至于NBT的读取，我相信读者已经有这个能力去探究的\n\n那么这里，我埋下一个伏笔：\n有没有发现，物品NBT留出了一个“tag”数据键，存放自定义NBT数据？\n而实体，没有。换句话说无法直接给实体存储自定义的NBT数据键值对，就算写在NBT数据包里面了，照样无法被load进实体（这些接口在读取的时候也只会读取对应的NBT数据键）\n该怎么做？",
    "replies": [
        {
            "author": "啦啦啦....",
            "timestamp": 1595259900,
            "txt_content": "11111111"
        }
    ]
}