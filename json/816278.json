{
    "title": "关于注册表判断JAVA信息的最优解",
    "author": "nsisogf",
    "replyCount": 2,
    "timestamp": 1534902600,
    "txt_content": "在以前的贴中（http://www.mcbbs.net/thread-704797-1-1.html）\n我曾以注册表+命令行的方法获取java位数，版本信息\n但事实是这种方式是效率及其低，并且最不稳定的方式\n一旦返回的内容修改，那么这种方法需要重新进行修改进行匹配\n\n先略谈下JAVA注册表机制（以JRE进行说明，JDK略特殊不进行说明）\n在安装JAVA后，JAVA会在注册表中写入相关信息\n节点位于\nLOCALMACHINE\n |-SOFTWARE\n    |-JavaSoft\n        |-Java Runtime Environment(新版本为JRE)\n在此节点中，所有子节点的名称即为一个JRE的版本\n但是我个人发现，安装一个版本会写入两个子节点，比如1.8和1.8.x.xx，应该取最长的那个作为版本号\n所以判断字符串的长度是否大于3即可\n\n接下来进入该子节点，获取其中JavaHome的值，既是JRE主路径\n但是由于启动mc需要的是可执行文件路径，所以在后面加上\\bin\\javaw.exe即可\n\n关键是，如何获取位数？\n这个需要你们动动脑筋咯\n先整理下逻辑，x86平台上只能装x86的JAVA，所以在x86系统上无论查找到什么JAVA，都应该是x86的\nx64平台上有两种可能，一种是32位的，另一种是64位的\n在64位系统上，注册表有这么一个机制\n在默认视图下，SOFTWARE里面还有一个Wow6432Node节点\n这个节点是供64位操作表中提供对32位注册表的支持\n也就是说64位注册表中32位应用写入的注册表在这个节点中\n所以我们就很灵活的能在64位平台上判断JAVA位数了\n\n接下来提供C#代码\n先定义JAVA信息类\npublic class Java\n    {\n        /// <summary>\n        /// JAVA路径\n        /// </summary>\n        public string Path { get; private set; }\n\n        /// <summary>\n        /// JAVA版本\n        /// </summary>\n        public string Version { get; private set; }\n\n        /// <summary>\n        /// java位数\n        /// </summary>\n        public ArchEnum Arch { get; private set; }\n\n        public Java(string path, string version, ArchEnum arch)\n        {\n            this.Path = path;\n            this.Version = version;\n            this.Arch = arch;\n        }复制代码\n\nSOFTWARE节点下操作方法：\npublic static Dictionary<string,string> GetJavaRegisterPath(RegistryKey key)\n        {\n            Dictionary<string, string> jres = new Dictionary<string, string>();\n\n            var oldKey = key?.OpenSubKey(\"JavaSoft\")?.OpenSubKey(\"Java Runtime Environment\");\n            var newKey = key?.OpenSubKey(\"JavaSoft\")?.OpenSubKey(\"JRE\");\n\n            //oldJre\n            if (oldKey != null)\n            {\n                foreach (var verStr in oldKey.GetSubKeyNames())\n                {\n                    if (verStr.Length > 3)\n                    {\n                        string path = oldKey.OpenSubKey(verStr).GetValue(\"JavaHome\")?.ToString() + @\"\\bin\\javaw.exe\";\n                        if (File.Exists(path))\n                        {\n                            jres.Add(verStr, path);\n                        }\n                    }\n                }\n            }\n\n            //newJre\n            if (newKey != null)\n            {\n                foreach (var verStr in newKey.GetSubKeyNames())\n                {\n                    if (verStr.Length > 3)\n                    {\n                        string path = newKey.OpenSubKey(verStr).GetValue(\"JavaHome\")?.ToString() + @\"\\bin\\javaw.exe\";\n                        if (File.Exists(path))\n                        {\n                            jres.Add(verStr, path);\n                        }\n                    }\n                }\n            }\n\n            return jres;\n        }复制代码\n\n全局方法：\n/// <summary>\n        /// 从注册表寻找本机JAVA列表\n        /// </summary>\n        /// <returns></returns>\n        public static List<Java> GetJavaList()\n        {\n            List<Java> javas = new List<Java>();\n            RegistryKey localMachine = Registry.LocalMachine.OpenSubKey(\"SOFTWARE\");\n            switch (SystemTools.GetSystemArch())\n            {\n                case ArchEnum.x32:\n                    var jres = GetJavaRegisterPath(localMachine);\n                    javas.AddRange(jres.Select(x => new Java(x.Value, x.Key, ArchEnum.x32)));\n                    break;\n\n                case ArchEnum.x64:\n                    var jres64 = GetJavaRegisterPath(localMachine);\n                    javas.AddRange(jres64.Select(x => new Java(x.Value, x.Key, ArchEnum.x64)));\n                    var jres32 = GetJavaRegisterPath(localMachine.OpenSubKey(\"Wow6432Node\"));\n                    javas.AddRange(jres32.Select(x => new Java(x.Value, x.Key, ArchEnum.x32)));\n                    break;\n            }\n            return javas;\n        }复制代码\n",
    "replies": [
        {
            "author": "。—。",
            "timestamp": 1534904340,
            "txt_content": "Oracle应该把写过的注册表项整理出一个文档来的……"
        },
        {
            "author": "gamerteam",
            "timestamp": 1534910340,
            "txt_content": "然后遇到绿色版的Java……完蛋\n如果你要允许用户自己自定义Java位置的话，我还是建议写一个Java程序进行检测，而且这个效率也低不到哪里去（我就不信他电脑装几十个Java！哼唧！）"
        }
    ]
}