{
    "title": "初步实现小木斧功能 2 简易平面内的点径画圆与三点画圆",
    "author": "qaz1-qaz1-",
    "replyCount": 3,
    "timestamp": 1550381340,
    "txt_content": "引言\n经过我内心百感交集后，我还是觉得把这个东西继续做下去，毕竟，做这个东西，我的原因有下：\n可以避免很次的输入fill指令时的记坐标 - 查方块，这一不直观的过程，改为比较直观的用准心选择坐标、方块做这个东西真的让我学到了很多，也锻炼了我的思维万一以后有用呢？\n此外，这个东西还会支持（？）一些一个/fill命令无法得到的却比较常用的东西，就比如说画圆\n效果\n过三点的圆↑\n\n基本圆↑\n功能实现\n接下来，我就来说明下这些功能是怎么实现的，这次主要实现了两个功能：两点画圆与三点画圆（当然，在命令中，要用到3、4个定位点）\n两点画圆（圆规画圆）\n\n首先，先说一下两点画圆就是类似于圆规画圆的方式，简单说有以下步骤\n获得圆心获得半径获得每次旋转角度旋转圆心，在前方半径长度处放方块，并不断重复此步骤直到画圆完成。\n这里说明一下迭代获得半径与获得每次旋转角度，与迭代。\n迭代获得半径\n接下来，我们认为圆心是第二个定位点，”圆规的笔尖“是第三个定位点，\n首先，在圆心处创建一个盔甲架，并将其指向“笔尖”；初始化记分板中的#r变量，来保存半径；\n接下来，调用一个自循环的函数，每一次循环都这样做：让盔甲架向“笔尖”迈0.5格，并将#r +50，直到盔甲架与“笔尖”重合（距离小于0.5）。\n这样我们就通过迭代获得了圆的半径。\n命令贴在下方：\n#@s 指临时盔甲架\n#@e[tag=tool_belong,scores={tool_selector=3},limit=1] 指笔尖\n#传送\ntp @s ^ ^ ^0.5\n#记分板设置\nscoreboard players add #r tool_calc 50\n#再循环\nexecute as @s at @s unless entity @e[tag=tool_belong,scores={tool_selector=3},limit=1,distance=..0.5] run function tool:circle/loop_get_r\n复制代码获得每次旋转角度说白了就是下面这一个公式：\n(2r*3.14)/360\n但是为了更加的精确，每次旋转可能还要除以2或4，这样就得到了每次旋转角度。\n迭代画圆\n画圆的实现是一个双层循环：外层旋转中心，内层将笔尖移到半径处，具体如下动图：语文不好，动图来凑\n\n再看一看命令：外层循环\n#定义还剩的 半径\nscoreboard players operation #r_left tool_calc = #r tool_calc\n#调整角度，并重置位置\nexecute at @e[tag=tool_circle_center,limit=1] run tp @s ~ ~ ~ ~ ~\n#调用循环\nexecute at @s as @s run function tool:arc/loop_to_r\n#复制\nfunction tool:clone/clone\n\n#旋转\n\n#获得旋转\nscoreboard players operation #rotation_left tool_calc -= #rd tool_calc\n#写入\nexecute store result entity @e[tag=tool_circle_center,limit=1] Rotation[0] float 0.01 run scoreboard players get #rotation_left tool_calc\n\n#循环\nexecute if score #rotation_left tool_calc matches 0.. as @s at @s run function tool:arc/loop_cw复制代码内层循环#传送\ntp @s ^ ^ ^0.5\n#减积分\nscoreboard players remove #r_left tool_calc 50\n#循环\nexecute unless score #r_left tool_calc matches ..0 as @s at @s run function tool:arc/loop_to_r复制代码再来一点细节：这里有两个变量来控制循环，一个是 #r_left ，指还剩多少距离，另一个是 #rotation_left，指还剩多少角度。\n好了，这一整个画圆的过程基本讲完了\n\n三点画圆\n三点画圆最重要的就是算，死命的算，我用了标准的作三角形的外接圆来模拟这一过程，具体如下：\n三点间任意连两条直线,在这两条线的中点各画一条垂直线,将两条垂直线延伸,交点即圆心,圆心与任意一点相连为半径.\n然后用到了以下三个公式来计算圆心：\n求过两点的直线（只需要斜率）求两点的垂直平分线求两线的交点\n这里就不再赘述了。但是mc的积分版只能接受整数，且Java Int 最大值为 2 ^ 31 - 1 = 2147483647 如果运算时精确到三位小数的话（运算中有二次多项式）那么传入坐标的x、z最大只能到 ±2147，这太小了，但是如果精确数太小的话就会让圆心偏离很多，所以这里折中取了两位，坐标可以到 ±214748 这里，应该是够用了。（计算足足有 61 次），获得圆心后正常画圆就好了。\n\n其他\n首先，61次运算实在难看，希望您能给一点办法来优化一下，还有画出来的圆实在有点难看，这个可以减小获得半径与画圆时的步长来解决。\n其实一开始我真的拒绝用视线追踪的，但是简单用了之后，哇，速度真的很快，声音真的很轻，生成的潜影贝都是 buling buling 的，每天带着小钓竿去测试......\n嗯，真香，此外，染色功能也用上去了。\n怕再使用中出现什么意外的东西，这次直接加了一个函数，用来复位\n部分函数有改动，请在游戏中用 ./function tool:commands/help 查看文件在https://pan.baidu.com/s/12lK-RU8qMDQ6LvVXcasveg,无提取码安装在我的之前的贴子中查看：http://www.mcbbs.net/thread-844698-1-1.html\n\n\n\n",
    "replies": [
        {
            "author": "(=°ω°)丿",
            "timestamp": 1550383800,
            "txt_content": "画圆这个问题我在问答版提过：\n二维：http://www.mcbbs.net/thread-841681-1-1.html\n三维：http://www.mcbbs.net/thread-840985-1-1.html\n圆太难画了\n我也正在想有什么好办法……"
        },
        {
            "author": "ATWY",
            "timestamp": 1582009440,
            "txt_content": "感谢楼主分享！！！"
        },
        {
            "author": "童年丶TK",
            "timestamp": 1582016460,
            "txt_content": "666666666666666666666666666666666"
        }
    ]
}