{
    "title": "NOI练习笔记#1",
    "author": "穆思成",
    "replyCount": 1,
    "timestamp": 1593744600,
    "txt_content": " 本帖最后由 穆思成 于 2020-7-3 10:55 编辑 \n\n题目来源\nhttps://www.luogu.com.cn/problem/P2670\n\n题目描述扫雷游戏是一款十分经典的单机小游戏。在nn行mm列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。现在给出nn行mm列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。\n输入格式第一行是用一个空格隔开的两个整数nn和mm，分别表示雷区的行数和列数。接下来nn行，每行mm个字符，描述了雷区中的地雷分布情况。字符’*’表示相应格子是地雷格，字符’?’表示相应格子是非地雷格。相邻字符之间无分隔符。\n输出格式输出文件包含nn行，每行mm个字符，描述整个雷区。用’*’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。\n输入输出样例输入 #1\n3 3\n*??\n???\n?*?输出 #1\n*10\n221\n1*1\n\n输入 #22 3\n?*?\n*??\n输出 #2\n2*1\n*21\n\n说明/提示对于100%的数据，1≤n≤100，1≤m≤100。\n 我的题解#include <iostream>\n\nusing namespace std;\n\nbool itrans();\n\nint main()\n{\n        int n, m, count = 0;\n        cin >> n >> m;\n        bool** in = new bool* [n];\n        char** out = new char* [n];\n        for (int i = 0; i < n; i++)\n        {\n                in[i] = new bool[m];\n                out[i] = new char[m];\n                for (int j = 0; j < m; j++)\n                {\n                        in[i][j] = itrans();\n                        if (in[i][j] == 1)\n                        {\n                                out[i][j] = '*';\n                        }\n                }\n        }\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = 0; j < m; j++)\n                {\n                        if (in[i][j] == 0)\n                        {\n                                if (i >= 1)\n                                {\n                                        if (in[i - 1][j] == 1)\n                                        {\n                                                count++;\n                                        }\n                                        if (j >= 1)\n                                        {\n                                                if (in[i - 1][j - 1] == 1)\n                                                {\n                                                        count++;\n                                                }\n                                        }\n                                        if (j <= m - 2)\n                                        {\n                                                if (in[i - 1][j + 1] == 1)\n                                                {\n                                                        count++;\n                                                }\n                                        }\n                                }\n                                if (i <= n - 2)\n                                {\n                                        if (in[i + 1][j] == 1)\n                                        {\n                                                count++;\n                                        }\n                                        if (j >= 1)\n                                        {\n                                                if (in[i + 1][j - 1] == 1)\n                                                {\n                                                        count++;\n                                                }\n                                        }\n                                        if (j <= m - 2)\n                                        {\n                                                if (in[i + 1][j + 1] == 1)\n                                                {\n                                                        count++;\n                                                }\n                                        }\n                                }\n                                if (j >= 1)\n                                {\n                                        if (in[i][j - 1] == 1)\n                                        {\n                                                count++;\n                                        }\n                                }\n                                if (j <= m - 2)\n                                {\n                                        if (in[i][j + 1] == 1)\n                                        {\n                                                count++;\n                                        }\n                                }\n                                out[i][j] = count + '0';\n                                count = 0;\n                        }\n                }\n        }\n        for (int i = 0; i < n; i++)\n        {\n                for (int j = 0; j < m; j++)\n                {\n                        cout << out[i][j];\n                }\n                cout << endl;\n                delete[] in[i];\n                delete[] out[i];\n        }\n        return 0;\n}\n\nbool itrans()\n{\n        char c;\n        cin >> c;\n        switch(c)\n        {\n        case '*':\n                return 1;\n        case '?':\n                return 0;\n        }\n}复制代码优化题解#include<bits/stdc++.h>\nusing namespace std;\nbool a[105][105];//一张地图，有雷为一，无雷为零 \nint main()\n{\n    memset(a,0,sizeof(a));//地图最开始清空 \n    int n,m;\n    char tmp;\n    cin>>n>>m; \n    for(int i=1;i<=n;i++)//读入地图 \n    {\n        for(int j=1;j<=m;j++) \n        {\n            cin>>tmp;//读入每一个点 \n            if(tmp=='*') a[i][j]=1;//如果是地雷就将这个点设为一 \n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(a[i][j]==1) printf(\"*\"); //如果是地雷不用输出数字 \n            else\n            {\n                printf(\"%d\",a[i+1][j+1]+a[i+1][j-1]+a[i+1][j]+a[i][j+1]+a[i][j-1]+a[i-1][j+1]+a[i-1][j]+a[i-1][j-1]);\n                //将旁边的雷加起来输出 \n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;//愉快的结束了主程序 \n}复制代码THE END\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "wenlonglong",
            "timestamp": 1593755280,
            "txt_content": "MCBBS有你更精彩~"
        }
    ]
}