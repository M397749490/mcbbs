{
    "title": "[已解决]两个类的死锁问题",
    "author": "夏雨吖",
    "replyCount": 9,
    "timestamp": 1581757620,
    "txt_content": " 本帖最后由 M8_mve 于 2020-2-16 23:45 编辑 \n\n在父类的静态构造里引用子类的静态变量IDEA警告说在会导致类加载死锁\n\n\n\n\n-1.png (31.73 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-15 17:02 上传\n\n\n\n\n\n试了一下真的锁了...\n\n\n\n\n0.png (268.62 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-15 17:04 上传\n\n\n\n\n\n\n\n\n\n1.png (121.77 KB, 下载次数: 3)\n\n下载附件\n\n2020-2-15 17:04 上传\n\n\n\n\n\n\n百度好像没有关于父类静态构造引用子类静态变量的...\n\n",
    "replies": [
        {
            "author": "耗子",
            "timestamp": 1581764700,
            "txt_content": " 本帖最后由 耗子 于 2020-2-15 19:13 编辑 \n\n那你这个类层次结构设计得好棒棒哦。为什么不把子类的常量提升到父类去，既然你都在父类要使用这个常量，那说明这个常量应该是归父类管而不是子类管。\n类比一下就是孙子没有生出来爷爷就在花孙子长大后赚的钱（超 前 消 费），恁就是顶级架构师？"
        },
        {
            "author": "夏雨吖",
            "timestamp": 1581768000,
            "txt_content": "耗子 发表于 2020-2-15 19:05\n那你这个类层次结构设计得好棒棒哦。为什么不把子类的常量提升到父类去，既然你都在父类要使用这个常量，那 ...\n我是要单例子类，又要可以从子类访问到，也要可以从父类访问到，写get方法有点掉价"
        },
        {
            "author": "耗子",
            "timestamp": 1581770400,
            "txt_content": "M8_mve 发表于 2020-2-15 20:00\n我是要单例子类，又要可以从子类访问到，也要可以从父类访问到，写get方法有点掉价 ...\n一个静态公开常量还要写什么get方法？搞了这么久你就舍不得放父类？"
        },
        {
            "author": "夏雨吖",
            "timestamp": 1581773160,
            "txt_content": "耗子 发表于 2020-2-15 20:40\n一个静态公开常量还要写什么get方法？搞了这么久你就舍不得放父类？\n是单例啊，然后在子类初始化单例的"
        },
        {
            "author": "耗子",
            "timestamp": 1581783420,
            "txt_content": "那父类既然需要访问单例子类，说明父类对于子类的某些功能有需求，应该将这部分代码提升到父类，然后将依赖关系反过来，让子类去访问父类而不是父类访问子类。你好好学学Java和设计模式吧。"
        },
        {
            "author": "轻光233",
            "timestamp": 1581828120,
            "txt_content": " 本帖最后由 轻光233 于 2020-2-16 12:45 编辑 \n\n额，看半天回复并没有明白lz的意思，应该是我设计模式还不熟吧233\n单说死锁的发生，两个线程如果是第一个先跑到sysout的话\n先会看B类有没有加载，发现没有加载就加载B类，又发现父类A没有加载就加载A类\n在A类的static代码块又调用了B类的字段，然后继续返回去看B类有没有加载\n然后在B类的static代码块跑的时候发现引用了A类的字段(此时A类实际上正在加载,但没加载完毕,所以会被判定为未加载)\n然后就会又跑回去再加载A类，之后就是一直死循环下去了\n第二个线程先跑sysout也是差不多的\n自己的一点浅显的知识，不知道是不是lz想要的答案233\n"
        },
        {
            "author": "夏雨吖",
            "timestamp": 1581850380,
            "txt_content": "轻光233 发表于 2020-2-16 12:42\n额，看半天回复并没有明白lz的意思，应该是我设计模式还不熟吧233\n单说死锁的发生，两个线程如果是第一个先 ...\n不会啊，类的字节码加载结束才会跑类的静态构造，所以在A跑静态代码块的时候A类已经加载完了"
        },
        {
            "author": "轻光233",
            "timestamp": 1581859320,
            "txt_content": " 本帖最后由 轻光233 于 2020-2-16 21:32 编辑 \nM8_mve 发表于 2020-2-16 18:53\n不会啊，类的字节码加载结束才会跑类的静态构造，所以在A跑静态代码块的时候A类已经加载完了 ...\n额，对啊，跑静态构造的时候才是类内静态字段真正开始加载的时候吧，所以这个时候其它类引用字段就会判断未加载啊"
        },
        {
            "author": "海螺螺",
            "timestamp": 1581865980,
            "txt_content": " 本帖最后由 海螺螺 于 2020-2-16 23:18 编辑 \n\npublic class Test {\n    public static void main(String[] args) {\n        new b();\n    }\n}\n\nclass a {\n    public static Object c = b.d;\n}\n\nclass b extends a {\n    public static Object d = \"\";\n}\n\n单独这样是不会锁的，因为类加载首先 defineClass，然后调用 <clinit>，已经被调用过 <clinit>的不会再次调用\n加载顺序是这样的\n\n首先加载 b 类，b 类的超类是 a\n因此最先 defineClass a\n然后 defineClass b  \n\n这个时候 c d 都是 null\nmain 里调用的是 b，因此调用 b 的 <clinit>\nb需要a，所以调用 a 的 <clinit>\n调用 a.c = b.d，b.d 这时候是 null，因为 b 的 <clinit> 还没跑\n然后 a <clinit>返回，b <clinit> 开始跑，b.d = \"\"\n\n两个线程会锁，因为类加载(<clinit>)是要上锁的，著名的静态内部类单例模式就是基于类加载要上锁实现的\n两个线程同时加载两个类，两个线程各自拥有自己类的锁，因此会死锁\n也只有两个线程加载这两个类的各一个会锁\n\n\n\n"
        }
    ]
}