{
    "title": "1.13 排序函数模板分享",
    "author": "Sairos",
    "replyCount": 3,
    "timestamp": 1549804500,
    "txt_content": " 本帖最后由 Sairos 于 2019-2-10 21:15 编辑 \n\n       因为某些原因要用排序相关内容，所以就网上找看看有没有现成的function供自己使用...或许是因为太匆忙，也或许是自己搜索方式或者关键字不对吧，没找到现成的......于是就自己写了一个作为例子或者模板分享给大家....利人利己嘛...（我确实是没搜到现成的来用，该贴实属原创无任何抄袭） \n      这里说的排序，是跟计分板相关，当然，看到这里可能会问，计分板的各个变量分数不是都已经排好了吗，还需要排什么序？而我指的是，这已经排好的顺序，改如何使用出来？比如，第一名是谁？分数多少？然后第二名？第三名？我会以此为例....\n\n\n排序有很多方法，希尔排序法，插入排序法，冒泡排序法balabalabala.....而这里我将用到类似冒泡排序的方法。\n\n\n       冒泡排序法：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。\n——360百科\n\n\n以上内容全是废话，下面开始吧：\n假设目前已有5个玩家，在一个计分板上有了不同的分数，现在要将五个玩家分数高低按名次排列并tellraw告知。\n首先，最基础的思路：\n#计分板一得到分数值\n#将计分板一的所有对应值转移到计分板二\n#将转移后的计分板最高值赋值给中间变量temp\n#对最高值执行逻辑并清除计分板二最高值\n\n这样得到的就是最高值也即第一名的相关信息\n\n进阶思路：\n一、将计分板一的所有对应值转移到计分板二\n二、统计人数计到分板三，并初始化计分板四（名次）\n三、将转移后的计分板最高值赋值给中间变量temp\n四、计分板四名次增加,对最高值执行逻辑，清除计分板二的最高值\n五、进行第二最高值执行逻辑(也即重复上述步骤)，直到计分板四的值大于计分板三的值，结束逻辑\n\n       这看起来好像很复杂的样子，又是转移计分板值又是中间变量，要死了啊！\n来看代码一一详解：\n用到的计分板如下：\n/scoreboard objectives add paixu dummy\n/scoreboard objectives add paixu1 dummy\n/scoreboard objectives add count dummy\n/scoreboard objectives add count1 dummy复制代码玩家和分数：\nexecute if entity @a[tag=gg] unless entity @e[tag=paixu] run tag @a remove gg\nexecute as @a[tag=!gg] at @s run scoreboard players set mingci count1 0\nexecute as @a[tag=!gg] at @s run summon minecraft:armor_stand ~-2 ~1 ~ {Invisible:0b,CustomNameVisible:1b,CustomName:\"1\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"paixu\"]}\nexecute as @a[tag=!gg] at @s run summon minecraft:armor_stand ~-1 ~1 ~ {Invisible:0b,CustomNameVisible:1b,CustomName:\"2\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"paixu\"]}\nexecute as @a[tag=!gg] at @s run summon minecraft:armor_stand ~ ~1 ~ {Invisible:0b,CustomNameVisible:1b,CustomName:\"3\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"paixu\"]}\nexecute as @a[tag=!gg] at @s run summon minecraft:armor_stand ~1 ~1 ~ {Invisible:0b,CustomNameVisible:1b,CustomName:\"4\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"paixu\"]}\nexecute as @a[tag=!gg] at @s run summon minecraft:armor_stand ~2 ~1 ~ {Invisible:0b,CustomNameVisible:1b,CustomName:\"5\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"paixu\"]}\nexecute as @a[tag=!gg] at @s run scoreboard players set @e[name=5] paixu 6\nexecute as @a[tag=!gg] at @s run scoreboard players set @e[name=4] paixu 8\nexecute as @a[tag=!gg] at @s run scoreboard players set @e[name=3] paixu 4\nexecute as @a[tag=!gg] at @s run scoreboard players set @e[name=2] paixu 12\nexecute as @a[tag=!gg] at @s run scoreboard players set @e[name=1] paixu 16复制代码首先我召唤五个盔甲架实体来当做是五个玩家，并分别给五个盔甲架命名12345和不同的计分板值，第一条和最后一条tag指令是因为后面有递归方法，使用tag避免重复召唤。temp是中间变量\n\nexecute as @e[tag=paixu,tag=!complete] at @s run scoreboard players operation @s paixu1 = @s paixu复制代码这条指令就是将计分板一的所有值转移到计分板二来做排序计算，其实转移不转移都无所谓的，只用计分板一也是完全可以，只因为每排一个名次就会删掉当前最高值，如果只用一个计分板，对于一个及时性的竞技小游戏，打一场算一场还行，但是如果是生存这样的呢？玩家的计分板值不断累加并且每天统计排名一次，你把别人的分数说删就删了岂不气死？\n\nexecute store result score zongshu count if entity @e[tag=paixu]复制代码这条指令是利用计分板三来统计玩家总数（在这里是盔甲架）\n\nscoreboard players operation temp paixu1 > @e[tag=paixu] paixu1复制代码这里，冒泡开始，中间变量temp会和12345盔甲架的值逐一比较，最终会得到盔甲架的最大值,如图：\n\n\n\n\n\nfile_1549804241000.jpg (239.89 KB, 下载次数: 0)\n\n下载附件\n\n2019-2-10 21:10 上传\n\n\n\n\n\n\nscoreboard players add mingci count1 1\nexecute as @e[tag=paixu] if score @s paixu1 = temp paixu1 run tellraw @a [\"\\u00a76第 \\u00a74\",{\"score\":{\"objective\":\"count1\",\"name\":\"mingci\"}},\" 名是\",{\"selector\":\"@s\"},\" \\u00a76,\\u00a7b他的分数为:\\u00a73\",{\"score\":{\"objective\":\"paixu1\",\"name\":\"temp\"}}]\nexecute as @e[tag=paixu] if score @s paixu1 = temp paixu1 at @s run tag @s add complete\nexecute as @e[tag=paixu] at @s if score @s paixu1 = temp paixu1 run scoreboard players reset @s paixu1\n复制代码这里就是开始执行逻辑了，首先是第一名，所以计分板四名为mingci的变量值由0加到1，然后tellraw第一名所属玩家与其对应的分数，然后给该玩家加上一个complete的tag表示该玩家相关逻辑已经执行完成以避免被重复计算（也就是说第一条和第二条命令就是针对第一名的命令，这里可以修改为其他自己需要的指令）然后清除当前最高值在该计分板的记录\nexecute as @e[tag=paixu] at @s if score @s paixu1 < temp paixu1 run scoreboard players set temp paixu1 0\nexecute if score mingci count1 >= zongshu count run tag @e[tag=paixu] remove complete\n\nexecute if score mingci count1 < zongshu count run function minecraft:paixu \n\nexecute if score mingci count1 >= zongshu count run tellraw @a [{\"text\":\"点击此处删除盔甲架\",\"color\":\"dark_red\",\"bold\":false,\"italic\":false,\"underlined\":false,\"strikethrough\":false,\"obfuscated\":false,\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/kill @e[tag=paixu]\"}}]\nexecute if score mingci count1 >= zongshu count run scoreboard players set mingci count1 0复制代码最后就是重复执行该function了，每次执行完一次最高值的相关命令后temp就会初始化一次，也就是每次都会重新冒泡，因为计分板各值高低顺序是排好了的，temp直接冒上去就行了.....后面mingci和zongshu的相互比较，在这里zongshu是5，当mingci小于zongshu时执行一次function，也就是function会执行五次，也就意味着tellraw也会跟着执行五次，而每一次的内容就是每一次的当前最高值的相关内容。\n执行结果：\n\n\n\n\n\n\n2.png (148.03 KB, 下载次数: 0)\n\n下载附件\n\n2019-2-10 21:10 上传\n\n\n\n\n\n\n       总之，这个例子的命令会在附件paixu.mcfunction里面，可以当模板来使用，自己需要什么逻辑自己改相关部分就行了.....如果要测试我这个已写好的mcfunction，那就直接/function minecraft:paixu执行一次就行了。\n\n\n最后，感谢各位大佬的阅读\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npaixu.zip\n\n\n2019-2-10 21:09 上传\n点击文件名下载附件\n\n\n\n\n1.2 KB, 下载次数: 6\n\n\n\n\n\n",
    "replies": [
        {
            "author": "1139365029",
            "timestamp": 1549806360,
            "txt_content": "说到排序，我想起网上流传的一个算法，\n当宇宙的高能粒子经过内存的时候，几率改变其中的数据，\n所以算法大概是这样：\n\n"
        },
        {
            "author": "Sairos",
            "timestamp": 1549806480,
            "txt_content": "1139365029 发表于 2019-2-10 21:46\n说到排序，我想起网上流传的一个算法，\n当宇宙的高能粒子经过内存的时候，几率改变其中的数据，\n所以算法大 ...\n66666，我竟然楞了30秒才懂...2333333"
        },
        {
            "author": "ruhuasiyu",
            "timestamp": 1549808820,
            "txt_content": "把每个玩家比他分数大的玩家数存为分数，这个分数就是他的排名，从0开始，可以并列。\n\n具体，用一个函数，里面给@s一个tag,然后if entity所有玩家比他分数大的，结果存入记分板。"
        }
    ]
}