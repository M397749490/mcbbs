{
    "title": "[管理]CommandsOnStarted——开服运行指令[1.10]",
    "author": "GiNYAi",
    "replyCount": 6,
    "timestamp": 1519544460,
    "txt_content": " 本帖最后由 GiNYAi 于 2018-2-25 15:44 编辑 \n开服运行指令\n一个简单的小插件\n总觉得名字起的有点奇怪\n在服务器开启之后执行命令 支持延迟和重复执行\n基于SpongeAPI 5.1 并不保证能在其它版本正常运行\n如果无法正常运行，并且你有需要，可以回帖告诉我\n下载\n\n\n\nCommandsOnStarted-1.0-SNAPSHOT.jar\n(8.33 KB, 下载次数: 89)\n\n\n\n2018-2-25 15:40 上传\n点击文件名下载附件\n\n\n\n\n\n\n安装\n放入mods文件夹\n命令\n没有命令，不支持使用/sponge plugins reload 重载\n配置文件\ngroup1:{\n        delay:{\n                //可以使用的time_units:\n                //TICKS,NANOSECONDS,MICROSECONDS,MILLISECONDS,SECONDS,MINUTES,HOURS,DAYS\n                //default:SECONDS\n                time_unit:\"TICKS\"\n                //default:0\n                delay:20\n        }\n        //如果设置interval为0则命令组将不会重复执行\n        repetition:{\n                //default:SECONDS\n                time_unit:\"SECONDS\"\n                //default:0\n                interval:0\n        }\n        commands:[\n                \"say hello world\"\n        ]\n}\n//可以设置多个命令组\ngroup2:{\n}复制代码\n源代码\npackage net.ginyai.commandsonstarted;\n\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Inject;\nimport ninja.leaping.configurate.ConfigurationNode;\nimport ninja.leaping.configurate.ConfigurationOptions;\nimport ninja.leaping.configurate.commented.CommentedConfigurationNode;\nimport ninja.leaping.configurate.hocon.HoconConfigurationLoader;\nimport ninja.leaping.configurate.loader.ConfigurationLoader;\nimport ninja.leaping.configurate.objectmapping.ObjectMappingException;\nimport ninja.leaping.configurate.objectmapping.serialize.TypeSerializer;\nimport ninja.leaping.configurate.objectmapping.serialize.TypeSerializerCollection;\nimport ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\nimport org.slf4j.Logger;\nimport org.spongepowered.api.Sponge;\nimport org.spongepowered.api.command.CommandSource;\nimport org.spongepowered.api.config.ConfigDir;\nimport org.spongepowered.api.entity.living.player.Player;\nimport org.spongepowered.api.event.Listener;\nimport org.spongepowered.api.event.Order;\nimport org.spongepowered.api.event.filter.Getter;\nimport org.spongepowered.api.event.game.GameReloadEvent;\nimport org.spongepowered.api.event.game.state.GamePreInitializationEvent;\nimport org.spongepowered.api.event.game.state.GameStartedServerEvent;\nimport org.spongepowered.api.event.network.ClientConnectionEvent;\nimport org.spongepowered.api.plugin.Plugin;\nimport org.spongepowered.api.scheduler.Task;\nimport org.spongepowered.api.text.Text;\nimport org.spongepowered.api.text.format.TextColors;\nimport org.spongepowered.api.text.format.TextStyles;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n@Plugin(\n        id = \"commandsonstarted\",\n        name = \"CommandsOnStarted\",\n        authors = {\n                \"GiNYAi\"\n        },\n        description = \"Run commands after server started.\",\n        version = \"1.0.0\"\n)\npublic class CommandsOnStarted {\n\n    @Inject\n    private Logger logger;\n\n    @Inject@ConfigDir(sharedRoot = true)\n    private Path configDir;\n\n    private List<CommandGroup> commandGroups = new ArrayList<>();\n\n    @Listener\n    public void onPreInit(GamePreInitializationEvent event) {\n        try {\n            load();\n        } catch (IOException e) {\n            logger.error(\"Failed to load config.\",e);\n        }\n    }\n\n    @Listener(order = Order.POST)\n    public void onServerStarted(GameStartedServerEvent event){\n        commandGroups.forEach(CommandGroup::process);\n    }\n\n    private void load() throws IOException {\n        Path configPath = configDir.resolve(\"CommandsOnStarted.conf\");\n        if(!configPath.toFile().exists()){\n            Sponge.getAssetManager().getAsset(this,\"default_config.conf\").get().copyToFile(configPath);\n        }\n        ConfigurationLoader<CommentedConfigurationNode> configLoader = HoconConfigurationLoader.builder().setPath(configPath).build();\n        TypeSerializerCollection serializers = TypeSerializers.getDefaultSerializers().newChild();\n        serializers.registerType(TypeToken.of(CommandGroup.class),new Serializer());\n        ConfigurationOptions options = ConfigurationOptions.defaults().setSerializers(serializers);\n        CommentedConfigurationNode configNode = configLoader.load(options);\n        for(Map.Entry<?,? extends CommentedConfigurationNode> entry : configNode.getChildrenMap().entrySet()){\n            try {\n                CommandGroup group = entry.getValue().getValue(TypeToken.of(CommandGroup.class));\n                commandGroups.add(group);\n            } catch (ObjectMappingException e) {\n                logger.error(\"Failed to load command group: \"+entry.getKey(),e);\n            }\n        }\n    }\n\n    public class CommandGroup implements Runnable{\n        private String name;\n        private List<String> commandLines;\n        private long delay;\n        private boolean isDelayTick;\n        private TimeUnit delayTimeUnit;\n        private long interval;\n        private boolean isIntervalTick;\n        private TimeUnit intervalTimeUnit;\n\n        private CommandGroup(){}\n\n        void process(){\n            Task.Builder builder = Sponge.getScheduler().createTaskBuilder();\n            builder.execute(this);\n            if(isDelayTick){\n                builder.delayTicks(delay);\n            }else {\n                builder.delay(delay,delayTimeUnit);\n            }\n            if(isIntervalTick){\n                builder.intervalTicks(interval);\n            }else {\n                builder.interval(interval,intervalTimeUnit);\n            }\n            builder.submit(CommandsOnStarted.this);\n        }\n\n        @Override\n        public void run(){\n            logger.info(\"processing command group: {}\",name);\n            CommandSource source = Sponge.getServer().getConsole();\n            for (String commandLine : commandLines) {\n                Sponge.getCommandManager().process(source,commandLine);\n            }\n        }\n    }\n\n    public class Serializer implements TypeSerializer<CommandGroup>{\n        @Override\n        public CommandGroup deserialize(TypeToken<?> typeToken, ConfigurationNode node) throws ObjectMappingException {\n            CommandGroup group = new CommandGroup();\n            group.name = node.getKey().toString();\n            group.commandLines = node.getNode(\"commands\").getList(TypeToken.of(String.class), Collections.emptyList());\n            //delay\n            group.delay = node.getNode(\"delay\",\"delay\").getLong(0);\n            if(group.delay<0){\n                throw new ObjectMappingException(\"delay should not be below 0\");\n            }\n            String timeUnitSting = node.getNode(\"delay\",\"time_unit\").getString(\"SECONDS\").toUpperCase();\n            if(\"TICKS\".equals(timeUnitSting)){\n                group.isDelayTick = true;\n            }else {\n                try {\n                    group.delayTimeUnit = TimeUnit.valueOf(timeUnitSting);\n                }catch (IllegalArgumentException e){\n                    throw new ObjectMappingException(\"Illegal argument for delay time unit\",e);\n                }\n            }\n            //repetition\n            group.interval = node.getNode(\"repetition\",\"interval\").getLong(0);\n            if(group.interval<0){\n                throw new ObjectMappingException(\"interval should not be below 0\");\n            }\n            timeUnitSting = node.getNode(\"repetition\",\"time_unit\").getString(\"SECONDS\").toUpperCase();\n            if(\"TICKS\".equals(timeUnitSting)){\n                group.isIntervalTick = true;\n            }else {\n                try {\n                    group.intervalTimeUnit = TimeUnit.valueOf(timeUnitSting);\n                }catch (IllegalArgumentException e){\n                    throw new ObjectMappingException(\"Illegal argument for interval time unit\",e);\n                }\n            }\n            return group;\n        }\n\n        @Override\n        public void serialize(TypeToken<?> typeToken, CommandGroup commandGroup, ConfigurationNode configurationNode) throws ObjectMappingException {\n            //do nothing\n        }\n    }\n}复制代码\n\n本插件所用所有代码均为原创,不存在借用/抄袭等行为",
    "replies": [
        {
            "author": "xmdhs",
            "timestamp": 1519545240,
            "txt_content": " 本帖最后由 xmdhs 于 2018-2-25 16:37 编辑 \n\n你厉害 为了一个爱心 自己做一个"
        },
        {
            "author": "ICEAC",
            "timestamp": 1524943980,
            "txt_content": "xmdhs 发表于 2018-2-25 15:54\n你厉害 为了一个爱心 自己做一个\n我收下了这爱心"
        },
        {
            "author": "Nanctime",
            "timestamp": 1536479040,
            "txt_content": "可以重复执行指令这个好评"
        },
        {
            "author": "1766313658",
            "timestamp": 1536976320,
            "txt_content": "太讲究的插件了，辛苦了，感谢大佬"
        },
        {
            "author": "cvczcvc",
            "timestamp": 1539761100,
            "txt_content": "1.12.2不加载"
        },
        {
            "author": "GiNYAi",
            "timestamp": 1539762360,
            "txt_content": "cvczcvc 发表于 2018-10-17 15:25\n1.12.2不加载\n无法复现"
        }
    ]
}