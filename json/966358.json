{
    "title": "[SCT]创建高版本自定义实体，自定义方块原理与应用",
    "author": "狡诈师",
    "replyCount": 6,
    "timestamp": 1582379520,
    "txt_content": " 本帖最后由 童鞋鞋 于 2020-3-5 09:00 编辑 \n\n\n我正在开发imiPet宠物插件，是运用NMS自定义实体，花了一段时间学习NMS自定义实体该视频有坐骑演示https://www.bilibili.com/video/av90213229?zw\n想必很多人看过莫老的自定义实体教程：https://www.mcbbs.net/thread-811096-1-1.html\n那么我为何要还要发表这样自定义实体教程呢？\n理由诸如：\n我发现其不适用于Minecraft-1.13+其坐骑需要等待一段时间才能驾驶\n\n那么通过我的教程能学到什么呢\n可以学到：\n注册实体，并生成实体（包括强制生成）在Minecraft1.12-1.15版本中自定义实体玩一把坐骑，到处跳，到处飞在Minecraft-1.14+利用纹理包实现自定义方块\n\n\n\nMinecraft-1.12-总汇我们开始创建一个类：TestEntity继承EntityArmorStand （也可以是其它BukkitNMS中EntityXXX）public class TestEntity extends EntityArmorStand {\n\n}复制代码\n接下来实现构造方法public TestEntity(Player player) {\n    super(((CraftWorld) player.getLocation().getWorld()).getHandle());\n    this.setPosition(location.getX(), location.getY(), location.getZ()); // 生成到这个位置\n}复制代码\n然后可以生成实体了吗？\n并不，我们需要对实体进行注册，否则是不能生成实体\n注册方法可以使用莫老的自定义实体教程：https://www.mcbbs.net/thread-811096-1-1.html\n    static {\n        // 给我们的自定义实体做一个MinecraftKey\n        MinecraftKey minecraftKey = new MinecraftKey(\"custom_armorstand\"); // minecraft:xxx\n        // 实体注册\n        EntityTypes.d.add(minecraftKey); // 将此key添加至EntityTypes的列表里\n        EntityTypes.b.a(54, minecraftKey, TestEntity.class); // 对其注册\n        // 如果想取消对该实体的注册那么可以执行下方的代码\n        EntityTypes.d.remove(minecraftKey);\n        MinecraftKey oldKey = EntityTypes.b.b(EntityArmorStand.class); // minecraft:armorstand\n        EntityTypes.b.a(54, oldKey, EntityArmorStand.class); // 把54号id所对应的minecraft:key和entity class进行覆盖\n    }复制代码\n好啦，我们可以生成实体了\n    // 生成实体\n    public void spawnEntity() {\n        WorldServer world = ((CraftWorld) this.player.getWorld()).getHandle();\n        \n        // 如果你想对NMS实体进行简单的修改，可以转换为Bukkit实体\n        ArmorStand armorStand = (ArmorStand) this.getBukkitEntity();\n        armorStand.setSmall(isSmall);\n\n        \n        // 注意这里，CraftWolrd的addEntity第二个参数\n        // 写入 CreatureSpawnEvent.SpawnReason.CUSTOM 可以强制生成实体了\n        // 没看到实体？因为没设置具体生成位置（1.12中），别忘了让实体传送到你身边\n        world.addEntity(this, CreatureSpawnEvent.SpawnReason.CUSTOM);\n    }复制代码\n别走，WASD操控实体呢？\n咳咳，喝杯奶茶后，咱们继续吧\n莫老的跳跃反射真方便，只要修改不同版本的字段，皆可在不同版本使用\n    private static Field jump = null; // 跳跃字段\n    static {\n        // 反射一下EntityLiving里的跳跃字段\n        try {\n            jump = EntityLiving.class.getDeclaredField(\"bd\"); // 就算这里字段\n            jump.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e1) {\n            e1.printStackTrace();\n        }\n    }复制代码那么字段\"bd\"怎么看的，我们可以反编译翻阅NMS中EntityLiving类看看\n悄悄告诉你：\nIDEA快捷键 Ctrl+鼠标左键 jump = EntityLiving.class..... 中的 EntityLiving 即可快速跳到该类\n该字段是有规律的，一般在 public float lastDamage; 下面\n\n\n\n\nQQ图片20200222203455.png (33.7 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-22 20:37 上传\n\n\n\n\n\n\n重点来了，实现坐骑代码\n\n    protected boolean isJumpOrFly = false; // 默认设置不跳跃或不飞行\n\n    // 防止摔伤\n    public void e(float f, float f1) {\n        if (!this.isJumpOrFly) {\n            super.e(f, f1);\n        }\n    }\n\n    /**\n     * \n     * @param motionSideways 左右移动\n     * @param motionForward 前后移动\n     * @param f 不太清楚\n     * \n     */\n    public void a(float motionSideways, float motionForward, float f) {\n        if (this.passengers != null && !this.passengers.isEmpty()) { // 判断有无乘客\n            EntityLiving passenger = (EntityLiving) this.passengers.get(0); // 获取坐骑列表第一个乘客(驾驶员2333)\n\n            UUID passengerUUID = passenger.getUniqueID(); // 玩家的UUID\n\n            boolean canFly = Bukkit.getPlayer(passengerUUID).hasPermission(\"xxx.fly\"); // 是否有飞行权限\n\n            if (this.onGround) { // 是否落到地面\n                this.isJumpOrFly = false; // 设置为不跳跃不飞行\n            }\n\n            // 设置实体与乘客一样的俯仰角，航向角        \n            this.lastYaw = (this.yaw = passenger.yaw);\n            this.pitch = passenger.pitch * 0.5F;\n            setYawPitch(this.yaw, this.pitch);\n            this.aP = (this.aN = this.yaw);\n\n            motionSideways = passenger.be * 0.5F; // 设置左右运动\n            motionForward = passenger.bg; // 设置前后运动\n\n            // 向后放慢\n            if (motionForward <= 0.0F) {\n                motionForward *= 0.25F;\n            }\n\n            motionSideways *= 0.8F; // 左右慢，但不如向后慢\n\n            float speed = 0.2F; // 实体行走速度\n            double jumpHeight = 0.5f; // 实体跳跃高度\n            float ascendSpeed = 0.2f; // 实体飞行速度\n\n            // 触发坐骑方法\n            ride(motionSideways, motionForward, f, speed);\n\n            if (jump != null && this.isVehicle()) {\n                boolean doJump = false;\n                if (jump != null) { // 是否跳跃了\n                    try {\n                        doJump = jump.getBoolean(passenger); // 触发跳跃或飞行\n                    } catch (IllegalAccessException ignored) {\n                    }\n                }\n\n                if (doJump) {\n                    if (canFly) { // 是否可以飞行\n                        if (this.motY < ascendSpeed) {\n                            this.motY = ascendSpeed; // 设置向上的飞行移动\n                            this.isJumpOrFly = true;\n                        }\n                    } else {\n                        if (onGround) { // 如果在地面则可跳跃\n                            this.motY = jumpHeight; // 设置向上的跳跃\n                            this.isJumpOrFly = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // 实现坐骑(MyPet开源项目有很好的算法：https://github.com/xXKeyleXx/MyPet)\n    private void ride(float motionSideways, float f, float motionForward, float speedModifier) {\n        double locY;\n        float f2;\n        float swimSpeed;\n        float speed;\n\n        if (this.isInWater()) { // 是否在水中\n            locY = this.locY; // Y轴的移动\n            speed = 0.8F; // 赋予实体速度\n            swimSpeed = 0.02F; // 赋予实体水中速度\n\n            // 开始设置实体水中运动\n            this.b(motionSideways, motionForward, f, swimSpeed);\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            this.motX *= speed;\n            this.motY *= 0.8D;\n            this.motZ *= speed;\n            this.motY -= 0.02D;\n            if (this.positionChanged && this.c(this.motX, this.motY + 0.6000000238418579D - this.locY + locY, this.motZ)) { // 实现真实游泳状态\n                this.motY = 0.3D;\n            }\n        } else if (this.au()) { // 在熔岩中\n            // 设置实体在熔岩的运动，让它下沉，无法上来\n            locY = this.locY;\n            this.b(motionSideways, motionForward, f, 0.02F);\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            this.motX *= 0.5D;\n            this.motY *= 0.5D;\n            this.motZ *= 0.5D;\n            this.motY -= 0.02D;\n            if (this.positionChanged && this.c(this.motX, this.motY + 0.6D - this.locY + locY, this.motZ)) {\n                this.motY = 0.3D;\n            }\n        } else { // 除了以上环境\n            // 实现操控实体地面/空中移动算法\n            float friction = 0.91F;\n            if (this.onGround) { // 在地面\n                friction = this.world.getType(new BlockPosition(MathHelper.floor(this.locX), MathHelper.floor(this.getBoundingBox().b) - 1, MathHelper.floor(this.locZ))).getBlock().frictionFactor * 0.91F;\n            }\n\n            speed = speedModifier * (0.2F / (friction * friction * friction)); // 此时实体运动速度\n\n//\n// 剩下的不太清楚\n//\n            this.b(motionSideways, motionForward, f, speed);\n            friction = 0.9F;\n            if (this.onGround) {\n                friction = this.world.getType(new BlockPosition(MathHelper.floor(this.locX), MathHelper.floor(this.getBoundingBox().b) - 1, MathHelper.floor(this.locZ))).getBlock().frictionFactor * 0.91F;\n            }\n\n            if (this.m_()) {\n                swimSpeed = 0.15F;\n                this.motX = MathHelper.a(this.motX, -swimSpeed, swimSpeed);\n                this.motZ = MathHelper.a(this.motZ, -swimSpeed, swimSpeed);\n                this.fallDistance = 0.0F;\n                if (this.motY < -0.15D) {\n                    this.motY = -0.15D;\n                }\n            }\n\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            if (this.positionChanged && this.m_()) {\n                this.motY = 0.2D;\n            }\n\n            this.motY -= 0.08D;\n\n            this.motY *= 1.0D;\n            this.motX *= friction;\n            this.motZ *= friction;\n        }\n\n        this.aF = this.aG;\n        locY = this.locX - this.lastX;\n        double d1 = this.locZ - this.lastZ;\n        f2 = MathHelper.sqrt(locY * locY + d1 * d1) * 4.0F;\n        if (f2 > 1.0F) {\n            f2 = 1.0F;\n        }\n\n        this.aG += (f2 - this.aG) * 0.4F;\n        this.aH += this.aG;\n    }复制代码\n其中 public void a(float motionSideways, float motionForward, float f) {} 怎么知道呢\n通过反编译翻阅EntityLiving类，很明显找到我们需要的东西，别忘了，不同版本不是相同的，尽量多自行查看\n\n\n\n\n11111.png (54.63 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-22 21:00 上传\n\n\n\n\n\n\n Minecraft-1.12-创建实体我们开始创建一个类：TestEntity继承EntityArmorStand （也可以是其它BukkitNMS中EntityXXX）public class TestEntity extends EntityArmorStand {\n\n}复制代码\n接下来实现构造方法public TestEntity(Player player) {\n    super(((CraftWorld) player.getLocation().getWorld()).getHandle());\n}复制代码\nMinecraft-1.12-注册实体然后可以生成实体了吗？\n并不，我们需要对实体进行注册，否则是不能生成实体\n注册方法可以使用莫老的自定义实体教程：https://www.mcbbs.net/thread-811096-1-1.html\n    static {\n        // 给我们的自定义实体做一个MinecraftKey\n        MinecraftKey minecraftKey = new MinecraftKey(\"custom_armorstand\"); // minecraft:xxx\n        // 实体注册\n        EntityTypes.d.add(minecraftKey); // 将此key添加至EntityTypes的列表里\n        EntityTypes.b.a(54, minecraftKey, TestEntity.class); // 对其注册\n        // 如果想取消对该实体的注册那么可以执行下方的代码\n        EntityTypes.d.remove(minecraftKey);\n        MinecraftKey oldKey = EntityTypes.b.b(EntityArmorStand.class); // minecraft:armorstand\n        EntityTypes.b.a(54, oldKey, EntityArmorStand.class); // 把54号id所对应的minecraft:key和entity class进行覆盖\n    }复制代码\nMinecraft-1.12-生成实体好啦，我们可以生成实体了\n    // 生成实体\n    public void spawnEntity() {\n        WorldServer world = ((CraftWorld) this.player.getWorld()).getHandle();\n        \n        // 如果你想对NMS实体进行简单的修改，可以转换为Bukkit实体\n        ArmorStand armorStand = (ArmorStand) this.getBukkitEntity();\n        armorStand.setSmall(isSmall);\n\n        \n        // 注意这里，CraftWolrd的addEntity第二个参数\n        // 写入 CreatureSpawnEvent.SpawnReason.CUSTOM 可以强制生成实体了\n        // 没看到实体？因为没设置具体生成位置（1.12中），别忘了让实体传送到你身边\n        world.addEntity(this, CreatureSpawnEvent.SpawnReason.CUSTOM);\n    }复制代码Minecraft-1.12-骑行实体别走，WASD操控实体呢？\n咳咳，喝杯奶茶后，咱们继续吧\n莫老的跳跃反射真方便，只要修改不同版本的字段，皆可在不同版本使用\n    private static Field jump = null; // 跳跃字段\n    static {\n        // 反射一下EntityLiving里的跳跃字段\n        try {\n            jump = EntityLiving.class.getDeclaredField(\"bd\"); // 就是这里字段\n            jump.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e1) {\n            e1.printStackTrace();\n        }\n    }复制代码那么字段\"bd\"怎么看的，我们可以反编译翻阅NMS中EntityLiving类看看\n悄悄告诉你：\nIDEA快捷键 Ctrl+鼠标左键 jump = EntityLiving.class..... 中的 EntityLiving 即可快速跳到该类\n该字段是有规律的，一般在 public float lastDamage; 下面\n\n\n重点来了，实现坐骑代码\n\n    protected boolean isJumpOrFly = false; // 默认设置不跳跃或不飞行\n\n    // 防止摔伤\n    public void e(float f, float f1) {\n        if (!this.isJumpOrFly) {\n            super.e(f, f1);\n        }\n    }\n\n    /**\n     * \n     * @param motionSideways 左右移动\n     * @param motionForward 前后移动\n     * @param f 不太清楚\n     * \n     */\n    public void a(float motionSideways, float motionForward, float f) {\n        if (this.passengers != null && !this.passengers.isEmpty()) { // 判断有无乘客\n            EntityLiving passenger = (EntityLiving) this.passengers.get(0); // 获取坐骑列表第一个乘客(驾驶员2333)\n\n            UUID passengerUUID = passenger.getUniqueID(); // 玩家的UUID\n\n            boolean canFly = Bukkit.getPlayer(passengerUUID).hasPermission(\"xxx.fly\"); // 是否有飞行权限\n\n            if (this.onGround) { // 是否落到地面\n                this.isJumpOrFly = false; // 设置为不跳跃不飞行\n            }\n\n            // 设置实体与乘客一样的俯仰角，航向角        \n            this.lastYaw = (this.yaw = passenger.yaw);\n            this.pitch = passenger.pitch * 0.5F;\n            setYawPitch(this.yaw, this.pitch);\n            this.aP = (this.aN = this.yaw);\n\n            motionSideways = passenger.be * 0.5F; // 设置左右运动\n            motionForward = passenger.bg; // 设置前后运动\n\n            // 向后放慢\n            if (motionForward <= 0.0F) {\n                motionForward *= 0.25F;\n            }\n\n            motionSideways *= 0.8F; // 左右慢，但不如向后慢\n\n            float speed = 0.2F; // 实体行走速度\n            double jumpHeight = 0.5f; // 实体跳跃高度\n            float ascendSpeed = 0.2f; // 实体飞行速度\n\n            // 触发坐骑方法\n            ride(motionSideways, motionForward, f, speed);\n\n            if (jump != null && this.isVehicle()) {\n                boolean doJump = false;\n                if (jump != null) { // 是否跳跃了\n                    try {\n                        doJump = jump.getBoolean(passenger); // 触发跳跃或飞行\n                    } catch (IllegalAccessException ignored) {\n                    }\n                }\n\n                if (doJump) {\n                    if (canFly) { // 是否可以飞行\n                        if (this.motY < ascendSpeed) {\n                            this.motY = ascendSpeed; // 设置向上的飞行移动\n                            this.isJumpOrFly = true;\n                        }\n                    } else {\n                        if (onGround) { // 如果在地面则可跳跃\n                            this.motY = jumpHeight; // 设置向上的跳跃\n                            this.isJumpOrFly = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // 实现坐骑(MyPet开源项目有很好的算法：https://github.com/xXKeyleXx/MyPet)\n    private void ride(float motionSideways, float f, float motionForward, float speedModifier) {\n        double locY;\n        float f2;\n        float swimSpeed;\n        float speed;\n\n        if (this.isInWater()) { // 是否在水中\n            locY = this.locY; // Y轴的移动\n            speed = 0.8F; // 赋予实体速度\n            swimSpeed = 0.02F; // 赋予实体水中速度\n\n            // 开始设置实体水中运动\n            this.b(motionSideways, motionForward, f, swimSpeed);\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            this.motX *= speed;\n            this.motY *= 0.8D;\n            this.motZ *= speed;\n            this.motY -= 0.02D;\n            if (this.positionChanged && this.c(this.motX, this.motY + 0.6000000238418579D - this.locY + locY, this.motZ)) { // 实现真实游泳状态\n                this.motY = 0.3D;\n            }\n        } else if (this.au()) { // 在熔岩中\n            // 设置实体在熔岩的运动，让它下沉，无法上来\n            locY = this.locY;\n            this.b(motionSideways, motionForward, f, 0.02F);\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            this.motX *= 0.5D;\n            this.motY *= 0.5D;\n            this.motZ *= 0.5D;\n            this.motY -= 0.02D;\n            if (this.positionChanged && this.c(this.motX, this.motY + 0.6D - this.locY + locY, this.motZ)) {\n                this.motY = 0.3D;\n            }\n        } else { // 除了以上环境\n            // 实现操控实体地面/空中移动算法\n            float friction = 0.91F;\n            if (this.onGround) { // 在地面\n                friction = this.world.getType(new BlockPosition(MathHelper.floor(this.locX), MathHelper.floor(this.getBoundingBox().b) - 1, MathHelper.floor(this.locZ))).getBlock().frictionFactor * 0.91F;\n            }\n\n            speed = speedModifier * (0.2F / (friction * friction * friction)); // 此时实体运动速度\n\n//\n// 剩下的不太清楚\n//\n\n            this.b(motionSideways, motionForward, f, speed);\n            friction = 0.9F;\n            if (this.onGround) {\n                friction = this.world.getType(new BlockPosition(MathHelper.floor(this.locX), MathHelper.floor(this.getBoundingBox().b) - 1, MathHelper.floor(this.locZ))).getBlock().frictionFactor * 0.91F;\n            }\n\n            if (this.m_()) {\n                swimSpeed = 0.15F;\n                this.motX = MathHelper.a(this.motX, -swimSpeed, swimSpeed);\n                this.motZ = MathHelper.a(this.motZ, -swimSpeed, swimSpeed);\n                this.fallDistance = 0.0F;\n                if (this.motY < -0.15D) {\n                    this.motY = -0.15D;\n                }\n            }\n\n            this.move(EnumMoveType.SELF, this.motX, this.motY, this.motZ);\n            if (this.positionChanged && this.m_()) {\n                this.motY = 0.2D;\n            }\n\n            this.motY -= 0.08D;\n\n            this.motY *= 1.0D;\n            this.motX *= friction;\n            this.motZ *= friction;\n        }\n\n        this.aF = this.aG;\n        locY = this.locX - this.lastX;\n        double d1 = this.locZ - this.lastZ;\n        f2 = MathHelper.sqrt(locY * locY + d1 * d1) * 4.0F;\n        if (f2 > 1.0F) {\n            f2 = 1.0F;\n        }\n\n        this.aG += (f2 - this.aG) * 0.4F;\n        this.aH += this.aG;\n    }复制代码\n其中 public void a(float motionSideways, float motionForward, float f) {} 怎么知道呢\n通过反编译翻阅EntityLiving类，很明显找到我们需要的东西，别忘了，不同版本不是相同的，尽量多自行查看\n\nMinecraft-1.13-1.13.X本版本 TestEntity 跟Minecraft-1.12的创建继承构造步骤一样，这里不重复讲了\n我们直奔注册实体\n在 TestEntity 类型写入\n    public static EntityTypes entityTypes; // 存储自定义实体类型\n    public static EntityTypes registerEntity\n    (String name, String from,\n    Class<? extends net.minecraft.server.v1_13_R1.Entity> clazz,\n    Function<? super World, ? extends Entity> function) {\n        // 获取服务器的类型数据\n        Map<Object, Type<?>> dataTypes = \n        (Map<Object, Type<?>>) \n        DataConverterRegistry\n        .a()\n        .getSchema(15190\n        ).findChoiceType(DataConverterTypes.n).types();\n        // 写入自定义实体(name是自定义名，from是目标实体诸如minecraft:armorstand)\n        dataTypes.put(\"minecraft:\" + name, dataTypes.get(\"minecraft:\" + from));\n        // 创建自定义实体并返回EntityTypes\n        return EntityTypes.a(name, EntityTypes.a.a(clazz, function));\n    }复制代码\n生成实体\n    public static void spawnEntity(Player player, Location location) {\n        World world = ((CraftWorld) player.getWorld()).getHandle();\n        Entity entity = entityTypes.a( // 从NMS的entityTypes，a是创造实体方法\n                world, // 引出NMS世界\n                null, // Entity Tag\n                null, // 实体自定义名\n                null, // 不清楚是什么\n                new BlockPosition(location.getBlockX(),\n                       location.getBlockY(), \n                       location.getBlockZ()), // 生成于BlockPosition\n                false, // 不清楚是什么\n                false);\n        world.addEntity(entity, CreatureSpawnEvent.SpawnReason.CUSTOM); // 强制生成\n    }复制代码\n\n并且在主类中注册实体（onEnable或onLoad也行）\n    @Override\n    public void onEnable() {\n        TestEntity.entityTypes = TestEntity.registerEntity(\n                                \"custom_armorstand\",\n                                \"armor_stand\",\n                                TestEntity.class,\n                                TestEntity::new);\n    }复制代码\n顺便说下跳跃字段，是\"bg\"\n同样可以翻阅MyPet开源项目得到坐骑关键代码\n\n\n\n\nMinecraft-1.14创建 TestEntity 类并继承，然后完成构造方法\npublic class Entity extends EntityArmorStand {\n    public Entity(EntityTypes<? extends EntityMonster> entitytypes, World world) {\n        super(EntityTypes.ARMOR_STAND, world);\n    }\n}复制代码\n对的，这时候你会发现，和此前版本注册不一样\n    private static EntityTypes entityTypes; // 存储自定义实体类型\n\n    public static void registerEntity() {\n        // 获取服务器的类型数据\n        Map<String, Type<?>> types = \n        (Map<String, Type<?>>) \n        DataConverterRegistry\n        .a()\n        .getSchema(DataFixUtils.makeKey(SharedConstants.a().getWorldVersion()))\n        .findChoiceType(DataConverterTypes.ENTITY).types();复制代码\n然后知道怎么在主类注册实体了吧？什么？不知道？！\n不认真看的挨批傲，快去看v1_13_R1 & v1_13_R2的内容\n\n在1.14生成实体方法是这样的，我们可以注意到，1.14的entityTypes.b是创造实体\n在1.13的entityTypes.a是创造实体，b则是生成实体\n（1.15也差不多，1.15中生成实体方法是 entityTypes.createCreature(... ，从这单词上容易看出，是创造实体）\npublic static void spawnEntity(Player player) {\n        World world = ((CraftWorld) player.getWorld()).getHandle();\n        Location location = player.getLocation();\n        Entity entity = entityTypes.b( // 从NMS的entityTypes，b是创造实体方法\n                world, // 引出NMS世界\n                null, // Entity Tag\n                null, // 实体自定义名\n                null, // 不清楚是什么\n                new BlockPosition(location.getX(), location.getY(), location.getZ()), // 生成于BlockPosition\n                null, // 不清楚是什么\n                false, \n                false);\n        // 强制生成\n        world.addEntity(entity, CreatureSpawnEvent.SpawnReason.CUSTOM);\n    }复制代码\n骑行实体，通过前面教程内容，我们容易找到跳跃字段了\n请自行反编译找出1.14的跳跃字段，再折叠打开看正确答案\n看看对不对，字段正确是\"jumping\"\n正确了？好，值得表扬，真棒\n那么找到实现骑行实体方法了吗？\n也许你这时候感到疑惑\n\n\n\n\n22222.png (57.14 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-22 21:37 上传\n\n\n\n\n\n是的，就是这里，但是呢，它的参数类型变成了Vec3D了！\n好在呢，MyPet开源项目已经做了很好的坐骑算法，在这里我简化一下吧\n\n    protected boolean isJumpOrFly = false; // 默认设置不跳跃或不飞行\n\n    // 防止摔伤\n    public void b(float f, float f1) {\n        if (!this.isJumpOrFly) {\n            super.b(f, f1);\n        }\n    }\n\n    @Override // 覆写实体移动\n    public void e(Vec3D vec3d) {\n        if (this.passengers != null && !this.passengers.isEmpty()) { // 判断有无乘客\n            EntityLiving passenger = (EntityLiving) this.passengers.get(0); // 获取坐骑列表第一个乘客\n\n            boolean canFly = xxx; // 可以是飞行权限\n\n            if (this.onGround) { // 在地面\n                this.isJumpOrFly = false; // 设置为不跳跃不飞行\n            }\n\n            if (this.a(TagsFluid.WATER)) { // 在水面\n                this.setMot(this.getMot().add(0, 0.4, 0));\n            }\n\n            // 设置实体与乘客一样的俯仰角，航向角\n            this.lastYaw = (this.yaw = passenger.yaw);\n            this.pitch = passenger.pitch * 0.5F;\n            setYawPitch(this.yaw, this.pitch);\n            this.aM = (this.aK = this.yaw);\n\n            double motionSideways = passenger.bb * 0.5F; // 设置左右运动\n            double motionForward = passenger.bd; // 设置前后运动\n\n            // 向后放慢\n            if (motionForward <= 0.0F) {\n                motionForward *= 0.25F;\n            }\n\n            motionSideways *= 0.85F; // 左右慢，但不如向后慢\n\n            float speed = 0.2F; // 行走速度\n\n            // 触发坐骑方法\n            ride(motionSideways, motionForward, vec3d.y, speed);\n\n            if (jump != null && this.isVehicle()) {\n                boolean doJump = false;\n                if (jump != null) { // 是否跳跃了\n                    try {\n                        doJump = jump.getBoolean(passenger); // 触发跳跃或飞行\n                    } catch (IllegalAccessException ignored) {\n                    }\n                }\n\n                double jumpHeight = 0.5f;\n                float ascendSpeed = 0.2f;\n\n                if (doJump) {\n                    if (canFly) { // 是否可以飞行\n                        if (this.getMot().y < ascendSpeed) {\n                            this.setMot(this.getMot().x, ascendSpeed, this.getMot().z); // 设置向上的飞行移动\n                            this.isJumpOrFly = true;\n                        }\n                    }else {\n                        if (onGround) { // 如果在地面则可跳跃\n                            this.setMot(this.getMot().x, jumpHeight, this.getMot().z); // 设置向上的跳跃\n                            this.isJumpOrFly = true;\n                        }\n                    }\n                }\n            }\n        }\n        super.a(vec3d);\n    }\n\n    // 实现坐骑方法\n    private void ride(double motionSideways, double motionForward, double motionUpwards, float speedModifier) {\n        double locY;\n        float f2;\n        float speed;\n        float swimSpeed;\n\n        if (this.b(TagsFluid.WATER)) { // 在水面\n            locY = this.locY;\n            speed = 0.8F; // 行走速度\n            swimSpeed = 0.02F; // 游泳速度\n\n            // 开始设置实体水中运动\n            this.a(swimSpeed, new Vec3D(motionSideways, motionUpwards, motionForward));\n            this.move(EnumMoveType.SELF, this.getMot());\n            double motX = this.getMot().x * (double) speed;\n            double motY = this.getMot().y * 0.8D;\n            double motZ = this.getMot().z * (double) speed;\n            motY -= 0.02D;\n            if (this.positionChanged && this.d(this.getMot().x, this.getMot().y + 0.6000000238418579D - this.locY + locY, this.getMot().z)) {\n                motY = 0.3D;\n            }\n            this.setMot(motX, motY, motZ);\n        } else if (this.b(TagsFluid.LAVA)) { // 在熔岩中\n            // 设置实体在熔岩的运动，让它下沉，无法上来\n            locY = this.locY;\n            this.a(0.02F, new Vec3D(motionSideways, motionUpwards, motionForward));\n            this.move(EnumMoveType.SELF, this.getMot());\n            double motX = this.getMot().x * 0.5D;\n            double motY = this.getMot().y * 0.5D;\n            double motZ = this.getMot().z * 0.5D;\n            motY -= 0.02D;\n            if (this.positionChanged && this.d(this.getMot().x, this.getMot().y + 0.6000000238418579D - this.locY + locY, this.getMot().z)) {\n                motY = 0.3D;\n            }\n            this.setMot(motX, motY, motZ);\n        } else {  // 除了以上环境\n            float friction = 0.91F;\n            // 实现操控实体地面/空中移动算法\n            // 未注释的不太清楚\n            speed = speedModifier * (0.16277136F / (friction * friction * friction));\n\n            this.a(speed, new Vec3D(motionSideways, motionUpwards, motionForward));\n            friction = 1.0F;\n\n            double motX = this.getMot().x;\n            double motY = this.getMot().y;\n            double motZ = this.getMot().z;\n\n            if (this.isClimbing()) {\n                swimSpeed = 0.15F;\n                motX = MathHelper.a(motX, -swimSpeed, swimSpeed);\n                motZ = MathHelper.a(motZ, -swimSpeed, swimSpeed);\n                this.fallDistance = 0.0F;\n                if (motY < -0.15D) {\n                    motY = -0.15D;\n                }\n            }\n\n            Vec3D mot = new Vec3D(motX, motY, motZ);\n\n            this.move(EnumMoveType.SELF, mot);\n            if (this.positionChanged && this.isClimbing()) {\n                motY = 0.2D;\n            }\n\n            motY -= 0.08D;\n\n            motY *= 1.0D;\n            motX *= friction;\n            motZ *= friction;\n\n            this.setMot(motX, motY, motZ);\n        }\n\n        this.aE = this.aF;\n        locY = this.locX - this.lastX;\n        double d1 = this.locZ - this.lastZ;\n        f2 = MathHelper.sqrt(locY * locY + d1 * d1) * 4.0F;\n        if (f2 > 1.0F) {\n            f2 = 1.0F;\n        }\n\n        this.aF += (f2 - this.aF) * 0.4F;\n        this.aG += this.aF;\n    }复制代码\n\n\n\n\n\n\n Minecraft-1.15令人欣慰的是，1.15与1.14的NMS实体创造注册差不多，只是这里不同\n获得服务器数据类型，和Minecraft-1.14用法一样的\n        Map<String, Type<?>> types = (Map<String, Type<?>>)DataConverterRegistry.a()\n                .getSchema(DataFixUtils.makeKey(SharedConstants\n                        .getGameVersion().getWorldVersion()))\n                .findChoiceType(DataConverterTypes.ENTITY_TREE).types();复制代码\n\n\n自定义方块\n适用范围\n需要纹理包需要编程仅支持Minecraft-1.14+版本\n\n\n为何不在材质版发答\n根据它的原理是需要编程配合的实现\n\n\n我们也许在Minecraft-1.13及以下版本知道了方块不能添加，从而无法自定义方块\n虽然盔甲架可以实现，但是它对服务器性能有影响的，大量集成放置会导致卡顿\n而我们又知道，方块与物品不同之处在于，不能将新模型方块直接加入Minecraft原版中\n当Minecraft-1.14正式版问世后，少数人发现了在此版本实现自定义方块\n当时我为此花费了几天才研究好，鉴于MCBBS没有相关教程，那么我来讲讲吧\n\n\n实现原理\n首先，我要指出重要的角色：蘑菇块\nMinecraft-1.14-1.15中，有三种这样的蘑菇块：蘑菇柄(mushroom_stem)，红色蘑菇块(red_mushroom_block)，棕色蘑菇块(brown_mushroom_block)\n\n\n\n\n\nfile_1582468892000.jpg (99.84 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-23 22:41 上传\n\n\n\n\n\n讲出原理之前，我们先放置蘑菇块来看看先，将两个方块放在一起\n\n\n\n\n\nfile_1582469103000.jpg (95.09 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-23 22:45 上传\n\n\n\n\n\n然后再拆快一个块，我们会发现它的接触面改变了\n\n\n\n\n\nfile_1582469196000.jpg (102 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-23 22:46 上传\n\n\n\n\n\n那么请问，你领悟到了什么呢\n接触后块发生了改变，我们称之为块状态\n主要应用到了纹理包，Minecraft渲染该块所需内容的Json中，对块状态进行属性操控\n方块不同的面显示不同贴图，注意，我的意思并不是说仅仅某个面不同就显示不同纹理贴图\n我的正确意思是：方块上有6个面，显示贴图与这些有关：不同方向的面，不同的面的数量\n\n按数学排列来说吧\n一共有 A B C D E F G 六个不同角色\nA角色变色，有5个面相同，则显示\"xxx\"贴图A E角色变色，有4个面相同，则显示\"vvv\"贴图A G角色变色，那么有4个面相同，则显示\"kaka\"贴图依次推类...\n\n最终，蘑菇柄可以提供给我们64-1=63个自定义方块，有人也许说，怎么扣去 1 了，那个 1 是留给蘑菇柄的贴图啊\n当然再加上红色蘑菇块，棕色蘑菇块，我们最终一共有 189 个自定义方块\n\n189个自定义方块应该足够了，不用灰心，Minecraft-1.16快照版中我们可以看到有新的蘑菇块\n悄悄告诉你，那个Minecraft-1.16发光蘑菇块可能是可发光的自定义方块\n\n\n关于纹理包\n请具备纹理包相关知识，此处我仅讲块状态\n向纹理包添加模型之类的MCBBS材质版有相关教程\n\n我们需要这三个角色：块状态(blockstates)，模型(models)，贴图(textures)\n\n\n\n\n@FCOH%7@KGB3W}M9X(CZ7~B.png (13.76 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-23 23:04 上传\n\n\n\n\n\n\n打开 minecraft\\blockstates\\mushroom_stem.json 写入（没有就自行创建）\n{\n    \"multipart\": [\n        {\n            \"apply\": {\n                \"model\": \"mushroom_stem\" #这个留给蘑菇柄\n            }, \n            \"when\": { # 它的块所有面是开放的(true)\n                \"east\": true, # 东\n                \"west\": true, # 西\n                \"south\": true, # 南\n                \"north\": true, # 北\n                \"down\": true, # 底\n                \"up\": true # 顶\n            }\n        },\n        {\n            \"apply\": {\n                \"model\": \"inewrx_block_one/0\" # 模型路径\n            }, \n            # 它的意思是\n            # 当该块不同面开放(true)与关闭(false)状态是这样时\n            # 就引用\"inewrx_block_one/0\"模型\n            \"when\": { \n                \"east\": false, \n                \"west\": true, \n                \"south\": false, \n                \"north\": false, \n                \"down\": false, \n                \"up\": false\n            }\n        }\n    ]\n}复制代码\n\n自定义方块的应用\n请具备Java基础能力，有BukkitAPI相关知识\n\n一开始，考虑其拓展性，我选择用 PlayerInteractEvent 监听，而不是 BlockPlaceEvent\n触发该事件时，判断是否是右手，否则返回\nif (event.getAction() != Action.RIGHT_CLICK_BLOCK) return;复制代码判断右手物品是否为空，否则返回\nItemStack handItemStack = event.getItem();\nif (handItemStack==null) return;复制代码实现放置自定义方块的代码\n翻阅BukkitAPI，方块有这样的方法MultipleFacing，里面有我们需要i的\n设置指定的面为开放(true)还是关闭(false)状态\n\n\n\n\n(F2Z@SOA9~I2KW@_7`G69T9.png (48.21 KB, 下载次数: 0)\n\n下载附件\n\n2020-2-23 23:53 上传\n\n\n\n\n\n// 为放置方块做准备，取点击的块的面\nBlock newBlock = clickBlock.getRelative(event.getBlockFace());\n\n// 为触发放置方块事件准备\nBlockPlaceEvent blockPlaceEvent = new BlockPlaceEvent(newBlock,\n newBlock.getState(), clickBlock, handItemStack, player, true, Objects.requireNonNull(event.getHand()));\n\n// 实例蘑菇块的MultipleFacing\nMultipleFacing newBlockDataStem = (MultipleFacing) Bukkit.createBlockData(Material.MUSHROOM_STEM);\n\nint id = 1; // 可以写0~63，得到63个不同的面\n\nItemMeta handItemMeta = handItemStack.getItemMeta();\nif (Xxxx.isCustomBlock(handItemMeta)) { // 判断是否是自定义方块(这里不讲了，可以是元数据等)\n    FastHandle.setBlockFacing(newBlockDataStem, id); // 设置自定义方块的面，从而实现显示某个贴图\n    newBlock.setBlockData(newBlockDataStem); // 放置自定义方块\n    event.setCancelled(true); // 取消事件\n    Bukkit.getPluginManager().callEvent(blockPlaceEvent); // 告知服务器该玩家触发了blockPlaceEvent事件\n    takeItem(player, handItemStack); // 取走玩家物品\n}\n\n// 取走玩家物品\nprivate void takeItem(Player player, ItemStack itemStack) {\n    if (!player.getGameMode().equals(GameMode.CREATIVE)) { // 如果不是创造模式\n        itemStack.setAmount(itemStack.getAmount() - 1);\n    }\n}复制代码\n其中是 setBlockFacing 设置方块的面方法\nOraxen作者编写了这样的函数方法\n该作者与我讨论中，得知该方法的原理：\n原话：\nIn fact the \"code\" is an integer between 0 and 2^6 because a block has 6 faces and each one can be disabled or enabled. \nThis function I wrote concerts a code to a list of faces enabled or disabled.\n In binary 000000, which is 0 in base 10 too, \nmeans every faces are disabled while 111111,\n which is equals to 63 in base 10, means that every faces are enabled. \nOne of these combinations is reserved for the default minecraft block but the others ones are automatically generated when you try to create a new block.\n其中重要意思是：在二进制000000中（基数10中也为0）意味着关闭所有面，而111111（基数10中等于63）则意味着开放了所有面\n如果我们写入 int id = 30; 则二进制是：11110\n在循环中，通过 int id 二进制已经为不同面设置开放或关闭状态的面\n这是关键的代码\n/**\n* @param blockData\n* @param id\n*/\npublic static void setBlockFacing(MultipleFacing blockData, int id) {\n    final BlockFace[] properties = new BlockFace[]{BlockFace.EAST, BlockFace.WEST, \nBlockFace.SOUTH, BlockFace.NORTH, BlockFace.DOWN, BlockFace.UP};\n    for (int i = 0; i < properties.length; i++) {\n        blockData.setFace(properties[i], (id & 0x1 << i) != 0);\n    }\n}复制代码\n\n\n\n\n\n\n\n\n\n\n\n[groupid=1511]Server CT[/groupid]",
    "replies": [
        {
            "author": "HotPe_e",
            "timestamp": 1582381800,
            "txt_content": " 本帖最后由 灬友情灬 于 2020-2-22 22:35 编辑 \n\n支持关于NMS的教学  正好想学习关于NMS的一些食用方法 "
        },
        {
            "author": "狡诈师",
            "timestamp": 1582382040,
            "txt_content": "灬友情灬 发表于 2020-2-22 22:30\n支持关于NMS的教学\n希望楼主能尽快填坑 \n秋梨膏\n我这不是写完了吗，创建，注册，坐骑"
        },
        {
            "author": "1837019522",
            "timestamp": 1582382700,
            "txt_content": "前排支持这种nms的教程  并且有个问题想问一下楼主 实现实体向量位移有什么好的方法呢"
        },
        {
            "author": "蓝京",
            "timestamp": 1582427160,
            "txt_content": "您好 您可以帮我看看我的代码吗 我按照您的教程写的 可是生成不了实体 版本1.15.2paper 感激不尽!\n\n\n\n\n\nhelp.png\n(40.62 KB, 下载次数: 0)\n\n\n\n\n下载附件\n\n\n2020-2-23 11:05 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhelp2.png\n(46.49 KB, 下载次数: 0)\n\n\n\n\n下载附件\n\n\n2020-2-23 11:06 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "author": "狡诈师",
            "timestamp": 1582427340,
            "txt_content": " 本帖最后由 童鞋鞋 于 2020-2-23 11:24 编辑 \n蓝京 发表于 2020-2-23 11:06\n您好 您可以帮我看看我的代码吗 我按照您的教程写的 可是生成不了实体 版本1.15.2paper 感激不尽!\n ...\n我漏了些东西，已更改"
        },
        {
            "author": "ksqeib445",
            "timestamp": 1583004660,
            "txt_content": "难顶 手机看感觉太硬核了 完全看不懂\n回头用电脑看看到底写了啥吧(貌似手机看会丢东西？)"
        }
    ]
}