{
    "title": "如何使用minecraft:tnt的形式获取物品实例,如何不附魔但显示附魔花纹",
    "author": "初音Py2001",
    "replyCount": 10,
    "timestamp": 1443844620,
    "txt_content": " 本帖最后由 初音Py2001 于 2015-10-3 12:02 编辑 \n\n如何使用minecraft:tnt的形式获取物品实例\n主要是想兼容MOD服务器\nbukkit的物品建立方式是\nItemStack(Material type)\n或者\nItemStack(int type)\n其中Material 是一个枚举类,只包含了原版所有的物品,肯定是不兼容MOD的\n而使用ID的方式,MOD在不同的服务器可能有不同的ID.\n每次换周目都要重新配置,无法一劳永逸.\n而minecraft在1.7.x中推出了用minecraft:tnt的形势give物品,没道理代码不行..\n故求正确姿势\n\n\n如何不附魔但显示附魔花纹\n类似经验瓶或者成书或者下界之星那样..",
    "replies": [
        {
            "author": "q88724653",
            "timestamp": 1444185720,
            "txt_content": "nbt应该可以"
        },
        {
            "author": "初音Py2001",
            "timestamp": 1444534500,
            "txt_content": "q88724653 发表于 2015-10-7 10:42\nnbt应该可以\n不太懂,望详细解释."
        },
        {
            "author": "Bryan33",
            "timestamp": 1444655280,
            "txt_content": "利用方法Bukkit.dispatchCommand(Sender,String)\n执行命令 如果要服务器执行请在Sender里填入Bukkit.getConsoleSender() 后面的String即为命令 不带/\n以此来执行原版/别的插件的命令"
        },
        {
            "author": "初音Py2001",
            "timestamp": 1445091060,
            "txt_content": "a390807154 发表于 2015-10-12 21:08\n利用方法Bukkit.dispatchCommand(Sender,String)\n执行命令 如果要服务器执行请在Sender里填入Bukkit.getCon ...\n我需要的是物品实例,而不是给玩家一个特殊的物品..."
        },
        {
            "author": "Bryan33",
            "timestamp": 1445091540,
            "txt_content": "初音Py2001 发表于 2015-10-17 22:11\n我需要的是物品实例,而不是给玩家一个特殊的物品...\nItemStack item = new ItemStack(Material.getMaterial(int id));以及\nItemStack item = new ItemStack(Material.getMaterial(String name));\n"
        },
        {
            "author": "云闪",
            "timestamp": 1445148000,
            "txt_content": "至于不附魔又显示花纹的话就不知道了= =你可以去看看Froge反编译出来的MineCraft的书这个类的源码"
        },
        {
            "author": "云闪",
            "timestamp": 1445148120,
            "txt_content": " 本帖最后由 splt 于 2015-10-18 14:06 编辑 \n\n看了一下服务器自带give命令的代码，发现他是这样获取物品实例的：\n       Material material = Material.matchMaterial(args[1]);\n       \n       if (material == null) {\n         material = Bukkit.getUnsafe().getMaterialFromInternalName(args[1]);\n       }\n代码很简单，如果从Material枚举类能获取到物品实例，那么就用获取到的实例，如果获取不到的话，会调用Bukkit.getUnsafe().getMaterialFromInternalName(String name)方法获取实例[这个方法的修饰符是public所有你应该可以直接用]\n\n那么这个参数怎么填呢\n\n我一路跟踪代码到最后，发现服务器自带的give命令的物品实例获取最终会调用到net.minecraft.server.v1_7_R1.RegistrySimple的a(Object paramObject)方法(之所以是a是因为没有反混淆= =)\n下面给出这个类的部分代码\n  private static final Logger a = ;\n  protected final Map c = a();\n  \n  protected Map a()\n  {\n    return Maps.newHashMap();\n  }\n  \n  public Object a(Object paramObject)\n  {\n    return this.c.get(paramObject);\n  }\n  \n  public void a(Object paramObject1, Object paramObject2)\n  {\n    if (this.c.containsKey(paramObject1)) {\n      a.warn(\"Adding duplicate key '\" + paramObject1 + \"' to registry\");\n    }\n    this.c.put(paramObject1, paramObject2);\n  }\n可以看到a(Object paramObject)方法是获取，而a(Object paramObject)方法获取的东西在a(Object paramObject1, Object paramObject2)方法会设置\n\n怎么设置的先不管，我又看到调用a(Object paramObject)方法之前有一行这样的代码来获取传入的参数：\nreturn paramString.indexOf(':') == -1 ? \"minecraft:\" + paramString : paramString;\n看得出来最后物品名会被转成minecraft:XXX的形式，从这一点看来参数填写minecraft:XXX或者XXX都是可以的XXX就是mod里定义的物品名字(不是显示的名字)，而这个定义的名字可以通过ESS插件的/itemdb命令获取(这个命令可以获取手上的物品的名字，就是\"物品简易名称\"那一栏，任选一个应该都可以的)"
        },
        {
            "author": "初音Py2001",
            "timestamp": 1445175600,
            "txt_content": "splt 发表于 2015-10-18 14:02\n看了一下服务器自带give命令的代码，发现他是这样获取物品实例的：\n\n代码很简单，如果从Material枚举类能获 ...\n大神缺腿部挂件么\n咱就是英语不好才看源码像天书.."
        },
        {
            "author": "云闪",
            "timestamp": 1445176860,
            "txt_content": "初音Py2001 发表于 2015-10-18 21:40\n大神缺腿部挂件么\n咱就是英语不好才看源码像天书..\n我都已经用中文讲明白了啊=￣ω￣="
        },
        {
            "author": "初音Py2001",
            "timestamp": 1445177820,
            "txt_content": "splt 发表于 2015-10-18 22:01\n我都已经用中文讲明白了啊=￣ω￣=\n恩,我已经知道该怎么用了"
        }
    ]
}