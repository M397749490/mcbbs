{
    "title": "扩展KMCCC MinecraftC#启动核心||优化&功能扩展篇",
    "author": "nsisogf",
    "replyCount": 18,
    "timestamp": 1511027220,
    "txt_content": "本篇前言：\n在深度优化和扩展KMCCC启动核心前，请您确保已提前阅读：http://www.mcbbs.net/thread-728419-1-3.html\n这能保证您对Minecraft的启动流程概念有一定的认知。\n\n在魔改KMCCC前，您必须了解：\nKMCCC遵循 GNU Lesser General Public License v3.0 协议\n简体中文协议原文：（若协议出现更新或冲突，请以官方最新版本为基础）GNU 通用公共授权 第三版 2007 年6 月29 日 版权所有（C ）2007 Free Software Foundation, Inc. (http://fsf.org) 允许所有人复制和发布本授权文件的完整版本 但不允许对它进行任何修改 导言 GNU 通用公共授权是一份针对软件和其他种类作品的自由的、公共的授权文件。 大多数软件授权申明被设计为剥夺您共享和修改软件的自由。相反地，GNU 通用公共授权力图保护您分享和修改自由软件地自由——以确保软件对所有使用者都是自由的。我们，自由软件基金会，对我们的大多数软件使用GNU 通用公共授权；本授权同样适用于任何其作者以这种方式发布的软件。您也可以让您的软件使用本授权。 当我们谈论自由软件时，我们指的是行为的自由，而非价格免费。GNU 通用公共授权被设计为确保您拥有发布自由软件副本( 以及为此收费，如果您希望的话) 的自由, 确保您能收到源代码或者在您需要时能获取源代码，确保您能修改软件或者将它的一部分用于新的自由软件，并且确保您知道您能做这些事情。 为了保护您的权利，我们需要做出要求，禁止任何人否认您的这些权利或者要求您放弃这些权利。因此，如果您发布此软件的副本或者修改它，您就需要肩负起尊重他人自由的责任。 例如，如果您发布自由软件的副本，无论以免费还是以收费的模式，您都必须把您获得的自由同样的给予副本的接收者。您必须确保他们也能收到或者得到源代码。而且您必须向他们展示这些条款，以使他们知道自己享有这样的权利。 使用GNU 通用公共授权的开发者通过两项措施来保护您的权利：（1 ）声明软件的版权；（2 ）向您提供本授权文件以给您复制、发布并且/ 或者修改软件的法律许可。 为了保护软件开发者和作者，通用公共授权明确阐释自由软件没有任何担保责任。如用户和软件作者所希望的，通用公共授权要求软件被修改过的版本必须明确标示，从而避免它们的问题被错误地归咎于先前的版本。 某 些设备被设计成拒绝用户安装或运行其内部软件的修改版本，尽管制造商可以安装和运行它们。这从根本上违背了通用公共授权保护用户能修改软件的自由的宗旨。 此类滥用本授权的系统模式出现在了最让人无法接受的个人用户产品领域。因此，我们设计了这个版本的通用公共授权来禁止那些产品的侵权行为。如果此类问题在 其他领域大量出现，我们准备好了在将来的通用公共授权版本里扩展这项规定，以保护用户的自由。 最 后，每个程序都经常受到软件专利的威胁。政府不应该允许专利权限制通用计算机软件的发展和使用，但是在政府确实允许这种事情的地区，我们希望避免应用于自 由软件的专利权使该软件有效私有化的危险。为了阻止这样的事情的发生，通用公共授权确保没有人能够使用专利权使得自由软件非自由化。 以下是复制，发布和修改软件的详细条款和条件。   条款和条件   0. 定义 “ 本授权” 指GNU 通用公共授权第三版 “ 版权” 一词同样指适用于其他产品如半导体掩膜等的保护版权的法律。 “ 本程序” 指任何在本授权下发布的受版权保护的作品。被授权人称为“您”。“被授权人”和“版权接受者”可以是个人或组织。 “修改”作品是指从软件中拷贝或者做出全部或一丁点儿的修改，这不同于逐字逐句的复制，是需要版权许可的。修改成果被称为先前作品的“修改版本”或者“基于”先前作品的软件。 “覆盖程序”指 未被修改过的本程序或者基于本程序的程序 。 “传播”程序指使用该程序做任何如果没有许可就会在适用的版权法下直接或间接侵权的事情，不包括在电脑上执行程序或者是做出您不与人共享的修改。传播包括复制，分发（无论修改与否），向公众共享，以及在某些国家的其他行为。 “发布”作品指任何让其他组织制作或者接受副本的传播行为。仅仅通过电脑网络和一个用户交流，且没有发送程序拷贝的行为不是发布。 一个显示“适当的法律通告”的交互的用户接口应包括这样一个方便而显著的可视部件，它具有以下功能：（1 ）显示一个合适的版权通告；（2 ）告诉用户对本程序没有任何担保责任（除非有担保明确告知），受权人可以在本授权下发布本程序，以及如果阅读本授权协议的副本。如果该接口显示了一个用户命令或选项列表，比如菜单，该列表中的选项需要符合上述规范。   1 ．源代码 “源代码”指修改程序常用的形式。“目标代码”指程序的任何非源代码形式。 “标准接口”有两种含义, 一是由标准组织分支定义的官方标准；二是针对某种语言专门定义的众多接口中，在该类语言的开发者中广为使用的那种接口。 可 执行程序的“系统库”不是指整个程序，而是指任何包含于主要部件但不属于该部件的部分，并且只是为了使能该部件而开发，或者为了实现某些已有公开源代码的 标准接口。“主要部件”在这里指的是执行程序的特定操作系统（如果有的话）的主要的关键部件（内核，窗口系统等），或者生成该可执行程序时使用的编译器， 或者运行该程序的目标代码解释器。 目 标代码中的程序“对应的源代码”指所有生成，安装，（对可执行程序而言）运行该目标代码和修改该程序所需要的源代码，包括控制这些行为的脚本。但是，它不 包括程序需要的系统库，通用目的的工具，以及程序在完成某些功能时不经修改地使用的那些不包括在程序中的普遍可用的自由软件。例如，对应的源代码包括与程 序的源文件相关的接口定义文件，以及共享库中的源代码和该程序设计需要的通过如频繁的数据交互或者这些子程序和该程序其他部分之间的控制流等方式获得的动 态链接子程序。 对应的源代码不需要包含任何拥护可以从这些资源的其他部分自动再生的资源。 源代码形式的程序对应的源代码定义同上。   2 ．基本的许可 所 有在本授权协议下授予的权利都是对本程序的版权而言，并且只要所述的条件都满足了，这些授权是不能收回的。本授权明确的确认您可以不受任何限制地运行本程 序的未修改版本。运行一个本授权覆盖的程序获得的结果只有在该结果的内容构成一个覆盖程序的时候才由本授权覆盖。本授权承认您正当使用或版权法规定的其它 类似行为的权利。 只 要您的授权仍然有效，您可以无条件地制作，运行和传播那些您不发布的覆盖程序。只要您遵守本授权中关于发布您不具有版权的资料的条款，您可以向别人发布覆 盖程序，以要求他们为您做出专门的修改或者向您提供运行这些程序的简易设备。那些为您制作或运行覆盖程序的人作为您专门的代表也必须在您的指示和控制下做 到这些，请禁止他们在他们和您的关系之外制作任何您拥有版权的程序的副本。 当下述条件满足的时候，在任何其他情况下的发布都是允许的。 转授许可证授权是不允许的，第10 节让它变的没有必要了。   3 ．保护用户的合法权利不受反破解法侵犯 在任何实现1996 年通过的世界知识产权组织版权条约第11 章中所述任务的法律，或者是禁止或限制这种破解方法的类似法律下，覆盖程序都不会被认定为有效的技术手段的一部分。 当您发布一个覆盖程序时，您将放弃任何禁止技术手段破解的法律力量，甚至在本授权关于覆盖程序的条款下执行权利也能完成破解。同时，您放弃任何限制用户操作或修改该覆盖程序以执行您禁止技术手段破解的合法权利的企图。   4 ．发布完整副本 你可以通过任何媒介发布本程序源代码的未被修改过的完整副本，只要您显著而适当地在每个副本上发布一个合适的版权通告；保持完整所有叙述本授权和任何按照第7 节加入的非许可的条款；保持完整所有的免责申明；并随程序给所有的接受者一份本授权。 您可以为您的副本收取任何价格的费用或者免费，你也可以提供技术支持或者责任担保来收取费用。   5 ．发布修改过的源码版本 您可以在第4 节的条款下以源码形式发布一个基于本程序的软件，或者从本程序中制作该软件需要进行的修改，只要您同时满足所有以下条件： * a ）制作的软件必须包含明确的通告说明您修改了它，并给出相应的修改日期。 * b ）制作的软件必须包含明确的通告，陈述它在本授权下发布并指出任何按照第7 节加入的条件。这条要求修改了第4 节的“保持所有通知完整”的要求。 * c ）您必须把整个软件作为一个整体向任何获取副本的人按照本授权协议授权。本授权因此会和任何按照第7 节加入的条款一起，对整个软件及其所有部分，无论是以什么形式打包的，起法律效力。本授权不允许以其他任何形式授权该软件，但如果您个别地收到这样的许可，本授权并不否定该许可。 * d ）如果您制作的软件包含交互的用户接口，每个用户接口都必须显示适当的法律通告；但是，如果本程序包含没有显示适当的法律通告的交互接口，您的软件没有必要修改他们让他们显示。 如 果一个覆盖程序和其他本身不是该程序的扩展的程序的联合体，这样的联合的目的不是为了在某个存储或发布媒体上生成更大的程序，且联合体程序和相应产生的版 权没有用来限制程序的使用或限制单个程序赋予的联合程序的用户的合法权利的时候，这样的联合体就被称为“聚集体”。在聚集体中包含覆盖程序并不会使本授权 应用于该聚集体的其他部分。   6 ．发布非源码形式的副本 您可以在第4,5 节条款下以目标代码形式发布程序，只要您同时以一下的一种方式在本授权条款下发布机器可读的对应的源代码： * a ）在物理产品（包括一个物理的发布媒介）中或作为其一部分发布目标代码，并在通常用于软件交换的耐用的物理媒介中发布对应的源代码。 * b ）在物理产品（包括一个物理的发布媒介）中或作为其一部分发布目标代码，并附上有效期至少3 年且与您为该产品模型提供配件或客户服务的时间等长的书面承诺，给予每个拥有该目标代码的人（1 ）要么在通常用于软件交换的耐用物理媒介中，以不高于您执行这种源码的发布行为所花费的合理费用的价格，一份该产品中所有由本授权覆盖的软件的对应的源代码的拷贝；（2 ）要么通过网络服务器免费提供这些对应源代码的访问。 * c ）单独地发布目标代码的副本，并附上一份提供对应源代码的书面承诺。这种行为只允许偶尔发生并不能盈利，且在您收到的目标代码附有第6 节b 规定的承诺的时候。 * d ） 在指定的地点（免费或收费地）提供发布的目标代码的访问并在同样的地点以不增加价格的方式提供对应源代码的同样的访问权。您不需要要求接收者在复制目标代 码的时候一道复制对应的源代码。如果复制目标代码的地点是网络服务器，对应的源代码可以在另外一个支持相同复制功能的服务器上（由您或者第三方运作），只 要您在目标代码旁边明确指出在哪里可以找到对应的源代码。无论什么样的服务器提供这些对应的源代码，您都有义务保证它在任何有需求的时候都可用，从而满足 本条规定。 * e ）用点对点传输发布目标代码，您需要告知其他的节点目标代码和对应的源代码在哪里按照第6 节d 的条款向大众免费提供。 目标代码中可分离的部分，其源代码作为系统库不包含在对应的源代码中，不需要包含在发布目标代码的行为中。 “用户产品”指（1 ）“消费品”，即通常用于个人的、家庭的或日常目的的有形个人财产；或者（2 ） 任何为公司设计或销售却卖给了个人的东西。在判断一个产品是否消费品时，有疑点的案例将以有利于覆盖面的结果加以判断。对特定用户接收到的特定产品，“正 常使用”指该类产品的典型的或通常的使用，无论该用户的特殊情况，或者该用户实际使用该产品的情况，或者该产品要求的使用方式如何。一个产品是否是消费品 与该产品是否具有实质的经济上的、工业的或非消费品的用处无关，除非该用处是此类产品唯一的重要使用模式。 用户产品的“安装信息”指从对应源码的修改版本安装和运行该用户产品中包含的覆盖程序的修改版本所需要的任何方法、过程、授权密钥或其他信息。这些信息必须足以保证修改后的目标代码不会仅仅因为被修改过而不能继续运行。 如 果您在本节条款下在用户产品中，或随同，或专门为了其中的使用，发布目标代码程序，而在发布过程中用户产品的所有权和使用权都永久地或在一定时期内（无论 此项发布的特点如何）传递给了接收者，在本节所述的条款下发布的对应的源代码必须包含安装信息。但是如果您或者任何第三方组织都没有保留在用户产品上安装 修改过的目标代码的能力（比如程序被安装在了ROM 上），那么这项要求不会生效。 提供安装信息的要求并没有要求为接收者修改或安装过的程序，或者修改或安装该程序的用户产品，继续提供支持服务、担保或升级。当修改本身实际上相反地影响了网络的运行，或者违反了网络通信的规则和协议时，网络访问可以被拒绝。 根据本节发布的对应源代码和提供的安装信息必须以公共的文件格式发布（并附加一个该类型文档的实现方法以源码形式向公众共享），解压缩、阅读或复制这些信息不能要求任何密码。   7 ．附加条款 “附 加许可”是通过允许一些本授权的特例来补充本授权的条款。只要它们在使用法律下合法，对整个程序都生效的附加许可就应当被认为是本授权的内容。如果附加许 可只是对本程序的一部分生效，那么该部分可以在那些许可下独立使用，但整个程序是在本授权管理下，无论附加许可如何。 当您发布覆盖程序的副本时，您可以选择删除该副本或其部分的任何附加许可。（当您修改程序时，附加许可可能要求在某些情况下将自身删除）。您可以把附加许可放在材料上，加入到您拥有或能授予版权许可的覆盖程序中。 尽管本授权在别处有提供，对于您加入到程序中的材料，您可以（如果您由该材料的版权所有者授权的话）用以下条款补充本授权： a. 拒绝担保责任或以与本授权第15 和16 小节条款不同的方式限制责任；或者 b. 要求保留特定的合理法律通告，或者该材料中或包含于适当法律通告中的该程序的作者贡献；或者 c. 禁止误传该材料的来源，或者要求该材料的修改版本以合理的方式标志为与原版本不同的版本；或者 d. 限制以宣传为目的的使用该材料作者或授权人的姓名；或者 e. 降低授权级别以在商标法下使用一些商品名称，商标或服务标记；或者 f. 要求任何发布该材料（或其修改版本）的人用对接收者的责任假设合同对授权人和材料作者进行保护，避免任何这样的假设合同直接造成授权人和作者的责任。 所有其他不许可的附加条款都被认为是第10 节 中的“进一步的约束”。如果您收到的程序或者其部分，声称自己由本授权管理，并补充了进一步约束，那么您可以删除这些约束。如果一个授权文件包含进一步约 束，但是允许再次授权或者在本授权下发布，只要这样的进一步的约束在这样的再次授权或发布中无法保留下来，您就可以在覆盖程序中加入该授权文件条款管理下 的材料。 如果您依据本小节向覆盖程序添加条款, 您必须在相关的源码文件中加入一个应用于那些文件的附加条款的声明或者指明在哪里可以找到这些条款的通告。 附加的条款，无论是许可的还是非许可的条款，都可以写在一个单独的书面授权中，或者申明为例外情况；这两种方法都可以实现上述要求。 8 ．终止授权 您只有在本授权的明确授权下才能传播或修改覆盖程序。任何其它的传播或修改覆盖程序的尝试都是非法的，并将自动终止您在本授权下获取的权利（包括依据第11 节第三段条款授予的任何专利授权）。 然而，如果您停止违反本授权，那么您从某个特定版权所有者处获取的授权许可能够以以下方式恢复（a ）您可以暂时地拥有授权，直到版权所有者明确地终止您的授权；（b ）如果在您停止违反本授权后的60 天内，版权所有者没有以某种合理的方式告知您的违背行为，那么您可以永久地获取该授权。 进一步地， 如果某个 版权所有者以某种合理的方式告知您违反本授权的行为， 而这是您第一次收到来自该版权所有者的违反本授权的通知（对任何软件），并且在收到通知后30 天内修正了违反行为，那么 您从该版权所有者处获取的授权将永久地恢复。 当您的授权在本节条款下被终止时，那些从您那获取授权的组织只要保持不违反本授权协议，其授权就不会被终止。您只有在授权被版权所有者恢复了之后才有资格依据第10 节的条款获取该材料的新的授权。 9. 获取副本不需要接受本授权 您 不需要为了接收或运行本程序的副本而接受本授权协议。仅仅是因为点对点传输获取副本引起传播行为，也不要求您接受本授权协议。然而，除了本授权外，任何授 权协议都不能授予您传播或修改覆盖程序的许可。因此，如果您修改或者传播了本程序的副本，那么您就默认地接受了本授权。   10. 下游接收者的自动授权 每次您发布覆盖程序，接收者都自动获得一份来自原授权人的依照本授权协议运行、修改和传播该程序的授权。依据本授权，您不为执行任何第三方组织的要求负责。 “实 体事务”指转移一个组织的控制权或全部资产，或者拆分组织，或者合并组织的事务。如果覆盖程序的传播是实体事务造成的，该事务中每一个接收本程序副本的组 织都将获取一份其前身拥有的或者能够依据前面的条款提供的任何授权，以及从其前身获取程序对应的源代码的权利，如果前身拥有或以合理的努力能够获取这些源 代码的话。 您不可以对从本授权协议获取或确认的权利的执行强加任何约束。比如，您不可以要求授权费用，版税要求或对从本授权获取的权利的执行收取任何费用。您不可以发起诉讼（包括联合诉讼和反诉）声称由于制作、使用、销售、批发或者引进本程序或其任何一部分而侵犯了任何专利权。   11 ．专利权 “贡献者”是在本授权下授予本程序或者本程序所基于的程序的使用权的版权所有者。这样的程序被成为贡献者的“贡献者版本”。 一 个贡献者的“实质的专利申明”是该贡献者所占有和控制的全部专利，无论已经获得的还是在将来获得的，那些可能受到某种方式侵犯的专利权。本授权允许制作、 使用和销售其贡献者版本，但不包括那些只会由于对贡献者版本进一步的修改而受到侵犯的专利的申明。为此，“控制”一词包括以同本授权要求一致的方式给予从 属授权的权利。 每个贡献者在该贡献者的实质的专利申明下授予您非独家的，全世界的，不需要版税的专利授权，允许您制作、使用、销售、批发、进口以及运行、修改和传播其贡献者版本内容。 在以下三个自然段中，“专利授权”指任何形式表达的不执行专利权的协议或承诺（例如使用专利权的口头许可，或者不为侵犯专利而起诉的契约）。向一个组织授予专利授权指做出这样的不向该组织提出强制执行专利权的承诺。 如果您在自己明确知道的情况下发布基于某个专利授权的覆盖程序，而这个程序的对应的源代码并不能在本授权条款下通过网络服务器或其他有效途径免费地向公众提供访问，您必须做到：（1 ）使对应的源代码按照上述方法可访问；或者（2 ）放弃从该程序的专利授权获取任何利益；或者（3 ） 以某种与本授权要求一致的方法使该专利授权延伸到下游的接收者。“在自己明确知道的情况下”指您明确地知道除了获取专利授权外，在某个国家您传播覆盖程序 的行为，或者接收者使用覆盖程序的行为，会由于该专利授权而侵犯一个或多个在该国可确认的专利权，而这些专利权您有足够的理由相信它们是有效的。 在依照或者涉及某一次事务或安排时，如果您通过获取发布或传播覆盖程序的传输版本，并给予接收该覆盖程序的某些组织专利授权，允许他们使用，传播，修改或者发布该覆盖程序的特殊版本，那么您赋予这些组织的专利授权将自动延伸到所有该覆盖程序及基于该程序的作品的接收者。 一 份专利授权是“有偏见的”，如果它没有在自身所覆盖的范围内包含，禁止行使，或者要求不执行一个或多个本授权下明确认可的权利。以下情况，您不可以发布一 个覆盖程序：如果您与软件发布行业的第三方组织有协议，而该协议要求您根据该程序的发布情况向该组织付费，同时该组织在你们的协议中赋予任何从您那里获得 覆盖软件的组织一份有偏见的专利授权，要么（a ）连同您所发布的副本（或者从这些副本制作的副本）；要么（b ）主要为了并连同某个的产品或者包含该覆盖程序的联合体。如果您签署该协议或获得该专利授权的日期早于2007 年3 月28 日，那么您不受本条款约束。 本授权的任何部分不会被解释为拒绝或者限制任何暗含的授权或其他在适用专利权法下保护您的专利不受侵犯的措施。 12 ．不要放弃别人的自由 如 果您遇到了与本授权向矛盾的情况（无论是法庭判决，合同或者其他情况），它们不能使您免去本授权的要求。如果您不能同时按照本授权中的义务和其他相关义务 来发布覆盖程序，那么您将不能发布它们。比如，如果您接受了要求您向从您这里或许本程序的人收取版税的条款，您唯一能够同时满足本授权和那些条款的方法是 完全不要发布本程序。 13 ．和GNU Affero 通用公共授权一起使用 尽管本协议有其他防备条款，您有权把任何覆盖程序和基于第三版GNU Affero 通用公共授权的程序链接起来，并且发布该联合程序。本授权的条款仍然对您的覆盖程序有效，但是GNU Affero 通用公共授权第13 节关于通过网络交互的要求会对整个联合体有效。 14 ．本授权的修订版 自由软件基金会有时候可能会发布GNU 通用软件授权的修订版本和/ 或新版本。这样的新版本将会和现行版本保持精神上的一致性，但是可能会在细节上有所不同，以处理新的问题和情况。 每个版本都有一个单独的版本号。如果本程序指出了应用于本程序的一个特定的GNU 通用公共授权版本号“以及后续版本”，您将拥有选择该版本或任何由自由软件基金会发布的后续版本中的条款和条件的权利。如果本程序没有指定特定的GNU 通用公共授权版本号，那么您可以选择任何自由软件基金会已发布的版本。 如果本程序指出某个代理可以决定将来的GNU 通用公共授权是否可以应用于本程序，那么该代理的接受任何版本的公开称述都是您选择该版本应用于本程序的永久认可。 后续的授权版本可能会赋予您额外的或者不同的许可。但是，您对后续版本的选择不会对任何作者和版权所有者强加任何义务。   15 ．免责申明 在适用法律许可下，本授权不对本程序承担任何担保责任。除非是书面申明，否则版权所有者和/ 或提供本程序的第三方组织，“照旧”不承担任何形式的担保责任，无论是承诺的还是暗含的，包括但不限于就适售性和为某个特殊目的的适用性的默认担保责任。有关本程序质量与效能的全部风险均由您承担。如本程序被证明有瑕疵，您应承担所有必要的服务、修复或更正的费用。 16 ．责任范围 除非受适用法律要求或者书面同意，任何版权所有者，或任何依前述方式修改和/ 或 发布本程序者，对于您因为使用或不能使用本程序所造成的一般性、特殊性、意外性或间接性损失，不负任何责任（包括但不限于，资料损失，资料执行不精确，或 应由您或第三人承担的损失，或本程序无法与其他程序运作等），即便该版权所有者或其他组织已经被告知程序有此类损失的可能性也是如此。 17 ．第15 和16 节的解释 如果上述免责申明和责任范围不能按照地方法律条款获得法律效力，复审法庭应该采用最接近于完全放弃关于本程序的民事责任的法律，除非随同本程序的责任担保或责任假设合同是收费的。   - 条款和条件结束- 如何在您的新程序中应用这些条款？ 如果您开发了一个新程序，并且希望能够让它尽可能地被大众使用，达成此目的的最好方式就是让它成为自由软件。任何人都能够依据这些条款对该软件再次发布和修改。 为了做到这一点，请将以下声明附加到程序上。最安全的作法，是将声明放在每份源码文件的起始处，以有效传达无担保责任的讯息；且每份文件至少应有「版权」列以及本份声明全文位置的提示。  < 用一行描述程序的名称与其用途简述> 版权所有(C) < 年份>< 作者姓名> 本程序为自由软件；您可依据自由软件基金会所发表的GNU 通用公共授权条款，对本程序再次发布和/ 或修改；无论您依据的是本授权的第三版，或（您可选的）任一日后发行的版本。 本程序是基于使用目的而加以发布，然而不负任何担保责任；亦无对适售性或特定目的适用性所为的默示性担保。详情请参照GNU 通用公共授权。 您应已收到附随于本程序的GNU 通用公共授权的副本；如果没有，请参照 . 同时附上如何以电子及书面信件与您联系的资料。 如果程序进行终端交互方式运作，请在交互式模式开始时，输出以下提示： < 程序> 版权所有(C) < 年份> < 作者姓名> 本程序不负任何担保责任，欲知详情请键入'show w' 。 这是一个自由软件，欢迎您在特定条件下再发布本程序；欲知详情请键入'show c' 。 所假设的指令'show w' 与'show c' 应显示通用公共授权的相对应条款。当然，您可以使用'show w' 与'show c' 以外的指令名称；对于图形用户界面，您可以用“关于”项代实现此功能。 如有需要，您还应该取得您的雇主（若您的工作为程序设计师）或学校就本程序所签署的“版权放弃承诺书”。欲知这方面的详情，以及如何应用和遵守GNU 通用公共授权，请参考  GNU 通用公共授权并不允许您将本程序合并到私有的程序中。若您的程序是一个子程序库，您可能认为允许私有的应用程序链接该库会更有用。如果这是您所想做的，请使用GNU 松弛通用公共授权代替本授权。但这样做之前，请阅读 \n根据协议原文第五条：\n5 ．发布修改过的源码版本\n您可以在第4 节的条款下以源码形式发布一个基于本程序的软件，或者从本程序中制作该软件需要进行的修改，只要您同时满足所有以下条件：\n* a ）制作的软件必须包含明确的通告说明您修改了它，并给出相应的修改日期。\n* b ）制作的软件必须包含明确的通告，陈述它在本授权下发布并指出任何按照第7 节加入的条件。这条要求修改了第4 节的“保持所有通知完整”的要求。\n* c ）您必须把整个软件作为一个整体向任何获取副本的人按照本授权协议授权。本授权因此会和任何按照第7 节加入的条款一起，对整个软件及其所有部分，无论是以什么形式打包的，起法律效力。本授权不允许以其他任何形式授权该软件，但如果您个别地收到这样的许可，本授权并不否定该许可。\n* d ）如果您制作的软件包含交互的用户接口，每个用户接口都必须显示适当的法律通告；但是，如果本程序包含没有显示适当的法律通告的交互接口，您的软件没有必要修改他们让他们显示。\n如 果一个覆盖程序和其他本身不是该程序的扩展的程序的联合体，这样的联合的目的不是为了在某个存储或发布媒体上生成更大的程序，且联合体程序和相应产生的版 权没有用来限制程序的使用或限制单个程序赋予的联合程序的用户的合法权利的时候，这样的联合体就被称为“聚集体”。在聚集体中包含覆盖程序并不会使本授权 应用于该聚集体的其他部分。重点：您，包括我们在内，需要在修改后的KMCCC核心中明确注明您曾进行修改，以及修改日期。尊重他人劳动\n在本帖中，由于发布的是零散需要修改区域的代码，就不再进行声明\nKMCCC著作权归原作者（们）所有（原帖地址http://www.mcbbs.net/thread-492606-1-1.html）\n\n下面我们将开始一步步进行优化",
    "replies": [
        {
            "author": "nsisogf",
            "timestamp": 1511027640,
            "txt_content": "环境声明：\n本贴的KMCCC使用的为2017年11月15日最新更新的版本\n并不保证KMCCC之后的更新会不会与本优化教程进行冲突。如果没有特殊情况，每次KMCCC的更新我都会同步进行说明和更新\n本贴使用的IDE为VisualStudio 2017\n请确保您已下载KMCCC最新版本并保存（GITHUB链接：https://github.com/MineStudio/KMCCC）"
        },
        {
            "author": "nsisogf",
            "timestamp": 1511241660,
            "txt_content": " 本帖最后由 nsisogf 于 2017-11-24 20:10 编辑 \n\n第一章：优化KMCCC的JAVA策略I-\n在KMCCC中，获取JAVA的唯一路径只能从注册表中获取一组JAVA路径的列表。并不能区分，标识各个java版本的不同（版本？位数？）\n在查询和操作时，也导致了非常大的不便。由此我们第一件事是优化KMCCC的JAVA路径\n\n打开原装KMCCC工程，可以见到有以下项目：\n\nKMCCC.Basic：调用核心示例文件\nKMCCC.Pro：添加了更多支持（MOJANG API）的核心调用示例文件\nKMCCC.Shared：KMCCC核心本体\nKMCCC.Simple：使用KMCCC的简单命令台示例\n\n打开KMCCC.Shared，我们开始对KMCCC的JAVA策略进行优化\n打开Tools文件夹，新建一个Java.cs(Java Class)，并将JAVA类\n\n\n将SystemTools.cs中的有关JAVA的静态方法移动至JAVA类中\n将方法名FindJava()改为FindJavaPath()\nFindJavaInternal(RegistryKey registry)改为FindJavaPathInternal(RegistryKey registry)\n\n完成后如下（截图时未改名，请自行改名）：\n\n\n我们知道，JAVA环境的三要素有：版本，位数，路径。在开发启动器时，我们都会经常使用到。（例如提供给用户选择java版本，根据用户环境判断java位数等...）\n\n那么现在我们为这三要素添加至JAVA类中（非静态，我们需要每一个JAVA的实例）\n再JAVA类中添加：\n/// <summary>\n        /// JAVA路径\n        /// </summary>\n        public string Path { get; private set; }\n\n        /// <summary>\n        /// JAVA版本\n        /// </summary>\n        public string Version { get; private set; }\n\n        /// <summary>\n        /// java位数\n        /// </summary>\n        public ArchEnum Arch { get; private set; }\n\n        /// <summary>\n        /// 位数ENUM\n        /// </summary>\n        public enum ArchEnum\n        {\n            x32,\n            x64\n        }复制代码\n接下来，在这个类中创建构建函数，保证在创建实例时能为每个属性赋值。\npublic Java(string path, string version, ArchEnum arch)\n        {\n            this.Path = path;\n            this.Version = version;\n            this.Arch = arch;\n        }复制代码\n因为KMCCC已经提供获取java路径列表的方法，我们就不多进行更改。现在我们需要根据java路径获取java具体信息（单个）\n下面代码的实现原理，请详情参考：http://www.mcbbs.net/thread-704797-1-1.html（也可以参考这贴中其他人提供的方法） /// <summary>\n        /// 根据路径获取单个JAVA详细信息\n        /// </summary>\n        /// <param name=\"javaPath\"></param>\n        /// <returns></returns>\n        public static Java GetJavaInfo(string javaPath)\n        {\n            Process p = new Process();\n            p.StartInfo.FileName = javaPath;\n            p.StartInfo.Arguments = \"-version\";\n            p.StartInfo.RedirectStandardError = true;\n            p.StartInfo.UseShellExecute = false;\n            p.StartInfo.CreateNoWindow = true;\n            p.Start();\n            string result = p.StandardError.ReadToEnd();\n            string version = result.Replace(\"java version \"\", \"\");\n            version = version.Remove(version.IndexOf(\"\"\"));\n            bool is64 = result.Contains(\"64-Bit\");\n            Java info;\n            if (is64) { info = new Java(javaPath, version, ArchEnum.x64); } else { info = new Java(javaPath, version, ArchEnum.x32); }\n            p.Dispose();\n            return info;\n        }复制代码\n\n\n\n接下来，我们可以创建一个公共方法，对外部提供JAVA实例列表：\n/// <summary>\n        /// 获取本机所有JAVA列表\n        /// </summary>\n        /// <returns></returns>\n        public static List<Java> GetJavaList()\n        {\n            var javaPaths = FindJavaPath();\n            List<Java> javas = new List<Java>();\n            foreach (string item in javaPaths)\n            {\n                //判断文件是否存在\n                if (File.Exists(item))\n                {\n                    javas.Add(GetJavaInfo(item));\n                }\n            }\n            return javas;\n        }复制代码\n\n为了方便接下来的外部使用，创建一个公共方法，获取本机最佳JAVA：\n/// <summary>\n        /// 从本机JAVA中获取最符合此电脑的JAVA版本\n        /// </summary>\n        /// <param name=\"javalist\">JAVA详细信息集合</param>\n        /// <returns>最佳JAVA详细信息</returns>\n        public static Java GetSuitableJava()\n        {\n            List<Java> javalist = GetJavaList();\n            List<Java> goodjava = new List<Java>();\n            if (SystemTools.GetArch() == \"64\")\n            {\n                foreach (var item in javalist)\n                {\n                    if (item.Arch == ArchEnum.x64)\n                    {\n                        goodjava.Add(item);\n                    }\n                }\n\n                if (goodjava.Count == 0)\n                {\n                    goodjava.AddRange(javalist);\n                }\n            }\n            else\n            {\n                goodjava = javalist;\n            }\n            goodjava = goodjava.OrderByDescending(a => a.Version).ToList();\n            return goodjava.FirstOrDefault();\n        }复制代码\n\n下一章我们将修改KMCCC中全部跟JAVA有关的东西\n\n"
        },
        {
            "author": "nsisogf",
            "timestamp": 1511502300,
            "txt_content": "第一章：优化KMCCC的JAVA策略II\n上次我们已经成功创建了Java类。但是我们光创建是没用的，我们要将其应用在KMCCC中。\n在LaucherCore.cs中，找到LauncherCoreCreationOption这个class\n将其中的属性\n/// <summary>\n                ///     JAVA地址\n                /// </summary>\n                public string JavaPath { get; internal set; }复制代码修改为下面的\n/// <summary>\n                /// 使用的JAVA\n                /// </summary>\n                public Java Java { get; internal set; }复制代码这样，我们在创建核心的时候，就可以传递一个JAVA实例参数了。核心也有更高的拓展性了\n\n修改完后，追踪程序的报错（红色波浪线），就可以方便的找到另一个修改的位置\n第一个报错的在这个方法力LauncherCoreCreationOption的构造函数中（背景色黄色）：\n/// <summary>\n                ///     核心选项\n                /// </summary>\n                /// <param name=\"gameRootPath\">游戏根目录，默认为 ./.minecraft </param>\n                /// <param name=\"javaPath\">JAVA地址，默认为自动搜寻所的第一个</param>\n                /// <param name=\"versionLocator\">Version定位器，默认为 JVersionLoacator</param>\n                public LauncherCoreCreationOption(string gameRootPath = null, string javaPath = null, IVersionLocator versionLocator = null)\n                {\n                        GameRootPath = new DirectoryInfo(gameRootPath ?? \".minecraft\").FullName;\n<span style=\"background-color: yellow;\">                        JavaPath</span> = <span style=\"background-color: yellow;\">javaPath</span> ?? <span style=\"background-color: yellow;\">SystemTools.FindJava().FirstOrDefault();</span>\n                        VersionLocator = versionLocator ?? new JVersionLocator();\n                        if (!Directory.Exists(GameRootPath))\n                        {\n                                Directory.CreateDirectory(GameRootPath);\n                        }\n                }复制代码第一个报错是因为这个类中不再存在JavaPath这个属性，我们已经将属性JavaPath改名为Java，同理，这里的JavaPath改为Java\n第二个报错是因为传递过来的javaPath参数为字符串。将参数中的string javaPath改为Java java即可\n第三个报错是因为systemTools中不再存在关于获取Java的方法。我们已经将其转移到Java这个Class中\n如果这时候你观察原版的代码，你会发现：原版KMCCC真的简单粗暴，如果你没有指定java路径的话，他直接选择List<string>Java路径中的第一位\n这时候我们前面做的GetSuitableJava()方法就起到作用了。他能自动选择这台电脑最匹配的Java实例：\nJava = java ?? Java.GetSuitableJava();复制代码\n到最后全部修改完的效果是这样的：\n/// <summary>\n                ///     核心选项\n                /// </summary>\n                /// <param name=\"gameRootPath\">游戏根目录，默认为 ./.minecraft </param>\n                /// <param name=\"java\">JAVA实例，自动搜索最佳匹配的java</param>\n                /// <param name=\"versionLocator\">Version定位器，默认为 JVersionLoacator</param>\n                public LauncherCoreCreationOption(string gameRootPath = null, Java java = null, IVersionLocator versionLocator = null)\n                {\n                        GameRootPath = new DirectoryInfo(gameRootPath ?? \".minecraft\").FullName;\n<span style=\"background-color: yellowgreen;\">                        Java = java ?? Java.GetSuitableJava()</span>;\n                        VersionLocator = versionLocator ?? new JVersionLocator();\n                        if (!Directory.Exists(GameRootPath))\n                        {\n                                Directory.CreateDirectory(GameRootPath);\n                        }\n                }复制代码\n\n追踪到下一个错误点，是这里：\n[Obsolete]\n                public static LauncherCoreCreationOption Create(string gameRootPath = null, string javaPath = null, IVersionLocator versionLocator = null)\n                {\n                        return new LauncherCoreCreationOption(gameRootPath, <span style=\"background-color: yellow;\">javaPath</span>, versionLocator);\n                }复制代码老样子，javaPath参数为字符串，不匹配这个方法。修改为Java类型的即可\n[Obsolete]\n                public static LauncherCoreCreationOption Create(string gameRootPath = null, <span style=\"background-color: yellowgreen;\">Java java = null</span>, IVersionLocator versionLocator = null)\n                {\n                        return new LauncherCoreCreationOption(gameRootPath, java, versionLocator);\n                }复制代码\n\n继续追踪下一个错误点：\n/// <summary>\n                ///     从CreationOption创建启动器核心\n                /// </summary>\n                /// <param name=\"option\">启动器创建选项</param>\n                /// <returns>创建的启动器核心</returns>\n                public static LauncherCore Create(LauncherCoreCreationOption option)\n                {\n                        var launcherCore = new LauncherCore\n                        {\n                                GameRootPath = option.GameRootPath,\n                                JavaPath = <span style=\"background-color: yellow;\">option.JavaPath</span>,\n                                VersionLocator = option.VersionLocator\n                        };\n                        return launcherCore;\n                }复制代码这个错误是因为：1.这个类的JavaPath为字符串类型，而option.Java是Java类型。2.option.JavaPath已经被我们改名了。\n先找到LauncherCore中的JavaPath属性\n/// <summary>\n                ///     JAVA目录\n                /// </summary>\n                public string JavaPath { get; set; }复制代码修改为Java类型：\n/// <summary>\n                ///     JAVA\n                /// </summary>\n                public Java Java { get; set; }复制代码\n\n接下来回到Create(LauncherCoreCreationOption option)方法，修改：\n/// <summary>\n                ///     从CreationOption创建启动器核心\n                /// </summary>\n                /// <param name=\"option\">启动器创建选项</param>\n                /// <returns>创建的启动器核心</returns>\n                public static LauncherCore Create(LauncherCoreCreationOption option)\n                {\n                        var launcherCore = new LauncherCore\n                        {\n                                GameRootPath = option.GameRootPath,\n<span style=\"background-color: yellowgreen;\">                                Java = option.Java</span>,\n                                VersionLocator = option.VersionLocator\n                        };\n                        return launcherCore;\n                }复制代码\n\n此时，当前的LauncherCore.cs中就没有显示其他错误了。但是当你尝试编译的时候，会发现另一个类：LauncherCoreInternal.cs也会开始报错\n追踪到第一个错误点：\ninternal LaunchResult LaunchInternal(LaunchOptions options, params Action<MinecraftLaunchArguments>[] argumentsOperators)\n                {\n                        lock (Locker)\n                        {\n                                if (!File.Exists(<span style=\"background-color: yellow;\">JavaPath</span>))\n                                {\n                                        return new LaunchResult {Success = false, ErrorType = ErrorType.NoJAVA, ErrorMessage = \"指定的JAVA位置不存在\"};\n                                }\n                                CurrentCode = Random.Next();\n                                var args = new MinecraftLaunchArguments();\n                                var result = GenerateArguments(options, ref args);\n                                if (result != null)\n                                {\n                                        return result;\n                                }\n                                if (argumentsOperators == null) return LaunchGame(args);\n                                foreach (var opt in argumentsOperators)\n                                {\n                                        try\n                                        {\n                                                if (opt != null)\n                                                {\n                                                        opt(args);\n                                                }\n                                        }\n                                        catch (Exception exp)\n                                        {\n                                                return new LaunchResult {Success = false, ErrorType = ErrorType.OperatorException, ErrorMessage = \"指定的操作器引发了异常\", Exception = exp};\n                                        }\n                                }\n                                return LaunchGame(args);\n                        }\n                }复制代码原因是我们改过名字。改为Java.Path即可：\ninternal LaunchResult LaunchInternal(LaunchOptions options, params Action<MinecraftLaunchArguments>[] argumentsOperators)\n                {\n                        lock (Locker)\n                        {\n                                if (!File.Exists(<span style=\"background-color: yellowgreen;\">Java.Path</span>))\n                                {\n                                        return new LaunchResult {Success = false, ErrorType = ErrorType.NoJAVA, ErrorMessage = \"指定的JAVA位置不存在\"};\n                                }\n                                CurrentCode = Random.Next();\n                                var args = new MinecraftLaunchArguments();\n                                var result = GenerateArguments(options, ref args);\n                                if (result != null)\n                                {\n                                        return result;\n                                }\n                                if (argumentsOperators == null) return LaunchGame(args);\n                                foreach (var opt in argumentsOperators)\n                                {\n                                        try\n                                        {\n                                                if (opt != null)\n                                                {\n                                                        opt(args);\n                                                }\n                                        }\n                                        catch (Exception exp)\n                                        {\n                                                return new LaunchResult {Success = false, ErrorType = ErrorType.OperatorException, ErrorMessage = \"指定的操作器引发了异常\", Exception = exp};\n                                        }\n                                }\n                                return LaunchGame(args);\n                        }\n                }复制代码\n\n继续追踪下一个。。。：\nprivate LaunchResult LaunchGame(MinecraftLaunchArguments args)\n                {\n                        try\n                        {\n                                var handle = new LaunchHandle(args.Authentication)\n                                {\n                                        Code = CurrentCode,\n                                        Core = this,\n                                        Arguments = args,\n                                        Process = Process.Start(new ProcessStartInfo(<span style=\"background-color: yellow;\">JavaPath</span>)\n                                        {\n                                                Arguments = args.ToArguments(),\n                                                UseShellExecute = false,\n                                                WorkingDirectory = GameRootPath,\n                                                RedirectStandardError = true,\n                                                RedirectStandardOutput = true\n                                        })\n                                };\n                                handle.Work();\n                                Task.Factory.StartNew(handle.Process.WaitForExit).ContinueWith(t => Exit(handle, handle.Process.ExitCode));\n                                return new LaunchResult {Success = true, Handle = handle};\n                        }\n                        catch (Exception exp)\n                        {\n                                return new LaunchResult {Success = false, ErrorType = ErrorType.Unknown, ErrorMessage = \"启动时出现了异常\", Exception = exp};\n                        }\n                }复制代码也是直接改为Java.Path，我就不再发修改后的了\n\n最后，在Reporter.cs中，最后一个错误在等待着我们\npublic class BasicLaunchReport : MinLaunchReport\n                {\n                        #region 目录/位置\n\n                        public string JavaPath;\n\n                        #endregion\n\n                        public BasicLaunchReport(LauncherCore core, LaunchResult result, LaunchOptions options) : base(result, options)\n                        {\n                                #region 系统信息\n\n                                VideoCardInfo = GetVideoCardInfo();\n                                ProcessorInfo = GetProcessorInfo();\n\n                                #endregion\n\n                                #region 启动信息\n\n                                JavaPath = <span style=\"background-color: yellow;\">core.JavaPath</span>;\n\n                                #endregion\n                        }\n\n                        #region 系统信息\n\n                        public string ProcessorInfo;\n                        public string VideoCardInfo;\n\n                        #endregion\n                }复制代码也是改为Java.Path。不再赘述\n\n这时候，我们就全部修改成功了。\n下一章我们将给KMCCC添加获取最佳内存大小方法。"
        },
        {
            "author": "nsisogf",
            "timestamp": 1511618820,
            "txt_content": "拓展阅读：我们获得JAVA详细信息的原理\n并不像其他人那样，选择使用注册表来获取JAVA的版本名称和JAVA位数\n相反，我们采用了使用-version参数来启动JAVA（在已有路径的前提下），截取信息流关键字眼的方式来获取JAVA的详细信息\n在介绍具体方法前，我们先简单概括两者特点，由用户自主选择最佳的方法\n\n注册表键法：\n通过读取表键的名称，以最快的方式获取JAVA的路径以及版本。至于位数，则要深入检查Wow6432\n这种方法在某种意义上来说，是最方便的。因为JAVA安装后的确会在注册表中留下详细信息。但在位数检测上，就显得比较繁琐。但要搜索路径的话，这种方法是不可避免的\n\n使用-version启动JAVA：\n在获取到路径的前提下，这个方法是最具有扩展性，获取JAVA信息最全，可靠的方式。在写出的数据流中，会包含大量有用的信息。但确定就是效率太低，但完全可以用它的弹性优势抵消。\n\n\n以下是我计算机上的JAVA Version信息\n如果您想体验，请在已装载官方JAVA的Windows计算机中使j用win+R，输入cmd，后输入java -version。输出的信息即JAVA详细信息\njava version \"1.8.0_144\"\nJava(TM) SE Runtime Environment (build 1.8.0_144-b01)\nJava HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)复制代码第一行java version，既JAVA版本，不再解释\n第二行中的SE代表所装JAVA为三个系列（SE/EE/ME）中的SE（详情https://www.cnblogs.com/EasonJim/p/6181981.html）\nRuntime Environment代表运行时环境，还有一个Development Kit（既JRE和JDK，详情：https://zhidao.baidu.com/question/55791862.html）\n扩号内build代表构建版本号\n第三号：Hotspot为JVM名称详情（http://xiaomogui.iteye.com/blog/857821）\n64-Bit为64位独有标志，用这个可以判断JAVA位数\n其他的对我们没什么用处，就不分析了\n"
        },
        {
            "author": "nsisogf",
            "timestamp": 1511847180,
            "txt_content": "第一章：KMCCC获取启动游戏最佳内存大小IIIKMCCC systemTools.cs中已经自带获取系统剩余内存以及全部内存的方法\nGetTotalMemory() 和 GetRunmemory()\n但是在启动时我们需要获取最佳内存大小，但又受限于JAVA位数已经系统剩余内存大小。所以我们创建一个获取最佳内存大小的方法：\n/// <summary>\n        /// 获取启动游戏的最佳内存大小\n        /// </summary>\n        /// <param name=\"java\">JAVA</param>\n        /// <returns>最佳启动内存</returns>\n        public static int GetSuitableLaunchMemory(Java java)\n        {\n            int rm = Convert.ToInt32(Math.Floor(GetRunmemory() * 0.6));\n            switch (java.Arch)\n            {\n                case Java.ArchEnum.x32:\n                    if (rm > 1024) { return 1024; }\n                    else { return rm; }\n\n                case Java.ArchEnum.x64:\n                    if (rm > 4096) { return 4096; }\n                    else { return rm; }\n\n                default:\n                    return rm;\n            }\n        }复制代码我们先通过判断JAVA位数，来确定最大内存限制\n在这里我需要声明下，32位JAVA我把上限调为1024MB是因为32位JAVA太奇葩了。。不同系统上的上限内存都不同。。1024一般是最安全的\n确定上限后，这个方**返回系统剩余内存的0.6倍的Int32整数（保证有其他空闲内存）"
        },
        {
            "author": "nsisogf",
            "timestamp": 1519203300,
            "txt_content": "第二章：扩展KMCCC的NET（网络操作）库\n我们知道，实际的优秀启动器会包含版本下载等需要网络操作的功能\n虽然KMCCC是启动类库，但个人喜爱和出于方便的原因，我硬生生的给她写了了NET库\n\n先在KMCCC中添加一个Net文件夹，作为Net类的namespace\n\n\n先从最基本网络操作类开始。就是GET/POST\n在Net文件夹中添加一个类，命名为HttpDownload(当然这个名字你自己可以换其他的)\n\n在类中写入方法\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Text;\n\nnamespace KMCCC.Net\n{\n    public static class HttpDownload\n    {\n        /// <summary>\n        /// Http发送Get请求方法\n        /// </summary>\n        /// <param name=\"Url\">GET网址</param>\n        /// <param name=\"postDataStr\">GET传递数据</param>\n        /// <returns>网站响应</returns>\n        public static string FromHttpGet(string Url, string postDataStr)\n        {\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url + (postDataStr == \"\" ? \"\" : \"?\") + postDataStr);\n            return WebGet(request);\n        }\n\n        /// <summary>  \n        /// 指定Post地址使用Get 方式获取全部字符串  \n        /// </summary>  \n        /// <param name=\"url\">请求后台地址</param>  \n        /// <param name=\"content\">Post提交数据内容(utf-8编码的)</param>  \n        /// <returns></returns>  \n        public static string FromHttpPost(string url, string content)\n        {\n            string result = string.Empty;\n            HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);\n            req.Method = \"POST\";\n            req.ContentType = \"application/x-www-form-urlencoded\";\n\n            #region 添加Post 参数  \n            byte[] data = Encoding.UTF8.GetBytes(content);\n            req.ContentLength = data.Length;\n            using (Stream reqStream = req.GetRequestStream())\n            {\n                reqStream.Write(data, 0, data.Length);\n                reqStream.Close();\n            }\n            #endregion\n\n            HttpWebResponse resp = (HttpWebResponse)req.GetResponse();\n            Stream stream = resp.GetResponseStream();\n            //获取响应内容  \n            using (StreamReader reader = new StreamReader(stream, Encoding.UTF8))\n            {\n                result = reader.ReadToEnd();\n            }\n            return result;\n        }\n\n        /// <summary>\n        /// Http发送Get请求方法\n        /// </summary>\n        /// <param name=\"Url\">GET网址</param>\n        /// <returns>网站响应</returns>\n        public static string FromHttpGet(string Url)\n        {\n            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(Url);\n            return WebGet(request);\n        }\n\n        private static string WebGet(HttpWebRequest request)\n        {\n            request.Method = \"GET\";\n            request.ContentType = \"application/x-www-form-urlencoded\";\n\n            HttpWebResponse response = (HttpWebResponse)request.GetResponse();\n            Stream myResponseStream = response.GetResponseStream();\n            StreamReader myStreamReader = new StreamReader(myResponseStream, Encoding.UTF8);\n            string retString = myStreamReader.ReadToEnd();\n            myStreamReader.Close();\n            myResponseStream.Close();\n            return retString;\n        }\n    }\n}\n\n这时候，KMCCC已经能做到基本的POST/Get数据操作"
        },
        {
            "author": "Oleg",
            "timestamp": 1519204500,
            "txt_content": "nsisogf 发表于 2018-2-21 16:55\n第二章：扩展KMCCC的NET（网络操作）库\n我们知道，实际的优秀启动器会包含版本下载等需要网络操作的功能\n虽 ...\n如果你打算扩展这个库的功能，为什么不把它放到 GitHub 上面？\n不过网络请求辅助这种功能不算 Kmccc 的核心功能。我不知道原先类库的作者会不会同意。"
        },
        {
            "author": "nsisogf",
            "timestamp": 1519205580,
            "txt_content": "Oleg 发表于 2018-2-21 17:15\n如果你打算扩展这个库的功能，为什么不把它放到 GitHub 上面？\n不过网络请求辅助这种功能不算 Kmccc 的核 ...\n我的启动器发布的同时我会把我修改的KMCCC放到Github上的（根据协议是这样要求的）\n新版本的KMCCC.Pro中已经自带了MOJANG API功能，而且她们也明确说了会发展Net部分"
        },
        {
            "author": "nidb",
            "timestamp": 1519352160,
            "txt_content": "表示KMCCC貌似无法启动1.12.2"
        },
        {
            "author": "nsisogf",
            "timestamp": 1519482180,
            "txt_content": "nidb 发表于 2018-2-23 10:16\n表示KMCCC貌似无法启动1.12.2\n我这里正常。\n有问题的话请去kmccc官方贴回复 = =这里是非官方的扩展贴"
        },
        {
            "author": "Oleg",
            "timestamp": 1519807440,
            "txt_content": "nsisogf 发表于 2018-2-21 16:55\n第二章：扩展KMCCC的NET（网络操作）库\n我们知道，实际的优秀启动器会包含版本下载等需要网络操作的功能\n虽 ...\n你注意到没有，有个流 double free 了。"
        },
        {
            "author": "nsisogf",
            "timestamp": 1519831740,
            "txt_content": "Oleg 发表于 2018-2-28 16:44\n你注意到没有，有个流 double free 了。\n神tm double free\n首先这里是C#，指针操作对于C#不安全。\n第二这里的方法都是我自己经过多次测试，在之前的启动器发布版本中用的都是这个方法，都没有出现异常。"
        },
        {
            "author": "Oleg",
            "timestamp": 1519882560,
            "txt_content": " 本帖最后由 Oleg 于 2018-3-1 13:52 编辑 \nnsisogf 发表于 2018-2-28 23:29\n神tm double free\n首先这里是C#，指针操作对于C#不安全。\n第二这里的方法都是我自己经过多次测试，在之前 ...\nusing 会调用 Dispose。你写那个 Close 在 Win32 已经是对 Socket 调用过 CloseHandle 了，在 Dispose 里面发现句柄已经关闭就不会进行有价值的操作。\n那个方法返回的流是 ConnectStream。ConnectStream 嵌套了 NetworkStream。你看看 NetworkSteam 源码：\nNetworkStream.cs\n是不是会在 Dispose 里面对套接字调用 Close 达到关闭流的效果 ?\n所以,\n\n            using (Stream reqStream = req.GetRequestStream())\n            {\n                reqStream.Write(data, 0, data.Length);\n                reqStream.Close();\n            }复制代码应该改成\nusing (Stream reqStream = req.GetRequestStream())\n{\nreqStream.Write(data, 0, data.Length);\n}复制代码\n\n"
        },
        {
            "author": "nsisogf",
            "timestamp": 1519988160,
            "txt_content": "Oleg 发表于 2018-3-1 13:36\nusing 会调用 Dispose。你写那个 Close 在 Win32 已经是对 Socket 调用过 CloseHandle 了，在 Dispose 里 ...\n不要乱说话。\nDispose和Close完全不一样。\n没错，Dispose的确会执行Close的大部分方法\n但是一个是基于对象销毁，一个是关闭资源。这个就是关于CLR托管，非托管的资源操作\n我用Close是方便将来对此方法的升级，我并不想他销毁（避免资源占用）\n另外，这并不会占用更多资源。你所谓的进行无价值操作，并不费时。详情参考Dispose过程。我先前的Close并不会影响整体效率。你也可以自己测试。\n所以说，Close在此没有任何问题，不会出现任何BUG，也不会额外占用资源耗时\n--这不叫double free"
        },
        {
            "author": "nidb",
            "timestamp": 1520527860,
            "txt_content": "nsisogf 发表于 2018-2-24 22:23\n我这里正常。\n有问题的话请去kmccc官方贴回复 = =这里是非官方的扩展贴\nemmmmm\n只是废话一句，看来我得看看自己的代码有没有锅\n顺便楼主写的很好，支持下w"
        },
        {
            "author": "nsisogf",
            "timestamp": 1520690760,
            "txt_content": "提示：\n请开启“只看该作者”选项方便浏览"
        },
        {
            "author": "nsisogf",
            "timestamp": 1520692800,
            "txt_content": "第二章：扩展KMCCC的NET（网络操作）库II\n完成NET API最基础的GET，Post方法来获取相应后，我们该着手建立API Json-Net Module\n在Mojang官方API中，响应都是以Json模式，我们需要对其进行解析为.NET Objec\n\n模型I：Minecraft版本列表\n官方API：https://launchermeta.mojang.com/mc/game/version_manifest.json\nBMCALAPI：https://bmclapi2.bangbang93.com/mc/game/version_manifest.json\n\n这个Json文件看起来是这样子的：\n{\n    \"latest\": {\n        \"snapshot\": \"18w10d\",\n        \"release\": \"1.12.2\"\n    },\n    \"versions\": [\n        {\n            \"id\": \"18w10d\",\n            \"type\": \"snapshot\",\n            \"time\": \"2018-03-09T15:20:10+00:00\",\n            \"releaseTime\": \"2018-03-09T15:19:12+00:00\",\n            \"url\": \"https://launchermeta.mojang.com/mc/game/bc15be0f8cffc646366f09c911e3c8c2e33a9061/18w10d.json\"\n        },\n        {\n            \"id\": \"18w09a\",\n            \"type\": \"snapshot\",\n            \"time\": \"2018-03-07T15:39:47+00:00\",\n            \"releaseTime\": \"2018-03-01T14:15:10+00:00\",\n            \"url\": \"https://launchermeta.mojang.com/mc/game/4b95a1f10798a6b05f65765bc52cc74862e9289d/18w09a.json\"\n        }\n        ......\n    ]\n}复制代码其进行试图化后呈现的结构为\n\n\n\n\nTIM截图20180310221839.png (33.56 KB, 下载次数: 2)\n\n下载附件\n\n2018-3-10 22:19 上传\n\n\n\n\n\n\n在此Json中，分为两个主结构，分别为：\n\nlatest-最新的版本\nsnapshot-快照ID\n     release-发布版本号\nversions-所有版本列表[数组]\n     id-版本ID\n     type-版本发布类型\n     time-修改时间\n     releaseTime-发布时间\n     url-版本引导Json URL\n\n现在我们了解了这个结构，就开始建立模型吧\n\n首先建立在versions列表中单个版本的结构\n新建一个Class叫APIModules专门放各种API模型，再向其中加一个Class，就叫JWVersion吧\npublic class JWVersion\n        {\n            /// <summary>\n            /// 版本ID\n            /// </summary>\n            [JsonPropertyName(\"id\")]\n            public string Id { get; set; }\n\n            /// <summary>\n            /// 版本类型\n            /// </summary>\n            [JsonPropertyName(\"type\")]\n            public string Type { get; set; }\n\n            /// <summary>\n            /// 版本修改时间\n            /// </summary>\n            [JsonPropertyName(\"time\")]\n            public string Time { get; set; }\n\n            /// <summary>\n            /// 版本发布时间\n            /// </summary>\n            [JsonPropertyName(\"releaseTime\")]\n            public string ReleaseTime { get; set; }\n\n            /// <summary>\n            /// 版本下载URL\n            /// </summary>\n            [JsonPropertyName(\"url\")]\n            public string Url { get; set; }\n        }复制代码每个属性上的[JsonPropertyName(\"......\")]为LitJson对property name识别特征的自定义标记\n\n为选择API获取源，建立一个能选择下载源的Enum枚举\npublic enum DownloadSource\n    {\n        Mojang = 0,\n        BMCLAPI = 1\n    }复制代码\n\n\n接下来为Json=>Object建立操作器\n新建一个Class就叫做FunctionAPIHandler吧\n\n向其中添加成员：\npublic DownloadSource Source { get; private set; }\n        const string BMCLBase = \"https://bmclapi2.bangbang93.com\";\n        public string VersionListURL { get; set; } = \"https://launchermeta.mojang.com/mc/game/version_manifest.json\";复制代码第一个是下载源的变量\n第二个是BMCL的Base URL\n第三个是版本列表URL，并向其赋值默认值：官方URL\n\n接下来建立这个类的构建函数\npublic FunctionAPIHandler(DownloadSource lib)\n        {\n            Source = lib;\n            switch (Source)\n            {\n                case DownloadSource.Mojang:\n                    VersionListURL = \"https://launchermeta.mojang.com/mc/game/version_manifest.json\";\n                    break;\n\n                case DownloadSource.BMCLAPI:\n                    VersionListURL = \"https://bmclapi2.bangbang93.com/mc/game/version_manifest.json\";\n                    break;\n            }\n        }复制代码就是根据构建时用户所提供的下载源枚举，选择VersionListURL的URL\n\n接下来添加方法成员：\n /// <summary>\n        /// 联网获取版本列表\n        /// </summary>\n        /// <returns>版本列表</returns>\n        public List<JWVersion> GetVersionList()\n        {\n            string json = HttpDownload.FromHttpGet(VersionListURL);\n            var e = LitJson.JsonMapper.ToObject<JWVersions>(json);\n            return e.Versions;\n        }复制代码其中，这要引用（using）之前我们写的GET,POST库，和模型库，并且还有LitJson库（KMCCC中自带）\n\n接下来执行这个方法就可以获取列表了\n怎么样？很不错吧\n"
        },
        {
            "author": "LoeGamingJoker",
            "timestamp": 1553352480,
            "txt_content": "大佬大佬，有没有外置登录的教程呀，那些java启动器都有外置登录，唉搞得我无从下手啊"
        }
    ]
}