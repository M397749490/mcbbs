{
    "title": "LuckPerms 各种信息堆",
    "author": "cc7w",
    "replyCount": 9,
    "timestamp": 1501827960,
    "txt_content": " 本帖最后由 mimimis 于 2017-9-10 13:44 编辑 * \\6 ]5 e6 z: q( q( X\n8 L; E/ O3 l, J. i# w\n1 d/ m8 ~! ], I\n\" M\" _$ c+ a$ ~1 e, b: z\n8 f; m! g& f5 T% ]\n\n8 C0 R8 ?5 Q# p) c1 F3 u6 F# sGitHub 地址 https://github.com/PluginsCDTribe/LuckPerms/wiki2 R6 F- K- z% o2 ?8 ?\n划去的内容是已经搞完的（汉字数/字节数）\n( j& d- f7 G2 C. T\n' W\" `: ]6 o# c4 T5 dHome(187/892, by 754)0 I! f+ \\; Z: t! }* \\\" A\nLuckPerms(1495/3927 ,By Art1900)Why LuckPerms?(1495/3927)\n$ J8 x/ g. W' u6 z7 KSetup(3878/11877 ,By c7w || 9224/73272 ,By 754 || 575/7025,By Art1900)Installation(553/1663,c7w)Choosing a Storage type(680/2907,c7w)Usage(2645/7307,c7w)Configuration(3231/29901, by 754)Command Usage(4582/30931,by 754)Migration from other plugins(798/6920, by 754)Command Equivalents(575/7025, by art)FAQ(613/5520, by 754)\n! ?1 S% ^\" r, D$ [Features(3824/12661,By c7w || 1899/11277,By 754 || 1513/5367,By Art)Verbose(629/1963,c7w)Bulk Editing(785/3261, by 754)Instant Updates(808/2452,c7w)Switching Storage Types & Backups(241/1658, by 754)Tracks(258/942,c7w)Prefixes, Suffixes & Meta(1537/4979,c7w)Prefix & Suffix Stacking(592/2325,c7w)Advanced Setup(1513/5367,Art)Default Groups(873/6358, by 754)( p3 Y  s  I  R& p* C\nDevelopers(1198/19751, by 754)Developer API\n: a% v8 t# \\, \\( k) uOther(By c7w,1025/4067)Locale and Translations(196/939)PlaceholderAPI(829/3128)\n1 X1 m' [. `6 s. hSummary( H- c$ L! R! }1 G( e5 ~8 m! y2 R\n754 —— 12508/105192\n. u  ?0 p+ |$ M2 T+ s- D8 mc7w —— 8727/28605\n) z* o7 l  k9 w* ^8 bArt —— 3583/163192 Y: q. @( @8 {9 r( a: }# U",
    "replies": [
        {
            "author": "海螺螺",
            "timestamp": 1501828080,
            "txt_content": " 本帖最后由 754503921 于 2017-8-6 13:02 编辑 \n# d# v) ^; f- D  u0 c+ l; j# g! R6 ?5 M, \\' c. a\nDevelopersDeveloper API\n7 j. W% ], l3 X2 [FeaturesVerboseBulk EditingInstant UpdatesSwitching Storage Types & BackupsTracksPrefixes, Suffixes & MetaPrefix & Suffix StackingAdvanced SetupDefault Groups/ c% @5 G' Q/ d5 ]; G* A, r\" C0 e\n\n* A$ y1 z( f+ G$ T. ]; YDeveloper API## 简介\n  m4 A\" e# i, ^$ w) m% h## Intro6 z# `8 A! \\6 }# ~+ W\nLuckPerms API 允许你更改大量的插件内部编程，并且能够轻松地将 LuckPerms 深度集成到你的插件和系统里。\n' o9 Y0 j/ `: g( TLuckPerms API allows you to change a huge amount of the plugins internals programmatically, and easily integrate LuckPerms deeply into your existing plugins and systems.\n+ n3 ?1 p: u( i/ C/ @  H9 c9 g9 K6 _+ U& x6 |\n大多数的其他的权限要么没有 API，要么有很差的 API，或者是有很差的文档的 API，而且里面的方法和类可能随机在不同版本里消失或是移动。Vault 项目就是一个很好的接口，并且是将大量插件一次性集成的很好的方法，可惜他的功能实在是太少了。7 r/ b; r4 W7 B\nMost other permissions plugins either don't have APIs, have bad APIs, or have APIs with poor documentation and methods and classes that disappear or move randomly between versions. The Vault project is a great interface and a great way to integrate with lots of plugins at once, but its functionality is very limited.\n8 m\" i. l9 w) [5 s, J0 i\n; f1 p8 c8 @( u1 M+ ILuckPerms 遵循 Semantic 版本控制，也就是意味着一个不向后兼容的新的 API 出现时，主版本会增加这个 API，你可以放心你的集成不会因为版本的不同而崩溃，主要的版本是保持不变的。3 G5 w, ?4 e5 B; [\" n\" {, l\nLuckPerms follows Semantic Versioning, meaning whenever a non-backwards compatible API change is made, the major version will increment. You can rest assured knowing your integration will not break between versions, providing the major version remains the same.8 b7 g' v* l* g+ }\n\" T: V& ^, Z2 o: {0 i\n## 如何在项目里使用 API\n+ Q; H' k+ R0 _9 x+ |3 u' U, i, q1 B## How to use the API in your project% p# J+ p( Q. j$ E1 X5 y$ e  F\nLuckPerms 的 API 包是 https://github.com/lucko/LuckPer ... /me/lucko/luckperms\n5 r, B7 }' F1 A! C9 LThe API package in LuckPerms is [`me.lucko.luckperms.api`](https://github.com/lucko/LuckPer ... /me/lucko/luckperms).% F( J' j$ u# [2 p* q\n\n8 b( D: v7 o3 l7 Q我的 Nexus 服务器可以在这里找到 https://nexus.lucko.me/](https://nexus.lucko.me/，你在你的构建脚本里需要的仓库在 https://repo.lucko.me/](https://repo.lucko.me/1 J% |1 X# r5 l+ o5 j) H\nMy Nexus Server can be found at [https://nexus.lucko.me/](https://nexus.lucko.me/). The repository you need for your build scripts is [https://repo.lucko.me/](https://repo.lucko.me/).\n2 F, ~6 `/ `* E- W# k' v) d& d- l! H5 K4 [\n#### 其他有用的链接. w* O2 ?\" a* S; P; G, F\n#### Other useful links% ~7 y' ~4 Q& ^* C: L( u\n* [JavaDocs](https://luckperms.lucko.me/javadocs/)\n- X$ H  S. W5 L9 X, n* [CI Server](https://ci.lucko.me/job/LuckPerms/)3 B\" e: \\' h# W5 f+ E9 z8 \\\n2 U1 f4 `5 x9 b0 L! C& J3 e\n### Maven# v4 ?5 j  F! ]8 Q6 `8 l& w\n````xml\n4 A5 E7 ~) c5 _' e& M* P( d<repositories>\n$ I9 @& e. ?. F/ `& G$ i4 u$ E    <repository>\n+ h\" X\" V* Q4 R4 d6 U        <id>luck-repo</id>\n1 i* j+ Z( V6 T; i        <url>https://repo.lucko.me/</url>\n) t& j! O' V& A+ y$ l- ^5 `  u    </repository>\" N\" o\" \\. M* O3 U0 V$ h# c\n</repositories>  d/ D( V* |' M, [\" O  X1 V  }- Y\n! P! Z/ K7 S8 @1 b2 u6 |- W5 k\n<dependencies>\n7 P0 ]8 g3 j2 {, h( t    <dependency>; a0 }, M# \\& L\" a6 I5 f' _\n        <groupId>me.lucko.luckperms</groupId>\n% p1 R6 o) ~+ T        <artifactId>luckperms-api</artifactId>\n1 _  m+ v* ]& ^        <version>3.2</version>, X4 D5 h( E\" U) [2 n- c' A\n        <scope>provided</scope>2 c' p% y9 W- c7 S6 G; P5 F\n    </dependency>\n8 ^! j) M& n5 y' T</dependencies>\n) G, ]& W' v) _! u$ V9 J% K& m````\n\" Q! K% L3 q& C2 T5 }' Y# F\n! _: }4 t\" R, Y$ J( ~### Gradle& Q1 w$ d) r5 ], z\n```gradle\n% y* ?  z6 X+ Y# O) B# k; U  drepositories {' t2 g* T7 a/ P1 c5 F/ T' d/ W+ d\n    maven {\n$ c  D8 b8 K/ s3 b3 h1 b        name \"luck-repo\"\n7 D\" R* l- S' f) y, o0 e$ i8 w2 n        url \"https://repo.lucko.me/\"; S- d/ \\- o( V( x+ J\n    }\n% A+ k- w, t& B! r}, j: H2 ~& O6 i4 p- R& G\n\n4 P6 w9 o. h' ]\" y% |: Kdependencies {\n& ]: ?7 f; _, s' q  I    compile (\"me.lucko.luckperms:luckperms-api:3.2\")- G\" I1 l3 W8 d\n}\n! x3 i4 m+ q( b. `# F8 t```1 m  L  v+ P# W2 u9 D& u6 n2 K\n! K\" A5 X- l# T- ?8 s2 _7 b\n## 使用指南) A# w\" ^8 B$ v- I* e& }% b7 Y# b5 k\n## Usage Instructions0 ?5 a1 @- t. S# H\n使用 API，你需要获得 LuckPermsApi 接口的实例，这可以通过几个方法完成。\n6 }) a8 r- y' G3 OTo use the API, you need to obtain an instance of the `LuckPermsApi` interface. This can be done in a number of ways.\n\" f6 V8 x& L: L2 _$ T. Z: V% Z6 R. w: W2 C% W. \\( ?5 ]\n```java\n* C\" h9 N& c\" y: O3 T// 所有平台 (抛出 IllegalStateException 如果 API 没有被加载)\n3 H; f) `1 x5 w5 t0 zfinal LuckPermsApi api = LuckPerms.getApi();' C. k6 \\! n9 g! }9 J6 e\n* `) H. A+ B, b, [\n// 或者可选的\n  O: u) o: H, K\" [9 q) ?$ ZOptional<LuckPermsApi> provider = LuckPerms.getApiSafe();\n) i! G) T) n$ w- Vif (provider.isPresent()) {\n  p. P- G+ g5 K    final LuckPermsApi api = provider.get();\n3 o$ i7 z\" U0 S6 i' n}( v. {0 k. W: N. z1 {\n\n2 S8 x% {1 \\: {// Bukkit/Spigot, a. U2 n6 _  s' y6 N\nServicesManager manager = Bukkit.getServicesManager();# K+ F7 `' j) U; B7 b$ e9 J\nif (manager.isProvidedFor(LuckPermsApi.class)) {\n2 W2 l+ G; Z3 }2 U6 l5 Z( p    final LuckPermsApi api = manager.getRegistration(LuckPermsApi.class).getProvider();0 U$ n) i& g- y) Z1 n  l, f\n}\n0 G8 ~7 K# Z\" F: |/ J1 V# G; B6 o\n7 a  o, Y, l/ {6 b( B9 H$ E// Sponge\n7 h& y' X' s; V1 X# s6 y+ q% ^Optional<LuckPermsApi> provider = Sponge.getServiceManager().provide(LuckPermsApi.class);5 r, `7 b8 a$ p/ q6 I+ H  v$ O3 H\nif (provider.isPresent()) {\n3 p3 K8 h. z* D5 e/ p$ a    final LuckPermsApi api = provider.get();\n5 C! y: Y' b  f; r}\n, h1 h/ F* n$ E4 g! [* ?; E  Q1 |```' t+ V8 y' [, P3 q( s\n4 ^; G# C( ~) a/ E3 g\n### 线程安全的警告\n/ G# y! y6 C8 B* y0 q### A warning about thread safety\n( J+ x5 Q. c' g- y% s\" A所有 LuckPerms 内部，包括 API 都是线程安全的，你可以在异步线程任意调用 API 而不用担心发生错误。\n7 n$ d4 Y) O4 N5 S1 s. [( @All LuckPerms internals are thread-safe, including the API. You can call API methods from async threads without incurring issues.% Z4 n9 f0 C1 m. D1 e\n\n. A& `: N9 ?6 P6 V但是，请注意一些操作，（尤其是存储类）是阻塞的。[CompletableFuture](https://docs.oracle.com/javase/8 ... pletableFuture.html) 就是用于这种情况：防止由于较差的处理导致的增加的错误，当出现 IO 时主线程等待处理完成。注意在添加 Callback 时指定正确的处理器。\n' u) P$ w. P/ Y7 q2 D, W  ^6 v: oHowever, please be aware that some operations, (especially in the Storage class) are blocking. [CompletableFuture](https://docs.oracle.com/javase/8 ... pletableFuture.html)s are used in these situations to prevent accidental issues whereby through poor handling, the main server thread waits for I/O to execute. Care should be taken to specify the correct executor when adding callbacks to these futures.\n9 e6 Q7 i4 f# n! i$ d; Y# A\n1 R1 J0 ~) u* H/ q6 M2 e3 z; E4 {### 我想将 LuckPerms 作为依赖项\" I# H4 _- B1 s\n### I want to depend on LuckPerms) m- w) l& \\; I* m$ V\n在 Bukkit/Bungee，你需要在你的 plugin.yml 添加以下信息\n0 _7 o' N$ a2 ?On Bukkit/Bungee, you need to add the following to your plugins `plugin.yml`.\n. g! s0 z; C  x5 [9 T```yml8 z: M# V# O7 G& j* O2 e* w4 S\ndepend: [LuckPerms]\n9 v, P  G/ L1 w3 C. M4 }0 Q```\n4 e3 I/ S# S/ i0 E* }% {, A\n7 V* A, S8 M! ?2 O# G2 q) \\在 Sponge, 在你的插件声明添加这些。% \\! \\- A% r% F8 ]) B1 @* W, R2 _\n```java* N- X3 t\" a7 \\5 n  |* H\n@Plugin(\n+ I( }, s5 q. ^, a7 E        id = \"myplugin\",+ Z1 n) z. \\\" i: k. Y\n        dependencies = {\n3 E$ C5 K& f! W) y* G' }) q7 p                @Dependency(id = \"luckperms\")* U1 O8 W/ }# X/ Q/ Y3 W$ v, |\" ^0 d\n        }\n& k% R: L\" g  ^& C; u5 {; \\\" e/ ?)9 g9 H$ y1 K8 K4 m\" p- a\npublic class MyPlugin {\n2 G+ B4 S8 m8 v  F8 Y% D4 B! _    ...\n2 b5 \\\" @5 {+ z5 g/ Z8 o$ D& u/ h}& W3 J7 n- i* p9 g\n```# i7 \\' F' D+ o& d\n2 g9 Q; D% m  v) u  r2 Q\n### 事件\n, A# m$ v5 Z8 P### Events9 U0 A* K. N5 e# S1 N% ^9 b; }# }\nLuckPerms 有一个完整的读写API，也有一个事件监听系统。由于插件的多平台的原因，我们使用了内部的事件系统，而不是每个平台已经使用的事件系统（举个例子，Bukkit Event API）。这意味着简单的注册你的平台的监听器将不会生效。\n/ p\" H. J/ \\# [; d: p7 T, rLuckPerms exposes a full read/write API, as well as an event listening system. Due to the multi-platform nature of the project, an internal Event system is used, as opposed to the systems already in place on each platform. (the Bukkit Event API, for example). This means that simply registering your listener with the platform will not work.\n) E3 l7 z2 T+ a6 Z, a% H8 k( E- j5 c/ e0 Y  l7 @5 v\" u' E\n所有的事件都是异步触发的。这意味着不应该在监听器里交互或者调用任何不是线程安全的方法。\n3 W  S: u( D/ g) w, }1 GAll events are **fired asynchronously**. This means you should not interact with or call any non-thread safe method from within listeners.\n& n4 y7 x* u$ b# Y; m; t7 x1 h\n4 z5 r# h, H. G5 ~4 E值得注意的是，大多数的 Bukkit/Sponge 都不是线程安全的，并且只应该使用主服务器线程来交互。你应该使用调度器来访问 LuckPerms 的监听器。9 N% _+ {; a6 v$ x5 v9 P$ Q7 {\nIt is important to note that most of Bukkit/Sponge are **not** thread safe, and should only be interacted with using the main server thread. You should use the scheduler if you need to access these methods fron LuckPerms listeners.) O- z1 A( U  s$ i8 U7 T2 W\n\n7 `\" F6 [& d, v### 我怎样才能监听一个事件\n7 S3 j5 G9 j) Z/ ]. v! F### How do I listen to an event) X7 x/ h4 K* \\$ d\" L6 x% _\n所有的事件接口都可以在 [me.lucko.luckperms.api.event](https://github.com/lucko/LuckPer ... luckperms/api/event) 包里找到，它们都继承了 [LuckPermsEvent](https://github.com/lucko/LuckPer ... LuckPermsEvent.java) 类。\n5 }  o% `+ W& G& u, ~All event interfaces can be found in the [me.lucko.luckperms.api.event](https://github.com/lucko/LuckPer ... luckperms/api/event) package. They all extend [`LuckPermsEvent`](https://github.com/lucko/LuckPer ... LuckPermsEvent.java).. e& E) k) H5 j\n% g( p5 O  f3 j% Y\n监听事件应该获得 [EventBus](https://github.com/lucko/LuckPer ... event/EventBus.java) 实例，使用 [LuckPermsApi#getEventBus](https://github.com/lucko/LuckPer ... ckPermsApi.java#L68)即可。% q. l$ y! G' {% o; G9 h\nTo listen to events, you need to obtain the [`EventBus`](https://github.com/lucko/LuckPer ... event/EventBus.java) instance, using [`LuckPermsApi#getEventBus`](https://github.com/lucko/LuckPer ... ckPermsApi.java#L68).\n1 s: q  z' o3 {4 x& J( ~5 k& z! h- ]* g. A8 J\n为你的监听器创建另一个类常常是个好想法，这是一个你可以用来参考的类。\n- s( F1 V  o0 W% D; ?7 N/ ]% w' UIt's usually a good idea to create a separate class for your listeners. Here's a short example class you can reference.; H: S; K# t0 a# F9 w/ R\n\n. V5 z( {0 g0 t7 e* u1 }5 x```java\n. i# Z# V* k4 H! p& Z$ Epackage me.lucko.test;\n2 E. L9 ~- z6 n9 |/ z& Y+ ^( T* L2 s/ O; G& `. N( I3 B\nimport me.lucko.luckperms.api.event.EventBus;\n6 R5 |( G1 v- r; B1 D- ~import me.lucko.luckperms.api.event.log.LogPublishEvent;4 J! _; V7 D$ ~2 z3 l\nimport me.lucko.luckperms.api.event.user.UserLoadEvent;\n& k( ^3 {3 U' D# T9 @import me.lucko.luckperms.api.event.user.track.UserPromoteEvent;# l9 U: Y8 B  G, E+ ^- V  H/ N: _\n: F\" v7 ]  `' [& `: `\npublic class TestListener {\n\" y) i/ ^) y6 h0 r$ \\5 p    private final MyPlugin plugin;\n; Q$ x7 @+ T3 q  p7 D. f2 E0 k/ g* c1 R' ?) i$ |) o\n    public TestListener(MyPlugin plugin, LuckPermsApi api) {\n  E1 w  F1 s6 A, {! Q        this.plugin = plugin;\n& _. P2 K# }1 _) U$ O\n9 D( ^& c\" X\" b9 ~        EventBus eventBus = api.getEventBus();\n. u  L$ i+ X1 `\" F# v. ]% _+ V3 l8 w' e' \\. F' W\" s% _\n        // use a lambda: }/ M, T6 D! \\* K: E! m: u\n        eventBus.subscribe(LogPublishEvent.class, e -> e.getCancellationState().set(true));\n/ v  |) ?! h/ O        eventBus.subscribe(UserLoadEvent.class, e -> {\n8 K# z+ O& R, t3 H, i$ X% Z+ {            System.out.println(\"User \" + e.getUser().getName() + \" was loaded!\");\n6 e\" B* P, p5 J5 _$ r1 k            if (e.getUser().hasPermission(\"some.perm\", true)) {$ R9 F. G2 y' r- |\n                // Do something\n2 a& S) K8 s  w! @) s\" b, x4 X            }\n7 P  f* S8 k1 w1 }! n6 T        });' G8 P2 Z0 y( y4 z\n, s- ~  |8 F3 Q$ v\n        // use a method reference\n, |/ A2 E\" N5 O0 Y5 L+ D        eventBus.subscribe(UserPromoteEvent.class, this::onUserPromote);$ t% g# }( e2 @# b& z\n    }\n2 P6 K! F' _% M\n) j. ^\" a6 e0 e7 ~* d  Z/ E7 I    private void onUserPromote(UserPromoteEvent event) {\n2 J/ e# |5 a( h+ ]9 |$ O9 t, V, r        Bukkit.getScheduler().runTask(plugin, () -> {\n9 {# b& N$ z: _, S$ B: u            Bukkit.broadcastMessage(event.getUser().getName() + \" was promoted to\" + event.getGroupTo().get() + \"!\");: b5 _0 C8 e2 C, \\0 D\n\n, N& w* A- c7 v7 s6 \\& q            Player player = Bukkit.getPlayer(event.getUser().getUuid());8 J0 v  I7 ~0 M, M4 ^; F, x\n            if (player != null) {; a/ @5 n' W6 |& @9 W  Y\n                player.sendMessage(\"Congrats!\");8 z; ^; b7 t. e* X$ H# V\n            }, T, `* _\" [1 O+ o\" s\n        });\n0 s$ f: y; j; S3 k$ C2 }    }  T* f5 [, L6 ?0 j  o2 F\n6 s\" _2 j) k( H0 Y\n}/ S$ o' A8 [  g! H- q\n```\n! Z- c+ o- E4 S0 I( d\n7 W% N# e\" l) @' Y[EventBus#subscribe](https://github.com/lucko/LuckPer ... t/EventBus.java#L43) 返回一个 [EventHander](https://github.com/lucko/LuckPer ... t/EventHandler.java) 实例，可以用来在插件停止的时候取消注册监听器。\n\" V# v& O* ~$ h4 J3 s[`EventBus#subscribe`](https://github.com/lucko/LuckPer ... t/EventBus.java#L43) returns an [`EventHander`](https://github.com/lucko/LuckPer ... t/EventHandler.java) instance, which can be used to unregister the listener when your plugin disables.. U. i\" ?: U. t) R; m( X\n\n: }& D9 O/ ~\" W* a! ~( m9 T## 示例用法\n7 Z# Y( g. H0 G4 g- Y! O3 w! a## Example Usage\n9 ^5 O$ }6 o# V0 Q; j8 k! ?下面就是一些简短的实例，使用了一些基本的 API 功能。\n: N\" [4 v: r3 q; Y' L4 \\Below are some short examples which illustrate some basic API functions./ U# p& f\" N0 V( d\n\n8 D% ^& [\" e: z### 获得玩家的组6 Y! \\9 j, p8 i\n### Finding a players group- N2 v6 v# A' V4 ?) P\n如果你只是想找到一个玩家的组，我非常建议你使用以下的方法（你甚至不需要使用 API）。\n3 p3 \\; o5 |& sIf you just want to find out which group a player is in, I **highly** recommend the following method. (you don't even need to use the API!)6 X5 v% h\" I3 p\n\n2 [1 p( g- f/ i7 i% q/ ````java) d4 v6 a% P  o: \\- Z\npublic static String getPlayerGroup(Player player, List<String> possibleGroups) {+ J5 E\" M1 Q+ w+ b\n    for (String group : possibleGroups) {\n! ^& R; n\" U* G2 R5 k  b: d- w\" C        if (player.hasPermission(\"group.\" + group)) {\n+ H: n' V/ c# `& W# n5 m5 D            return group;3 l5 a/ }3 P9 ^6 y\n        }\n- T6 N, ]4 a2 G( k1 @0 \\  ?    }: Q& ~5 H  Z( q) B\n    return null;\n- ?2 K\" {5 n\" R( W}8 ?2 _( ~7 F9 j4 O% l4 c\n```\n: v+ z) F5 I' p; n& ~6 x6 i5 p- v# I记住将你的组排列为优先级的顺序（比如组长在前，成员在后）。/ J7 w, x( L6 K( i, d8 ?\nRemember to order your group list in order of priority. e.g. Owner first, member last. * g! p  ?$ `. n/ Y. P* U\n\n! a- {, O$ L4 ~- d3 @3 n! c: ]### 为一个玩家添加权限! @9 b: l/ Q/ F/ b7 W' ^# f3 ~\n### Adding a permission to a user& j7 I4 C( _, f8 R  t# o\n```java\n! W& ?% R2 O7 _% uLuckPermsApi api = null; // See above for how to get the API instance.\n  i9 Z, j5 Q. |- p- k# u\n$ m9 M+ j& @  l, i1 V2 H6 VOptional<User> user = api.getUserSafe(uuid);# {. ~' n! L* C3 w\nif (!user.isPresent()) {\n& P7 W2 a: l% B' C4 `    return false; // The user isn't loaded in memory.1 w: g4 {) R0 N) q+ w1 Z\n}\n# B9 P' \\- l; O- t3 z\n3 o- f. q. N7 r' ]# E$ O5 _// Build the permission node we want to set; ^7 l, O' K' n1 S\nNode node = api.getNodeFactory().newBuilder(permission).setValue(true).build();\n1 X# J( f$ L\" E) T  `1 I% f7 c) [4 o4 l6 T, I3 S7 s1 ?\n// Set the permission, and return true if the user didn't already have it set.4 q8 u; m4 ^4 f( H* R. A2 T\ntry {% J3 h( m/ O* K. m4 |\n    user.get().setPermission(node);\n/ J$ m$ ~/ ~7 A- G\" H  f8 x  v9 e\" {! ]) B, |$ _\n    // Now we need to save the user back to the storage, u: W. O\" U# }$ {4 g* q* t) j\n    api.getStorage().saveUser(u);\n8 ^\" c! h2 t( _: x. _' z1 [# i. g\n    return true;( R. |# x& K2 N9 V2 T* c6 j\n} catch (ObjectAlreadyHasException e) {\n7 B' m; T1 q) h8 z: u    return false;\n8 o% {% y3 @$ {& l1 Q( R}) T* R. d\" b# T. m8 y\" F& k+ Q( H\n```\n5 `( W) T) R! _% {( `5 M; @2 o: n' [6 V# D- D6 T\n### 为（可能的）离线玩家添加权限) J( Z! Y7 F0 d# n2 C\n### Adding a permission to a (potentially) offline user\n$ L* d5 f0 K9 ?- a! b\" UCompletionStage API 可以用来轻松交互插件的存储，查看[这里](https://docs.oracle.com/javase/8 ... ompletionStage.html) 和 [这里](https://docs.oracle.com/javase/8 ... pletableFuture.html) 来查看这两个类的详细信息。- P\" c: s1 K8 ^\nThe CompletionStage API can be used to easily interact with the plugins Storage backing. See [here](https://docs.oracle.com/javase/8 ... ompletionStage.html) and [here](https://docs.oracle.com/javase/8 ... pletableFuture.html) for more details about these classes.5 O2 ~% G) E: ^+ W6 c7 {\n\n/ p9 n1 x1 o* m6 c- W0 B  U, D```java\n! i/ J1 E6 k* d0 @  ?/ pLuckPermsApi api = null; // See above for how to get the API instance.) a9 G- C! W6 v6 `% m& W) r+ M\n\n5 s# t; @5 ]; a# o: L// load the user in from storage. we can specify \"null\" for their username,  ^7 e/ `2 l) b% ]$ d+ @/ r- E9 D\n// since it's unknown to us.\n% a/ e6 Y0 x! t( e6 }api.getStorage().loadUser(uuid, \"null\").thenComposeAsync(success -> {\n# h\" Y2 B, W- B; Z; L    // loading the user failed, return straight away0 ^# J\" j9 X( s/ D) D\n    if (!success) {\n- e* N\" j- `7 v        return CompletableFuture.completedFuture(false);\n& ~& w8 n1 B$ v/ c    }) N; N1 N6 P2 ?: ?( n\n    - `  I9 c: `& @5 {3 T4 _. k\n    // get the user instance, they're now loaded in memory.5 B/ d\" e) b9 N+ L9 u\" @: Q\n    User user = api.getUser(uuid);\n3 X# q; f% K+ T8 ?4 ~, G% }9 b+ e- ^. U9 d+ u4 e6 H( I\n    // Build the permission node we want to set\n) D8 }- |4 z4 h  }* K7 @) `( Q    Node node = api.getNodeFactory().newBuilder(permission).setValue(true).build();2 q+ `9 h\" u0 D$ v\n\n$ y! d$ Z0 @: [% ^: Q$ }( N& W9 l0 x    // Set the permission, and return true if the user didn't already have it set.( M4 J# w: D* o4 ~- b+ u\n    try {7 w9 o; {\" J) m# f6 K$ z. @: u\n        user.setPermission(node);\n5 X* I3 L( S. F, ~/ b' L        \n% I8 l! ~3 `# D6 c8 P/ V5 }: a        // now we've set the permission, but still need to save the user data\n+ P- w; O$ p: w7 O; E        // back to the storage.\n4 S3 W3 f4 ^7 p9 p- v        \n; D) S' j1 h2 V1 A) _+ l3 p        // first save the user1 j* I/ |2 f- `' N. b6 w  h\n        return api.getStorage().saveUser(user)\n+ |5 {: g. Y8 W# x6 a6 i0 i* S                .thenCompose(b -> {& C+ s! e9 g1 n7 p\n                    // then cleanup their user instance so we don't create\n/ Z3 _+ K% ^# b                    // a memory leak.8 [- }1 }\" W& e\n                    api.cleanupUser(user);\n5 g0 T/ ~\" C) c                    return CompletableFuture.completedFuture(b);- `: X7 P\" {  {5 I\n                });  m8 y! Q# v$ J5 g\n        # w4 v$ {+ Y; @8 [3 b\n    } catch (ObjectAlreadyHasException e) {0 L. Y' m, D8 ]% ?\n        return CompletableFuture.completedFuture(false);- B4 P9 W  O6 Z* }\n    }\n; X$ B6 X% k5 D  }, Y0 w/ [    \n* C1 L2 `/ |6 w8 Q8 |3 w8 X}, api.getStorage().getAsyncExecutor());) ^. U- G% F, ~. E0 s# {\n```\n# ^# g4 Q; `, ?# Y( E; R, A  L* J- c/ ^& R* G9 j) J\n### 获得玩家的前缀\n9 J+ s& f' Y\" ?9 {7 R/ T### Getting a players : B6 n+ t6 y+ x) B: ~\nLuckPerms 有一个（复杂的）缓存系统，用于非常快速的权限/信息查询。这些类都在 API 里，并且可以在可能的地方使用。\n5 I( A# p' d* f) h' |LuckPerms has a (somewhat complex) caching system which is used for super fast permission / meta lookups. These classes are exposed in the API, and should be used where possible.\n, F1 a9 d0 N: g$ W7 e\" B\" O% ^0 O2 U* i$ C* G+ F: c+ T$ Q* G\n```java\n  o+ A) n8 p: Q# D0 S\" }LuckPermsApi api = null; // See above for how to get the API instance.7 ]' T# P2 k# m\n\n$ R: b3 W' C$ X! I! [// Get the user, or null if they're not loaded.% z6 e; m% k. Y\" O\" e5 \\\nUser user = api.getUserSafe(uuid).orElse(null);\n: s6 ?/ Z, u; h1 Wif (user == null) {9 T: k, w/ ]\" O0 ?  X3 Y, G- [4 f' I- B\n    return Optional.empty(); // The user isn't loaded. :($ J\" @4 R' O$ V  s' Y  Z/ b7 a\n}3 t) n: d4 P1 `* a1 \\\n  \\& C6 k/ B0 u. e\n// Now get the users \"Contexts\". This is basically just data about the players current state.\n. G+ b2 }$ b6 _2 f// Don't worry about it too much, just know we need it to get their cached data.8 Y6 Y0 |2 [\" E2 c' g0 p\nContexts contexts = api.getContextForUser(user).orElse(null);\n2 C; t* L( ^$ f2 J. f3 B\" }& R3 Q5 _if (contexts == null) {\n; N& A8 {5 ?& j7 G- x, K9 I    return Optional.empty();\n9 r* C  H& [% w+ H}7 K$ m# F1 b3 w5 X6 c\n\n# s+ e2 Z, d7 u8 P// Ah, now we're making progress. We can use the Contexts to get the users \"MetaData\". This is their cached meta data.4 ~6 P( f# L$ Q/ d6 V\nMetaData metaData = user.getCachedData().getMetaData(contexts);3 l9 L1 k! ^+ b\n8 f; c2 a5 D8 X\n// MetaData#getPrefix returns null if they have no prefix.6 U. P3 y$ Q9 a! D/ Q) ?\nreturn metaData.getPrefix();' Y0 {\" n' m! v; X+ U& w\n```2 v) ?% z) {* U0 x' V5 H\n\n0 w! b8 W4 A7 Q' x\" j### 获得玩家请求的权限\n0 c\" a) B2 z  M2 P### Getting a players applied permissions\n5 T. e) q: o: |5 r我们也可以使用这个缓存系统来获得一个包含用户权限的 Map 实例，包含了基础的权限查询。# U* G, H, O) e\nWe can also use this caching system to get a Map containing the users permissions. This map contains the data which backs their permission lookups.\n% C\" w; L& g- |7 L( Q```java\n, r. g. `3 A. N; J4 I; J/ G. u4 b// All retrieved in the same way as shown above.\n; c6 T+ W. W- `# X6 O3 O9 QUser user;\n9 s1 G, b, `  W\" P, bContexts contexts;  i' W$ @: L9 Z% Z8 c1 v, u6 k\n\n0 ?$ }1 |+ i/ gPermissionData permissionData = user.getCachedData().getPermissionData(contexts);\n2 ^- r! F- U% r' s, D# D+ @Map<String, Boolean> data = permissionData.getImmutableBacking();4 \\) @0 }* i# i4 u) y\n```\n3 ]/ y( V8 a\" x4 ~0 f& l9 `( v' X/ o/ @/ @, O1 r* h; Y9 k* N+ c/ e\n### 寻找权限\n/ t/ [+ ~9 }$ T' F( S### Searching for a permission\n4 k  o) z; {+ V; y你可以使用 Java 8 的流轻松过滤并返回一个用户请求的权限\n2 ]1 \\9 S! \\! ^# w, X' S  @4 PYou can use Java 8 streams to easily filter and return permissions applied to a user.\n* M  _' @% n# d$ o& l  C( _```java5 ?: h# v0 m2 _\" w\npublic boolean hasPermissionStartingWith(UUID uuid, String startingWith) {  N, O  ?, d$ `: J3 Z\n    // Get the user, if they're online.6 ?$ Q; r7 m2 k' u; F3 ?4 o% y6 o\n    Optional<User> user = api.getUserSafe(uuid);! W) D5 r/ ^% B; t3 X6 `& P\n# c4 C% x% `+ J& Y8 ~% M4 {' l2 ^3 L2 o\n    // If they're online, perform the check, otherwise, return false.\n4 v% R; _! F# \\' w! B    return user.map(u -> u.getPermissions().stream()& J/ o) G! n5 `8 J/ e3 G\n            .filter(Node::getValue)\n6 o+ U$ Z, [! K+ j# P            .filter(Node::isPermanent)\n# o& ]/ ~! X. U6 O8 s            .filter(n -> !n.isServerSpecific()). ~8 N3 A5 T7 |& t\n            .filter(n -> !n.isWorldSpecific()). ]) [9 j& b+ ]- P\" v# Q6 m\n            .anyMatch(n -> n.getPermission().startsWith(startingWith))\n8 P  Z' b, o4 c3 S. c7 m# x  _    ).orElse(false);\n/ H. s; P0 W% ?' I\" o/ i& ^}\n: T, n$ H; l: c, @* n6 }```4 M2 P& g! t5 v! E% x. S\n8 p  ~3 p% @$ U# a* U\n### 创建新的组并分配权限' k& @: p' m0 ?0 K2 R! f& e7 p\n### Creating a new group and assigning a permission\n+ k) |; ]  M* H. L3 Y# t这个方法不是阻塞的，所以可以安全的在主线程调用，一旦操作完成，回调会异步运行。- O% ?* W6 m& U\nThis method is not blocking, so can be safely called on the main server thread. The callback will be ran async too, once the operation has finished.\n# c8 t, \\, F1 K- i' W```java\n0 ?9 K2 T. t# Z  l* wapi.getStorage().createAndLoadGroup(\"my-new-group\").thenAcceptAsync(success -> {  n0 |# S9 {3 a) m\n    if (!success) {: V; T2 F7 O2 f\" h6 g0 o\n        return;\n9 ^7 A# ~+ c* t2 A7 b$ `    }\n6 e) m1 l7 C( q% o  S! [$ t\n& y, B7 u2 Q4 |+ S  [: l    Group group = api.getGroup(\"my-new-group\");( A$ r0 W/ E6 Y8 P+ e4 g\n    if (group == null) {0 G: s6 i- f3 U\" V0 {8 [5 T\n        return;1 N; D6 q+ w\" I\n    }\n0 u* @\" t( r7 T\" N. {/ m$ g( e9 ]) e+ A3 [\n    Node permission = api.buildNode(\"test.permission\").build();\n& m5 x) ^. k9 y( C- v\n: `& k/ p9 n1 Z    try {\n6 R' {3 x8 }) r9 d\" V        group.setPermission(permission);) r# i5 V' j% e9 c6 B: x\n    } catch (ObjectAlreadyHasException ignored) {}- v+ z- Z, v3 Z  Q\n\n4 _8 F9 C  l  b6 @' B* z2 Z    // Now save the group back to storage\n' E$ |3 c: n; E8 I- b    api.getStorage().saveGroup(group);' K2 H* r: l% ]. q\n}, api.getStorage().getAsyncExecutor());\n, w- @8 n0 a$ O0 ~. z, T3 i\" d```8 \\# Y* s. s) j/ s! s\n6 ?6 r4 V\" @9 i2 [\" T\n## 版本控制* }\" O5 x6 n: e- T\n## Versioning\n1 d$ C' a, k* t0 {: y' I; s9 }9 P! h\" ^在 2.0 版本里，LuckPerms 遵循了 Semantic 版本控制。\" Z5 N1 B% q9 o! e; S\nAs of version 2.0, LuckPerms roughly follows the standards set out in Semantic Versioning.\n1 d/ k7 \\$ j$ W/ j\n5 q$ Q* U* b% |7 U唯一不同的是 patch 号不包含在任何地方，除了 pom，并且每次构建都会计算，基于上次提交后的提交数量。（每个新的小版本都会创建新的标签）\n: f# T, w0 a5 iThe only difference is that the patch number is not included anywhere within the pom, and is calculated each build, based upon how may commits have been made since the last tag. (A new tag is made every minor version)9 o8 V1 P4 \\* [\n\" e5 y6 p  f4 m+ B( }3 x\n这意味着 API 版本不再有 patch 号（在 patch 里没有 API 的变化），API 版本会是 x.y，每个不同的 LuckPerms 构建都会遵循 x.y.z。: a& w- F1 T6 t& _1 j# C\nThis means that API versions do not have a patch number (as no API changes are made in patches). API versions will be x.y, and each individual build of LuckPerms will follow x.y.z.\" x/ v6 p3 B. e\" s% @8 H( x, A\n2 B' u9 y- w+ O5 S\n### 变更日志\n* d$ y5 S% ?! C8 [, e\" {### Changelog\n7 M% h1 [/ f  n+ c1 A* 版本 2.x 保持了几个月的稳定，没有任何向后不兼容的变更，但是在之后的版本里很多的方法变为弃用状态，并且事件 API 的确应该重写一遍。\n, p8 a' K9 I. u% r& |* Version 2.x remained stable for a number of months, without any backwards incompatible changes. However, a number of methods became deprecated in the later versions, and the event API really needed a rewrite.\n+ ?3 N4 t\" f5 s# b* 版本 3.x 包含了以下的向后不兼容的变化。9 I- l& ^3 m0 g\" u/ Y: h\n* Version 3.x introduced the following backwards incompatible changes.8 w5 I5 \\0 X# ?' Z\nhttps://gist.github.com/lucko/fdf6ae4b2d9e466d8103dd9c68e5db9e\n2 }4 w) r' W- o$ [0 e% hFAQ# 常见问题\n& K& f( L/ Y9 ?& l& L# Frequently Asked Questions  y1 }& E$ }) K: d( `* J- u\n这些是我经常被问到的问题，我很高兴你在直接问我之前看了这些问题。9 b5 `  M1 M4 h/ A0 F; W\nThese are some of the questions I get asked quite frequently. I'd appreciate it if you check to see if your question has already been answered here before asking me directly. \n. \\8 Z/ x6 W  [. z+ c\n; Q: }% }# a1 H  x3 O5 e### 我在用 EssentialsChat 然后它不工作了\n4 A% D1 j0 U- |1 R5 p; r### I'm using EssentialsChat and it's not working\n. Q5 D0 J: j9 p7 R请确保你在使用最新版的 [EssentialsX](https://ci.drtshock.net/job/essentialsx/) 并且你安装了 [Vault](https://dev.bukkit.org/bukkit-plugins/vault/)。EssentialsX 的 X 是很重要的，老的版本不会工作。\n6 |1 f  K7 Y. qPlease make sure you are using the latest version of [EssentialsX](https://ci.drtshock.net/job/essentialsx/) and you have [Vault](https://dev.bukkit.org/bukkit-plugins/vault/) installed on your server. The \"**X**\" part of Essentials**X** is important - the older versions of Essentials do not work.\n' M. H4 y, n$ D# [5 x\n' C- r# D; ]3 ~0 U7 d. L3 e4 V### 我在哪里安装 LuckPerms 呢？. H/ x) \\3 r; `1 `5 _! O+ n- G+ b\n### Where do I install LuckPerms?\n8 i6 f! m8 Q* ~! b如果你在运行很多的服务器，你应该将 LuckPerms 放入每个服务器的 plugins 文件夹。  {6 P% K) d0 U6 Q\nIf you run a network of servers, you should install LuckPerms into the plugin folder of every server you want to use LuckPerms on.& m9 I, Z4 C& D0 h\n如果你想使用 BungeeCord 来应用权限，你需要将 LuckPermsBungee.jar 放入 BungeeCord 插件文件夹。\n! o\" B9 v( N, JIf you also want to use LuckPerms to apply permissions on your BungeeCord proxy, you should place LuckPermsBungee.jar into your BungeeCord plugins folder.. n+ ^; {6 H3 Q/ a5 L\n如果你选择只在 BungeeCord 安装 LuckPerms，他将不会影响任何 Spigot/Sponge 服务器的权限检查，如果你想要使用 LuckPerms，你必须将 LuckPerms 安装在这些服务器。\n5 `1 K, [1 O# f* ]- [If you choose to only install LuckPerms on your BungeeCord proxy, it will have no impact on any permission checks performed by plugins on any backend Spigot/Sponge servers. If you want that functionality, you need to install LuckPerms on those servers too.\n3 ^+ C/ N7 W  o4 K/ w( F0 `5 ?\" M\n\" m\" f. v\" i$ z- z% Q! ]- P### 我可以只在 BungeeCord 安装 LuckPerms 吗？\n7 c7 C/ e9 w& w4 S3 D1 c& r0 l### Can I just install LuckPerms on BungeeCord?9 @  A8 v) I$ X' }3 C9 s8 {. v1 J\n在 BungeeCord 上的权限系统是完全独立于 Spigot/Sponge 服务器的。\n7 c& n, Z1 p- l$ o% k( `The permissions system used on BungeeCord is completely separate from the systems used on the backend Spigot/Sponge server.\" b) q  P\" S: K2 n+ B\n如果你想让 Spigot/Sponge 的权限检查被 LuckPerms 处理的话，在每个 Spigot/Sponge 服务器都安装 LuckPerms。2 H* k* x- \\+ W/ C% B/ g\nIf you want the permission checks performed by Spigot/Sponge plugins to be handled by LuckPerms, install LuckPerms on your Spigot/Sponge server.\n+ G8 ]0 K0 K6 G% o! y如果你想让 BungeeCord 服务器的权限检查被 LuckPerms 处理，在 BungeeCord 服务器安装 LuckPerms。\n5 A& p5 B7 H: @, }If you want the permission checks performed by BungeeCord plugins to be handled by LuckPerms, install LuckPerms on your proxy.\n8 B- w  k7 }: r; y+ g' x你可以只在 BungeeCord 安装 LuckPerms，但是 Spigot/Sponge 服务器的权限检查将不会被 LuckPerms 处理。. }. s3 f  N# ?4 V  o# ^$ O\nYou **can** just install it on the proxy, but any checks which are performed by Spigot/Sponge plugins will not be handled by LuckPerms.\n5 `+ k) o4 N, K: K\n) ?6 t8 @1 r4 _: }3 @### 我应该怎样在多个服务器中同步权限呢？, p, f+ Q2 v\" u\n### How do I get permissions to sync across multiple servers\n: O; H\" N8 V! t: }将每个 LuckPerms 连接到同一个 MySQL/MongoDB 服务器，你可以使用 /luckperms sync 来从数据库获得最后的权限更新。你也可以 [建立一个通讯服务](https://github.com/lucko/LuckPer ... #messaging-services) 来立刻在你的服务器之间同步更改。\n6 l  ]* B/ p! oConnect each LuckPerms installation to the same MySQL/MongoDB server. You can use `/luckperms sync` to pull the latest changes from the database. You can also [setup a Messaging Service](https://github.com/lucko/LuckPer ... #messaging-services) to have your changes sync instantly between servers.0 O5 L4 h* L8 e/ l  e6 }\n\n/ H9 F5 |$ x8 _/ a### LuckPerms 不能连接到我的 Redis 服务器\n  w+ G3 W2 L% p### LuckPerms cannot connect to my Redis server\n% f) C\" e1 A, H: v检查以下是否正常：% {, @$ e, }6 a1 v. i8 G) ^) i\nCheck that the following is correct:\n$ m; p9 Q8 K  Y4 o( @: j8 }7 M1 |- H\" y, m% l) }3 N  Q\n* 你正阿紫使用正确的地址和端口\n1 _% k; i- i0 g$ c$ W* You are using the correct address and port\" b3 l! v8 d5 n3 F4 |\n* 你的密码是正确的\n: Z; P- R% f5 {8 V+ N* Your password is correct# B\" ]. v0 ~5 @6 C. d4 s\n* 没有防火墙规则阻拦了连接5 O( i. v6 _, j\" ~7 N\n* There are no firewall rules blocking the connection\n7 o* b6 |7 `) z: q4 |' m+ X9 X$ P* Redis 服务器正在运行\n! y' B1 [0 N6 A/ u  N7 o# v* The Redis server is actually running( ^' a& x; W8 n% C9 S* E\n# N# ?, w+ _5 R( A  b: n; R3 Y\n### LuckPerms 不能连接到我的 MySQL 服务器' Q5 O5 O, g' o: p5 |\n### LuckPerms cannot connect to my MySQL server\n0 y* _% ]9 p2 O. V' i\" p& \\6 q7 H检查以下是否正常：5 ~; E9 Z4 w* s8 Z\nCheck that the following is correct:\n2 ?; d8 J6 I0 d: r/ [7 U# j\n. W3 N' I' c. J3 H9 E3 z* 你正在使用正确的地址和端口/ ^/ X' a0 Y+ k' V; v/ d( D\n* You are using the correct address and port% _  k! {0 i* r( h4 H2 j\n* 你使用了正确的用户名 / 密码\" J  M0 K8 q$ `6 y\n* You are using the correct username / password5 A# A! B% r\" v* {1 U\n* 数据库存在并且用户可以访问/ s' e4 R: G\" l$ S\" }5 Y\n* That the database exists and is accessible by the user5 K4 N6 Q) u( N\n* 该服务器在线并且接受连接. [5 y4 a, @. z& g\n* That the server is online & accepting connections4 c$ I, |2 ]# V, x\" T  A  k\n* 没有防火墙规则阻拦了连接\n; O# O; _/ c0 u% z9 }* There are no firewall rules blocking the connection0 a% h( A/ T8 e  `\n* MySQL 正确绑定了端口，并且安装 LuckPerms 的服务器可以访问' |1 Y- e; _+ }, E2 A( S, z, C\n* MySQL is bound to the correct port, and is accessible from the server where LuckPerms is installed  p( \\3 l9 G* n7 ~\" \\8 Z\n* 检查 MySQL 的连接限制没有超过，默认 LuckPerms 会使用 10 个连接，如果你有过多的插件连接了同一个服务器，你需要增加这个限制。1 D% ^, u2 U# W# J; y\n* Check that your MySQL max connections limit is not being exceeded. By default, LuckPerms will use 10 connections per server. If you have lots of plugins connecting to the same server, you will need to increase this limit.$ `8 Y/ n0 q8 b5 f\" h9 Z) m\n\n* Q1 k5 m  N0 [, |1 j' h# `( e2 l如果你得到了 `Communications link failure` 的错误，或者由于超时导致的错误，那么上面的有一条是不正常的。\n: _% I  Y( ]- |7 n+ ?& BIf you are getting `Communications link failure` errors, or errors relating to a timeout, then something from the list above is incorrect.\n/ ~) o6 B$ u+ n3 e* Q& ?\n& K9 x9 H3 H! q) u5 W) b% X给玩家 LuckPerms 表的权限，使用\n. e5 E, {- @) M\" Z6 NTo give the user access to the LuckPerms tables, execute:1 J! f: N0 z5 f6 @5 p\n```sql\n( S& f2 K/ w( X0 ?) XGRANT ALL PRIVILEGES ON [databasename].* TO '[username]'@'[ipaddress]';\n0 M: v4 x\" Q/ L7 |) l9 z/ [```\n5 E2 o$ T  r7 Z& Q\" Q记得替换 [ ] 里的东西。6 M) m# h% Q9 j; s\n\n% f6 T( H: Q0 `6 t比如：\n9 e' p0 O' y! k, @3 S7 i7 L```sql\n, Z* z9 k9 @. sGRANT ALL PRIVILEGES ON luckperms.* TO 'luck'@'%';- M8 ^9 v- H/ R4 q\n```4 O7 Q4 Y/ j3 o6 A\n\n8 W5 v& ]3 y/ o* U( w  A! v接着当你完成这个更改后，使用\n; N  U0 h& o9 Q/ V# U8 V; N```sql\n/ S\" o- n4 G( i! U6 W3 V\" L! eFLUSH PRIVILEGES;$ @3 l) Z3 l$ l2 F: N\n```0 _0 g) h! h& C! l0 Q4 O\n6 m/ z\" `$ d, e: K8 D\nMigration from other pluginsLuckPerms 有内置的支持其他的权限插件轻松迁移到 LuckPerms 的功能。# k, L7 ^\" `- {7 N5 E$ w\nLuckPerms has built in support to allow easy migration of permissions data from existing permissions plugins to LuckPerms.\n! B  p\" j  Z: j$ T5 _  g) l\n8 u6 C, F6 G' _6 \\8 `. H7 p( G## 开始之前0 w1 l5 {' h' P5 _3 |\n## Before we get started9 p! ~+ x3 f. w% s+ n# P) V\n需要注意的是这个系统还不是那么的完美，在绝大多数情况下，它在转变数据时相当不错，但是不是所有的数据都是相同的，并且有时我可能没有考虑这么多。$ @5 m$ C* H. a) {0 _3 n\nIt should be noted that this system is not perfect. It will do a pretty decent job at converting all of your existing data, and works perfectly in *most cases*. However, not all data is the same, and there are sometimes things I haven't accounted for.4 e# O& j7 ?- \\) x9 U: h7 d\n\n) G% u+ y1 p9 v; H, T6 ?) yLuckPerms 有和其他权限插件相同的地方，但是有些部分从根本上不同，有些迁移运用了一些技巧。  U# [& v9 A% l5 B* s$ f\nLuckPerms has some similarities with other permission plugins, however, some parts are fundamentally different, and therefore sometimes automatic migration is tricky.\n7 B) M\" \\- `+ m( Y- C( z& l$ P+ R' j0 ^\" C# p! l\n另外，让插件迁移你的所有的数据意味着你没有机会学习任何一个 LuckPerms 命令，这可能会是一个麻烦的地方，如果你是从 PermissionsEx 或者 GroupManager 迁移来的数据，你应该看看 [GM PEX 的等同命令](https://github.com/lucko/LuckPer ... Command-Equivalents); J9 V* ~- {, g5 t! k( `\nAdditionally, letting the plugin migrate all of your data for you means you will not have a chance to learn any of the LuckPerms commands. This may become an issue later on. If you're migrating from PermissionsEx or GroupManager, you might [find this page useful](https://github.com/lucko/LuckPer ... Command-Equivalents).\n- @3 _! g: a3 `: E! w$ `4 ~9 u6 ~\n+ a+ {/ y9 V' T5 T5 B如果你使用了老版本的权限插件，或者你根本不喜欢的，现在可能是一个机会来重新构建清理，顺便学习 LuckPerms 的命令！\n& H+ \\8 a) C/ S) r0 ]If you have an old permissions setup, or a setup you're not completely happy with, now might be a great time to have a restructure and cleanup, and a chance to learn LuckPerms commands in the process!9 I6 ?2 }  R  I- Z* i; U\n\n* P* J8 I# y3 {' ~不？！就喜欢你现在的权限插件？让我们来迁移。2 @) `, J9 y4 f! m2 f\nNope?! Happy with what you have? Let's migrate.  - @  F( N3 O! O- D: o\n   \n( B5 v' Y5 Q. J   \n/ ~$ Z. s8 s' I2 [; J2 e## 目前支持的插件. H\" Z9 V4 X7 ?) J5 r/ [) E# A\n## Currently supported plugins\n, X# P7 [1 C2 l$ T+ V( \\9 X| Bukkit / Spigot       | BungeeCord            | Sponge                |\n+ ?3 w) o4 A) `% `6 @! j, z|-----------------------|-----------------------|-----------------------|\n5 r8 z- [* B* @( D# L| GroupManager          | BungeePerms           | PermissionsEx         |# B  Y: ^0 [5 D  o0 d1 S\n| PermissionsEx         |                       | PermissionManager     |# |  T- X, r! Y! U' r\n| zPermissions          |                       |                       |5 \\/ ^& B, l' u\n| PowerfulPerms         |                       |                       |\n, C' Y+ ~* c- D; T! V- S: x0 W| bPermissions          |                       |                       |+ U7 b9 y0 Y; u7 x/ d  D, O\n\n! `9 E* G\" ^9 ?$ ?8 F\n, z7 C- Y) U9 g  Z- a# 如何5 k, Q2 ^# ]3 g& K( ^3 l8 V\n# How to; Y. O# @0 q% T5 M\n迁移的处理很简单，但是每个平台可能有不同。\n: r; W: u+ }( F' Q  ~& bThe migration process is fairly simple, however it varies slightly for each platform./ M' _: j* x0 ?' u, G  T\n\n+ N8 D% F3 h' H6 m- R1. 将 LuckPerms jar 文件放入你的服务器文件夹。\n\" O: \\8 n- K, |- t. D9 a1. Place the LuckPerms jar file in your servers plugin folder. ([How to?](https://github.com/lucko/LuckPerms/wiki/Setup))1 E1 H8 g8 J% s) i) F4 q\n2. 保证两个权限插件的文件夹在同一个文件夹里（现在还不要卸载）\n+ C, q5 y( a) @* J2. Ensure that the jar of the plugin you are migrating from is **also** in the plugins folder. (don't uninstall it just yet!). N# @# U, O/ W# b# I\n3. 开启服务器，你可以在活跃的服务器来进行这个操作，但是我建议在没有人的服务器上进行。4 h0 `+ J\" C- d7 G1 f& @7 N8 Y\n3. Start your server up. You can technically carry out the process on a live production server, however I advise that if possible, you do it on a server with no players.7 g- t% s0 W; B4 l3 f4 n0 T: ]\n! Q4 P1 f: W% a% Z\n**运行一下命令: `lp migration <插件名>`**\n4 v2 @& O+ q$ ^\" M/ U7 k# r**Run the following command: `/lp migration <plugin name>`**   \n( ^$ N) a6 B\" g! n, M% k& U6 G: A3 b\" O\n有些插件需要你填写额外的选项/标签，如果需要，你会在迁移之前被通知。) P7 M: v9 R( g! \\\nSome plugins also require you to specify extra options/flags. If any are needed, you will be notified in chat before the migration begins.! n6 t$ O) K! @; w& b\n\n& y4 U' s- e/ S, @. D接着只需要让 LuckPerms 处理剩下的事了！你将会被提示迁移进度，完成时也会被提示。1 ^, Y/ b8 {( r$ X\nThen, just let LuckPerms handle the rest! You will be notified of the migration progress, and then notified again once it has finished.\n# t7 ^( w! x8 F7 ]8 A: @$ @\n( M1 j3 H% E) ?( u' O8 y5 M2 ?当处理完成，停止服务器，移除其他权限插件的 jar，再次开启你的服务器。\n, Q7 }; t5 i: V0 G6 c7 GWhen the process has finished, stop the server, remove the other jar file, and start your server again.6 ?  o: I/ ^' l: Q, Q6 Z5 J' f\n+ I6 e* o9 p$ I! r2 W# v7 C0 s\n控制台的输出一定是冗长繁杂的，以 \"(LP) LOG\" 开头的命令都可以忽略，但是栈堆信息不应该忽略（一般表示出现了什么问题）。如果你的迁移输出含有栈堆信息，请反馈给我，更多的信息在这一个页面的底部。; L- p, F7 E7 b, T, d8 m% U\nThe console output during the migration process is purposely verbose and spammy. Messages starting with \"(LP) LOG\" can be ignored, however stack traces shouldn't be (they usually mention some sort of exception). If your migration output contains stack traces, please report them to me. More info at the bottom of this page. # B% J' I5 \\; m  j6 m\n% I# s: ]) |6 E+ K/ L) G\n## PowerfulPerms\n! T. z6 h6 L9 z: R4 e0 X处理 PowerfulPerms 的过程更加复杂。\n; E+ r! j6 S! ~The process for PowerfulPerms is more complicated.; c5 n- f! F* M9 C\n\n7 }& ?! I3 v; S玩家的信息只有在加入服务器时才被加载，插件 API 没有方法一次性获得所有的玩家的数据。2 R; c6 f' L: [) {2 w* F\nUsers are only loaded into the plugin when they join the server, and the plugins API does not expose a way to get all players from its backend.\n% Z4 N# K2 ]' C2 A4 H/ E/ R7 y: j# Z/ k/ W\n这意味着我们在导入数据时，我们必须得查询 PowerfulPerms MySQL 表来获得所有玩家的信息。\n0 D* n- _0 c. i; j# [This means that during the import process, we have to query the PowerfulPerms MySQL tables to get a list of all users.\n0 q# e& t9 {' M5 ~* Z5 D4 r: O' z, M6 J3 o4 R- {% L\n命令使用将会不同。\n! B9 w8 g( a* n7 T8 S1 JThe command usage is therefore different.\n  f8 S1 F* B. p4 h! i\n) p0 f3 Q, j# J- ~  L' v( ~3 r* l\" O`/luckperms migration powerfulperms [address] [database] [username] [password] [db table]`& c* r0 M. x! c# ^/ o, ^4 F\n\n1 ~3 r* I4 N8 d5 k# i5 G, Z解释：\n3 x1 f0 C& \\2 \\# PWhere:* F& v0 |* l+ Z; ?! m) B8 t; j) {! T\n* address = MySQL 服务器的 IP 地址，比如 127.0.0.1:33061 U6 d8 j0 G! m$ ^' W- e\n* address = the address and port of your MySQL server e.g. 127.0.0.1:3306* _7 M+ |/ v4 ^\" ?3 n' {\n* database = PowerfulPerms 插件使用的数据库的名称3 z: C, P$ }3 L\n* database = the name of the database where your PowerfulPerms data is stored\n1 k: _: T# ]6 n# Z; H* username = SQL 服务器登入需要的用户名\n5 l0 l3 p- ^2 e2 ~* username = the username to login to the SQL server\n( r  m) Y' s7 x1 E* password = SQL 服务器登入需要的密码- m9 u: I) r9 V4 a\n* password = the password to login to the SQL server( c, _7 m( J\" r% o' T$ h4 l\n* db table = 存储玩家数据的表名（尽管我们只关注 UUID 列表）/ u  ?* G* k$ ~6 ^\n* db table = the name of the table where player data is stored (although we're only concerned about a list of uuids).\n4 @! P\" s& c0 g3 ^\n* ?: z/ _; x1 @7 O3 m3 j. i& X默认的表名，据我所知，是 \"players\"，但是如果你添加了表名的前缀，你需要添加他们。  s. r  E) l1 v+ W. g5 p) r; c, L; d\nThe default db table, as far as I know, is \"players\", however if you have an added table prefix, you will need to include that too.\n% K7 A! L2 y, A' d) F3 _0 x% p) U$ F, j\n比如如果我的表的前缀是 \"pp_\"，那么 db table = \"pp_players\"（不需要引号）\n$ B' s$ h  u' Q$ _$ Se.g. if my table prefix is \"pp_\", the db table should = \"pp_players\". (without the quotes)+ [; F  c  L# @9 ^\n\n7 ?  @! |' @+ d+ ]% l; [4 o比如: `/luckperms migration powerfulperms 127.0.0.1:3306 minecraft root passw0rd players`\n0 I. z+ L: J  |For example: `/luckperms migration powerfulperms 127.0.0.1:3306 minecraft root passw0rd players`7 H) l; T) q5 ^5 F  C! w9 S\n\n2 q( o: u. q0 }/ G- V8 d7 l9 Q# 错误\n! @. q# h+ l\" [; p* P# Errors\n: h6 C5 A( d\" B; w- W如果这个命令不存在，请检查这个插件是否正确加载。  w7 Q3 S* h/ e* @# ~\nIf it seems that the command does not exist, check your server's startup log to check if the plugin you are importing from loaded correctly.5 W$ {: U  R8 F: x. `3 n- A\n* ~5 E# e5 I% ]% Z6 j, |2 t\n如果处理没有完成，并且打印了错误消息，请在 GitHub 提交 issue 或者 [在这里联系我](https://github.com/lucko/LuckPerms/wiki#cant-find-something)，我将尽力尽可能快的回复你。\n* ^* A4 i/ }' I* UIf the process doesn't complete and prints an error message, please submit an Issue on GitHub or [contact me here](https://github.com/lucko/LuckPerms/wiki#cant-find-something). I'll try to reply to you ASAP.5 |3 ?5 b: _/ C$ t\nSwitching Storage Types & Backups## 如何1 l; c, U! \\3 ]) b9 J) g0 R7 N\n## How to3 Y) m9 H- m  a\n切换存储是很简单的。2 P  F) X  ~\" |: y\nSwitching datastores is easy.\n% r3 M! ?, D9 W' g6 Q( }* G5 L1 B( m9 t3 c3 y& S0 x/ g0 X\n1. 第一，运行 `/luckperms export <file>`* ^  W, e( L: s\n1. Firstly, run `/luckperms export <file>`. N4 C& c+ e6 I& L' O: W0 w# e; R  \\\n2. 接着，完全停止你的服务器8 W; b! [' `4 y  A3 l& Y/ P\n2. Then, stop your server completely.\n' ^/ V5 m$ N8 \\& A- ^# ?  t$ c& q3. 编辑你的配置文件，更改存储类型\n; J  G# {- l5 l# i% i- ?3. Edit your config file and change the storage type.; }+ J3 s4 }) V/ s! p. x\n4. 开启你的服务器，等待数据存储的初始化\n4 J: Y: r4 X+ e/ M$ J# M2 |! \\8 N4. Now, start your server again. Let the new datastore initialise./ Z8 ?) G9 M\" c- }1 I+ y\n5. 接着，使用 `/luckperms import <file>`/ q5 c; q& H0 W\n5. Then, run `/luckperms import <file>`' ~& R+ v: j! I2 g6 q  Z\n6. 所有的数据已经迁移到新的数据存储中了\n* X\" G( Y5 n, \\: x6. All of your data should have been moved to the new datastore.& v# o# v/ W9 K* P\n0 D: v2 B( f' q, p: z0 G2 `; I0 U\n<file> 是你想用来存储/加载的文件的名称，文件位于 LuckPerms 的数据文件夹里。你可以任意命名，只要在 import 命令中正确填写。1 m1 j$ U' o' }\n\\<file\\> is the name of the file which you want to save to/load from. The file is located in the LuckPerms data folder. You can name it whatever you like in the import command.\n: B7 ]+ }1 |9 O$ u0 D) B\n  L5 r/ l9 B3 X## 备份\n$ y! V/ x# |+ g  ^. w1 M8 @1 O## Backups8 \\2 n6 y% ^6 D# o1 l6 T\n你可以使用这个特性来备份所有你的 LuckPerms 的数据，只需要运行 export 命令，将文件保存到一个安全的地方。; D\" e4 A: D6 y# l\nYou can also use this feature to backup all of your LuckPerms data. Just run the export command, and save the file output in a safe place.\n- g6 d& z( K0 N) z# G2 K, B- s$ v# e: q3 E\n## 这是怎么工作的？\n9 v1 S) E6 S* s7 j\" F## How does it work?\n0 g' s0 {( Y; D) |9 {5 {export 命令将所有的数据转换为一串命令，处理后将会重建你的安装，import 命令只是将每个命令运行一遍，这意味着你可以只导出/导入一小部分数据，你删掉不需要的一部分就可以了。\n1 [7 p( ?  p9 `$ Q# bThe export command converts all of your data into a list of commands, than when executed, will recreate your existing setup. The import command just runs each command sequentially. This means that you can export/import small parts of your data, by deleting the parts you don't need.  N# W! O! S\" V& b  C; H2 l\nDefault Group我在 LuckPerms 里处理默认和默认组的方法可能是整个插件里最不受喜爱的特性了。最新我做了一些添加/调整，做了一些替代的特性，允许最大程度的控制像其他权限插件的方法，希望这会成为插件最好的方面，而不是最差的方面。8 R( q9 s$ j  g3 `\nThe way I handle defaults and default groups in LuckPerms is probably the most disliked feature in the whole plugin. Recently I've been adding some additional / alternative features to the plugin to allow a greater degree of control compared with what's seen in any of the other permission plugins out there, and hopefully making my approach people's favourite part of the plugin, not their least favourite.\n' u/ z! n, A) c# K$ c\n. q* C$ }9 }% p7 [/ ?# 从何开始4 ?( [& w: [( n8 |0 g2 @5 h- M4 W) Y\n# Where to start: T7 J, \\4 |/ h$ n6 n+ w\n这是我的想法。\n- C7 t, u% S\" U8 ~So, here's my thinking.\n0 i4 S% B0 j+ {2 q9 T, O+ z6 G/ j& ?  v6 z0 F- f8 K\n你的服务器的用户可以分为两种。\n- d+ P# f7 `2 j\" ~( c. E3 bUsers on your server are likely to be split into two types. 9 [% Y0 s. G1 s  z2 T7 }\n\n( x\" \\5 c- @& r8 Q1. 基础玩家9 X5 s; a% o+ ^0 d\n1. The standard player.- l& L2 S; p- @\" f* m\n2. 加入不同的组的玩家，或者有他们特别权限的玩家。\n% E: M: R; j8 {/ Y7 v3 M% }2. Players who have been added to a different group, or given their own special permissions.2 R0 f. ?/ O5 ]. M5 n\" @. _\n\n& f% `% h3 I\" q* r/ \\; a你不希望浪费宝贵的硬盘空间来存储第一种玩家，你只希望存储你的职员，或者有特殊等级的玩家。平凡的\"成员\"就只是平凡，没有必要存储他们的信息。) s2 Z+ `\" q! {! U0 m: Z; j+ q\nYou don't want to waste precious disk space storing data about Player Type #1. You only want to store data about your staff members, and people with special ranks. Regular \"members\" are just that, regular. There's no need to store any data about them.\n: t\" b' t( C; S1 D) t\n6 M+ T/ s( \\# X- \\下一个问题是如何确定一个用户是\"平凡的\"或不是，想象一下情景。9 r& |* q& I6 b% s\nThe next issue I face is how to decide if a user is \"regular\" or not. Imagine the following situation.\n+ `: t2 @& N# C/ C3 L* }/ x. C  ~( m7 f# X7 o+ w' W7 l# z\n1. 默认的组设置为\"默认\"，当玩家加入，他们被设置为\"默认\"，并被保存。\n  f: x0 v) z3 h. z! X+ R- f1. The default group is set to \"default\". When players join, they're given \"default\", and then get saved.  Z0 ~8 d7 P; [6 y# C+ K\n2. 过了一会儿，你想将默认的组更改为\"成员\"。8 Y. _( \\8 u. r\n2. A little while down the line, you decide you want to change the default group to \"member\".\n/ E1 J' t: n0 |\" V\" F3. 接着你的老的成员全部在\"默认\"组里，剩下的人都在\"成员\"，这不好。4 I: ?' a+ e2 W- M* |8 @\n3. You then have all of your old players in the \"default\" group, and everyone else in \"member\". Not good., [% U& w. _) T1 E, F$ K* \\\n6 p1 z. B0 i6 K- d  k\n甚至我们没有\"平凡\"的用户，这个问题依然会出现。7 J\" L! k7 h# A+ w8 ?2 C0 r4 ]* D( \\7 w\nEven if we don't save \"regular\" users, this issue can still happen.\n6 Q) F5 T1 d1 ^% T) n6 \\  r! K8 R& a+ @\" @\n1. 默认组设置为\"默认\"\n6 S7 c% Y( R, r, v+ o3 ^( x% ^6 ]/ Q1. The default group is set to \"default\".  P: |& h; d1 d( d; T( n\n2. 你想给 \"Notch\" 一个特殊的 \"essentials.fly\" 权限，Notch 的权限被保存，标记为\"默认组\"的成员，有特殊的飞行权限。\n1 ?; V) F; P6 H9 r2. You want to give \"Notch\" a special \"essentials.fly\" permission. Notch's permissions are saved, indicating he's a member of the \"default\" group, and has the special fly permission.\n! Y+ n\" Q) T# m9 _+ I3. 接着你编辑了默认的组，所有的\"平凡的\"成员全部进入了新的组，但是 Notch 还是默认组的。% }4 Z( t! W\" O9 g0 v5 I\n3. You then edit the default group. All of your \"regular\" members get the new default group, but Notch still has default!/ l0 o' }7 c: l( y8 a\n\n8 u6 E8 @: \\; `) ^因为这个原因，我让默认的组不可配置，这让所有对我的事情都简单了 10 倍，这意味着我可以写有效率的存储系统，并且不用担心一些稀有的情况下服务器的管理员更改了默认组，但是，我知道这对一些人很反感。9 f! D0 a. }0 O1 ?- F8 H* M\nFor this reason, I made it so that the default group is **not** configurable. It makes things 10x easier for me. It means I can write efficient storage systems, with no chance of nasty race conditions occurring when a server admin decides to change the default group. However, I understand this is annoying for some people.\n' d1 ?6 Y6 M/ g( N7 H& |4 Q\n! c7 C7 S3 P4 C+ n6 l这对一些等级插件也有问题，如果你想要一个\"主\"组，并且分离\"升级\"组，你需要多于一个的默认组。\n1 O3 ^7 n9 |: `$ V) c! TThere's also issues with rankup plugins. If you want a \"main\" group, and then separate \"level\" ranks, you need to be able to grant more than one group by default. : H6 g8 r7 A. R\" ~# X0 _- ~6 {6 {. d\n/ v) _6 d  t6 y\n这里是你的选项。\n2 c2 Q& b8 y1 g9 }- {Here are your options.3 d& d) W7 |! i, @\" I+ r1 R6 {+ T\n! r2 @8 Q\" B7 |$ i5 I  @\n## 继续使用默认组，但是只是更改\"显示名\"\n8 @! n- [0 I; f& l2 F8 [  a4 B## Keep using the default group, but just modify the \"display name\"4 {/ [9 k- f* c  z\n我非常推荐这个做法，因为你继续使用默认组。\n& ~* B% c  D! r/ DI strongly recommend for the reasons above that you keep using the default group.$ T0 J( E: J1 q: N% y8 b\n6 _  c& j' Q2 t\n如果你只是想简单的更改默认组的显示名，（比如在 Vault），我推荐你配置一个 `group-name-rewrite` 规则，通过添加这些到你的 `config.yml`/`luckperms.conf` 来实现。9 G! S5 B. L* ^\nIf you want to simply change the visible name of the default group, (in Vault for example), I suggest you configure a `group-name-rewrite` rule, by adding the following to your `config.yml`/`luckperms.conf` file.7 p2 p$ _6 |- O1 Q, k) L+ x\n\n* w- `% T$ J# H: B3 W8 i( J1 K. u```yml\n, V6 g' o\" x2 r3 G2 k# Rewrites group names. The underlying name of the group does not change, just the output in commands / placeholders / Vault.\n\" @: a, {* j1 [+ cgroup-name-rewrite:# `, x* n* U! C$ i$ g( l\n  default: Member\n, |. N# r$ v/ f3 t8 N. u\" \\) }```\n4 a- {# T+ I( E2 T1 r1 L; i3 x  @8 n\n$ d$ |9 F9 s% t  x& w+ [你也可以使用这个：https://github.com/lucko/LuckPerms/wiki/Primary-Groups* O& T2 e2 U$ {4 A- I  b\nYou can also use this approach: https://github.com/lucko/LuckPerms/wiki/Primary-Groups\n! J* x\" R- X' K( X8 D2 w, |* o: O$ b$ z# N% x\n## 配置继承\n' `( L5 N! f  r+ [* S, }; A## Configure inheritance\n3 _2 T/ w6 s. i这个选项意味着所有的用户都还在\"默认\"的组里，但是这个默认组作为父组，这样他就可以将配置继承给不同的组。\n# [% ~2 c6 a' ]1 ?; U+ g\" C+ n3 @* h' EThis option would mean that all users are still in the \"default\" group. However, a parent group is configured for default, so it can inherit permissions from a group with a different name.\n\" J+ g# O1 f1 Y* C- G* }% c& o9 O\n```- I: B  x( [( y) R1 b  F  V\n/luckperms creategroup member\n! x/ u6 U+ _: P/luckperms group default parents add member\n/ B4 c+ j, s( Z8 }% N\" L4 C+ r```0 j5 e5 Y& |1 c- w\n. O, f3 O/ o9 {\" a\n## 配置默认分配\n; [/ b! J. ]+ N  a6 o2 g8 L## Configure default assignments9 s- j5 G  a0 s2 S4 |\n如果你有更多的特殊需要，你可以使用这个选项，但是，这将否定我们在这个页面的第一节讨论的存储空间规划，所有的用户都会被存储，无论是\"平凡的\"成员还是不是。4 c& B\" G4 [9 Y1 }2 P\nIf you have more specific needs, then you can use this option. However, be aware that it will negate the storage space optimisations discussed in the first section of this page. All users will be explicitly saved, whether they are a \"regular\" user or not.\n0 I! t: _8 q5 G% n6 Z8 Y3 \\5 D\" g\" ?& y+ U! z, u\n##### 注意：查看 \"Default Assignments\" 章节\n3 o4 ~6 v6 N' j\" G5 r4 @$ A##### Note: see the \"Default Assignments\" section of the config for more detail on this.\n' A( }  n7 v; h9 L\n\" r& i5 u0 ~! f  \\% g接下来的规则将会创建一个不同的默认的组。# L! ^2 H2 e+ U* D\nThe following rule will configure a different default group.\n: U\" X% R( G5 l```yml\n4 _\" F( g$ C6 \\: Y; N1 K5 z  d4 Z. Pdefault-assignments:\n6 x) q& W8 k- M4 i  my-defaults-rule:\n7 X3 Y- A, u0 e2 C    if:\n: i2 I0 P0 m\" q4 A! y9 P: w      has-true: <group.default>\n  e% `; Y! i7 D- @( W; m' P7 O    take:8 ~1 s# g: f% U9 w7 U1 V\n      - group.default\n1 f* U3 O& |; s: V* ~! U    give:\n' _! |4 N' Q: Z$ L1 Q- A      - group.member  {% R2 k\" G: I, R' V\n    set-primary-group: member5 e/ R, a& x( i2 n\n```5 |. X* y& s0 w/ u\" j( `\" c\n\n: I: h! S: x: s) `) U\" ^放入以后，每次玩家登入时，插件会检测这个玩家是不是\"默认\"组的成员，如果是，插件将会把玩家从\"默认\"组移除，将他们添加至\"成员\"组，将他们的主组也设置为\"成员\"组。* f6 B' N0 s( G5 I( n2 _, b2 G\nSimply put, every time a user logs in, the plugin will check if they are a member of the \"default\" group. If they are, it will remove them from \"default\", add them to \"member\", and set their primary group to \"member\".\n0 E( g! c# x' F9 E) P6 `\n- W) C# n7 q4 ]8 \\/ |这个系统非常强力，允许你配置按你自己的需求而定的默认组，记住你可以将玩家添加至不止一个的\"默认\"组。\n4 m7 r: G9 K\" r& K0 ]0 JThis system is very powerful, and allows you to configure defaults to your exact needs. Remember you _could_ add users to more than one \"default\" group.. x, a* v! N5 A\nConfiguration不同平台的 LuckPerms 的配置文件可以在这里找到。\n, W: l1 x6 y7 j1 R! L6 D6 DThe main configuration file for LuckPerms can be found at these locations.: l' X# l! A, K6 }9 o% j\n; n/ |5 f: W* Z: d( A: F; n\n| 平台          | 位置                                                                                                                      |: V* e. a. @. v8 W. ~, W2 T! Q' ~3 `\n|---------------|-------------------------------------------------------------------------------------------------------------------------------|\n) T2 }9 L3 }8 ?6 J/ n. }2 Q| Bukkit/Spigot | [`/plugins/LuckPerms/config.yml`](https://github.com/lucko/LuckPer ... esources/config.yml)        |\n: m! I8 R$ _# Z( @4 d8 ?' V$ k| BungeeCord    | [`/plugins/LuckPerms/config.yml`](https://github.com/lucko/LuckPer ... esources/config.yml)        |\n' m; r$ |$ w% X' x4 n- ^/ `| Sponge        | [`/config/luckperms/luckperms.conf`](https://github.com/lucko/LuckPer ... rces/luckperms.conf) |) T2 s4 o$ I0 B+ f' N7 F\n* a4 O' X; M7 |1 G\n请注意配置文件不能在有新配置的时候自动添加，如果文件中没有找到任何东西，我们将使用默认选项。\n3 I! r3 U! t; zLinks to the default file for each platform are above. Please note that the configuration does not automatically update when new options are added. The default options are used if nothing is found in the file.\" m- R: X( ^% l9 [! p\n\n\" m, @. L* J$ U$ d2 [' s## 索引+ |$ b6 F$ ^+ `0 G+ x, a\n### 基础\n( e4 B) e! a3 Z, A7 y* [`server`](#server)\n0 S( V# f& C* P9 O, W4 G6 ~* [`include-global`](#include-global)# J. m+ ^* Z$ W$ k4 B9 g\n* [`include-global-world`](#include-global-world). O9 d4 [+ z0 b' c1 J. z: {# o: j\n* [`apply-global-groups`](#apply-global-groups)\n\" n; Y4 j1 B+ s* [`apply-global-world-groups`](#apply-global-world-groups)\n4 x+ f% B) ]3 G  s0 i# v* [`use-server-uuids`](#use-server-uuids)\n1 Z6 {  U/ D3 P  u6 k. D* [`log-notify`](#log-notify)\n% `\" T9 f; j8 {& ]* [`world-rewrite`](#world-rewrite)\" {\" w- A' k  b3 i$ b* B9 s  V\n* [`group-name-rewrite`](#group-name-rewrite)\n( z8 l7 u/ U0 R, T' K4 n* [`temporary-add-behaviour`](#temporary-add-behaviour)7 n5 c, e: w. u/ ?5 K' }% N. u\n* [`primary-group-calculation`](#primary-group-calculation)8 q5 I7 B0 H9 ]& R% Z8 d\n### 权限计算\n) }; E( ^* l8 j, Q* [`apply-wildcards`](#apply-wildcards)3 s0 g( _6 n# s) [+ \\( \\\n* [`apply-regex`](#apply-regex)\n6 ?1 @+ F) v+ b' `' a* [`apply-shorthand`](#apply-shorthand)\n$ H8 j7 d4 k% T##### Bukkit\n' @/ o; \\  |8 [0 v6 o* [`apply-bukkit-child-permissions`](#apply-bukkit-child-permissions)3 O( G+ `( l. o, E\n* [`apply-bukkit-default-permissions`](#apply-bukkit-default-permissions): \\9 L3 ~2 C- x, i\n* [`apply-bukkit-attachment-permissions`](#apply-bukkit-attachment-permissions)6 W: [. h7 M+ R1 I& M\n##### Bungee\n2 e, [+ ]9 k, k  O  I9 K\" J# ?5 o* [`apply-bungee-config-permissions`](#apply-bungee-config-permissions)\n/ D* n\" j- ~! i. Q2 b% v. k; a##### Sponge\n# z- r8 K, o$ n8 p! U/ m* [`apply-sponge-implicit-wildcards`](#apply-sponge-implicit-wildcards)\" \\* k2 i4 ]) y0 S# W\n* [`apply-sponge-default-subjects`](#apply-sponge-default-subjects)  }/ Z' _# d- A, e' ~: X. s% Q\n### 服务器管理员 / Vault (仅 Bukkit 版本)- A- P( Y- C( g9 P\n* [`enable-ops`](#enable-ops)# d1 ^3 P& y& B\n* [`auto-op`](#auto-op)1 ?; R* _. o7 ?7 ~' b\n* [`commands-allow-op`](#commands-allow-op)\n6 b( z( U( u4 m& F2 o* [`use-vault-server`](#use-vault-server)\n( f) _$ x+ z8 a, n; s0 o4 u9 i* [`vault-server`](#vault-server)4 O* B& r& @4 h2 i\n* [`vault-include-global`](#vault-include-global)! D* M/ N; u$ `. ~\n* [`vault-ignore-world`](#vault-ignore-world)  l2 _  n  O* O, u4 C\n* [`vault-debug`](#vault-debug): C' l; C5 Z7 k) T\n### 存储\n) g6 H# x* X# ?. X  N9 t' I+ e* [`storage-method`](#storage-method)\n' t0 R5 @1 z; x& @# X* [`watch-files`](#watch-files)\n4 e) R4 Z1 q4 s3 F* k5 N) S) `! x* [`split-storage`](#split-storage)\n  v\" ?1 w- S6 w* [`data`](#data)  u/ p/ b0 q9 z  {1 P+ ?; I# {\n* [`pool-size`](#pool-size)\n  {# Q8 E% o! T5 H3 g  y! g. l3 [* [`table-prefix`](#table-prefix)* `) c. R+ H; V\" b\n* [`sync-minutes`](#sync-minutes)\n: I) A- }0 |+ ]- b* [`messaging-service`](#messaging-service)\n2 U1 P4 A' T# S% v3 T* [`auto-push-updates`](#auto-push-updates)\n\" s0 ~( V+ e) `7 Q# e  ~- n* [`redis`](#redis)\n  D\" g$ E+ l. b! X\" a/ k% L6 d) z\n/ J2 T. |! e2 _0 ]\n2 P4 h* E8 N8 Z$ r$ n## 基础+ A5 n( A6 q! G+ z\n___$ H3 |9 ]( V- D\n### `server`! o) n: t0 [8 [! R8 ^6 b. R\n服务器的名称，用于制定服务器的权限。- E' x% l; u# A0 b/ b. L3 P) E\nThe name of the server, used for server specific permissions.   , r4 Y, A' q2 ?: {! D0 e\n如果设置为 \"global\" 这个设置将会被忽略，更多关于服务器指定的权限可以在[这里](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup)找到。  t\" [/ R; F! c0 D% Y\nIf set to \"global\" this setting is ignored. More details about how server specific permissions are groups work can be found [here](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup).& |& X\" B4 x% j4 g6 P9 `\n6 Y1 }2 M\" b. a5 `5 u$ K& D. l6 }\n##### 示例1 X# n% n\" F8 E: u8 b$ H2 l$ b& }\n```yaml8 p8 T9 B& C3 C( e8 [! j5 s\nserver: global\n( t$ j\" E9 s4 ^; [- j8 B3 Y```\n+ Z  O) M: R% A. N8 E( K1 T, |\" A2 _  h' I7 p\n___\n. F: S1 G8 y3 A$ f# H2 I### `include-global`8 `5 V+ A) [0 W, I$ \\% e% d# {4 ^\n这个服务器的玩家是否应该应用他们的全局权限。（没有指定服务器的权限）$ E2 B$ k. j7 ^\nIf players on this server should have their global permissions applied. (permissions that were not set with a specific server).; J# H  o; u  C\" \\$ O\n如果这个选项被设置为 false，只有指定在此服务器的权限才会被应用。如果上方的 \"server\" 选项设置为 global，请不要将其设置为 false。更多的有关服务器指定的权限可以在[这里](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup)找到。# ?0 N. K$ ~\" u0 @5 g\nIf this option is set to false, only permissions that were specifically set to apply on this server will apply. Do not set to false if the \"server\" option above is set to global. More details about how server specific permissions are groups work can be found [here](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup).( x; A3 a; ~5 d- U& J. E) G\n9 N/ }$ g7 X* L' Z1 Z\n##### 示例\n4 h1 f9 I\" p; V9 G' ]  t```yaml$ i( r. e6 j4 \\8 k2 _# {\ninclude-global: true\" f4 Z' V9 y& p' }( t! F' y\n```\n) Q, d4 @* K# ~$ D# N# y( R# \\) {0 Y# d. A$ G7 `; `/ z  c\n___+ V$ m, U9 C8 }) [% C\" ]2 w4 F\n### `include-global-world`4 K) p! s% G* I9 f+ V# {: i9 E\n与上方的选项相似，只是这个选项用于世界的设定。如果设置为 false，只有指定了世界的权限才会被应用至玩家。任何没有指定世界的权限都不会被应用。\n5 M, i) `9 r2 [' RSimilar to the option above, except this works with worlds. If set to false, only permissions that are set in specific worlds will be given to users. Any permissions set without a specific world context will not be applied.\n% S2 s$ f1 F5 e. W: t\" }- `/ a; }8 ]( N\n##### 示例. B& t# A( L( |5 b! U2 G\n```yaml\n2 @- S! i+ d9 c5 ^; u! I- Rinclude-global-world: true\n/ ~. p+ d3 I& T\" |, q% ^```\n$ A8 n& i6 `6 o\n- `- t- |( q3 x, C- o___9 c0 q  P. L7 k8 }\" r% b\n### `apply-global-groups`\n4 x3 H5 P% ]$ b2 F, r  W. b这个选项与 \"include-global\" 选项类似，但是此选项更改了组的继承设定。\n  ~- L/ E7 D' jThis option operates in the same manner as \"include-global\", except changes the setting for group inheritance.\n( F# h* o. c# Z5 j. q8 G当计算玩家的权限时，插件将会给继承树设定范围，递归解析组成员关系。如果这个设置设置为 false，如果一个组没有被应用，那么它的父组都不会被计算，继承查询将会在此终止。8 N6 B4 ]- Z' G4 |$ }2 k\nWhen calculating a players permissions, the plugin will scale the inheritance tree, resolving group memberships recursively. If this setting is set to false, and as a result, a group is not \"applied\", then none of that groups parents will be considered, and the inheritance lookup will stop at that point.; h* B# o8 F* ?4 a\n这意味着就算一个玩家没有在一个特定服务器直接继承一个组，如果这个组通过了一个没有指定服务器的组继承，这个组将不会被应用。\n& b) G( d2 ^( b7 IThis means that even if a player indirectly inherits a group on a specific server, the group will not be applied if it is inherited through a non-server specific group.\n4 x7 c, l3 j- u* V; J4 q\n) v6 ?# J9 v+ l举个例子，当设置为 false，使用以下设置：\n5 J; }- m* a: AFor example, with this setting false, and the following setup:( u. R+ M: q9 I+ }+ W\n, ~7 k/ T0 r, |, d\n```\n3 c; V* S; [! |0 ?. JUser \"Luck\" inherits from group \"admin\" globally, and admin inherits from \"default\" on a specific server.\n5 V+ V: [8 P( n* `' g  F```. J& e7 i. q$ }\" p\n* W  h2 a5 d\" e2 q  t% A4 Y\n尽管 Luck 在指定服务器上继承了默认组，它将不会被应用，因为继承查询在 admin 停止。admin 的父组将不被考虑。\n6 z) f! g7 h% U. {  c& @2 O8 oEven though Luck inherits default on the specific server, it will not be applied, because the inheritance lookup stops at admin. The parent groups of admin are therefore never even considered.! ?0 T# I  ^3 Y\n% `! X) |$ B  y* u, L8 h2 F* y\n##### 示例\n3 ^- G( e/ O. f' }. s```yaml\n7 b/ H, Y* X! L- J) V& xapply-global-groups: true' Y* r\" M( x- n9 V1 \\( P; e\n```\n. k\" q% h) G: n# s0 N, K1 b2 h\n9 f) R7 T2 X* Q) \\2 X___# N; `0 g  D5 _3 r: A\n### `apply-global-world-groups`\n7 F\" o4 c/ G# w, b3 H' C与上面的选项相似，但是这个选项用于世界的设定。如果设置为 false，只有指定了世界的组才会被分配，给用户解析。任何没有指定世界的组都不会被应用。: {! d* Z1 `5 k0 E( Z; B# ]\nSimilar to the option above, except this works with worlds. If set to false, only groups that are set in specific worlds will be assigned and resolved for users. Any groups set without a specific world context will not be applied., Z0 j. e: e! `8 }\n5 p! h. Y) a\" D& P9 L& R- Q8 e\n##### 示例\n% p8 ^, N/ t; ^+ J$ ?' n```yaml\n- h, s# Q- m3 f: m4 P- Y0 X! napply-global-world-groups: true  g2 ~, L, L% y! i+ O\n```\n) B# r7 A. q4 C( v/ S; s\n, c  ^  C- y. V/ J+ k; s___\n2 b- Z' J; {# U8 E6 ^6 }1 n### `use-server-uuids`\n2 u4 b$ }* C4 L4 y7 ~. F9 b如果使用服务器的UUID，或者根据之前的连接的用户名来查询，那么这个设定应该使用 true，除非你很确定你在做什么。\n$ d+ u) e* q  i# r6 ^) \\' iIf UUIDs should be pulled from the server, or looked up by username based upon previous connections. This setting should be kept set to true, unless you're sure you know what you're doing.\n\" O# U! I' {& b9 z\" X一般的，当这个选项设置为 true 时，当玩家登入时，LuckPerms 将会使用服务器提供的用户名/UUID来标识玩家。这个在大多数的服务器都是适用的。\n3 e( b# E! g8 C7 y2 j( e1 d8 UNormally, when this is set to true: when a player logs in, LuckPerms will use the username / uuid provided by the server to identify the player. This is fine for the majority of servers.\n5 p* o8 T' M+ b$ M7 W( P当设置为 false，LuckPerms 将会检查玩家是否曾经在服务器登录过，如果找到了一个玩家，那么之前映射的UUID将会被使用，否则将会回到默认的使用服务器的UUID的方法。\n2 [1 x* i+ B; p. r) k, tWhen set to false, LuckPerms will first check to see if someone has joined previously with the same username. If a player is found, then the previous UUID mapped to that username will be used. Otherwise, it will fallback to the standard method of retrieving uuids from the server.\n% K9 |7 |. a# ^9 _在离线模式（破解版）的服务器，玩家的UUID基于他们的用户名创建。$ d& M/ W/ I  |7 O3 J8 G2 |\nOn offline mode (cracked) servers, a players UUID is generated based upon their username.\n) s7 N\" P7 e. [8 k**重要**\n/ `\" d9 m0 p; A. P. I# h\" q* q**Important:**' I\" ]$ V$ C8 }% `* \\( ]\n如果你在运行一个 BungeeCord 服务器，你必须开启 IP forward 设置，这将让服务器使用正确的UUID。\n) C5 ?7 m* y' i, w/ `If you are running a BungeeCord proxy, you *must* have IP forwarding setup, in order for the backend server to use the correct uuid for players.$ B0 F. a% o, l\n[Spigot](https://www.spigotmc.org/wiki/bungeecord-ip-forwarding/) [Sponge](https://docs.spongepowered.org/s ... ted/bungeecord.html). SpongeForge 推荐使用 [HexaCord](https://github.com/HexagonMC/BungeeCord), 这是一个 BungeeCord 分支，支持 Forge 的 IP forwarding。\n; }! X3 z7 J; a) @Guides for this can be found [here for Spigot](https://www.spigotmc.org/wiki/bungeecord-ip-forwarding/), and [here for Sponge](https://docs.spongepowered.org/s ... ted/bungeecord.html). SpongeForge users are advised to use [HexaCord](https://github.com/HexagonMC/BungeeCord), a BungeeCord fork, which supports IP forwaring for Forge.3 @! B: \\$ z6 p\n如果你的 BungeeCord 代理运行于离线模式并且你使用了 Spigot，你也应该像下方一样开启 IP forwarding，但是推荐你安装 [Paper](https://ci.destroystokyo.com/job/PaperSpigot/) 并设置 paper.yml 中的 `bungee-online-mode: false`。# _) e+ H  }. [: `$ }/ F; u\nIf your BungeeCord proxy is running in offline mode & you are running Spigot, you should still be setting up ip forwarding as described above. However, it is reccomended that you install [Paper](https://ci.destroystokyo.com/job/PaperSpigot/) and set `bungee-online-mode: false` in paper.yml.6 u\" ^) \\0 m/ ]: i( l! q; m+ j\n如果还有什么原因导致了你无法设置 Ip forwarding，你可能需要将其设置为 false，请确保这样做之前你知道这样做的后果。\n2 k6 p7 p# P( K7 v! MIf for whatever reason you are unable to setup IP forwarding, you may need to set this option to false. Make sure you are aware of the consequences before you do this.\n% c  H, j: t4 K2 @/ K; T' ]: g8 I\n4 L- x1 |+ i: [3 y##### 示例4 }( Q1 X* Q! u. s\n```yaml\n& j+ ?7 N1 `; ~$ H+ ruse-server-uuids: true\" Q\" j8 y2 B0 a) y2 J0 S( H\n```& V7 {4 g9 S% V) v\n\n  R) v; _3 V) B  ~& f4 ]( ]___\n/ J1 V& M+ k* g5 O, q& F9 G# s4 r### `log-notify`\n& u  Q- S0 G6 V2 a+ c当任何权限被修改后是否向玩家发送长的提醒。提醒将只发送给拥有正确权限的用户。\n. u& F0 K# t# E& O% K4 J6 nIf the plugin should send log notifications to users whenever permissions are modified. Notifications are only sent to those with the appropriate permission to recieve the notification. \n' I, J5 {' }\" N4 V; J; P提醒可以在游戏中使用 `/lp log notify off` 临时关闭。\n4 _: K- c3 ^/ A  h' z7 S/ RNotifications can also be disabled temporarily in-game using `/lp log notify off`* l8 U1 z4 o) \\5 W  ~\n: M% o0 m\" j4 k; Q* y% j) A\" D\n##### 示例% u) ?+ @4 |! l  Y6 |5 E\n```yaml\n0 m1 ?6 S  x2 D8 Y! F; D$ ^log-notify: true# C9 H* A7 |% J- [' w' Y\n```\n; g3 }, s\" M/ K9 e8 @7 ~\n2 z, B) Y0 M. `___\n2 g6 t' O  H7 F5 W5 t\" J  V### `world-rewrite`  ^) L+ e! I8 }8 J7 j: M\n允许你给发送的世界设置别名，别名附加于真正的世界名，递归应用。& n& `6 e6 \\  B0 W\" q% j$ `\nAllows you to set \"aliases\" for the worlds sent forward for context calculation. These aliases are provided in addittion to the real world name. Applied recursively.' z2 f! q\" ?6 E6 f- J7 V, P7 r\n\n/ `, C2 h+ s4 y5 {# Q##### 示例9 Z5 }2 k0 r2 q4 p) ?/ w\n```yaml' j; i2 C, y9 [\nworld-rewrite:2 {$ j; e, _: H5 \\# W\n  world_nether: world9 W\" i1 M0 |5 V0 Q+ w+ @( ^\n  world_the_end: world\n/ }  @0 \\5 `( ?) W: h4 D+ y0 ^```\n* {' z+ G9 i7 A3 Z  d\n0 w% E. C3 N. y( {% z  {___\n( u) z8 w. L  M) f/ \\### `group-name-rewrite`\n& c: I$ g6 t; T- }1 c, O% Z7 `允许你设置组名的别名。它们是纯粹的显示名称，实际上的名称不会改变，只有命令/信息的输出会改变。5 m\" b% t& u) ~9 [, d' ]\nAllows you to set \"aliases\" for group names. These are purely display names, the actual underlying name of the group does not change. Only the output in commands/messages are affected.\n; z  k: X1 Q) F\n( ^) O+ b. t6 j##### 示例; Q0 H( B) r' _7 V8 L) J6 \\- g\n```yaml  n+ X6 h7 D& h% A\ngroup-name-rewrite:\n/ K' Y/ q/ n' e\" z6 G* Q: c  default: Member\n+ g7 u1 U+ p0 m; D: r- W```\n! M) s. W0 n\" E9 n* {$ s. m\n8 s5 W. U\" ?! e% C, g___! C, y) m! ?, ?- n, Z# z\n### `temporary-add-behaviour`\n* ~  X- K; ?$ K7 q控制临时的权限/父类/元数据，默认是 `deny`! X' `: b0 J\" Y\nControls how temporary permissions/parents/meta should be accumulated. The default behaviour is `deny`.\n7 B+ }/ ]& m+ t% t4 r* accumulate - 任何添加的节点将被添加\n+ }+ P/ y5 a# `% ]- y% A- j+ z* **`accumulate`** - the duration of any existing nodes will just be added to the new duration& v. L, O$ D7 n. T/ C& L! c' j( h\n* replace - 临时的节点持续的最长的时间，其他的节点将被忽略\n4 N9 S* u' u: M  e6 \\* **`replace`** - the longest duration will be kept, any others nodes will be forgotten2 A& i. N! }- d2 x5 o5 g\n* deny - 如果你试图添加一个重复的临时节点命令将被拒绝) a6 f7 f( U2 L! j\n* **`deny`** - the command will just fail if you try to add a duplicate temporary node\n/ Z$ m, r* i5 T+ E8 b\n/ z( r  W4 K5 Q9 v$ q2 ^##### 示例$ W4 h) Q! Q5 Z0 c3 f\n```yaml\n/ E6 r: m\" R7 z7 d5 `4 jtemporary-add-behaviour: deny) ]1 G* \\$ `/ j\n```\n* J* n& A- Z6 O9 r; B* H/ x! a  d5 h1 j; Z\" ?, S\" S! ^% {4 ^\n___6 y7 l# U1 I- Q$ H$ l- ]& [\n### `primary-group-calculation`4 }0 j( c- q6 _7 \\0 L, d\nLuckPerms 如何决定用户的主组，Bukkit/Bungee 默认的是 `stored`，Sponge 默认的是 `parents-by-weight`。\n) U; X0 n& A  q' G4 h) `How should LuckPerms determine a users \"primary\" group. The default behaviour for Bukkit/Bungee is `stored`, and the default for Sponge is `parents-by-weight`.9 r! M3 n* W6 y' ^( h9 U\n* stored - 使用存储的记录在文件/数据库的数据\n* ~\" O6 r& n( x8 Q; w5 J* **`stored`** - use the value stored against the users record in the file/database: T* o# N8 _/ C& L5 S$ X- y* O\n* parents-by-weight - 使用用户权重最高的父组9 R. o6 n6 i: }) L- I# R# G8 L\n* **`parents-by-weight`** - use the users most highly weighted parent\n9 ~$ d) `: i( G; R% \\- ^: V+ L* all-parents-by-weight - 像上面的一样，但是计算所有的继承，包括直接继承和间接继承\n; ]6 ~( @1 Y6 a) `. |1 s1 r* **`all-parents-by-weight`** - same as above, but calculates based upon all parents inherited from both directly and indirectly% |+ H5 z& r( \\& _! n\n. v2 k2 `- A6 E; L5 ]- J! x\n##### 示例; `! j& ]1 I/ }2 e\n```yaml\n4 c# k: O9 K. @. h; m, Cprimary-group-calculation: stored\n: s- n. [+ d) [* t9 s6 Z```, R: B5 `/ M0 B3 C\n, E( H8 K2 l2 ?4 O1 O* A\n___\n/ U, p+ M% q2 K+ y& w9 _) z9 n+ ^0 w5 l# U9 i7 I! C- B\n\n  M; k9 t% w\" b# K. P$ o## Permission Calculation\n. i. \\' H1 k6 C4 l) {___# P6 a  V- `9 D- ^- }$ ~\n### `apply-wildcards`8 ~% e  ^  O\" v\n插件是否应用带有通配符的权限。\n+ K+ h: r# }$ r; }1 V: OIf the plugin should apply wildcard permissions.+ e5 X+ }# \\; R; v  t- K/ D\n如果插件的作者没有提供他们自己的通配符权限，那么开启这个选项将会让 LuckPerms 转换它们。Bukkit 尤其不认同这种做法，但是它们在管理员中间适用的相当普遍。在 Sponge，这个选项控制 \"node.part.*\" 类型的通配符是否生效。/ ?8 r+ _) p8 `& _( _! w' [8 E3 [/ D( w+ f\nIf plugin authors do not provide their own wildcard permissions, then enabling this option will allow LuckPerms to parse them instead. Bukkit especially did not endorse this practice, however it has become common among server administrators. On Sponge, this setting control whether \"node.part.*\" style wildcards will function.+ t- H\" r( x: ^\n8 G8 ?9 h1 w% }% N! S\n##### 示例\n0 R$ h1 g1 J# ^  x( I```yaml& Q* }* I# e7 _: y$ b; p\napply-wildcards: true* `& E; b1 G  }+ u# O! D\" ^\n```\n0 A# c# x: q6 ?\" B0 {( d8 L) N\" ?3 M\n___\n5 w/ w* g1 G% X) a2 w, z9 U, E### `apply-regex`1 G3 s5 |  G1 w/ b8 O# B\n插件是否转换正则表达式权限。\n7 {: b3 N) ?. l$ @& kIf the plugin should parse regex permissions.\n+ ~( S8 o5 Y# q$ \\3 j, ~# C如果设置为 true，LuckPerms 将会检测任何正则表达式权限，正则表达式权限节点以 \"r=\" 开头，返回所有匹配这个节点的请求。如果你没有任何正则表达式权限的设置，开启这个将没有任何性能的影响。这个特点的更多信息可以在[这里](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup#regex)找到。\n; n( b) a# O8 s& O1 LIf set to true, LuckPerms will detect any regex permissions, marked with \"r=\" at the start of the node, and return all requests matching the node. If you do not have any regex permissions setup, enabling this option will have no impact on performance. More info on this feature can be found [here](https://github.com/lucko/LuckPerms/wiki/Advanced-Setup#regex).\n\" j% r: r1 [% a( I1 t' E\n* x5 H- @, I, l2 O0 t6 z5 x##### 示例2 e* V9 u' J# r\n```yaml* E+ B0 ?) ^4 t! F6 z! V0 L\napply-regex: true: g& \\/ F, @; @& m3 i8 A& U\n```\n: o3 A\" A5 s. @3 P: z- F6 X7 x5 n8 p\n___\n* e  b- h/ S0 t### `apply-shorthand`8 I' c: ]. Q  M& A5 U& ^\n是否允许GLOB风格的速记权限。: J% D  G- }8 L( a2 f\nIf the plugin should resolve and apply any shorthand (GLOB style) permissions.\n5 W\" Z* P! Z7 a& t9 ]4 ?2 u' l& H更多这个特性的信息可以在[这里](https://github.com/lucko/LuckPer ... orthand-permissions)找到。% g2 n! U: X0 T+ a# N3 E: _\nMore info on this feature can be found [here](https://github.com/lucko/LuckPer ... orthand-permissions).9 I' D' T+ C( M6 q3 k: Z1 T& h: B\n\n\" Q\" G0 v) X  X4 r2 `6 l( f##### 示例\n: B% U1 f+ p8 B```yaml\n* a7 T$ D% R8 M5 D: B/ n$ eapply-shorthand: true' C6 Q8 }7 J, q7 _, z  F8 ]. f, W\n```5 X; b, a3 Q  m4 ~) r; r\n\n+ d5 K8 q! P& f0 x___\n7 X9 K, \\0 m# ^) ^! X### `apply-bukkit-child-permissions`\n; ^# `5 L\" h7 v4 j1 E插件是否应用Bukkit子权限。+ ?\" e8 l9 h\" O2 y6 ?+ q; q! {\nIf the plugin should apply Bukkit child permissions.\n! S! V# S! M: }) i* e2 U' t插件的作者可以给他们的插件定义自定义权限结构，如果设置为 true，LuckPerms 将会使用他们。\n/ H\" z2 K8 g4 E; Y8 f  \\, E- XPlugin authors can define custom permissions structures for their plugin, which will be resolved and used by LuckPerms if this setting is enabled.* Y* e# z: m7 V\n这个选项是默认启用的，因为这是一个基础的Bukkit特性，大多数的服务器管理员都需要，但是如果你不希望使用这个系统，它将可以被安全关闭。2 j& }/ h6 f1 c* ~, c1 X\nThis is enabled by default, as it is a standard Bukkit feature, which most server admins expect to work. However, if you'd prefer not to use this system, it can be safely disabled./ q' d5 H+ s0 @- }. U7 u\n\n2 ]! @: }6 L. O3 _##### 示例\n# N\" L+ \\! B! g1 z8 S```yaml\n& W5 c- E: e/ C+ mapply-bukkit-child-permissions: true\n8 i4 b8 j/ I# ^( Q! K```\n& d% p1 L& T1 E# o- D4 i4 j\n7 p- c8 r) d& E* W___\n1 Y2 a7 @5 v& h8 G### `apply-bukkit-default-permissions`: w5 B$ Q3 c8 {; g+ X1 n\n插件是否应该应用Bukkit的默认权限。4 u5 H/ i\" b7 D, _\nIf the plugin should apply Bukkit default permissions.8 G$ S  q. ~! i9 a\" d5 ?* `8 \\\n插件作者可以给所有的用户默认权限，或者设置应该/不应该给OP玩家。如果这个设置为 false，LuckPerms将会忽略这些默认权限。\n, e0 h3 n& ]* Q/ D# r, N9 ~6 DPlugin authors can define permissions which should be given to all users by default, or setup permissions which should/shouldn't be given to opped players. If this option is set to false, LuckPerms will ignore these defaults.\n) |/ m8 C$ Z7 w! [! j. q, v这个选项是默认启用的，因为这是一个基础的Bukkit特性，大多数的服务器管理员都需要，但是如果你不希望使用这个系统，它将可以被安全关闭。\n\" Q3 i$ @- S' J  W; N% z* ?9 E4 }This is enabled by default, as it is a standard Bukkit feature, which most server admins expect to work. However, if you'd prefer not to use this system, it can be safely disabled.\n$ r  J3 a/ r1 e& r9 s, N4 w2 k( T+ U/ P( g3 K9 i, z/ s: Z! }! `) g\n##### 示例\n0 X) e& Y2 W  _$ M```yaml\n3 V2 a' y0 L) u* K2 rapply-bukkit-default-permissions: true\n7 R: z* t- C2 N- ]\" g+ h6 k4 y```+ e+ f0 e2 W+ q& D\" s$ k. R5 W% N\n\n! M- {5 O  T: s\" @* W. m% b/ ^5 q___\n2 O1 _! u9 n' V! [8 L  r/ a### `apply-bukkit-attachment-permissions`\n\" X8 h1 u6 H+ \\& `9 l$ |6 y插件是否应该应用Bukkit的附加权限。0 [. N1 a: q' N4 y) ?. S# ^\nIf the plugin should apply Bukkit attachment permissions.\n) G\" c2 l0 a' f! l5 M服务器的其他插件可以添加它们自身的\"权限附加\"到玩家，这允许大量的玩家附加权限持续到回话结束，或者被移除。如果这个设置被设置为 false，LuckPerms 在考虑玩家是否有某一特定的权限时，将不会包括这些附加的权限。\n6 O; O; r0 H$ ^) z: f7 uOther plugins on the server are able to add their own \"permission attachments\" to players. This allows them to grant players additional permissions which last until the end of the session, or until they're removed. If this option is set to false, LuckPerms will not include these attachment permissions when considering if a player should have access to a certain permission.\n! _\" }: ~0 D' H) H% s6 g1 ?\" h0 p你在开启这个选项后可能会见到一个小的性能提升，关闭 OP 系统后，这个系统可以非常有效的阻止恶意插件给玩家任意权限的尝试。, l4 \\4 V5 w2 @3 T7 m\nYou may also see a slight performance improvement by enabling this feature. Combined with disabling the OP system, this system can be quite effective at disabling malicious attempts by plugins to grant arbitrary permissions to players.\n$ P' ]& J' G$ o; i. f1 O这个选项是默认启用的，因为这是一个基础的Bukkit特性，大多数的服务器管理员都需要，但是如果你不希望使用这个系统，它将可以被安全关闭。\n/ ^( o! T  p  E+ }- I- {9 BThis is enabled by default, as it is a standard Bukkit feature, which most server admins expect to work. However, if you'd prefer not to use this system, it can be safely disabled.( v- |) r, E! N- g* I9 U\n! ^2 v3 Q7 h# B# j\n##### 示例\n1 m& V% y) T7 l\" c```yaml: F3 u; a7 d7 V# K6 L\napply-bukkit-attachment-permissions: true3 u2 b7 `) S9 L+ z( q! c\n```\n. M! A* V3 _/ |: c) P* l: h7 Z2 F; |0 c( S5 e. F+ W- y* M0 z% {8 _\n___) V# Y# i\" I3 s' L) \\0 b\n### `apply-bungee-config-permissions`0 @1 v0 }, Q* S# h2 c# W9 O\n插件是否应用 BungeeCord config.yml 里设置的权限和组。\n% @8 o; O. @% |If the plugin should apply the permissions & groups defined in the BungeeCord config.yml% [1 [$ A% ~% [, t( X' k; w4 J\n如果设置为 false，LuckPerms 将会忽略这些值。0 b# s4 m) L0 G+ @% g\nIf set to false, LuckPerms will ignore these values.\n: P' M1 d! `' ^. j/ |3 \\; E这个是默认关闭的，因为所有的权限都应该通过 LuckPerms 来设置，这样他们可以在游戏中查看和编辑。\n+ D' B! ?) g& j/ g: ~This is disabled by default, as permissions should really be defined within LuckPerms, so they can be viewed and edited in-game alongside everything else.\n( d7 D# S- p3 P3 v; f' I5 Q+ m( E3 `  ]\n##### 示例' u+ u) A, D- \\- m$ `\n```yaml\n+ x* h, R: L  t# {apply-bungee-config-permissions: false5 z4 C, I1 t+ l$ e5 i\n```\n' @0 V% U8 `9 c  M# [\n* P6 x# ?/ ]- j& Q' w6 `___\n. v, W* u2 g8 q$ e) w8 j### `apply-sponge-implicit-wildcards`$ y4 K8 l8 i: i7 }\n插件是否解析并应用Sponge的通配符集成系统的权限。% V) q$ P- C4 H$ w\nIf the plugin should resolve and apply permissions according to Sponge's implicit wildcard inheritance system.\n& N; R0 E+ V4 Z; s1 b; w7 J% k如果一个玩家获得了 `example`，那么他将自动获得 `example.function` 权限，`example.another`，`example.deeper.nesting` 等。\n! d4 Z, ^  }5 RThat being: If a user has been granted `example`, then the player should have also be automatically granted `example.function`, `example.another`, `example.deeper.nesting`, and so on.\n4 a. p4 s. v5 D+ Y' |- [如果这个选项被设置为 false，系统将不会被应用。\n* K8 ~% N4 Q( U0 m9 z2 S; Q9 VIf this option is set to false, this system will not be applied.\n! l- q' t* \\9 d: i4 m1 J这个选项是默认启用的，因为这是一个基础的Sponge特性，大多数的服务器管理员都需要，但是如果你不希望使用这个系统，它将可以被安全关闭。  I7 y( t1 J/ b\nThis is enabled by default, as it is a standard Sponge feature, which most server admins / plugin authors expect to work. However, if you'd prefer not to use this system, it can be disabled.\n2 o! N5 B( Z$ H( U! E' e8 f1 y+ W# C( {* K. W, M6 a1 G\n##### 示例\n9 Q* b\" S4 h. F* W# M```hocon\n% x9 e- S( S' d+ U- y5 Qapply-sponge-implicit-wildcards=true\n4 p5 y. L- k0 J8 S! B```\n( a  a; X% V/ M- Z) O6 q$ Q0 ^9 a+ f) r\n___' @5 [' [$ n- |0 w/ h% _\n### `apply-sponge-default-subjects`; O9 l) N8 _, V( Q\n插件是否应用Sponge的默认权限。\n1 Y  K0 Z/ B5 L! D, J1 b$ V: HIf the plugin should apply Sponge default subject permissions.\n0 g( `7 n) A2 A1 n插件将会授予玩家一组默认权限，如果设置为 false，那么插件将在考虑玩家是否拥有某权限时忽略这一组权限。\n2 V' ~) N* H7 KPlugins can manipulate a set of default permissions granted to all users. If this option is set to false, the plugin will ignore this data when considering if a player has a permission.\n( O7 N, {7 X: {; T( Q: t' g这个选项是默认启用的，因为这是一个基础的Sponge特性，大多数的服务器管理员都需要，但是如果你不希望使用这个系统，它将可以被安全关闭。\n) q# E: n) G* O4 F; X. Y$ s3 NThis is enabled by default, as it is a standard Sponge feature, which most server admins / plugin authors expect to work. However, if you'd prefer not to use this system, it can be disabled., F9 |5 ]& [, A$ P' Q* a# \\\n0 n2 K3 L8 ^+ C) F9 N\n##### 示例\n5 R+ N! Y& [) l0 ~* L```hocon\n1 E1 O$ |- N\" m6 R2 k\" @apply-sponge-default-subjects=true4 C; s8 L; L+ S: ~* N: A& a' @\n```\n5 L& P/ a, i* V0 Q) p0 ]- S) m& B0 H. v: K\" ~, e9 Z4 Q# h5 u\n% I* Q) ]8 d8 t, l, t\n## Server Operator / Vault (Bukkit version only)\n( a9 c/ ]7 f( n' \\$ d5 w: Z! t___\n% F. {: _% g3 h! p) z; z5 L+ ?### `enable-ops`& l% t; \\+ @  q$ m# X7 W# Y\n是否使用原版的OP系统。\n\" h3 c, X. Y5 w$ I7 Z1 s  q* `If the vanilla OP system should be used.: R; g: C! @- O6 u\n如果设置为 false，所有玩家都不是 op，op/deop 命令将被禁止。' ?8 s1 N# k0 P$ T% ]& ~  m: Z\nIf set to false, all users will be de-opped, and the op/deop commands will be disabled.\n. F$ v/ G' V6 z3 D9 ~4 _8 p9 o; X\n6 v& t7 [/ `\" z- J4 s##### 示例\n5 V% L3 S6 M5 P# v```yaml\n+ Z8 o0 ]1 O3 I' Henable-ops: true6 J) x: l0 y- a# R# a\n```\n/ w- e* i/ c1 [6 X9 i/ K8 E2 E3 {- P6 g$ N7 S- p\n___\n. }0 t9 ?9 R; {5 T### `auto-op`: m$ C: L\" T1 a/ Y, j6 \\\" o, y9 o) S\n如果设置为 true，任何拥有 \"luckperms.autoop\" 权限的玩家将会自动设置为服务器OP。\n3 m4 L3 W3 j2 r& U# S! SIf set to true, any user with the permission \"luckperms.autoop\" will automatically be granted server operator status.\n: Q: ]  i1 ?! W# u这个权限可以被继承，或者设置在特定的服务器/世界，临时的等等。另外，设置此选项为 true 将会强制上方的选项 \"enable-ops\" 为 false。所有的用户都将被 deop 直到他们有了这个权限节点，并且 op/deop 命令将被禁止。\n7 X! }6 y. t! a( eThis permission can be inherited, or set on specific servers/worlds, temporarily, etc. Additionally, setting this to true will force the \"enable-ops\" option above to false. All users will be de-opped unless they have the permission node, and the op/deop commands will be disabled.\n: `8 ^. A\" y# Q9 X有一点需要注意的是，自动OP检测只有在玩家进入服务器和切换世界时生效，这意味着，简单的移除他们的权限并不会自动去除玩家的OP，玩家必须重新登陆才能使其生效。# w7 o0 Y\" X6 b$ g; L+ @/ ~# m; o\nIt is important to note that this setting is only checked when a player first joins the server, and when they switch worlds. Therefore, simply removing this permission from a user will not automatically de-op them. A player may need to relog to have the change take effect.& @5 i- ]8 k3 G% i9 T\n推荐使用这个选项而不是简单的分配一个 \"*\" 权限。\n( m6 c, Z\" l0 _: ?; ?\" ~' LIt is recommended that you use this option instead of assigning a single '*' permission.\n/ `& C$ T9 n/ [1 h5 y; ~\n. a& b, E* n+ l##### 示例+ O: N9 u9 O. _+ s5 n\n```yaml\n2 A9 L; n1 o) A& ^* s0 U2 dauto-op: false\n1 E& P; e& k  p0 B: }$ k```2 r) i( ^7 V* t& D1 N' ^\n\n$ a! b9 R$ i& Z6 K___\n4 K& A% x2 ^. |### `commands-allow-op`& w! e+ c$ Z6 x$ @6 |5 V\nOP玩家是否有权限使用 LuckPerms 指令。\n4 |8 r: M8 j- RIf opped players should be allowed to use LuckPerms commands.\n; P* U$ ^5 I2 t- @% u\" _设置为 false 将只允许有命令指定的权限的玩家使用。6 c. C+ M; J! v4 b7 Q\nSet to false to only allow users who have the permissions access to the commands\n0 `/ G& |/ v; V/ K\n2 x# b' m3 |4 M' G9 @' p6 s##### 示例\n7 T6 R  n$ L' I- O4 w' \\; t```yaml4 G: H6 c9 S* p6 p4 G+ V' B\ncommands-allow-op: true\n6 j) N  w7 @& S6 r```% o3 X; b  c: z9 L\n, \\8 J+ R/ ?2 {' a' w2 a. p3 A* f\n___3 U# s8 j  {6 o5 i\n### `use-vault-server`\n2 N1 `\" m- i1 P; g0 R下方的 `vault-server` 选项是否应该使用。' N* ?. [3 ]/ A. n3 l$ z\nIf the `vault-server` option below should be used.. w7 N. V7 f. a1 z: S\" `$ J9 u\n当这个选项设置为 false 时，\"server\" 值用于 Vault 操作。) ~. d: s1 m/ g8 W( I' d, U) I\nWhen this option is set to false, the server value defined above under \"server\" is used for Vault operations.; O+ m6 n0 l) v0 p# N7 \\; f  n! F\n\n8 t6 V\" z- N, j( |##### 示例1 U5 {# J- S  z! F; P: l\" B/ q\n```yaml\n* I9 d% f+ D$ Z5 Ruse-vault-server: false\n3 w' d) e\" i) R+ j5 Q3 r) F' A```! N  k9 v% ^6 {) i( k\" U+ s: h\n/ g7 X4 w# N; j2 {+ X2 V\n___\n' h2 `4 w- p' D4 g$ q8 p, I### `vault-server`0 U6 @, P% h6 k' Z% u# V! k\nVault 操作中使用的服务器名称。\n5 U4 Z+ c- F5 v' N1 V+ HThe name of the server used within Vault operations.\n! _  D; B  O4 d8 n' T如果你不想让 Vault 操作为特定服务器，将其设置为 \"global\"。\n( e, B( N8 o\" M+ n9 z& P1 gIf you don't want Vault operations to be server specific, set this to \"global\".5 V: G/ ], e5 Y+ U' f+ {\n只有当 `use-vault-server` 设置为 true 时生效。  @- N+ d' ^% }0 ?\nWill only take effect if `use-vault-server` is set to true above.\n; f/ r2 T: ~/ s9 n: c\n$ J$ D' T4 @+ k: o8 W! `# B) S##### 示例\n/ R* z* v; m/ }0 W+ v5 j```yaml4 T' P* U' k# @\" j4 U# d* ^\nvault-server: global\n/ d: ^; f/ k0 y, p```\n$ a* T  c/ y/ Z, N% H4 C6 C4 _% `2 n; e\" T  N9 E0 J6 _+ I\n___+ Z& q- j  K/ q\n### `vault-include-global`' t# j, M# M7 m3 K5 X7 b8 B\n玩家组接受元数据时是否考虑全局权限。\n* |4 I7 V2 [! ]# O& vIf global permissions should be considered when retrieving meta or player groups.\n( |9 E6 r4 \\5 ]\n! g& \\0 W7 @# ]( L##### 示例/ N1 W6 |% O* [0 q* v\" [5 W1 J6 W\n```yaml6 O- s- s% B; q, V$ r\nvault-include-global: true: l. Z) P- n# B\" k- o+ }\" M  h\n```3 L5 m) ~0 j  O4 O# p\n\n9 \\! Q- D  `. t! k6 t. H1 i___\n$ m: s' H) {6 t! R### `vault-ignore-world`\n+ o4 C' f/ l$ yVault 操作是否应该忽略提供的世界参数。\n* q) g% l8 f9 TIf Vault operations should ignore any world arguments if supplied.& Q* ]7 ]* M7 t% Z. {0 T0 P$ [\n默认情况下，如果没有提供世界参数，权限将会设置在玩家当前的世界。（Vault 的设计给满分）。设置为 true 来更改这项操作的结果。0 x8 V  m% q# P9 ?) [0 u\nBy default, if a world argument is not supplied, permissions will be set on the players current world. (Vault design is just 10/10). Set this to true to change this behaviour.\n0 g+ K9 y7 z6 X  U: x5 O9 V3 Z0 \\% ^' F  @/ t; N\n##### 示例\n2 T! M9 K\" |% @9 S```yaml, w6 d6 N) {7 Z0 P9 f\nvault-ignore-world: false# Z* N+ m+ @- q' i& \\* y\n```7 }6 ~2 B) `8 J9 ]! B3 ?/ k\n\n% N8 l; w; K6 U& G) V0 s1 u- y___\n$ ?( p+ f# T9 Q) \\### `vault-debug`\n5 {% Q& v+ X5 X5 S0 e. S, ?LuckPerms 是否应当在一个插件使用了 Vault 的功能后打印 debug 信息。\n5 x9 W\" X6 S$ k( F4 P2 O) ?! DIf LuckPerms should print debugging info to console when a plugin uses a Vault function' l\" e, Y8 n: V. [0 ]\" S# P\n\n( t* J0 l8 \\/ c! I# u3 Y##### 示例! o2 J& t5 C8 {% y+ G- q\n```yaml2 q\" D, V0 O' m* ^0 b; ]$ L8 }  c\nvault-debug: false\n* L. {, K. r- g0 n2 S! @0 A```\n! y5 g& d8 x. H0 ?7 Q, F9 ^\n! d' Z. A4 {- H! _& b6 f/ S\n3 U# H* p( T, |' V5 o## Storage\n. u9 N3 R  V; u4 L\" M% t9 W+ C* P9 [\" q___\n( I2 d\" {) M. a% Q### `storage-method`\n5 e4 }- z3 q/ d$ P\" X9 e% _插件应该使用哪个存储方法。\n6 V5 a4 X/ @& v$ B1 V- |Which storage method the plugin should use.\n, h9 P+ M. e  }( f2 |* Z2 p查看[这里](https://github.com/lucko/LuckPerms/wiki/Choosing-a-Storage-type)查看支持的所有类型。& F\" @/ H7 g- T* t* Y\nSee [here](https://github.com/lucko/LuckPerms/wiki/Choosing-a-Storage-type) for a full list of supported types.- i1 j) I2 P; d& i2 {- A$ q& ]\n接受： `mysql`, `mariadb`, `postgresql`, `sqlite`, `h2`, `json`, `yaml`, `mongodb`\n5 T3 h0 |1 c- K) ?/ Q: x0 M**Accepts:** `mysql`, `mariadb`, `postgresql`, `sqlite`, `h2`, `json`, `yaml`, `mongodb`1 I& Y# s- E# y; v; r: {- J, |\" E\n如果你的 MySQL 支持，那么 `mariadb` 选项比 `mysql` 更好，`h2` 当然也比 `sqlite` 更好。\n. j0 b! g# q7 aIf your MySQL server supports it, the `mariadb` option is preferred over `mysql`. `h2` is also generally preferred over `sqlite`.\n  E# X- r  B- G6 ~, Y/ c\n9 t' r( P\" S0 U; w% P  S, \\8 O##### 示例/ [9 l, \\! u0 s\" F- g6 q! ^; Z\n```yaml\n# [) p. Q\" }2 T2 d9 }storage-method: h21 I- d4 \\) X9 d5 X' R8 \\\n```\n/ v, _1 G  X. ~\n# g# i5 p\" G9 \\. h: z5 {6 L___\n5 `. Z2 r/ X2 F- Y4 ?/ B\" ^### `watch-files`\n\" @\" G, Q* m4 `9 |0 S! U2 V当使用基于文件的存储系统，LuckPerms将会监视数据文件的变化，并在文件变化被检测到的时候自动规划更新数据、\n2 j& O) N' N4 Y6 Y- b3 T& v4 zWhen using a file-based storage type, LuckPerms will monitor the data files for changes, and then schedule automatic updates when changes are detected.\n  I' t, {8 w# H5 D. K  {. B如果不想让这个发生，那么将此选项设置为 false。\n! r* U$ k. T7 ^0 x7 k0 UIf you don't want this to happen, set this option to false.- K2 R1 k0 i7 [. ~: v\n\n4 ~( y* r9 |9 z) B4 H##### 示例/ s* e  M' f+ H\n```yaml\n( \\7 \\5 J4 t; e+ M0 H# _, c8 zwatch-files: true\n4 Q, m3 a6 e8 ~! F$ K  ~```. c/ ~4 \\8 R% }! [\n. u! V# k( q: U\" [\n___\n; b2 R9 k1 F4 L4 i/ j) x- P$ ]### `split-storage`\n$ C- v/ {\" s5 w; o, Y/ c分离存储允许你为不用的数据类型使用不同的存储选项。* j6 g; b8 s! S7 ^9 K' r' @: G\nThe split storage section allows you to use multiple storage options for different types of data.\n4 O/ C- q* _/ t, V4 t5 a5 L不同类型的数据有：9 a& V( l) ?- H8 L\n**The different types of data are:**\n7 ?\" A/ y8 K- k# o; e* user - 关于用户的数据，包含权限、父组和元数据\n5 K2 W6 S& X9 e2 H7 Y5 h1 O$ Y* **`user`** - data about users, including their permissions, parents and meta\n1 N7 v  G) l& s* P0 D* group - 关于组的数据，包括了组权限、继承组和元数据2 o9 j- q9 E4 m/ i( P+ ~3 @\n* **`group`** - data about groups, including their permissions, parents and meta\n0 O( u) e! n& h' T+ T\" I( E* track - 关于轨道的数据（或者说是梯子）\n: J9 _. g. t5 m* **`track`** - data about tracks (or so called \"ladders\")3 Y) a5 U# C8 n: _/ P& u4 p\n* uuid - LuckPerms 适用的 `uuid <-- --> username` 缓存，当 `/lp user` 使用的是用户名而不是 UUID& I# U4 r$ m+ u9 }; i1 O. f0 p0 g3 @: I\n* **`uuid`** - a cache of `uuid <-- --> username` used by LuckPerms when usernames are used in the `/lp user` command instead of uuids.\n8 @- G7 J* Q' Z\" a/ W* log - LuckPerms 存储的日志\n) @1 H) v! q& {* **`log`** - the action log stored by LuckPerms; T- X7 u' p/ g: }2 W; ^\n允许的数据类型在上方列出\n, x' h% ]) _4 \\  M4 p' QThe allowed storage types are detailed above.\n0 h# Y: l$ h9 O# H/ U, n9 R& D\n% X6 H/ M' c( h! g- ~3 f##### 示例  ?; E2 i4 z  V5 T: r\n```yaml\n% D; C$ U3 y1 z/ M6 zsplit-storage:- W1 s! |9 O; t9 C6 w- V\n  enabled: true( }# }  c: t; M; y# Y4 Q# p8 q\n  methods:  p6 u1 G- A. \\. `0 O$ e- n\n    user: mariadb\n  ~1 l& V4 ~& h# w5 ]    group: yaml\n! m6 e% w0 w2 T& |( U- Q    track: yaml/ X\" _& N+ d+ I* L' Z! n\n    uuid: mariadb\n6 s% W' d' w3 r6 V+ ^5 B1 k! W    log: mariadb4 z! K$ ?6 V2 z% h\n```\n2 r+ d' n4 ?% |; B( J; V2 k! I* B( }8 |; }: t\n___3 {# a8 g8 }8 ~- V/ X\n### `data`\n+ H& [9 ~( O1 p& E, W8 Y! I此选项用于指定数据库的存储凭据。\n$ p. ?; z% n$ E6 D+ jThis section is used for specifying credentials used for storage methods.: t# F* l7 U' q; @, a\n\n. a4 `2 d; n1 m. t* address - 数据库的地址，如果使用默认的端口可以不填写，如果使用了特定端口，请使用 `host:port`\n6 b/ f5 s$ C0 t/ P6 [* **`address`** - the host to be used for the database. Uses the standard DB engine port by default. If you have a non-default port, specify it here using `host:port`.\n7 y; ?8 \\7 g; X9 i+ z* E* database - LuckPerms 应该使用的数据库6 j7 ]- t& N; ?$ q9 a# o\n* **`database`** - the database which should be used by LuckPerms/ B+ b, t: [\" b% ~2 l\n* username - 使用的用户名\n' n7 x, l1 m9 {; y. r! K0 W) u* **`username`** - the username to be used\n9 _0 ^$ v8 X5 \\) x$ z8 L3 @* password - 使用的密码，留空则不使用验证: Y) I  O( ^& t; Y0 C\n* **`password`** - the password to be used. Leave empty to use no authentication.\n5 v. \\7 d* d4 V+ }, t8 B# |# R\n' f\" y: \\) a0 f* L' q( O+ o5 l4 R\n##### 示例\n+ J7 K: h+ i- s2 E# B: f: @```yaml\n0 t7 h\" m& v; C! Idata:\n& g% x\" P4 u9 t' }& _4 k# @  address: localhost\n. d# ~! R. |( @, a- c  database: minecraft\n+ _  P% v5 r1 W  username: root\n3 _5 Y2 D* V1 y7 H  password: ''\n/ ^$ y/ t' `3 P```; |( _* t% Z' j: j2 u* h% D\n\n9 |, U1 L* L0 J6 K) J7 M7 V___\n) I! M7 A, O* U$ j\" E### `pool-size`' H6 @( w! |+ i$ K\nMySQL 连接池大小。8 u. [# i3 e& M3 h! Y! e7 `+ s\" [\nThe size of the MySQL connection pool.\n/ {0 \\7 D! b9 q1 g& L+ T* s默认为 `10`，应该适合大部分服务器。只有你清楚你在干什么再更改这项设置。6 y) l) y3 v  A- Z! e: I% G\nBy default this option is set to `10`, which should be fine for most servers. Only change this option if you know what you're doing.; h1 ?2 B- a! _8 q3 ~\n查看[这里](https://github.com/brettwooldrid ... i/About-Pool-Sizing)了解更多关于连接池大小的信息。9 ]' P8 [$ A* Y0 b: L\nSee [here](https://github.com/brettwooldrid ... i/About-Pool-Sizing) for more details about pool sizing.\n$ w9 V7 p& J! |4 ^\n, E! N0 X1 b' Y: L4 \\* L8 I5 D! ?( ^& N##### 示例- |\" U* z\" h! O5 M\n```yaml\n  w' t% A4 n3 h4 F( ndata:# B: r3 V1 Y2 ~( H\n  pool-size: 10 # The size of the MySQL connection pool.; N1 [, V7 k; \\\" o# b& X+ e& E\n```8 F& p/ Y% T& ~6 Z* A  y\n\n8 o- _( R3 A9 ?* K___\n7 O# C9 Q* O* w; @& |7 g* Y  Q### `sync-minutes`; n* A, x$ J\" h( y1 q( z7 e\n此选项控制 LuckPerms 多长时间进行一次同步任务。2 B/ R6 E$ P5 s2 U; \\\nThis option controls how frequently LuckPerms will perform a sync task.\n. q  n2 T3 y6 R# r/ n% G3 [' }0 H同步任务将会刷新存储中的所有信息，保证插件使用的是最新的数据。\n0 T% w3 b/ S) P% q8 oA sync task will refresh all data from the storage, and ensure that the most up-to-date data is being used by the plugin.\n* R8 T2 g9 u\" o) b+ i% R& [这个选项默认关闭，因为大多数的用户都是不需要这个功能的，但是如果你使用远程存储，又没有设置信息服务，那么你可能将其设置为像 3 这样的数值。% s+ W+ f  X, s& X2 y% _( [5 n\nThis is disabled by default, as most users will not need it. However, if you're using a remote storage type without a messaging service setup, you may wish to set this value to something like 3.\n% H* y5 w* {\" g2 O6 U设置为 -1 来完全停用这个任务。. a9 ~/ k5 _' a\" ~# Y+ r7 f\nSet to -1 to disable the task completely.0 H$ b' u8 q% G; S! k# y\n\n; _' {2 @! Y4 F  ?##### 示例\n1 {& ?4 ?# h* C5 T, ^# }1 P) S```yaml4 l  ]' Y* w; b! _* U\ndata:\n/ W2 C  G% I' h2 \\, _  sync-minutes: 3; m% i! J: k$ t# v: F2 [\n```\n$ C* \\! _- @$ N. O* E+ H\n9 N! T& |  j3 B+ b- w3 V1 ?___\n) `, \\! ]# x4 U( \\/ b, Y### `messaging-service`\n7 I7 y% c0 U; D: i0 s; m5 I设置信息服务。\n% z- y( ]1 a3 I( r' rSettings for the messaging service.- ?8 k* ~, c* [6 y\n如果开启并且正确配置了，LuckPerms 可以使用消息系统来通知其他连接的服务器更改。使用命令 `/luckperms networksync` 来推送更改，使用这个服务不会存储数据，只是用于消息平台。$ s2 Z$ {5 Y& D* ~0 P5 j\nIf enabled and configured, LuckPerms will use the messaging system to inform other connected servers of changes. Use the command \"/luckperms networksync\" to push changes. Data is NOT stored using this service. It is only used as a messaging platform.\n! w8 @9 P\" l* u; y如果你决定开启这个功能，你应该设置 \"sync-minutes\" 为 -1，因为没有必要将数据推至数据库。9 N/ W! w. G) p\" c7 Q+ n\nIf you decide to enable this feature, you should set \"sync-minutes\" to -1, as there is no need for LuckPerms to poll the database for changes.' B. h% J) i  Y\n可用的选项\n7 j9 O+ d3 F2 S6 Z**Available options:**\n/ M- Y  E+ Y( K1 {6 @1 y) v\n7 _# \\/ }9 n1 x# `8 a* bungee - 使用插件的 messaging channel。必须在所有的子服务器开启才能使用，并且要在 Bungee 安装 LuckPerms。/ K# `3 F' s7 ~& `: i7 W\n* **`bungee`** - uses the plugin messaging channels. Must be enabled on all connected servers to work, and you need to have LP installed on your proxy.  h, t, S+ \\4 {9 ?\n* lilypad - 使用 LilyPad 的 pub sub 来推送更改。你需要安装 LilyPad-Connect 插件。\n. W: p2 J: H9 M: \\* **`lilypad`** - uses LilyPad's pub sub to push changes. You need to have the LilyPad-Connect plugin installed.\n! k+ {5 V* T: Y: s* redis - 使用 Redis 的 pub sub 来推送更改。6 [7 \\* t) m% `; D\n* **`redis`** - uses Redis pub sub to push changes.. a, ]* c# r# o5 e0 f$ y\n* none - 啥都没有！\n8 F, |( m' ~+ J7 y4 y' m* **`none`** - nothing!\n\" P+ l  a* q( v\n7 [2 ~# n\" p; w- a- p. J##### 示例6 }\" T% M$ c, U! R. a* f4 c\n```yaml* [9 H- e) v/ j4 G0 P2 P; H\nmessaging-service: none. r) m$ K+ |& Q& e; l# L4 n, ]- L\n```) S& n$ P3 M8 S\" ^$ t* F\n$ H' x# X3 m# \\% ~* l& Y3 H\n___\n. P1 J+ r8 ]7 J1 I! T9 j: G! y### `auto-push-updates`, f- e; ?! z# {2 h/ G& s\nLuckPerms 是否应该在命令执行后自动推送更改。; `4 d( \\* r' g5 n\nIf LuckPerms should automatically push updates after a change has been made with a command.\n- P$ R7 R# O& @. L5 w5 s\n: C+ g1 Y& w/ @9 o8 R# f) i##### 示例\n! v+ X1 V( n* K, b* ]4 l```yaml# o# a! B+ E  \\; }  E3 f& F7 E\nauto-push-updates: true\n5 O1 O, i1 W& i1 s, E( |```\n& y: T) s5 t; G* P2 L\n+ |- K  l, @; r. M* S___, a0 e& G& f, D; g\n### `redis`\n% s9 }- l# J* z  BRedis的设定。$ g; q8 `4 \\+ I7 ~: d\nSettings for Redis.! Q& }6 G3 J4 n, a\n( Z% ^$ v. F% X5 G+ l* t\n* address - redis 使用的地址，默认使用默认端口（6379），如果你有特定的端口，请使用 `host:port`。% Q& C0 X, O8 l3 o0 y\n* **`address`** - the host to be used for redis. Uses the standard port by default (6379). If you have a non-default port, specify it here using `host:port`.* M+ d& @8 I0 Z- s\n* password - 使用 Redis 需要的密码。留空则不使用验证。\n6 Z# r8 k\" I1 `& R* **`password`** - the password to be used. Leave empty to use no authentication.) L5 \\7 |( ]& d+ u* ^\n\n5 e5 w# q) _8 L3 k  y0 R+ c: ~##### 示例7 O! }+ j' H/ @  T4 ]+ S\n```yaml\n6 a. `4 U. K! c6 ~\" @8 ?2 }4 Fredis:% w. P5 C3 g& R% ]  r3 b) B' o* Q\n  enabled: true1 E( k; C$ J# [- H+ \\3 }8 c; w\n  address: localhost\n4 R2 f' i# s; ]3 u# j  password: 'passw0rd'\n; Y& e; }' T- a\" x\" K: n$ w; D+ d  I```\n4 p) e* s2 V2 g/ @- ]/ E\" S$ w, c( a4 S' ?! j\nHome# LuckPerms Wiki8 M  ?# m) R+ t- _\n  s8 B) C\" f- P\" F+ O, ]\n欢迎来到 LuckPerms wiki。这里你将会找到本插件的完整的使用文档，包括了安装、设置、配置和如何高效的使用 LuckPerms。% g+ A- s2 O+ F, ?, Q+ r\n\n1 @% c) i% A0 i' @### 从何开始?\n) P9 O2 {+ S\" P' U5 I4 Q+ j如果您从未使用过任意权限插件，我推荐你从头开始看。\n! n  S# J5 G# T9 ?7 j5 ^: O0 f. O3 u. K7 `! E' Q0 L- x/ g* g2 J- g\n基础都在[使用教程](https://github.com/PluginsCDTribe/LuckPerms/wiki/Usage)页面。完整的命令使用在[命令使用](https://github.com/PluginsCDTribe/LuckPerms/wiki/Command-Usage)页面。\n( ?6 F/ P3 b: F# I' B\n3 B; B+ h. R' T0 c( i### 什么也没找到?\n1 Z$ e# g+ Z$ a% Z( u* S4 a7 y7 B9 v5 C0 O1 l\n如果你有更多的问题是这篇Wiki没有解决的，你可以通过以下几种方式联系我。2 f3 p. N1 C$ o; P; P: \\\n) `5 f; _\" \\9 Q$ p) _1 ~8 U7 W8 \\\n* [Discord 服务器](https://discord.gg/W3FzxHA) (就算我不在，也有很多人帮助你!). F\" T  V4 m3 [\" l) J. W/ O9 P\n* 在 irc.esper.net 我是 \"Luck\"，我也在 irc.spi.gt 和 chat.freenode.net4 ?3 r; c8 Q- n. A\n* 在 SpigotMC 和 Sponge 论坛我是 \"Luck\"' ]: l\" N! M5 G) P+ ]\n* 在[GitHub](https://github.com/lucko/LuckPerms/issues)提交一个 issue (如果你要提交一个BUG，这是最好的方式)\n# J4 f6 L\" p$ \\1 j9 l6 Q# G& t! w- {) ?- I1 f9 S7 v\" n( ]\n### 一些有用的链接: c* e0 u& {7 ^1 U9 I\n* [**开发构建**](https://ci.lucko.me/job/LuckPerms)\n: \\, S% [: X6 X  n9 O# S, `* [**Javadocs**](https://luckperms.lucko.me/javadocs/)"
        },
        {
            "author": "cc7w",
            "timestamp": 1501828800,
            "txt_content": "杂项  z% {0 {6 B  Q- Z/ D\n本地化与语言文件\n4 |& C, H# G/ ?0 q) U7 t( MLuckPerms 插件中所有的消息（包括颜色和格式代码）都能够修改。（似乎合情合理）& c, L/ l5 w1 y& Z\n& a9 p+ r4 W, f4 ~\n将下面的文件之一下载然后存储到LuckPerms的文件夹中，然后命名为 \"lang.yml\"。\n6 Q+ y7 M! X, ^! e\n! ?, g( A% W8 R3 u8 [5 g: D将文件中的消息文本改成你喜欢的样子，然后重启你的服务器就好了。/ E% ~; Z* d+ q6 U: D7 v\n- Y5 b, e5 I  o( n, q# f' I\n语言文件, y  z* o! t* `# b7 ~9 w\n1 T6 R# l) R: D. y1 [\nen_US - 英语es_ES - 西班牙语ru_RU - 俄语zh-CN - 简体中文pl_PL - 波兰语\n1 g# z# L$ h) _0 H$ k2 ]- o- k' \\\n$ z& |! k/ A3 h+ }9 y6 U1 {\n  j( e/ x: ]# u+ z6 U  {# i为翻译做贡献- O' [) z# x/ A\n\n  T6 n; [* P5 p5 z5 q, {+ X如果你翻译了语言文件，然后提交回工程的话，我（和其他使用本插件的人）会很高兴的，因为其他使用者会受益。; u& Z! s: D( \\6 e. b% ~1 ~0 L\n\n/ z; n/ Q( f  q4 e- k  n上面的 \"en_US\" 语言文件应作为翻译的标准，你只能修改文本消息的值，关键字应保留原样。3 k# v! i6 d8 t# N/ D% O\n6 Y' V' [$ `, O) D"
        },
        {
            "author": "cc7w",
            "timestamp": 1501830060,
            "txt_content": "PlaceholderAPI' U( N: }4 d7 v1 o0 p- m& }\n6 h  ?: t3 H) \\) h* M1 d) y\" |\n在 extended_clip 的 PlaceholderAPI 插件中，LuckPerms 也注册了一些变量（Placeholders）。7 n& K. t4 I! ~$ p\n: i6 }& ~. A& r3 ^3 H\nLuckPerms 插件所使用的标识符是 \"luckperms\"。- a) z3 V% Q/ N$ b* N% \\\" I\n6 d% q- e1 b  v5 r7 M5 |: e\" \\\n使用\n* D! p% E3 K: Y' |5 K* |0 M  W) ?: W7 i3 G: E* E0 L\n要想使用变量的话，你需要运行下列命令。/ g% n* i6 r0 C; h1 `8 p& m\n\n1 B. v6 j. f* Z3 [这些命令的作用就是安装 LuckPerms 的变量扩展，安装后你就可以使用下面列举出的变量了。8 n. q$ o1 l- @$ W( S- ]\n! K- k& p& ]4 w& c\" q# K\n/papi ecloud download LuckPerms. S# `- V* e. h. `$ W+ `\n/papi reload) n7 s3 r; s2 A( R\n复制代码\n7 P\" b  B( |5 X. Q# u请记住使用这些指令你需要OP权限（或者你也可以选择在控制台中运行这些指令）\n- R  C, ]  D  ]6 [% y\n+ M. v. T, I( ^5 C\" |: `3 R同时请注意，如果你想得到玩家的前缀或后缀数据，——如果你在服务器上安装了Vault插件和Vault的变量扩展的话，你也可以使用 Vault 插件所提供的变量。0 S0 Q; @& e/ z$ c& O+ W$ u\" X* Q\n\n: j. s\" [7 j1 L# r3 z\" x! K变量列表* P; W& j. e/ j; d: A1 K( F! ~+ Y$ h\n( E\" R+ X  p0 S  l\n%luckperms_group_name%\n- z' l6 P/ ?8 Y: \\6 S4 l, Y\n: z\" x' y+ f$ W2 T: K& ^9 q使用说明： 返回玩家当前所在组的名字\n: l9 z. Q+ p7 o3 ]使用示例： 暂无示例\" K$ u9 P0 R2 C4 h/ N\n\n7 e! T/ N% `! Q) c4 ?1 p: C/ Q6 }. V%luckperms_context_<context key>%; q% B; I7 a, p0 a! R\" w\n\" I2 A& X4 q; O\" a& ]\n使用说明： 返回给定内容关键字的值，如果内容没有值的话会返回空\n2 A3 L' Z/ b$ H6 t+ h! G使用示例： %luckperms_context_server%; R  P: A/ o9 x: \\; C6 i9 N7 u\n) p* Z4 {9 q/ R, b% Y; _\n%luckperms_groups%\n  s% n( t9 Z6 @( b/ I( x\" \\4 u\" ~1 h+ m2 y) z0 n0 K* u5 i\n使用说明： 返回服务器上的权限组列表，用逗号分割\n0 _5 g* C' c% `6 G+ L* U使用示例： 暂无示例0 v' E# `8 ?( i7 m0 {4 `5 X\n\n9 F5 u/ M, J7 ?' D: b& z; R+ m%luckperms_has_permission_<permission>%\n( o) `2 ?% V; b\" R! o% i# G/ c2 P4 \\6 P\n使用说明： 检查玩家是否直接拥有该权限，不会检查通配符或继承的权限  H8 Q8 j, n1 p5 }6 g: R9 {3 `) b\n使用示例： %luckperms_has_permission_essentials.ban%( w$ T4 F9 ?! O) T4 u- K\n\n6 Q& C: P0 W, w* y) ?9 Z# V; S( h%luckperms_check_permission_<permission>%\n% ~* m0 T; r# C8 @\n& E\" @+ E* X0 p  a5 s( \\  `& h\" O使用说明： 检查玩家是否拥有指定权限，这个变量工作的方式和正常插件的检查方式没有区别\n7 R$ K# o1 x6 K- t. }) W使用示例： %luckperms_check_permission_some.cool.permission%4 A$ ~- L, v- B- p- d\n\n\" j2 x: F9 ?. Q+ Q%luckperms_in_group_<group>%8 L: h4 E6 y8 m8 l8 e5 z\n, K3 H* D' c+ C7 d\n使用说明： 返回玩家是否为给定组的成员，不包括继承组\n3 t1 Q! d( p2 B0 t6 g3 |使用示例： %luckperms_in_group_admin%\n& c7 A) |9 k9 M% L+ b3 X- M$ ]+ H7 {4 f6 K( \\4 R) S5 {\n%luckperms_inherits_group_<group>%\n1 B% E\" I- _7 |' c( C+ Y\n$ x5 E- w2 `- i0 }. f' N使用说明： 返回玩家是否在给定组或继承给定组\n: W- \\  l# y/ m3 Z! x使用示例： %luckperms_inherits_group_vip%  I' A: M% @\" S4 X- ^  h' c\n\n. P. d) [  G8 G) M( q$ p% G%luckperms_on_track_<track>%\n5 T/ F  u\" w0 f, _) D+ m, Y\n$ U5 i3 a' J2 O% H1 G+ M; n' B使用说明： 返回玩家的权限组是否在给定权限组树上, R% d2 M* f  v% z! {* e* u& ~- ~, m\n使用示例： %luckperms_on_track_staff%\n( q8 g\" ~% E8 a\n! x* B  o/ ~. @& h  n  o%luckperms_has_groups_on_track_<track>%\n4 w$ \\. z, S9 v  }, ]& @( _) [3 V' k  j- A# U* X0 u2 c2 ?. v1 ^: V& A\n使用说明： 检查玩家是否继承给定权限组树中的任何一个组/ b% C/ W7 U$ D: P9 o\" Y1 m\n使用示例： %luckperms_on_track_donor%$ Z8 L; [9 x1 E6 i\n- j. P# ^2 x* G5 X9 R. `\n%luckperms_highest_group_by_weight%\n1 c. }% y8 c) ?% z1 Q) `: E+ ?! k1 b  b  M7 ?9 }( Z+ W! d\n使用说明： 返回玩家所在权限组树种的最高级权限组\n1 j4 p2 t# F; m: A( x# u使用示例： 暂无示例- o, d* Y7 J' R; C\n\n7 }* ?+ I: j1 K( B' t3 ~& n  y+ ^%luckperms_lowest_group_by_weight%\n% P4 d! h# \\1 V( s. v% i1 p0 g# q\n6 h5 W7 ]6 P4 O$ a5 S( F7 q. g0 Q使用说明： 返回玩家所在权限组树种的最低级权限组\n- p4 s1 A8 w% G* s使用示例： 暂无示例\n& e4 G\" C, J) M: `5 b, q2 g4 T# S5 r3 k# q% i\n%luckperms_first_group_on_tracks_<tracks>%; J/ Z6 W1 F9 s\" C/ ], G! b' k& H+ d0 |\n6 q, w) Q7 c, q) p; t* a\n使用说明： 返回玩家在给定权限组树上所在的第一个组，权限组树会返回一组用逗号分隔的权限组名，权限组树中的每一个权限组都正序排列。使用示例： %luckperms_first_group_on_tracks_staff,donor%\n1 L' ~- ]2 Z/ p% J* c6 F3 x\n& C4 }& S+ S9 A! M%luckperms_last_group_on_tracks_<tracks>%\n% B2 v) o: K' U9 ]1 w# ?4 ]& j\n# {; q5 l5 A! l使用说明： 返回玩家在给定权限组树上所在的最后一个组，权限组树会返回一组用逗号分隔的权限组名，权限组树中的每一个权限组都倒序排列。( g2 g4 n) {, W\" q/ p6 f\n使用示例： %luckperms_last_group_on_tracks_staff,donor%2 N' K# k# O- x3 o/ h\n/ ?( j' t3 Z1 ~9 {2 a6 H6 J/ U\n%luckperms_expiry_time_<permission>%! K( D# X3 i2 E\n) ^3 s' _) _% W) y/ a+ ]+ C9 u- U  `, w\n使用说明： 获得玩家拥有的临时权限剩余的时间，如果玩家没有该权限的话会返回空  r! K2 y; ~+ Y+ v; K* d: @9 p\n使用示例： %luckperms_expiry_time_essentials.fly%\" z' `) X# V4 L. d, ^\n\n0 |1 N. l2 J* \\. q% e- \\%luckperms_group_expiry_time_<group name>%\n2 ^( w+ b! B0 Q& e. W; |$ c+ s' k: G3 z3 k) \\' @\n使用说明： 获得玩家拥有的临时权限组所剩余的时间，如果玩家不在该权限组的话会返回空\" H  N( C( x\" O\" q0 B\n使用示例： %luckperms_group_expiry_time_vip%\n2 a\" w0 F  X. T8 e% V8 B: `# V$ ~; Q1 U9 R  {\n%luckperms_prefix%\n2 E  k& R0 d8 W& y, E使用说明： 返回玩家的前缀，使用Vault所提供的变量所输出的结果可能会更精确，这一项不会被Vault的配置设置影响\n5 @, q: m4 @\" v8 m使用示例： 暂无示例; Q3 i7 D& Z! [: G/ N/ Z. T7 y\n\n! [9 P( h2 S2 V) O  D6 B%luckperms_suffix%. }8 |' b8 v, _4 n/ o+ W4 i, Z! m\n\n- n4 c' @  G6 ^- v: P5 k( b使用说明： 返回玩家的后缀，使用Vault所提供的变量所输出的结果可能会更精确，这一项不会被Vault的配置设置影响  {9 y, U$ @6 }( c  A2 [7 m\n使用示例： 暂无示例( H. f' _( U8 E% g( s\n( J7 L. W$ |: ]! A\n%luckperms_meta_<meta key>%6 V! A4 H6 z0 Q) _\n7 p/ z; z) R. Z9 u: S\n使用说明： 返回与指定Meta关键字联系的值3 Y! P1 _* f- v. \\/ ~# v( v\n使用示例： %luckperms_meta_some-key%$ _4 D3 I) e- V\n\n, [2 {3 i& A! W/ D8 t4 T+ L- W: S) c% y$ Q8 W3 G# G\n\n% _: @, i8 ]\" P8 U"
        },
        {
            "author": "cc7w",
            "timestamp": 1501831860,
            "txt_content": "安装\" l1 F2 a; Z- K9 G- [\n初始设置* P0 V9 j. Q+ i4 q\n\n/ }9 l9 ]5 x7 `' x' N; b下载适合你平台的 LuckPerms-???-x.x.x.jar 文件。你可以点这里查看最新的版本。4 J/ y, u$ U* H) H0 _' i4 @5 c\n打开你的 Mod 或插件所在路径，这路径通常要么是 /server/plugins/ ，要么是 /server/mods/。\n1 i$ m; h0 F; ]+ ]% q+ z1 k7 d然后把 LuckPerms 的 jar 文件放入文件夹中。% W$ ~* V- Q# a& D\n\n5 K+ @+ ^8 N- C( I请完全关闭你的服务器，然后再打开，这会生成默认配置。8 N/ c- j* p- U& J2 \\5 M\n完全关闭你的服务器，打开配置文件。配置文件的位置在 /plugins/LuckPerms/config.yml 或 /config/luckperms/luckperms.conf。\n$ \\: r. q6 e8 F5 v1 e\" ~请浏览配置文件，然后根据你的服务器修改设置，尤其是请注意存储相关设置。3 M5 |! Z* W& }: n- q* @1 ]) ~\n再次开启你的服务器。. F6 @1 V; g, l/ z& P\n\n\" O' A1 {4 P* L! B你可以更改配置文件中的很多内容，文件有很细节化的注释，每个设置的作用注释中都解释的很清楚。\n0 ]\" F5 M  y8 X6 C# Y. s\" d8 w! h; t4 E( Y3 Y8 i\n需求( t! w3 J3 c( J' |) i& a4 [! D\n\n7 X* b9 @- B- O; ]- b$ q% f2 t3 [LuckPerms 插件只有一个环境需求。; {5 L% ?\" C% ^9 W: [. x! Y\nJava 8\n) V. H5 g* u& b1 D: |! V0 R6 O) G: X3 H& i, T8 f, I\n没错，唯一需求就是你必须使用 Java 8，LuckPerms 插件在旧版本的Java上不会工作。\n, ?/ X/ l6 P7 l到目前为止很多服务器提供商都已经升级到Java 8了，但是如果你的服务器提供商没有升级的话，请温和地和他们谈谈，让他们去升级。% L6 m+ r/ x+ @+ n\n如果你是自己租主机开服的话，你应该对你还没有升级Java感到羞愧！\n! r: F) e; m, C. Y- c( x0 ?升级的过程是很简单的，如果你想升级的话网上也有大量的教程。\n/ y) r0 g4 j( Q* Z9 A4 |; j使用过期的软件肯定不是好的:)& g! L6 z! h- l, j7 F4 U' u\n\n$ E/ d: T- ~. Y# I$ n+ g$ u( Y$ v6 tBukkit版本过旧\n3 G5 H( \\/ T% K\n- t6 f& F2 i1 e. {8 I如果你收到了类似于 \"NoSuchMethod\" 或 \"ClassNotFound\" 这类错误的话，十有八九就是你在使用较旧的Bukkit版本。3 o1 y2 F& K5 V7 G7 e3 `\n在将它作为错误报告给我之前，请尝试使用\"Development Builds\"（构建版本）下载页面的\"Bukkit-Legacy\"（Bukkit-旧版）版本。\n2 H* a9 Z# M- |( P& Z) ]2 ~- B& s7 \\\n切换存储类型- i* i\" j2 \\0 P  D5 g\n\n# y0 ]. S% E7 I( o\" N5 C; H9 ILuckPerms 插件所使用的默认数据存储类型是 H2 数据库。\n4 g4 P0 U* S; G! A2 X! I所有的数据都会储存在LuckPerms插件目录下的 luckperms.db.mv.db 文件之中。\" B. n! O0 D. s4 O1 j\n（插件目录为 /plugins/LuckPerms/ 或 /luckperms/）\n8 b! k- _& q' j3 f. s! ~\n' d  S! _/ G0 V( k) j这个数据格式普通的文本编辑器是不能读取的。\n7 n% K8 ~5 D+ d- R% n0 G- ^8 J如果你想要手动阅读/编辑LuckPerms插件的数据的话，你就需要切换到YAML或JSON存储格式，更改 config.yml 文件中的配置选项就好了。; Q1 f  x& D. \\9 O\" P\n3 F2 Y6 ]  w$ D\" j\" X$ D5 q\n\n\" d; B9 W) ^. Z1 W: H2 L更多相关于存储类型的有关信息请阅读下一节\n1 b. I' @. B8 I# p/ ^* z! q"
        },
        {
            "author": "INKDRRAK",
            "timestamp": 1501833480,
            "txt_content": " 本帖最后由 1345979462 于 2017-8-4 16:00 编辑 \" y2 r! Y# W% ?1 P: ~\n\n- D- N$ B( [; v7 L\" t  ]! \\Why is LuckPerm部分翻译\n9 i$ b9 z$ _\" @8 g' h& c% qLuckPerms是什么？这是另外一款全新的权限插件？% q$ Z/ h' L2 b2 [! T\n是的，我认为LuckPerm相比其他权限插件还有很大的发展空间\n2 b2 D. s+ {: D- S( M$ a' ]' Y3 }5 RLuckPerm是一款先进、高等的权限插件，仅仅以快速、稳定可靠、灵活多变的特点\n: a7 o9 _' l( W: Q' n\" ^) {便可以替代现有的许多权限插件，例如PermissionsEX、GroupManagerX、z/bPermissions、BungeePerms等主流权限插件\n+ M. f9 x\" C& qLuckPerms这个插件的计划，本来是围绕着两个主要特点来制作的：高性能、强大且广泛的功能7 J( k5 d1 M$ u7 p9 ?* g) L) J\n填补其他同类插件的功能缺陷、并且建立在同类现有功能上更进一步的优化功能: U& ]! z\" S1 ~6 @- @\nLuckPerms还包括了非常广泛的API支持，这是为开发人员的添加的\n1 \\/ T8 S# H) Z9 L. `$ I\" q并且，luckperms还兼容各式各类Minecraft服务器软件&支持多种数据存储的选择\n4 }% `. @- |( Y# P2 x( j! ^我已经使用某插件很长一段时间了，它对我的帮助很大，我也很熟悉它了，为什么我要更换它而选择LuckPerm呢？\n6 @# X( l' j' M现在主流的权限插件大多数都是老牌插件了，并且都是在Bukkit早期就被创造出来了: _8 \\1 O+ Y$ u+ F  f9 o\n虽然，这可能意味着它们非常的稳定可靠，但通常也意味着它们被原作者抛弃，并且一般不会再有任何更新、修复\n  I6 k3 R0 {7 q\" _: D7 T/ g8 p但LuckPerm却任然是一个需要成长、需要磨砺的插件！\n. [4 ]% c) Q3 B* Z我会尽力及时查看并回复所有的bug报告、问题，以及可实现的新功能建议+ ^* c/ {\" O8 f\n你说的不错，但是我更加偏爱某插件，因为仅凭它就完成了我需要的一切\n) s- i  g  l5 z( x% C这没关系，我完全理解你的这种心态，我并不是想要说你必须用LuckPerm来作为你服务器的权限插件$ L2 q4 W/ q% L3 u. F! B1 g  n\n当然还有更多适合你服务器权限插件，但是LuckPerm确实是个很棒的选择，不是么？9 r# S! T% H* d. Z3 L\n来吧兄弟，告诉我，我为什么要使用LuckPerm？\n4 E; U; I( K: F& eLuckPerm能做很多事情，至少单在技术层面，LuckPerm就胜过大部分同类插件\n: R, D5 S' b! l7 y\" Q\" a2 {' B我认为这不取决于我制作插件的水平，而是取决于我在LuckPerm上面花费的精力与时间\n! P' [8 K\" H8 K0 t& sLuckPerm是我在2016年开始准备编写的插件，但因为Bukkit变得流行起来，许多同一时期的插件都变成了老牌稳定插件\n) b8 N- L6 B. V4 t- }! V% o不过，这也为我编写LuckPerm提供的很好的参考帮助，因为我可以避免其它同类插件的缺陷4 j0 v' y! d; f3 B\n并且明白它们哪些地方做的特别出色，我可以在其基础之上进一步优化，使那部分功能变得更加引人瞩目\n, b7 a6 \\, L1 n, \\0 _8 g记着，如果你对LuckPerm技术性方面的内容感兴趣，我推荐你从命令使用部分开始阅读) M: e) P  S* S/ ]\n或者看看wiki列出的其他部分内容，在本节的其余部分，我会将阅读重点放到LuckPerm一些全新的特色功能上面5 V4 A* [) e+ ^\n这些内容是你不太可能从其他插件中找到的，专属luckPerm的特色功能！+ o/ s& D, l% }* Q* W. {! q7 f# Q\nVerbose（权限查看系统）\n& |: I3 U\" e\" J, o8 k2 {) p$ @, n: ILuckPerm有一套完整的权限查看系统，是的，它叫做Verbose; x1 T( w6 O$ `3 P\n他可以实时监视并检测其他插件所需的权限，就像下面示例的动态图那样% N* t  u$ z$ D( O+ v  D5 o/ B) f$ |\n\n4 N, S$ ~5 i' ?4 |) F3 g, m# [/ S% b$ y\n你也可以把录像上传到网上，方便查看、分析和阅读：https://git.io/vQitM\n8 c* s\" `/ W6 H' v' o+ I权限树系统\n+ f8 l( v2 z6 S1 ^. l$ pLuckPerm允许你在服务器所有已知权限上建立编写\"权限树\"- S! k- o  O5 s7 z- `2 U\n权限树上的数据是由你所有的插件在服务器注册的权限构成的\n1 S8 q% Q4 J\" |7 p& X随着你服务器运营时间的增长，因为服务器添加了许多插件，它们都会注册权限，这些数据都会被纳入权限树中, h: [$ D% O, }' ?* b\n这是个清真的例子（https://git.io/vQiti）\n) p( T$ Y0 g\" V7 X+ m/ f- H- Q你看到的权限树的颜色，代表了你的玩家是否拥有对应的权限，这一机制很方便的让你查阅到服务器的相应权限9 g; _6 U) D) f3 Z  x( L\n这还是那个清真的例子（https://git.io/vQit1）4 g  O/ m\" F$ E0 X4 t% u\" ^8 R\n指令界面&TAB补全\n5 w! X, a  s$ X3 vLuckPerm的指令系统被我设计的尽可能便捷、易用、人性化\" R/ T# G- C8 z+ j# _4 N8 ]\n这样一来，你除了查阅LuckPerm的大量相关帮助文档，还可以在游戏中查看指令用法、以及指令列表\n, o' _) w. T6 \\  {2 d8 _+ H\n% {+ m8 z9 O2 Y! PLuckPerm的所有指令皆可使用TAB补全功能，这就意味着，你可以通过输入更少的指令来完成你的工作！\n% F. s% E' h) m这是不是在一定程度极大地提高了你的工作效率呢？就像下面那样\n9 k' U: q8 \\1 q  a\n( F  B6 w6 r6 Y  s\" e\" B% E网站编辑! I0 E% o0 I4 y. @% j( w\n除了使用指令来编辑服务器权限相关，LuckPerm还提供了更加便捷的编辑方式\n; @1 m& ?\" R2 f) M你可以使用Web网站编辑器来对服务器的权限数据进行快速更改4 Z6 U- r3 w\" X\n任何人都能够使用网站编辑器，不论你使用了哪种存储方式！\n. `3 r. U) A8 j1 c网站编辑功能非常容易使用，且易于上手0 b4 a' \\  G# c\n& ^8 i\" P1 @# `7 x# |- `- _6 y' [\n行为记录仪\n9 _. I* y  M; y为了防止服务器中出现心存不轨的管理员，想要私自给自己添加权限  i9 H: ]( Y/ a+ n\nLuckPerm详细的记录了服务器各类权限的微小变化\n2 p! }: [; ~7 K6 ^$ s你可以通过行为记录仪来搜索每个人的详细操作\n' A; o; U7 W\" y1 ~/ `"
        },
        {
            "author": "cc7w",
            "timestamp": 1501834920,
            "txt_content": "选择存储类型\n, o- ?+ ~% o* {  X\n\" H0 M& c, {. e- CLuckPerms 插件带有很多存储数据的方式，你可以从中选择。\n( a) \\\" v- h( _! s1 N* Z4 x存储类型选项可以在 config.yml 或 luckperms.conf 文件中修改。\n& F2 [% S5 n+ K' C7 d+ Y( W) l) O: U& {! K* o\" V* X2 z\n# Which storage method the plugin should use.\n( N; x: X! F) ?8 t4 t# Currently supported: mysql, postgresql, sqlite, h2, json, yaml, mongodb\n3 P5 I% s8 h/ N! {# Fill out connection info below if you're using MySQL, PostgreSQL or MongoDB\n% U% r6 J7 O\" p2 xstorage-method: h2\n4 f; c2 t) Q& [& a3 I复制代码1 Y, e3 Q: P( I+ l\n6 m  k9 [9 z- F5 f: X* ], D\n请记住如果你想改变存储类型的话，你的数据不会自动转移到新的存储库中。3 @# ~! v' D0 t- P1 [4 h\n要想手动在数据存储方式间转移数据的话，请查看这里来获得更多信息。\n' r( l, n: X6 X' h/ i3 |& _9 T\n7 H+ }' O$ x9 c7 _8 _可用的选项都列在了下面。1 S\" H# w0 ~- J7 k\n4 v% U. o; s; S3 {% `& ?4 E' o\nH2 / SQLite6 m7 n% p8 x8 ~) E; R\n默认的存储类型是 H2 。\n: X* A+ a# y3 q6 B% J\" B这两种文件类型都是以SQL数据库为基础的。  ]/ }# o1 h4 @, n# c4 {6 e6 u7 f& V\n所有的数据都会存储在LuckPerms插件目录下的一个文件之中。\n- j4 C+ H% u3 S# J: [和YAML和JSON方式的不同之处在于，这个文件不能用文本编辑器打开。% P\" c9 ]\" q1 t# U/ V\" f0 F\n你必须使用插件提供的命令才能编辑或查看数据。\n' R' K4 |& G  A  m* v  n, R& b6 V0 Y\n如果你选择使用 H2 数据库的话（默认设置），所有的数据都会储存在 luckperms-h2.mv.db 文件中。\n' u: C' w( s. G. R3 e# z% MSQLite 类型所提供的存储文件是 luckperms-sqlite.db。. J8 O9 J+ g7 O8 D/ U' W\n; w' U; x4 m) I/ i& ]\n要想使用这两种类型中的一种，请将配置设置为：4 p) L6 |0 _\" P\" |# ^8 c\n\n% A( H/ _' {6 h# q/ E; zstorage-method: h2\n) z: l\" }, e8 ^\" i0 V# or\n# Z. d3 b* h6 P4 pstorage-method: sqlite\n- X6 u2 s8 Y* I5 p! b复制代码\n7 z+ @2 x\" J7 x$ SJSON / YAML\n. ^; c) w$ I3 G4 I0 i\n4 I% W6 A! j+ H\" ]  v' d$ QJSON 和 YAML 存储类型会将数据存储在可读可编辑的文本文件中。YAML 类型所提供的文件扩展名为 .yml ，JSON类型所提供的文件扩展名为 .json。; e7 i$ V1 f2 {  P\n: W# _/ u+ y4 U' ?) a( b% L\n这两种类型的存储格式很相似，只是在一些句法上不同。4 t) D7 K! j7 N2 L! [. u8 u\n\n% z* L9 [6 ^) k: Z2 S+ N1 a% B2 M, S示例YAML文件\n5 Z/ _0 t; B( buuid: c1d60c50-70b5-4722-8057-87767557e50d- C# F, o\" ^$ A2 q: ^% @4 c' |4 Y9 K\nname: Luck# a8 d( x+ ~' o% G' k9 b, S, [7 z, \\\nprimary-group: default  t! [1 B# U0 D2 w\npermissions:\" V* Q  k7 G& c: A9 \\( G( L9 |\n- group.default:) V\" h( a, e, G\n    value: true\n7 k\" e& `9 x8 v0 ~8 S/ N- test.permission:0 {% P; e4 A& c# d\n    value: true\n7 [$ y- A\" r+ Q# u/ |; W8 A) n    server: factions, x# h( s' l2 d. F\" {  h, }\n- other.test.permission:\n8 N7 H& ^5 a/ A    value: false复制代码\n7 _3 K6 j% h5 m) w' A\" s# C0 O' h\n' {5 G* q0 P7 K, k示例JSON文件, n\" ?\" {4 J. I\n{% B7 d( M7 |3 l0 ^\n  \"uuid\": \"c1d60c50-70b5-4722-8057-87767557e50d\",\n* T# l. [1 ^* e& l6 ^$ ]  \"name\": \"Luck\",\n7 R% G9 p  q, y- }  \"primaryGroup\": \"default\",\n5 `) \\1 O+ E* e: N& S7 C7 i7 }  \"permissions\": [% H$ R, R! t; n4 F0 O) \\\" l\n    {\n/ E9 @& |& y* e3 a4 j3 ?) L      \"group.default\": {\n( m! B+ z1 s* {\" J        \"value\": true: D; R( X1 X9 |: w4 J& L# f\n      }\n. ~, Y* J% a* f% \\    },8 p% a\" ~. K. t& K9 B' d& J\n    {\n4 ^6 p+ L0 |1 j      \"test.permission\": {6 Z' \\# F0 l& z6 i! G' S\n        \"value\": true,\n9 s3 |  i\" v6 R) Y& s        \"server\": \"factions\"\" c2 p' Z, ~: Y  X) z\n      }\n# e+ [& Y0 o: r$ r( Z    },\n8 g  [. @' l+ h. x2 T2 N) h    {7 d6 a1 A! e! n: }) S0 M\n      \"other.test.permission\": {* p! j0 M, S/ D1 v\n        \"value\": false,\n1 f: s8 w3 w/ k        \"server\": \"test\"& C/ d/ c1 E$ E\n      }\n6 o5 V/ @9 t/ N    }+ i& _8 O0 P2 B) o: p# z% Q\n  ]\n\" `) w/ k' f8 y9 B2 \\1 O- r  L9 h}复制代码\n3 Z# m  `( `; w6 R' e, T\n: i. Z5 Q5 L1 m\" p  d5 ^( }) P9 t要想使用这两种类型中的一种，请将配置设置为：/ N8 f\" r/ Y\" @$ `. j\n. y* K5 C9 R  }\" i( y* W+ L2 |$ p\nstorage-method: yaml( ^' E  ?  c; x5 p! ^) y. Y! O\n# or\n+ _. j& I. |3 I+ T3 p  qstorage-method: json: c$ S$ M- l) d: a* d\n复制代码  R% |1 n7 {, {# Z6 a0 v\n6 Z3 n; H) r+ U\nMySQL / PostgreSQL\n. {  q' N' p7 B0 k' k( j\n7 A; g+ ^$ }! b7 s3 _. _4 e3 @/ n4 `: A储存在 MySQL 类型和 PostgreSQL 类型中的数据格式上与上文提及的 H2/SQLite 类型相同，但是数据是储存在远程服务器上的。\n- i; K: z  j$ f$ f这意味着你可以跨服分享相同的数据。' u# T6 G& B9 q\n你需要在配置文件中输入你数据库服务器的地址，端口，数据库名，用户名和密码。\n! l- o) g\" A0 n6 E6 E/ q这种类型推荐要存储大量数据的用户，或是想要搭建群组服务器的用户所使用。\n3 C! H& a6 ]# g) @) l% U8 z/ S1 d3 R, J如果你已经在运行群组服务器，并且想要在子服务器之间同步数据的话，你就必须选择这种类型了。: q7 O- S; K  c\n1 }: ]& ]& ~- K\n格式布局示例在这里。\n; s1 L% g2 Z5 S4 j8 b# b3 p* L- }1 w+ J\n要想使用这两种选项中的一种，请将配置设置为：\n; o6 |2 p& C3 G0 [* ?8 M\" B. ^5 a- ^\nstorage-method: mysql\n9 N  K& f4 [9 k( R+ ]( ~# or\n% d\" B  J$ k% Q  @$ ], J\" Lstorage-method: postgresql复制代码\n$ }6 c  K$ x& v, q6 P- D+ q4 f/ x9 ^( @2 ?. ?/ ~5 e1 M6 r  E\" W\nMongoDB# o: T# @, B% m9 g7 Q* ~7 `+ v\n0 _) U) d& ]/ j! j6 x8 T1 N\nLuckPerms 也支持 MongoDB 类型的存储，它也是一种远程数据库，在有些方面上和 MySQL 相似。: c4 I3 Z2 O4 N; ]% B& l\n这种类型也只会被一小部分的用户所使用。\n  Z+ v8 l! r! i5 D/ W要想使用这种类型的存储，请将配置设置为：\n# k. J1 ^! v! K6 p' [* R\n. k, _1 w8 R: q! J! j4 h; ostorage-method: mongodb复制代码9 c% F( j9 y+ [% S* s- K\n\n* h* B1 z1 X  x6 l8 J; s"
        },
        {
            "author": "cc7w",
            "timestamp": 1501837260,
            "txt_content": "使用教程$ R! ?# r% j$ ]9 j! l- I+ ?1 t\n\n/ p, z( {4 m2 ~, f这篇教程是为之前从来没有使用过权限管理插件的人所准备的。\n$ _; p' O: F4 n如果你已经很熟悉权限管理等相关概念了的话，我认为你应该就能够理解命令中的东西了。8 F0 N. _/ }\" J: j\n这样我就推荐你去阅读命令和权限页面，这样更加“直奔主题”，你也能够更容易理解插件的工作方法。\n- c  @! Q! i. p: i; r; K5 k/ w, [9 H, S) z% n  a\n如果你正在努力想弄明白权限管理相关概念的话，这篇教程就是你起步的最佳地方:)2 r/ ]6 n% @3 u$ K3 }\n5 p# X7 m& X& [4 ~. D$ ^5 y* E% x\n关键术语3 S& n, M$ P7 p$ z  H  a4 x\n\n$ Z: G0 {/ r0 S! {: T4 F. w权限\n; ^0 f* i3 M+ m& e在你的服务器上会有大量的特性，命令和一些新功能。4 L9 u: ?' Z2 m( c: Q+ v\n这其中的一些特性是服务器自带的，另一些是由“插件”所添加的。* |' H5 E+ f8 B3 M' F1 h\n与这些特性相联系的大多数行为都是由权限所控制的，因此你可以控制哪些用户可以使用你指定的特性或权限。# o; `& b\" Z5 c* Q- |2 c0 t\" `3 q\n6 y9 ~: I- ], s9 T2 l\" P- Y- V( ?\n权限仅仅是个字符串，并且使用英文的句号（半角 → . ←）分成几部分。\" p: v: @0 ~/ E- ~! z  G\n举个例子， “minecraft.command.ban” 就是原版 /ban 命令所使用的权限。\n- A0 m\" a' F& S# r2 w显然我们不想让所有用户都能执行这个命令，所以我们只给我们信任的玩家这个权限。! H1 ]4 P+ R$ w7 N3 z\n( g; ~, E- \\0 C2 D' k  J/ j5 M\n代表特定行为的使用许可的字符串，我们就称之为权限，它又名“权限节点”，简称“权限”。\n- e6 a& i. I1 R3 H2 P\n& p4 j4 G4 x4 U& E6 R& E1 b权限组0 Y: y1 y; i; C% b6 {6 q2 Y. x\n代替单独为每个用户设置权限，我们可以将权限捆绑为一组，然后直接将这一组给予玩家。1 r5 V9 A7 x' ]5 `) W% @8 n  [; o\n举个例子，在我设置的“admin”权限组中，我可能会添加使用ban和unban指令的权限，然后将玩家加入admin权限组中。; ^& I\" B( h: S! M\n这意味着他们能够获得“admin”权限组所设置的所有权限和他们自身被设置的权限。\n2 b4 z5 W' A. t' n; N\n% m9 }+ H5 o& i6 Z) `1 u4 O继承\n1 w8 w' |2 V9 ~: O用户和权限组能够互相继承权限。) {- A+ J8 o+ D' L4 r0 O( p\n举个例子，默认地，所有的用户都会从“default”权限组继承权限。\n3 J: m) b3 ^  U# O+ r$ J% U你可以为你自己的服务器设置你自己的权限组与继承方式，或是制作你自己独特的系统。\n1 z( V  S; A% ~  _9 q8 I9 o* ]& h6 d2 B$ m7 r: S2 ~\n举个例子，我设置了三个权限组， “default”， “moderator” 和 “admin”。: H% Y  [1 N8 t6 }  @\n我想让“moderator”权限组从“default”权限组继承所有权限，“admin”权限组从“moderator”权限组继承所有权限。\n1 _1 o1 q% k% T$ |$ D% M3 I- R7 q0 y% n! ?\n起步6 O+ y- U4 x- ^\n如果你还没有将LuckPerms插件安装在你的服务器上的话，我们推荐你先阅读安装有关的教程。; x$ N) P/ t0 L: z4 n- F\" d\n然后，请确保你在继续之前已经阅读了选择数据存储类型的有关章节。$ U9 L) [* H9 j+ w\n虽然你在后期也能实现数据之间的转移，但第一次就将他们弄对位置是更好的。\n. B0 `! Y2 i\" H$ t\n+ F0 U0 x7 ]' E7 P: X3 y6 D9 S给予修改权限的全部权限. y8 m* k3 Q\" l! H\n你想做的第一件事情就是给你本插件的所有权限。0 _' T7 K1 j' Z# s2 ?  _, n  f\n当本插件首次安装后，没有人能够使用LuckPerms插件的有关命令。\n, }9 D3 ?& b& J% g: M0 t9 v) j, b# S\" j/ i4 \\\n要想做到这个的话，你需要在服务器控制台输入 /luckperms user Luck permission set luckperms.* true 。8 ~\" c- }/ R$ ~6 e\n当然，请把我的名字换成你自己的（不用担心，这条命令的使用方法之后会详细讲解）+ u% e* q! ~- O0 X. U1 X. f% w\n这应该就是运行的结果：$ |6 S) ~# w: P7 P& x\n\n: k3 g# P\" c- X, p9 ?' h- }4 j' {$ Z\n实际上，这条命令起的效果，就是给了 Luck 用户 luckperms.* 权限。（或者说，为用户设置权限为 true）\" _$ c. o# [. n\n0 W: Q7 [$ X\" G4 \\\n你可能已经注意到了我们刚才在权限字符串的末端使用的 * 字符了。\n) `0 I% m# I- R# z5 G( N: y* X这个字符叫做通配符，它会给玩家所有以 \"luckperms\" 为开头的权限。3 I: Q3 l  R& i& A: Q\n\n' O* W  q% g7 [# W( i  X创建第一个权限组\n' h8 u7 ?3 D, U# Z7 P我们可以使用创建权限组命令来创建一个新的权限组。\n$ a5 \\' j# C- G, p让我们创建一个叫做“admin”的权限组，然后给它附加一条权限吧。5 v; i# O* x6 i+ z( J\n首先，运行 /luckperms creategroup admin 命令。\n. Q1 H. I* b5 S8 L这会创建一个叫做“admin”的空权限组。( p% X! F* w8 L& R8 m& N% }\n' a( o' f) J+ H- z( J' w/ f\n& J) W# Q0 z* L0 K4 _; J\n接下来，我们想为“admin”权限组增加一条权限。\n4 \\1 i  o/ f\" s5 W/ M$ K用来修改权限组的命令是 /luckperms group <group>。\n8 Q% L4 |: ^  v& Q如果你执行这条命令的话，它会为你显示所有可用的子命令。\n, w8 Y: ?/ V0 ]  d4 k2 t# F\n# }3 y! e1 p1 n! A1 `; \\\n$ I- y+ ~/ e; M% G* w: B你可能注意到了第一个子命令是“info”命令。它只会列举出一些权限组相关的信息。\n  {4 I4 r: b! O8 F* ]) x3 B我们可以运行 /luckperms group admin info 来查看新建立的“admin”权限组的一些信息。+ @5 K& {3 v- J& U6 X5 i; t\n2 l. r  d5 u3 u5 l: ~: o\n\n7 ?- o$ v, L8 m1 S8 V0 q2 U: w  N接下来就是“permission”命令。这能够帮助你修改权限组的权限。0 F\" ~8 p7 s! Z8 B' X1 @  A+ X\n再一次，使用 /luckperms group admin permission 命令会列出所有可用的子命令。( F7 U1 N6 V: }( v% A% L\n\n6 O9 Y- w1 x. h) ^* ~0 L\" z- C$ @5 _* `7 |6 K/ Y\n再一次，我们看到了更多我们可以执行的命令。\n4 {9 I8 `: p' A8 {; ]8 f第一个就是另一个 \"info\" 子命令。\" E$ b: o% b6 k/ t  d4 ?9 S\n因为它是“permission”子命令下的又一子命令，它就会显示某一权限组所拥有的所有权限。\n4 h' F; e* I& {7 q0 q' D3 r8 \\下面的命令是“set”子命令。\n$ g! r5 A' k2 o/ J; M! |! K* D' B$ V6 T9 ?1 U8 Y4 n\n你还记得吗，之前我们使用相似的指令来给玩家 \"luckperms.*\" 权限。这里它也相同\n1 N8 T5 m* d0 {# t  G9 g2 ~只需要不加参数运行该命令就可以返回该命令的使用方法。举个例子：\n, X, m2 [7 }& y4 P) \\\n; s% X0 b- `\" i% @2 G! K8 Q8 g/ ^& L3 z) i) c. r* x+ o\n举个例子，我想给我的“admin”用户组 \"minecraft.command.ban\" 权限。# r% g4 `6 Y6 \\5 X: p) k. r8 @\n因此我可以输入 /luckperms group admin permission set minecraft.command.ban true 。\n: ~, s: I9 }* {& F! y: N& u+ @! q# k3 E9 O3 B- s) t\n\n+ X3 ?\" P) q\" F3 ]这条命令就会给予“admin”用户组 “minecraft.command.ban permission” 权限。\" Q; u% @5 r\" s) j5 @# h\n末端的true控制我们设置的权限的启用与否。\n- T' X, j7 j8 z/ _- V, q& c5 O你可以将权限的启用与否设置为 true 或 false 。\n; G5 K( _; B! I2 b; g' \\为用户或权限组将权限设置为 true 能够让他们拥有该权限，设置为 false 即该权限无效。（指定他们没有该权限）\n5 V# b  z# {9 x6 Y% k\n- |: f3 M2 O# h$ H. \\0 K如果晚些时候我决定不再让“admin”用户组拥有这个权限了，我可以使用 unset 命令来移除该权限的设定。\n( w0 N- d: Y5 r, ~2 y5 d, [3 j  v输入 /luckperms group admin permission unset minecraft.command.ban 。  r- ~  g: r% n\n4 M1 L; B* `: I( n. @; C\n\n$ o3 Q3 C) D1 m3 C/ Y+ q3 [& k将玩家加入到权限组中\n4 q9 q  i; J8 v) w将用户加入到权限组中需要使用 \"parent\" 命令。（在我们的命令使用页我们经常用“permission”替换“parent”）* p$ k' P) |% n\n举个例子，把我自己加入“admin”权限组中，我需要使用 /luckperms user Luck parent add admin 。4 i) z# A/ \\( U8 D+ C\n% _/ q+ _) Y! h; z3 V7 r\n; x7 G% [( o: z6 n- Q\" F\n这条命令会将用户 Luck 加入到“admin”权限组中。, V7 F- k$ L6 w! I; C\n这意味着任何“admin”权限组所拥有的权限我现在也继承下来了。& G7 t2 p5 k: w6 m  C. l\n\n; K# |3 V$ p- l- H  D# `让一个权限组继承另一个权限组\n8 }' s( g: L0 z2 u1 Z3 a# r就像用户能够继承一样，权限组也能够继承另一个权限组。\n3 [! D8 J/ J5 \\& e, |. s举个例子，想想下面这种情况的设置方法。（有些权限仅仅是为了演示而编造出来的）7 H4 w  F# K1 |* d+ c% E- Z\nAdminModDefaultminecraft.command.banminecraft.command.muteminecraft.command.sayminecraft.command.pardonminecraft.command.unmuteminecraft.command.mesome.cool.admin.permsome.cool.mod.permsomeplugin.vanishchatcolor.bold) S# H- s- ~  a2 Y\n我想让“admin”权限组中的用户拥有“mod”和“default”权限组的权限，同时“mod”权限组中的用户拥有“default”权限组中的权限。要想实现这个的话，我可以设置用户组之间的相互继承。\n; S) a) }/ T! D5 e( E( `# w\n- K6 z: V5 w- W+ e) y1 p- C9 ^0 {: T/luckperms group admin parent add mod 命令会让“admin”权限组继承所有“mod”权限组中的权限。5 @# O! K, V3 i# H: d# c\n然后要想让“mod”继承“default”，同样的道理，我可以输入 /luckperms group mod parent add default。\n' I' z; D. \\' X- y\n& e* E$ Y+ I; o6 Z2 K% x\n5 |7 D' ^' M2 j# ~9 q' A; B6 X继承是可递归的，所以这样以后“admin”权限组就不仅仅继承了“mod”权限组，还继承了“default”权限组。- q8 E9 s- l6 V) N\n这意味着“admin”权限组中的玩家拥有“mod”和“default”两权限组中的权限了。\n1 s% v  i6 p( h+ e\" n' k; H3 i# p\" C3 R8 @& _( @' Q\n在“admin”组的一位用户因此拥有 minecraft.command.ban，minecraft.command.mute 和 minecraft.command.say 权限。\n* Q. g4 h& y$ `8 B. H  y* g0 k: }; l: N+ u7 m\n移除继承权限组, U9 M8 D/ b& D2 Q; O\n要想移除权限组间的继承关系只需要输入一个类似的命令就好了。) Y% y; a* i5 V6 ?9 Y4 {1 V8 d* b- T\n要想让我自己不再继承“admin”权限组，我只要输入 /luckperms user Luck parent remove admin 就好了。1 ~1 T- j4 q% e& O! K% Z6 l\n& A( F6 l8 t\" N. [7 j6 K3 |- u. C\n\n6 s9 U. j% |, i; N7 ]; W% [2 Y\" V0 B; d% U* \\7 Y3 k\" s5 U\n\n9 ~7 S4 X7 Y, ?, |- Z, ~  h7 y"
        },
        {
            "author": "INKDRRAK",
            "timestamp": 1501913520,
            "txt_content": "GM&PEX对应等效指令*我编写这部分WIKI内容的目的是为了帮助用户们适应从GM/PEX到LuckPerm的转变4 N0 g9 r4 K! y% [4 g\n这里我制作了一份对应等效指令的表格，方便用户随时查阅\n; R: u0 W; J' X$ @* z# o1 K9 i- W5 ~*对应等效指令：在LuckPerm中与其他权限插件效果相同的指令\n6 U3 ]4 h9 D7 c$ k2 W0 KGroupManager与LuckPerm的对应等效指令：\n6 ^, Z5 r/ O& CGroupManager 指令LuckPerms 对应等效指令manuadd <玩家> <组>lp user <玩家> parent set <组>manudel <玩家>lp user <玩家> clearmanuaddsub <玩家> <组>lp user <玩家> parent add <组>manudelsub <玩家> <组>lp user <玩家> parent remove <组>manpromote <玩家> <组>lp user <玩家> promote <权限系>mandemote <玩家> <组>lp user <玩家> demote <权限系>manwhois <玩家>lp user <玩家> infomanuaddp <玩家> <权限>lp user <玩家> permission set <权限> truemanudelp <玩家> <权限>lp user <玩家> permission unset <权限>manulistp <玩家>lp user <玩家> permission infomanucheckp <玩家> <权限>lp user <玩家> haspermission <权限>manuaddv <玩家> prefix <值>lp user <玩家> meta addprefix <优先级> <值>manuaddv <玩家> suffix <值>lp user <玩家> meta addsuffix <优先级> <值>manuaddv <玩家> <变量> <值>lp user <玩家> meta set <变量> <值>manudelv <玩家> <变量>lp user <玩家> meta unset <变量>manulistv <玩家>lp user <玩家> meta infomangadd <组>lp creategroup <组>mangdel <组>lp deletegroup <组>mangaddi <甲组> <乙组>lp group <甲组> parent add <乙组>mangdeli <甲组> <乙组>lp group <甲组> parent remove <乙组>listgroupslp listgroupsmangaddp <组> <权限>lp group <组> permission set <权限> truemangdelp <组> <权限>lp group <组> permission unset <权限>manglistp <组>lp group <组> permission infomangcheckp <组> <权限>lp group <组> haspermission <权限>mangaddv <玩家> prefix <值>lp group <组> meta addprefix <优先级> <值>mangaddv <玩家> suffix <值>lp group <组> meta addsuffix <优先级> <值>mangaddv <玩家> <变量> <值>lp group <组> meta set <变量> <值>mangdelv <玩家> <变量>lp group <组> meta unset <变量>manglistv <玩家>lp group <组> meta infomansavelp syncmanloadlp sync, {# H9 ?7 A* y* [! s& k- B\nPermissionsEx与LuckPerm的对应等效指令\n- v; \\2 `! _. H: EPermissionsEx 指令LuckPerms 对应等效指令pexlppex reloadlp syncpex toggle debuglp verbose truepex user <玩家> check <权限>lp user <玩家> haspermission <权限>pex backendlp infopex import <终端>lp export <file> / lp import <file>pex set default group <组>(in the config file)pex user <玩家> listlp user <玩家> permission infopex user <玩家> prefixlp user <玩家> meta infopex user <玩家> prefix <前缀>lp user <玩家> meta addprefix <优先级> <前缀>pex user <玩家> suffixlp user <玩家> meta infopex user <玩家> suffix <后缀>lp user <玩家> meta addsuffix <优先级> <后缀>pex user <玩家> deletelp user <玩家> clearpex user <玩家> add <权限> <世界>lp user <玩家> permission set <权限> true global <世界>pex user <玩家> remove <权限> <世界>lp user <玩家> permission unset <权限> global <世界>pex user <玩家> timed add <权限> <时间> <世界>lp user <玩家> permission settemp <权限> true <时间> global <世界>pex user <玩家> timed remove <权限> <时间> <世界>lp user <玩家> permission settemp <权限> true <时间> global <世界>pex user <玩家> set <选项> <值> <世界>lp user <玩家> meta set <选项> <值> global <世界>pex user <玩家> group listlp user <玩家> parent infopex user <玩家> group add <组> <世界>lp user <玩家> parent add <组> global <世界>pex user <玩家> group add <组> <世界> <时间>lp user <玩家> parent addtemp <组> <时间> global <世界>pex user <玩家> group set <组>lp user <玩家> parent set <组>pex user <玩家> group remove <组> <世界>lp user <玩家> parent remove <组> global <世界>pex groups listlp listgroupspex group <组> listlp group <组> permission infopex group <组> prefixlp group <组> meta infopex group <组> prefix <前缀>lp group <组> meta addprefix <优先级> <前缀>pex group <组> suffixlp group <组> meta infopex group <组> suffix <后缀>lp group <组> meta addsuffix <优先级> <后缀>pex group <组> createlp creategroup <组>pex group <组> deletelp deletegroup <组>pex group <组> parents listlp group <组> parent infopex group <组> parents set <parents>lp group <组> parent add <parent>pex group <组> add <权限> <世界>lp group <组> permission set <权限> true global <世界>pex group <组> remove <权限> <世界>lp group <组> permission unset <权限> global <世界>pex group <组> timed add <权限> <时间> <世界>lp group <组> permission settemp <权限> true <时间> global <世界>pex group <组> timed remove <权限> <时间> <世界>lp group <组> permission settemp <权限> true <时间> global <世界>pex group <组> set <选项> <值> <世界>lp group <组> meta set <选项> <值> global <世界>pex group <组> user add <玩家>lp user <玩家> parent add <组>pex group <组> user remove <玩家>lp user <玩家> parent remove <组>pex promote <玩家> <梯>lp user <玩家> promote <梯>pex demote <玩家> <梯>lp user <玩家> demote <梯>% m' _3 h/ d; ?/ A% P* Z/ _6 |"
        },
        {
            "author": "INKDRRAK",
            "timestamp": 1502006160,
            "txt_content": "Advanced Setup部分翻译\n\" w1 b* v/ V% L2 k$ j( ]# {5 u- n高级设置\n3 F) w1 B6 B0 @/ n1 a& Z, K简介：3 a& q: z, H7 W6 m9 w\nLuckPerm总体来说虽然是相对简单的..4 V0 G: M* ~* I3 \\( M\n你可以利用插件的一些特点与内部规则来制定一个适合你服务器情况的高等权限系统！+ u4 s\" B' d, m; @\n分服务器权限&分世界权限：4 K& B$ _# p+ D  g, m\nLuckPerm本来是针对群组服的情况来工作的' _' ?+ v9 B8 o5 a3 O\n但是你可以自定义一些只在特定子服/特定世界才生效的权限\n* C- G4 y$ j+ E* _$ O; ~6 i3 X5 `. ~% [9 k\n配置中一些重要的选项说明：\n3 k9 U( Z/ }( @3 E* V- w# 服务器名称，用于上面讲到的分服务器的特定权限，该项设置为global即为禁用! b( z\" m/ g* m\nserver: global复制代码该项为设置服务器的名称，如果要想设置特定服务器的权限，则需要通过修改server项来命名服务器\n! K) A+ s! \\. d3 m7 ~, v* Q8 t7 K7 z; N如果你愿意，同一个群组服是可以一起使用相同的服务器名的\n' @1 j% V, h$ F& B! k0 I0 i$ H% w# 玩家在此服务器上是否应该应用他们的全局组/权限  r' U9 D2 N\" i\" k3 W\ninclude-global: true复制代码include-global选项也是非常重要的。\n* L! b6 i  w% v! K; K3 oLuckPerm有两种体现方式，一是特定服务器的权限，二则是直接应用全局权限设置\n4 h% ]- U( S: H1 q, }. M  G如果这个选项被设置为 false，只有指定在此服务器的权限才会被应用。$ l' H+ t. L% P9 p# k; B* j\n如果上方的 \"server\" 选项设置为 global，请不要将其设置为 false。更多的有关服务器指定的权限可以在这里找到。\n/ U3 W6 U# @% \\: \\\" w. E* j& H) j通过编辑更改这两个选项，你可以灵活的为每个服务器的权限组/权限做出意想不到的配合效果\" a  z; y+ d- Q6 T& t: ?0 r\n示例例子一：- [- D) t, f3 {\" h1 g\nserver: global8 w8 y: P  |8 C& S7 V\" @\ninclude-global: true复制代码 /luckperms user Luck set minecraft.command.gamemode true 将应用 /luckperms user Luck set minecraft.command.gamemode true factions 不应用- t) e! ~. p1 M9 M% j: H\n例子二：4 n- @+ ]: x$ y3 ]\nserver: lobby; z& s) ^/ R\" J1 [\ninclude-global: true复制代码 /luckperms user Luck set minecraft.command.gamemode true 将应用 /luckperms user Luck set minecraft.command.gamemode true lobby 将应用; x4 }2 \\( i4 }) F\" ]\n例子三：\n) c+ q' g6 F: l; B3 S8 F$ d8 mserver: bungeecord/ ]0 E/ Y  L% \\! m$ j# }\ninclude-global: false复制代码 /luckperms user Luck set minecraft.command.gamemode true 不应用 /luckperms user Luck set bungeecord.command.alert true bungeecord 将应用, l8 T; h7 {) c4 y\n例子四\" g# O0 f6 X& K2 \\\nserver: global\n; V\" E$ [1 ]6 ]- o2 C; u) b( D3 T' dinclude-global: false复制代码没有任何权限将会应用！; j) p5 D2 ~4 J; _\n如果没有设置服务器名字（server项设置为global）且全局设置未开启（include-global项设置为flase）. i% j! p- a: q& y$ n9 U) z9 r\n将不会有任何权限可以应用到服务器上！\n! v5 o: Y* h$ e7 f$ G$ @2 j+ p权限计算\n7 k7 {: K- _2 M7 |: b3 k+ ?权限是根据优先级进行计算的，如下所示\n2 M. ]' w4 t( o' M. K1 L3 v8 K! Q服务器特定的权限是会覆盖通用/全局权限设置的\n' N9 X. L: O\" o5 K: e$ k0 O. }# ~例如：有一个玩家，我们姑且叫他海螺，他拥有一个全局的“fly.use”（允许飞行）权限\n' j6 u9 O: X' W! y\" f, B) l1 F$ T然后在“factions”这个服务器上，取消了“fly.use”权限，服务器的特定权限设置将会覆盖全局设置/ z* ~* u2 q' o3 v* ], D\n即，这个海螺在“factions”服务器上是无法使用“fly.use”权限的，他就不能够上天了\n# n4 _; w; d% d% {- S\" p前提是海螺现在正在“factions”服务器上。\n$ A3 b$ S' E: `1 K! n世界特定的权限也是会覆盖通用/全局权限设置的: {7 T) r0 E, H0 [9 b\n例如：上文我们说的玩家“海螺”，他现在任然有一个全局的“fly.use”权限\n  U' a( P7 e7 O# f' }然后在“world_nether”（地狱）世界，取消了“fly.use”权限，世界的特定权限设置将会覆盖全局设置- X! b! }  T  _5 I\n即，这个海螺在地狱就无法上天了（只要海螺在地狱世界）: v  ^1 P- z8 n5 U0 r/ f\n临时权限将会覆盖非临时权限\n' {. e/ G( e+ m\" i0 g例如：如果玩家海螺本来关闭了一个权限“test.node”\" J* z: A# i4 X, u) |\n以此为基础，服务器给海螺设置新的临时权限“test.node”\n: f; G4 G& V8 r$ t4 o+ t海螺的临时权限则会覆盖本身关闭的权限，即海螺会在特定时间（临时权限）获得“test.node”权限8 o3 \\1 N6 `* L\n如果同时有两个节点相同、但时长不同的临时权限，时间较长的会覆盖时间较短的更加具体的通配符权限将覆盖不具体的通配符权限\n1 o0 |! q. J* O' M# h3 h例如：一个用户拥有权限“luckperms.*”并且设置为true，但是“luckperms.user.*”权限却设置为false4 ^& x; r\" N* ~, d8 y) [1 `/ E( W\n那么所有玩家的权限都将被设置为false！\n; |6 @/ f/ k3 t\" z1 t# n因为尽管“luckperm.*”有更加通用的通配符，但是他没有“luckperms.user.*”具体6 M+ L$ x+ b3 |9 ]\n继承权限将由对象自己的权限来重写\" y- ], j% f. G& C  I3 [# L/ r5 r\n例如：一个玩家是默认权限组的成员，默认权限组有“some.thing.perm”权限% g/ O0 C' a7 u: O9 a7 N$ c\n但是这个玩家又被以用户形式给予了权限“some.thing.perm”\n4 W8 s) t. C1 e  I& b, {  A3 h继承而来的权限将会被玩家自己的权限给覆盖, a& Y+ z& n! ^\" X2 D6 M- t\n临时权限\n* P  ~! y8 O( g2 [\" T, g4 I# h& ~8 c\" L\n临时权限每间隔3s会检查一遍，检查临时权限的时限是否到期8 s' v7 _2 y7 Q6 R; y$ g\n不论同步间隔设置的怎么样，这个检查都会照常工作，这意味着你可以安全的设置临时权限在几秒后过期: x  }5 Y! w% `\" t, K# ]; G\n他们将会在时限到期时被删除\n& s! s& E; [9 l8 }5 S4 N速记权限LuckPerms有他自己的速记权限系统，在这一点上，它非常类似PermissionsEx7 b: V  \\6 Z* W3 K. K' K9 \\, @\n它允许你使用速记格式来设置权限+ u* f) o' V% z0 j\n例子：\n% x2 U+ L2 l' H; [* |$ c例子一. i- Z( e/ w1 L\n使用LuckPerm的允许节点来作为例子，比如说，你想让一个用户组与用户权限设置/取消允许节点\n1 S  v8 K0 \\& H) x如果没有速记，你就必须键入下面四个节点% o* @+ }5 P2 V; B3 ^& K3 }\nluckperms.user.setpermission/ j, A2 N3 z, Z2 ^3 i\nluckperms.user.unsetpermission\n0 S. v6 Q\" B1 P$ J$ e% q9 T, mluckperms.group.setpermission* |- c6 [' \\; K  }\nluckperms.group.unsetpermission复制代码但是，你要是使用速记，你就可以应用以下节点/ D  \\, l2 e7 m\nluckperms.(user|group).(setpermission|unsetpermission)\n$ F, I$ s2 B% ]$ b你可以使用括号来让一个节点成为一个速记的权限组，然后用“|”来分隔他们\n- u\" ?, a. {  A$ F! {% e* G3 R例子二4 _4 n! e. X( G4 K8 M\n你可以使用“-”来创建字符范围，如果没有使用速记，则必须键入以下四个节点：\n: `0 _- k  `! Dcoolkits.kit.a/ D' t- [! }! u- @# p\ncoolkits.kit.b\n( h7 O\" `, H% p* \\2 ucoolkits.kit.c\n4 d; ]) Q# S; ~$ ^' ^8 kcoolkits.kit.d复制代码然而，使用了速记方法，你只需应用下面的节点：9 g% E+ K3 t5 Z3 ]/ D* @\ncoolkits.kit.(a-d). U) t1 q8 W0 _( L- s\n例子三7 |\" o9 m, E2 r' `4 D* ]\n你可以使用“-”来创建字符范围，如果没有使用速记，则必须键入以下四个节点：\n) t* m9 Q0 z& iprisonmines.teleport.1\n' x, \\\" @3 u1 Fprisonmines.teleport.2\n! s' t- M7 `( Bprisonmines.teleport.3- y( Y- Y: ]- k\nprisonmines.teleport.4复制代码不过，你只要使用速记方法，这一切都会变得简单许多！你只需要应用下面的节点：% v% T: x, `1 o# D  k+ j& ]\nprisonmines.teleport.(1-4)\n& F; C6 g. p% Q& {0 X6 A' t4 m3 K正则表达式0 @: v  F1 E1 d\" K* k3 V' J/ Z$ [\nLuckPerms支持使用正则表达式来定义权限节点与服务器/世界的名字* ~. k+ M( e- f& }\n当使用正则表达式的时候，必须添加前缀“R=”\n/ e$ U' c% K% [) Q所以LuckPerm才会知道将它是作为正则表达式来输出，而不是作为普通的字符串来输出2 i! ]9 q6 z5 \\, W) k9 b\n例如：你希望玩家可以创建两个组与权限系（tracks），通常只需要添加两个权限节点; [& `0 O, z! @; q. M\n然而使用正则表达式，你只需要添加一个权限节点  luckperms\\.create.* \n0 a- e5 x9 L8 _7 C( y8 P& @: l记住，转为任何字符，例如一个点，都将作为一个节点被系统解析\n. B4 O! W2 n9 D9 W7 B: S- J& ?\" \\6 a7 ~+ R3 T  d1 n\n"
        }
    ]
}