{
    "title": "[1.14.4] Forge 能量系统简述",
    "author": "土球球",
    "replyCount": 50,
    "timestamp": 1588316460,
    "txt_content": " 本帖最后由 土球球 于 2020-9-6 04:03 编辑 \n\nForge 能量系统简述\n\n这些内容本来是期望成为某本实体书的一部分的，但是一方面编辑在催稿，另一方面再往里塞东西就超字数了（超字数会影响书价，进而影响销量），因此没能最终塞进去。最近我把这些内容整理出来，并顺道把版本从 1.12.2 升级到了 1.14.4（毕竟 Forge 目前声称 1.14.4 是 LTS 来着），在这里分享给大家。\n\n全系列教程分为五讲（看上面的目录），大概涵盖了从物品到机器再到导线等所有和能量有关的东西，希望能够作为各位读者的参考吧。\n\n本文同时在本人的博客发布：\n\nhttps://blog.ustc-zzzz.net/forge-energy-demo-1/https://blog.ustc-zzzz.net/forge-energy-demo-2/https://blog.ustc-zzzz.net/forge-energy-demo-3/https://blog.ustc-zzzz.net/forge-energy-demo-4/https://blog.ustc-zzzz.net/forge-energy-demo-5/\n\n以下是本文相关源代码：\n\n\n\n\nFEDemo.zip\n(82.51 KB, 下载次数: 222)\n\n\n\n2020-9-6 04:03 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n\n\n虽然夹杂着众多争议，但 Forge 最终仍然决定在 1.10.2 加入官方的能量系统，并一直将其延续到现在。该系统参考了 CoFH 团队的众多设计，因此和在此前已经拥有鼎鼎大名的 Redstone Flux 能量系统有着众多的相似之处。\n\n在本系列教程中，各位读者将走入 Forge 能量系统所带来的奇妙世界。由于本文将使用 Minecraft 1.14.4 和 Forge 28.2.4 进行讲解，因此如果读者想要顺畅阅读本教程，那么有一些要求是需要满足的：\n\n已能够相对熟练地使用 Java 8 编写代码和设计程序。已能够基于 Minecraft 1.14.4 和 Forge 添加简单的方块或物品。\n\n废话不多说，我们开始吧。\n\n准备工作\n\n我们决定将 ModID 起名为 fedemo，以下是 META-INF/mods.toml 文件：\n\nmodLoader=\"javafml\"\nloaderVersion=\"[28,)\"\n\n[[mods]]\nmodId=\"fedemo\"\nversion=\"${file.jarVersion}\"\ndisplayName=\"FE Demonstration Mod\"\ndescription=\"Demonstration for Forge Energy\"\n\n[[dependencies.fedemo]]\nmodId=\"forge\"\nmandatory=true\nversionRange=\"[28.2,)\"\nordering=\"NONE\"\nside=\"BOTH\"\n\n[[dependencies.fedemo]]\nmodId=\"minecraft\"\nmandatory=true\nversionRange=\"[1.14.4]\"\nordering=\"NONE\"\nside=\"BOTH\"复制代码\n以下是主类，非常简洁：\n\n@Mod(\"fedemo\")\npublic class FEDemo\n{\n    public static final Logger LOGGER = LogManager.getLogger(FEDemo.class);\n}复制代码\n本系列教程的所有 Java 代码均在 com.github.ustc_zzzz.fedemo 包下。\n\nCapability 系统\n\nCapability 系统是 Forge 能量系统的基石。\n\nCapability 系统对原版游戏元素和第三方行为（大多数情况下和 Mod 有关）实施了一定程度的解耦合。具体来说，Mod 开发者可通过调用 getCapability 方法获取并操纵特定的第三方行为。getCapability 方法由 ICapabilityProvider 接口声明，而 Forge 为很多游戏元素都实现了这一接口，比如我们耳熟能详的物品堆叠（ItemStack）、实体（Entity）、方块实体（TileEntity）等。\n\nCapabilityDispatcher 是一类特殊的 ICapabilityProvider，因为它可以存有多个 ICapabilityProvider。刚才我们提到的物品堆叠、实体、方块实体等游戏元素，内部都存在一个由 Forge 提供的 CapabilityDispatcher，这使得我们向已有的游戏元素添加 ICapabilityProvider 成为可能。\n\n我们来看 getCapability 方法的声明：\n\n@Nonnull <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, Direction side);复制代码\ngetCapability 方法的第一个参数代表的是特定的 Capability，我们可以通过 CapabilityEnergy.ENERGY 来拿到它，从而为实现 Forge 能量系统铺路；getCapability 方法的第二个参数代表一个方向，在和方块实体打交道的时候我们用得着。\n\n为物品添加 Capability\n\n我们决定制作一个存储 FE 的电池。我们先编写一个最最基础的物品类，并为其指定创造模式物品栏和最大物品数量：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoBatteryItem extends Item\n{\n    public static final String NAME = \"fedemo:battery\";\n\n    @SubscribeEvent\n    public static void onRegisterItem(@Nonnull RegistryEvent.Register<Item> event)\n    {\n        FEDemo.LOGGER.info(\"Registering battery item ...\");\n        event.getRegistry().register(new FEDemoBatteryItem().setRegistryName(NAME));\n    }\n\n    private FEDemoBatteryItem()\n    {\n        super(new Item.Properties().maxStackSize(1).group(ItemGroup.MISC));\n    }\n}复制代码\nForge 为 Item 额外追加了 initCapabilities 方法，这个方法的返回值是 ICapabilityProvider，我们需要覆盖这个方法：\n\n@Override\npublic ICapabilityProvider initCapabilities(@Nonnull ItemStack stack, CompoundNBT nbt)\n{\n    return new ICapabilityProvider()\n    {\n        private LazyOptional<IEnergyStorage> lazyOptional; // TODO\n\n        @Nonnull\n        @Override\n        public <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, Direction side)\n        {\n            boolean isEnergy = Objects.equals(cap, CapabilityEnergy.ENERGY);\n            return isEnergy ? this.lazyOptional.cast() : LazyOptional.empty();\n        }\n    };\n}复制代码\n我们注意到了 LazyOptional 的存在。LazyOptional 类由 Forge 提供，本质和 Java 的 Optional 类似，不过其内部的实例只在用到的时候才会加载。我们在参数为 CapabilityEnergy.ENERGY 的时候返回一个预先准备好的 LazyOptional，否则便返回一个 LazyOptional.empty()。\n\nCapabilityEnergy.ENERGY 的类型是 Capability<IEnergyStorage>，因此我们要实现的也是 IEnergyStorage。\n\n物品能量的具体实现\n\nItemStack 存储三种数据：物品类型、数量、和 NBT。很明显，我们的物品能量只能放在 NBT 里。\n\n我们会用到以下五个方法操纵 NBT：\n\nhasTag：检查一个 ItemStack 是否拥有 NBT。getTag：返回一个 ItemStack 的 NBT，如果不存在则返回 null。getOrCreateTag：返回一个 ItemStack 的 NBT，如果不存在则为其创建一个。putInt：设置 NBT 复合标签的特定整数值。getInt：获取 NBT 复合标签的特定整数值，如果值不存在或者不是整数则返回 0。\n\n很好。以下是具体实现：\n\nprivate final LazyOptional<IEnergyStorage> lazyOptional = LazyOptional.of(() -> new IEnergyStorage()\n{\n    @Override\n    public int receiveEnergy(int maxReceive, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(this.getMaxEnergyStored() - energy, maxReceive);\n        if (!simulate)\n        {\n            stack.getOrCreateTag().putInt(\"BatteryEnergy\", energy + diff);\n        }\n        return diff;\n    }\n\n    @Override\n    public int extractEnergy(int maxExtract, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(energy, maxExtract);\n        if (!simulate)\n        {\n            stack.getOrCreateTag().putInt(\"BatteryEnergy\", energy - diff);\n        }\n        return diff;\n    }\n\n    @Override\n    public int getEnergyStored()\n    {\n        if (stack.hasTag())\n        {\n            int energy = Objects.requireNonNull(stack.getTag()).getInt(\"BatteryEnergy\");\n            return Math.max(0, Math.min(this.getMaxEnergyStored(), energy));\n        }\n        return 0;\n    }\n\n    @Override\n    public int getMaxEnergyStored()\n    {\n        return 48_000;\n    }\n\n    @Override\n    public boolean canExtract()\n    {\n        return true;\n    }\n\n    @Override\n    public boolean canReceive()\n    {\n        return true;\n    }\n});复制代码\n代码有点复杂，我们一个方法一个方法拆开看。\n\ncanReceive 代表是否能输入能量，这里我们让它返回 true。canExtract 代表是否能输出能量，这里我们也让它返回 true。getMaxEnergyStored 代表内部能够存储的最大能量，这里我们设定在 48000。getEnergyStored 代表内部存储的实际能量，这里我们通过物品的 NBT 读取能量。extractEnergy 代表实施输出能量的行为，其中 simulate 参数代表是否为模拟行为。receiveEnergy 代表实施输入能量的行为，其中 simulate 参数代表是否为模拟行为。\n\nextractEnergy 和 receiveEnergy 各自均接收一个 int 作为参数，并生成 int 作为返回值。其中，作为参数传入的 int 代表期望输入输出的能量，而作为返回值的 int 代表实际输入输出的能量。这两个参数都非常重要，希望读者能够加以注意。\n\n杂项\n\n我们可以向 en_us.json 这一语言文件里添加一项：\n\n\"item.fedemo.battery\": \"FE Battery\"复制代码\n我们还可以通过覆盖 addInformation 方法添加额外的提示文本：\n\n@Override\n@OnlyIn(Dist.CLIENT)\npublic void addInformation(@Nonnull ItemStack stack, World world, @Nonnull List<ITextComponent> tooltip, @Nonnull ITooltipFlag flag)\n{\n    stack.getCapability(CapabilityEnergy.ENERGY).ifPresent(e ->\n    {\n        String msg = e.getEnergyStored() + \" FE / \" + e.getMaxEnergyStored() + \" FE\";\n        tooltip.add(new StringTextComponent(msg).applyTextStyle(TextFormatting.GRAY));\n    });\n}复制代码\n我们也可以通过覆盖 fillItemGroup 方法为创造模式物品栏添加多个物品，分别对应 0 FE，12000 FE，24000 FE，36000 FE，和 48000 FE：\n\n@Override\npublic void fillItemGroup(@Nonnull ItemGroup group, @Nonnull NonNullList<ItemStack> items)\n{\n    if (this.isInGroup(group))\n    {\n        IntStream.rangeClosed(0, 4).forEach(i ->\n        {\n            ItemStack stack = new ItemStack(this);\n            stack.getCapability(CapabilityEnergy.ENERGY).ifPresent(e ->\n            {\n                int energy = e.getMaxEnergyStored() / 4 * i;\n                e.receiveEnergy(energy, false);\n                items.add(stack);\n            });\n        });\n    }\n}复制代码\n到目前为止，我们已经解决了除材质外的所有问题了。\n\n材质\n\n我们为电池绘制了五种材质，分别对应电量空到电量满等五种情况，也恰好对应创造模式物品栏的五个物品：\n\n\n\n\n\n\nimage-1.png (42.03 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n默认情况自然是电量空，那我们怎么映射剩下的四种情况呢？原版 Minecraft 为我们提供了 Item Property Override 机制，该机制使得根据 NBT 动态调整材质成为可能。\n\n欲使用 Item Property Override，我们只需在构造方法中添加下面一句：\n\nthis.addPropertyOverride(new ResourceLocation(\"energy\"), (stack, world, entity) ->\n{\n    LazyOptional<IEnergyStorage> lazyOptional = stack.getCapability(CapabilityEnergy.ENERGY);\n    return lazyOptional.map(e -> (float) e.getEnergyStored() / e.getMaxEnergyStored()).orElse(0.0F);\n});复制代码\n这样我们的物品就有了一个名为 energy 的属性，我们在描述材质的 JSON 文件（应为 battery.json）写下：\n\n{\n  \"parent\": \"item/generated\",\n  \"textures\": {\n    \"layer0\": \"fedemo:item/battery\"\n  },\n  \"overrides\": [\n    {\n      \"predicate\": {\n        \"energy\": 0.125\n      },\n      \"model\": \"fedemo:item/battery1\"\n    },\n    {\n      \"predicate\": {\n        \"energy\": 0.375\n      },\n      \"model\": \"fedemo:item/battery2\"\n    },\n    {\n      \"predicate\": {\n        \"energy\": 0.625\n      },\n      \"model\": \"fedemo:item/battery3\"\n    },\n    {\n      \"predicate\": {\n        \"energy\": 0.875\n      },\n      \"model\": \"fedemo:item/battery4\"\n    }\n  ]\n}复制代码\n注意和普通 JSON 相比，该文件额外多出了 override 部分，其中 predicate 判定的是当前属性值是否不小于提供的值，因此我们在该 JSON 中将 energy 划分为了五档，从而应对五种可能的情况。\n\n接下来我们只需要完善 battery1.json 到 battery4.json 就可以了。以下是 battery4.json 的全部内容：\n\n{\n  \"parent\": \"item/generated\",\n  \"textures\": {\n    \"layer0\": \"fedemo:item/battery4\"\n  }\n}复制代码\n以下是打开游戏后的显示结果。\n\n\n\n\n\n\nimage-2.png (126.26 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n代码清单\n\n这一部分添加的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/FEDemo.javasrc/main/java/com/github/ustc_zzzz/fedemo/item/FEDemoBatteryItem.javasrc/main/resources/pack.mcmetasrc/main/resources/META-INF/mods.tomlsrc/main/resources/assets/fedemo/lang/en_us.jsonsrc/main/resources/assets/fedemo/models/item/battery.jsonsrc/main/resources/assets/fedemo/models/item/battery1.jsonsrc/main/resources/assets/fedemo/models/item/battery2.jsonsrc/main/resources/assets/fedemo/models/item/battery3.jsonsrc/main/resources/assets/fedemo/models/item/battery4.jsonsrc/main/resources/assets/fedemo/textures/item/battery.pngsrc/main/resources/assets/fedemo/textures/item/battery1.pngsrc/main/resources/assets/fedemo/textures/item/battery2.pngsrc/main/resources/assets/fedemo/textures/item/battery3.pngsrc/main/resources/assets/fedemo/textures/item/battery4.png\n\n\n\n\n这一讲我们将达成两个目标：\n\n制造一个作为用电器的机器方块，且当实体生物站在该方块上时耗费能量为实体回血。使电池在右键方块时可以将自己的能量转移到特定方块，按住 Shift 右键则反过来。\n\n添加方块\n\n我们先编写一个最最基础的方块类，并为其指定材料、硬度、和爆炸抗性，同时为对应的物品指定创造模式物品栏：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoMachineBlock extends Block\n{\n    public static final String NAME = \"fedemo:machine\";\n\n    @ObjectHolder(NAME)\n    public static FEDemoMachineBlock BLOCK;\n\n    @SubscribeEvent\n    public static void onRegisterBlock(@Nonnull RegistryEvent.Register<Block> event)\n    {\n        FEDemo.LOGGER.info(\"Registering machine block ...\");\n        event.getRegistry().register(new FEDemoMachineBlock().setRegistryName(NAME));\n    }\n\n    @SubscribeEvent\n    public static void onRegisterItem(@Nonnull RegistryEvent.Register<Item> event)\n    {\n        FEDemo.LOGGER.info(\"Registering machine item ...\");\n        event.getRegistry().register(new BlockItem(BLOCK, new Item.Properties().group(ItemGroup.MISC)).setRegistryName(NAME));\n    }\n\n    private FEDemoMachineBlock()\n    {\n        super(Block.Properties.create(Material.IRON).hardnessAndResistance(3));\n    }\n}复制代码\n这里使用了 ObjectHolder 注解来使 Forge 自动注入对应的方块类型的实例。注意该注解的参数正是方块的注册名。\n\n然后我们添加语言文件：\n\n\"block.fedemo.machine\": \"FE Heal Machine\"复制代码\n以及同名方块状态 JSON 文件（machine.json）：\n\n{\n  \"variants\": {\n    \"\": {\n      \"model\": \"fedemo:block/machine\"\n    }\n  }\n}复制代码\n该 JSON 文件指向同名材质描述文件。\n\n我们创建 machine.json 文件，该文件的上一级目录名应为 block：\n\n{\n  \"parent\": \"block/cube_bottom_top\",\n  \"textures\": {\n    \"bottom\": \"block/furnace_top\",\n    \"top\": \"fedemo:block/machine_top\",\n    \"side\": \"fedemo:block/energy_side\"\n  }\n}复制代码\n该文件复用了熔炉的 JSON 材质，并引用了两张额外的材质（machine_top.png 和 energy_side.png）。\n\n在添加这两张材质的同时，我们不要忘了让 item 目录下的同名文件（machine.json）引用该 JSON：\n\n{\n  \"parent\": \"fedemo:block/machine\"\n}复制代码\n现在打开游戏。如一切顺利，方块和对应物品均应正常显示：\n\n\n\n\n\n\nimage-3.png (232.33 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n为方块添加方块实体\n\n如果想要让方块存储复杂的数据，执行复杂的行为，方块实体（TileEntity）是必不可少的。更重要的一点是，TileEntity 本身实现了 ICapabilityProvider 接口，因此如果我们想要声明一个方块拥有能量，我们必须为该方块指定方块实体。\n\n添加 TileEntity 前必须首先添加 TileEntityType。和方块物品等类似，TileEntityType 本身也有注册事件，因此我们要监听这一事件并将 TileEntityType 的实例注册进去：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoMachineTileEntity extends TileEntity\n{\n    public static final String NAME = \"fedemo:machine\";\n\n    @ObjectHolder(NAME)\n    public static TileEntityType<FEDemoMachineTileEntity> TILE_ENTITY_TYPE;\n\n    @SubscribeEvent\n    public static void onRegisterTileEntityType(@Nonnull RegistryEvent.Register<TileEntityType<?>> event)\n    {\n        FEDemo.LOGGER.info(\"Registering machine tile entity type ...\");\n        event.getRegistry().register(TileEntityType.Builder.create(FEDemoMachineTileEntity::new, FEDemoMachineBlock.BLOCK).build(DSL.remainderType()).setRegistryName(NAME));\n    }\n\n    private FEDemoMachineTileEntity()\n    {\n        super(TILE_ENTITY_TYPE);\n    }\n}复制代码\n除去注册名外，构造一个 TileEntityType 一共需要不少于三个参数：\n\ncreate 方法的第一个参数代表方块实体的构造器，而后续参数代表能够和方块实体相容的方块类型（由于是变长参数，因此可传入多个），这里直接传入对应方块就好了。build 方法的唯一参数代表方块实体 NBT 类型。该类型由 Mojang 官方的 DataFixer（com.mojang.datafixers）定义，这里直接取 DSL.remainderType()（代表未知类型）即可。\n\n最后我们需要在方块类中声明方块和方块实体的关联，为此我们需要覆盖 Block 类的 hasTileEntity 和 createTileEntity 方法：\n\n@Override\npublic boolean hasTileEntity(@Nonnull BlockState state)\n{\n    return true;\n}\n\n@Override\npublic TileEntity createTileEntity(@Nonnull BlockState state, @Nonnull IBlockReader world)\n{\n    return FEDemoMachineTileEntity.TILE_ENTITY_TYPE.create();\n}复制代码\n为方块实体添加 Capability\n\n由于每个方块实体都分别对应一个 TileEntity 的实例，因此我们可以将数据直接以字段的方式存放在 TileEntity 中。唯一不同的是，为了让我们的数据能够映射到 NBT，我们需要同时覆盖 TileEntity 的 read 和 write 两个方法：\n\nprivate int energy = 0;\n\n@Override\npublic void read(@Nonnull CompoundNBT compound)\n{\n    this.energy = compound.getInt(\"MachineEnergy\");\n    super.read(compound);\n}\n\n@Nonnull\n@Override\npublic CompoundNBT write(@Nonnull CompoundNBT compound)\n{\n    compound.putInt(\"MachineEnergy\", this.energy);\n    return super.write(compound);\n}复制代码\nread 和 write 两个方法反映的分别是方块实体的反序列化和序列化两个过程。一个 TileEntity 通过这两个方法实现了和 NBT 复合标签的映射。\n\n现在我们来实现 getCapability 方法。在上面的内容中我们提到过，TileEntity 本身实现了 ICapabilityProvider 接口，因此我们只需覆盖这一方法即可：\n\nprivate LazyOptional<IEnergyStorage> lazyOptional; // TODO\n\n@Nonnull\n@Override\npublic <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, Direction side)\n{\n    boolean isEnergy = Objects.equals(cap, CapabilityEnergy.ENERGY) && side.getAxis().isHorizontal();\n    return isEnergy ? this.lazyOptional.cast() : super.getCapability(cap, side);\n}复制代码\n注意相较物品，我们的 getCapability 方法在判断时额外判定了传入的是否为水平朝向（东南西北）。通过这种方法我们可以设定输入输出能量相较朝向的限制，在这里我们直接禁止了能量在上下两个朝向的交互。\n\n然后我们构造 LazyOptional<IEnergyStorage> 的实例：\n\nprivate final LazyOptional<IEnergyStorage> lazyOptional = LazyOptional.of(() -> new IEnergyStorage()\n{\n    @Override\n    public int receiveEnergy(int maxReceive, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(this.getMaxEnergyStored() - energy, maxReceive);\n        if (!simulate)\n        {\n            FEDemoMachineTileEntity.this.energy += diff;\n            if (diff != 0)\n            {\n                FEDemoMachineTileEntity.this.markDirty();\n            }\n        }\n        return diff;\n    }\n\n    @Override\n    public int extractEnergy(int maxExtract, boolean simulate)\n    {\n        return 0;\n    }\n\n    @Override\n    public int getEnergyStored()\n    {\n        return Math.max(0, Math.min(this.getMaxEnergyStored(), FEDemoMachineTileEntity.this.energy));\n    }\n\n    @Override\n    public int getMaxEnergyStored()\n    {\n        return 192_000;\n    }\n\n    @Override\n    public boolean canExtract()\n    {\n        return false;\n    }\n\n    @Override\n    public boolean canReceive()\n    {\n        return true;\n    }\n});复制代码\n和基于物品的实现，基于方块实体的实现有以下几点不同：\n\n直接通过修改 energy 字段调整能量。getMaxEnergyStored 返回的是最大存储能量，这里设置为 192000。由于是作为用电器的机器，所以能量是只进不出的。注意 canExtract 和 extractEnergy 两个方法的返回值。注意 markDirty 方法的使用。该方法将方块实体所处区块标记为需要保存，虽然如果不标记，游戏大概率也会保存，但我们强烈建议这么做。\n\n为方块实现具体功能\n\n为了更方便地调整方块实体的能量，我们为方块实体类添加一个 heal 方法用于回血，一次回复 0.1 点（约一秒一颗心）：\n\npublic void heal(@Nonnull LivingEntity entity)\n{\n    int diff = Math.min(this.energy, 100);\n    if (diff > 0)\n    {\n        entity.heal((float) diff / 1_000);\n        this.energy -= diff;\n        this.markDirty();\n    }\n}复制代码\n若想判断实体是否接触了方块，我们需要利用方块的 onEntityCollision 方法。原版 Minecraft 会在实体进入方块所处区域时触发该方法，我们覆盖 Block 类的这一方法即可：\n\n@Override\n@SuppressWarnings(\"deprecation\")\npublic void onEntityCollision(@Nonnull BlockState state, @Nonnull World world, @Nonnull BlockPos pos, @Nonnull Entity entity)\n{\n    if (!world.isRemote && entity instanceof LivingEntity)\n    {\n        LivingEntity livingEntity = (LivingEntity) entity;\n        if (livingEntity.getHealth() < livingEntity.getMaxHealth())\n        {\n            TileEntity tileEntity = world.getTileEntity(pos);\n            if (tileEntity instanceof FEDemoMachineTileEntity)\n            {\n                ((FEDemoMachineTileEntity) tileEntity).heal(livingEntity);\n            }\n        }\n    }\n}复制代码\n在上面的方法里我们主要检查了四件事，如果四件事均满足我们便调用方块实体类的 heal 方法：\n\n世界处于逻辑服务端（使用 !world.isRemote 判断）。实体属于实体生物这一范畴（使用 entity instanceof LivingEntity 判断）。实体生物并未满血（使用 livingEntity.getHealth() < livingEntity.getMaxHealth() 判断）。对应的方块实体是我们所期望的（使用 tileEntity instanceof FEDemoMachineTileEntity 判断）。\n\n最后，为了让我们的实体进入方块所处区域，我们需要重新定义碰撞箱，不能让碰撞箱占满整个方块：\n\n@Nonnull\n@Override\n@SuppressWarnings(\"deprecation\")\npublic VoxelShape getCollisionShape(@Nonnull BlockState state, @Nonnull IBlockReader world, @Nonnull BlockPos pos, @Nonnull ISelectionContext context)\n{\n    return Block.makeCuboidShape(0, 0, 0, 16, 15, 16);\n}复制代码\n代码很简单，只是让高度也就是 Y 轴从 16 变成了 15 而已，X 轴和 Z 轴方向都没有变。\n\n为物品实现具体功能\n\n现在进入到这一讲的最后一步，也就是实现电池右键方块的行为。原版 Minecraft 会在物品右键方块时调用 Item 类的 onItemUse 方法，因此我们可以通过覆盖这一方法实现相应行为：\n\n@Nonnull\n@Override\npublic ActionResultType onItemUse(@Nonnull ItemUseContext context)\n{\n    World world = context.getWorld();\n    if (!world.isRemote)\n    {\n        TileEntity tileEntity = world.getTileEntity(context.getPos());\n        if (tileEntity != null)\n        {\n            Direction side = context.getFace();\n            tileEntity.getCapability(CapabilityEnergy.ENERGY, side).ifPresent(e ->\n            {\n                this.transferEnergy(context, e);\n                this.notifyPlayer(context, e);\n            });\n        }\n    }\n    return ActionResultType.SUCCESS;\n}\n\nprivate void notifyPlayer(@Nonnull ItemUseContext context, @Nonnull IEnergyStorage target)\n{\n    PlayerEntity player = context.getPlayer();\n    if (player != null)\n    {\n        String msg = target.getEnergyStored() + \" FE / \" + target.getMaxEnergyStored() + \" FE\";\n        player.sendMessage(new StringTextComponent(msg).applyTextStyle(TextFormatting.GRAY));\n    }\n}\n\nprivate void transferEnergy(@Nonnull ItemUseContext context, @Nonnull IEnergyStorage target)\n{\n    // TODO\n}复制代码\n首先我们进行了必要的逻辑服务端检查，以及方块实体本身的检查。然后我们通过 getCapability 方法获取方块实体的能量相关信息。紧接着我们调用了 transferEnergy 方法，该方法将完成能量的传输。最后我们调用了 notifyPlayer 方法，通知右键方块的玩家能量相关信息。\n\n我们现在实现 transferEnergy 方法：\n\nprivate void transferEnergy(@Nonnull ItemUseContext context, @Nonnull IEnergyStorage target)\n{\n    context.getItem().getCapability(CapabilityEnergy.ENERGY).ifPresent(e ->\n    {\n        if (context.isPlacerSneaking())\n        {\n            if (target.canExtract())\n            {\n                int diff = e.getMaxEnergyStored() - e.getEnergyStored();\n                e.receiveEnergy(target.extractEnergy(diff, false), false);\n            }\n        }\n        else\n        {\n            if (target.canReceive())\n            {\n                int diff = e.getEnergyStored();\n                e.extractEnergy(target.receiveEnergy(diff, false), false);\n            }\n        }\n    });\n}复制代码\n我们获取了物品本身对应的 IEnergyStorage 后，判断玩家是否按下 Shift。\n\n接下来进入到了两个分支。我们先从第一个分支，也就是玩家按下 Shift 取出能量开始看：\n\nif (target.canExtract())\n{\n    int diff = e.getMaxEnergyStored() - e.getEnergyStored();\n    e.receiveEnergy(target.extractEnergy(diff, false), false);\n}复制代码\n一个重要的问题是取出多少能量。很明显，为了达成“能取多少取多少”的目标，我们需要划定一个可以承受的上限，这个上限自然是电池还可以容纳的能量。我们计算出数值后存放到 diff 变量下，然后我们调用方块实体的 extractEnergy 方法以及和物品相关的 receiveEnergy 方法就可以了。\n\n现在我们来看第二个分支，也就是玩家不按下 Shift 存入能量：\n\nif (target.canReceive())\n{\n    int diff = e.getEnergyStored();\n    e.extractEnergy(target.receiveEnergy(diff, false), false);\n}复制代码\n整段实现和取出能量类似，但具体上仍有细微的差别。除了存取能量的身份对调外，如果我们想贯彻“能存多少存多少”的目标，我们需要把上限划定为 e.getEnergyStored()。\n\n以下是打开游戏后的显示结果。\n\n\n\n\n\n\nimage-4.png (225.52 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n代码清单\n\n这一部分添加的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/block/FEDemoMachineBlock.javasrc/main/java/com/github/ustc_zzzz/fedemo/tileentity/FEDemoMachineTileEntity.javasrc/main/resources/assets/fedemo/blockstates/machine.jsonsrc/main/resources/assets/fedemo/models/block/machine.jsonsrc/main/resources/assets/fedemo/models/item/machine.jsonsrc/main/resources/assets/fedemo/textures/block/energy_side.pngsrc/main/resources/assets/fedemo/textures/block/machine_top.png\n\n这一部分修改的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/item/FEDemoBatteryItem.javasrc/main/resources/assets/fedemo/lang/en_us.json\n\n\n\n\n在这一讲我们将制造一个作为发电机的机器方块：\n\n该方块收集太阳能作为能量来源。该方块能够向周围方块输出能量。\n\n添加方块和方块实体\n\n以下是方块类的基础实现：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoGeneratorBlock extends Block\n{\n    public static final String NAME = \"fedemo:generator\";\n\n    @ObjectHolder(NAME)\n    public static FEDemoGeneratorBlock BLOCK;\n\n    @SubscribeEvent\n    public static void onRegisterBlock(@Nonnull RegistryEvent.Register<Block> event)\n    {\n        FEDemo.LOGGER.info(\"Registering generator block ...\");\n        event.getRegistry().register(new FEDemoGeneratorBlock().setRegistryName(NAME));\n    }\n\n    @SubscribeEvent\n    public static void onRegisterItem(@Nonnull RegistryEvent.Register<Item> event)\n    {\n        FEDemo.LOGGER.info(\"Registering generator item ...\");\n        event.getRegistry().register(new BlockItem(BLOCK, new Item.Properties().group(ItemGroup.MISC)).setRegistryName(NAME));\n    }\n\n    private FEDemoGeneratorBlock()\n    {\n        super(Block.Properties.create(Material.IRON).hardnessAndResistance(3));\n    }\n\n    @Override\n    public boolean hasTileEntity(@Nonnull BlockState state)\n    {\n        return true;\n    }\n\n    @Override\n    public TileEntity createTileEntity(@Nonnull BlockState state, @Nonnull IBlockReader world)\n    {\n        return FEDemoGeneratorTileEntity.TILE_ENTITY_TYPE.create();\n    }\n}复制代码\n以下是方块实体类的基础实现：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoGeneratorTileEntity extends TileEntity implements ITickableTileEntity\n{\n    public static final String NAME = \"fedemo:generator\";\n\n    @ObjectHolder(NAME)\n    public static TileEntityType<FEDemoGeneratorTileEntity> TILE_ENTITY_TYPE;\n\n    @SubscribeEvent\n    public static void onRegisterTileEntityType(@Nonnull RegistryEvent.Register<TileEntityType<?>> event)\n    {\n        FEDemo.LOGGER.info(\"Registering generator tile entity type ...\");\n        event.getRegistry().register(TileEntityType.Builder.create(FEDemoGeneratorTileEntity::new, FEDemoGeneratorBlock.BLOCK).build(DSL.remainderType()).setRegistryName(NAME));\n    }\n\n    private FEDemoGeneratorTileEntity()\n    {\n        super(TILE_ENTITY_TYPE);\n    }\n}复制代码\n方块和方块实体类的实现和上一讲针对用电器的实现大同小异。\n\n然后我们指定方块状态 JSON（generator.json）：\n\n{\n  \"variants\": {\n    \"\": {\n      \"model\": \"fedemo:block/generator\"\n    }\n  }\n}复制代码\n接下来是描述方块材质的同名 JSON（generator.json）：\n\n{\n  \"parent\": \"block/cube_bottom_top\",\n  \"textures\": {\n    \"bottom\": \"block/furnace_top\",\n    \"top\": \"fedemo:block/generator_top\",\n    \"side\": \"fedemo:block/energy_side\"\n  }\n}复制代码\n以及描述方块对应物品的同名 JSON（generator.json）：\n\n{\n  \"parent\": \"fedemo:block/generator\"\n}复制代码\n相较上一讲，我们额外添加了 generator_top.png 作为发电机顶部的新材质。\n\n最后我们补充语言文件（en_us.json）：\n\n\"block.fedemo.generator\": \"FE Energy Generator\"复制代码\n打开游戏就可以看到效果了：\n\n\n\n\n\n\nimage-5.png (349.45 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n为方块实体实现 Capability\n\n我们仍然使用一个 int 字段存储方块实体的能量，并将其通过 read 和 write 方法和 NBT 映射：\n\nprivate int energy = 0;\n\n@Override\npublic void read(@Nonnull CompoundNBT compound)\n{\n    this.energy = compound.getInt(\"GeneratorEnergy\");\n    super.read(compound);\n}\n\n@Nonnull\n@Override\npublic CompoundNBT write(@Nonnull CompoundNBT compound)\n{\n    compound.putInt(\"GeneratorEnergy\", this.energy);\n    return super.write(compound);\n}复制代码\n然后我们基于此实现我们自己的 LazyOptional<IEnergyStorage> 和基于能量的 Capability 实现：\n\nprivate final LazyOptional<IEnergyStorage> lazyOptional = LazyOptional.of(() -> new IEnergyStorage()\n{\n    @Override\n    public int receiveEnergy(int maxReceive, boolean simulate)\n    {\n        return 0;\n    }\n\n    @Override\n    public int extractEnergy(int maxExtract, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(energy, maxExtract);\n        if (!simulate)\n        {\n            FEDemoGeneratorTileEntity.this.energy -= diff;\n            if (diff != 0)\n            {\n                FEDemoGeneratorTileEntity.this.markDirty();\n            }\n        }\n        return diff;\n    }\n\n    @Override\n    public int getEnergyStored()\n    {\n        return Math.max(0, Math.min(this.getMaxEnergyStored(), FEDemoGeneratorTileEntity.this.energy));\n    }\n\n    @Override\n    public int getMaxEnergyStored()\n    {\n        return 192_000;\n    }\n\n    @Override\n    public boolean canExtract()\n    {\n        return true;\n    }\n\n    @Override\n    public boolean canReceive()\n    {\n        return false;\n    }\n});\n\n@Nonnull\n@Override\npublic <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, Direction side)\n{\n    boolean isEnergy = Objects.equals(cap, CapabilityEnergy.ENERGY) && side.getAxis().isHorizontal();\n    return isEnergy ? this.lazyOptional.cast() : super.getCapability(cap, side);\n}复制代码\n这里的实现和上一讲针对用电器的实现类似，唯一的不同之处在于：发电机的电量应该是只出不进的。注意 canReceive 和 receiveEnergy 两个方法的返回值。\n\n为方块实体实现功能\n\n我们既然希望方块收集太阳能，那我们自然是希望方块实体所存储的能量随时间递增。这需要我们让我们的方块实体每 tick 执行一段代码，原版 Minecraft 为我们提供了 ITickableTileEntity 接口。我们只需要让我们的类在继承 TileEntity 的同时实现这一接口即可：\n\npublic class FEDemoGeneratorTileEntity extends TileEntity implements ITickableTileEntity\n{\n    // ...\n\n    @Override\n    public void tick()\n    {\n        if (this.world != null && !this.world.isRemote)\n        {\n            this.generateEnergy(this.world);\n            this.transferEnergy(this.world);\n        }\n    }\n\n    private void generateEnergy(@Nonnull World world)\n    {\n        // TODO\n    }\n\n    private void transferEnergy(@Nonnull World world)\n    {\n        // TODO\n    }\n\n    // ...\n}复制代码\n我们先从 generateEnergy 方法的实现开始：\n\nprivate void generateEnergy(@Nonnull World world)\n{\n    if (world.getDimension().hasSkyLight())\n    {\n        int light = world.getLightFor(LightType.SKY, this.pos.up()) - world.getSkylightSubtracted();\n        int diff = Math.min(192_000 - this.energy, 10 * Math.max(0, light - 10));\n        if (diff != 0)\n        {\n            this.energy += diff;\n            this.markDirty();\n        }\n    }\n}复制代码\n表达式 world.getLightFor(LightType.SKY, this.pos.up()) - world.getSkylightSubtracted() 返回的是当前方块上方的天空亮度值，不超过 15。它的下一行代码规定了亮度和能量的映射关系：亮度不超过 10 时不增加 FE，超过 10 后每增加 1 每 tick 相应增加 10 FE，亮度为 15 时为 50 FE。最后别忘了不要让能量值超过能够存储的最大值。\n\n然后我们实现 transferEnergy 方法。\n\n能量的主动输出\n\n我们希望实现发电机和用电器相邻时传输能量的功能，但仅仅为两个机器实现能量相关的 Capability 是远远不够的：计算机程序不是物理定律，不会出现自然而然的能量流动，换言之，我们需要手写能量流动的相关代码。那么这段代码到底应该是“发电机主动输出能量”，还是“用电器主动吸收能量”呢？答案是显然的：我们应该让发电机控制能量的流动，因此，我们需要让我们的发电机对应的方块实体每 tick 自动搜寻附近的方块实体，并分别注入能量。\n\n我们现在来实现 transferEnergy 方法：\n\nprivate final Queue<Direction> directionQueue = Queues.newArrayDeque(Direction.Plane.HORIZONTAL);\n\nprivate void transferEnergy(@Nonnull World world)\n{\n    this.directionQueue.offer(this.directionQueue.remove());\n    for (Direction direction : this.directionQueue)\n    {\n        TileEntity tileEntity = world.getTileEntity(this.pos.offset(direction));\n        if (tileEntity != null)\n        {\n            tileEntity.getCapability(CapabilityEnergy.ENERGY, direction.getOpposite()).ifPresent(e ->\n            {\n                if (e.canReceive())\n                {\n                    int diff = e.receiveEnergy(Math.min(500, this.energy), false);\n                    if (diff != 0)\n                    {\n                        this.energy -= diff;\n                        this.markDirty();\n                    }\n                }\n            });\n        }\n    }\n}复制代码\n方法还是相对简单的：通过遍历水平方向的所有相邻方块，然后逐个注入能量，一次最多注入 500 FE。注意在获取相邻方块时，需要获取的是相反的方向（例如对于东侧的方块，注入能量时应该从该方块的西侧注入），也就是对 Direction 调用 getOpposite 方法并取其返回值。\n\n唯一可能令人费解的是这一行：\n\nthis.directionQueue.offer(this.directionQueue.remove());复制代码\n通过 directionQueue 字段的声明我们可以注意到，我们把该队列的第一个元素取出放到了最后一个元素的位置，这是为什么呢？\n\n我们思考一下如何不这么做会发生什么：\n\n首先找到北侧的方块并注入能量。然后找到东侧的方块并注入能量。接着找到南侧的方块并注入能量。最后找到西侧的方块并注入能量。\n\n我们可以注意到，如果只是平凡地遍历，那么北侧的方块将永远拥有最大的优先级。如果我们每 tick 只能产出 50 FE 能量，但北侧的方块一次可以吸收 200 FE 的能量，那势必会导致能量会全部被北侧的方块吸走。因此，我们为了雨露均沾，必须每次注入能量时人为调整能量的优先级。当然了，可以考虑的实现有很多，这里读者可以尽情地发挥自己的想象力。\n\n现在打开游戏，能量应能正常收集并传输了。\n\n\n\n\n\n\nimage-6.png (349.14 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n代码清单\n\n这一部分添加的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/block/FEDemoGeneratorBlock.javasrc/main/java/com/github/ustc_zzzz/fedemo/tileentity/FEDemoGeneratorTileEntity.javasrc/main/resources/assets/fedemo/blockstates/generator.jsonsrc/main/resources/assets/fedemo/models/block/generator.jsonsrc/main/resources/assets/fedemo/models/item/generator.jsonsrc/main/resources/assets/fedemo/textures/block/generator_top.png\n\n这一部分修改的文件有：\n\nsrc/main/resources/assets/fedemo/lang/en_us.json\n\n\n\n\n在这一讲和下一讲我们将制造一个作为导线的方块。\n\n这一讲我们将从作为方块的导线着手（换言之只是一个空壳子），而下一讲我们将着重介绍作为能量传输载体的导线。\n\n添加方块和方块实体\n\n以下是方块类的基础实现：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoWireBlock extends Block\n{\n    public static final String NAME = \"fedemo:wire\";\n\n    @ObjectHolder(NAME)\n    public static FEDemoWireBlock BLOCK;\n\n    @SubscribeEvent\n    public static void onRegisterBlock(@Nonnull RegistryEvent.Register<Block> event)\n    {\n        FEDemo.LOGGER.info(\"Registering wire block ...\");\n        event.getRegistry().register(new FEDemoWireBlock().setRegistryName(NAME));\n    }\n\n    @SubscribeEvent\n    public static void onRegisterItem(@Nonnull RegistryEvent.Register<Item> event)\n    {\n        FEDemo.LOGGER.info(\"Registering wire item ...\");\n        event.getRegistry().register(new BlockItem(BLOCK, new Item.Properties().group(ItemGroup.MISC)).setRegistryName(NAME));\n    }\n\n    private FEDemoWireBlock()\n    {\n        super(Block.Properties.create(Material.GLASS).hardnessAndResistance(2));\n    }\n\n    @Override\n    public boolean hasTileEntity(@Nonnull BlockState state)\n    {\n        return true;\n    }\n\n    @Override\n    public TileEntity createTileEntity(@Nonnull BlockState state, @Nonnull IBlockReader world)\n    {\n        return FEDemoWireTileEntity.TILE_ENTITY_TYPE.create();\n    }\n}复制代码\n以下是方块实体类的基础实现：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.MOD)\npublic class FEDemoWireTileEntity extends TileEntity\n{\n    public static final String NAME = \"fedemo:wire\";\n\n    @ObjectHolder(NAME)\n    public static TileEntityType<FEDemoWireTileEntity> TILE_ENTITY_TYPE;\n\n    @SubscribeEvent\n    public static void onRegisterTileEntityType(@Nonnull RegistryEvent.Register<TileEntityType<?>> event)\n    {\n        FEDemo.LOGGER.info(\"Registering wire tile entity type ...\");\n        event.getRegistry().register(TileEntityType.Builder.create(FEDemoWireTileEntity::new, FEDemoWireBlock.BLOCK).build(DSL.remainderType()).setRegistryName(NAME));\n    }\n\n    private FEDemoWireTileEntity()\n    {\n        super(TILE_ENTITY_TYPE);\n    }\n}复制代码\n我们还可以在 en_us,json 给方块起个名字：\n\n\"block.fedemo.wire\": \"FE Energy Transmission Conduit\"复制代码\n本讲接下来将不会涉及到方块实体的任何内容（放到下一讲进行）。\n\n方块状态\n\n由于导线在和周围连通时的状态会随着周边环境有所不同，因此我们需要为同一个导线指定不同的方块状态（BlockState）。每个方块状态都是特定属性（Property）和对应值的结合，我们需要声明导线在六个方向的连接状态，因此我们需要共六个描述方块状态属性。这六个属性都可以在 BlockStateProperties 类里找到，我们为这六个属性建立一个针对方向的映射表：\n\npublic static final Map<Direction, BooleanProperty> PROPERTY_MAP;\n\nstatic\n{\n    Map<Direction, BooleanProperty> map = Maps.newEnumMap(Direction.class);\n    map.put(Direction.NORTH, BlockStateProperties.NORTH);\n    map.put(Direction.EAST, BlockStateProperties.EAST);\n    map.put(Direction.SOUTH, BlockStateProperties.SOUTH);\n    map.put(Direction.WEST, BlockStateProperties.WEST);\n    map.put(Direction.UP, BlockStateProperties.UP);\n    map.put(Direction.DOWN, BlockStateProperties.DOWN);\n    PROPERTY_MAP = Collections.unmodifiableMap(map);\n}复制代码\n接下来我们需要覆盖 fillStateContainer 方法，用来声明该方块拥有以上全部六个属性：\n\n@Override\nprotected void fillStateContainer(@Nonnull StateContainer.Builder<Block, BlockState> builder)\n{\n    builder.add(PROPERTY_MAP.values().toArray(new IProperty<?>[0]));\n    super.fillStateContainer(builder);\n}复制代码\nStateContainer.Builder 的 add 方法需要传入变长参数，因此这里直接构造并传入了一个数组。\n\n接下来我们需要在特定场合自动调整方块状态，我们需要：\n\n在放置该方块时调整方块状态在该方块周围的方块发生变动时调整方块状态\n\n前者对应 getStateForPlacement 方法，后者对应 updatePostPlacement 方法。我们覆盖这两个方法：\n\n@Override\npublic BlockState getStateForPlacement(@Nonnull BlockItemUseContext context)\n{\n    BlockState state = this.getDefaultState();\n    for (Direction facing : Direction.values())\n    {\n        World world = context.getWorld();\n        BlockPos facingPos = context.getPos().offset(facing);\n        BlockState facingState = world.getBlockState(facingPos);\n        state = state.with(PROPERTY_MAP.get(facing), this.canConnect(world, facing.getOpposite(), facingPos, facingState));\n    }\n    return state;\n}\n\n@Nonnull\n@Override\n@SuppressWarnings(\"deprecation\")\npublic BlockState updatePostPlacement(@Nonnull BlockState state, @Nonnull Direction facing, @Nonnull BlockState facingState, @Nonnull IWorld world, @Nonnull BlockPos pos, @Nonnull BlockPos facingPos)\n{\n    return state.with(PROPERTY_MAP.get(facing), this.canConnect(world, facing.getOpposite(), facingPos, facingState));\n}\n\nprivate boolean canConnect(@Nonnull IWorld world, @Nonnull Direction facing, @Nonnull BlockPos pos, @Nonnull BlockState state)\n{\n    return false; // TODO\n}复制代码\n前者我们需要对六个方向分别检查属性值，而后者我们只需要对受到影响的方向检查就可以了。\n\n我们对连接状态的检查主要分为两部分：\n\n检查连接的是不是我们的导线检查连接的方块是否有能量相关的 Capability\n\nprivate boolean canConnect(@Nonnull IWorld world, @Nonnull Direction facing, @Nonnull BlockPos pos, @Nonnull BlockState state)\n{\n    if (!state.getBlock().equals(BLOCK))\n    {\n        TileEntity tileEntity = world.getTileEntity(pos);\n        return tileEntity != null && tileEntity.getCapability(CapabilityEnergy.ENERGY, facing).isPresent();\n    }\n    return true;\n}复制代码\n方块材质\n\n如果考虑所有的方块状态，一个导线甚至能够有多达 64 个方块状态。如果我们为每一个方块状态都指定一次材质和模型，那这注定会带来很大的工作量。\n\n不过，原版 Minecraft 提供了 multipart 机制，能够让我们为每个属性指定独有的一部分模型和材质，然后将每个属性所指定的拼合起来。\n\n以下是我们的整个方块状态 JSON：\n\n{\n  \"multipart\": [\n    {\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_core\"\n      }\n    },\n    {\n      \"when\": {\n        \"north\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\"\n      }\n    },\n    {\n      \"when\": {\n        \"east\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\",\n        \"y\": 90\n      }\n    },\n    {\n      \"when\": {\n        \"south\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\",\n        \"y\": 180\n      }\n    },\n    {\n      \"when\": {\n        \"west\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\",\n        \"y\": 270\n      }\n    },\n    {\n      \"when\": {\n        \"up\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\",\n        \"x\": 270\n      }\n    },\n    {\n      \"when\": {\n        \"down\": \"true\"\n      },\n      \"apply\": {\n        \"model\": \"fedemo:block/wire_part\",\n        \"x\": 90\n      }\n    }\n  ]\n}复制代码\n我们的核心位于 fedemo:block/wire_core，这是无论什么方块状态都会有的。我们为每个属性都指定了 fedemo:block/wire_part，在特定方向的连接存在时提供相应的模型和材质。\n\n不同的连接方向属性所引用的 JSON 是相同的，但旋转方向有细微的差别（注意是顺时针）：\n\nnorth 为默认，也就是不旋转。east 沿 Y 轴顺时针旋转 90 度。south 沿 Y 轴顺时针旋转 180 度。west 沿 Y 轴顺时针旋转 270 度。up 沿 X 轴顺时针旋转 270 度。down 沿 X 轴顺时针旋转 90 度。\n\n现在我们需要制作一个代表核心的 wire_core.json：\n\n{\n  \"parent\": \"block/block\",\n  \"ambientocclusion\": false,\n  \"textures\": {\n    \"wire\": \"fedemo:block/wire_core_part\",\n    \"particle\": \"fedemo:block/wire_core_part\"\n  },\n  \"elements\": [\n    {\n      \"from\": [5, 5, 5],\n      \"to\": [11, 11, 11],\n      \"faces\": {\n        \"north\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        },\n        \"east\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        },\n        \"south\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        },\n        \"west\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        },\n        \"up\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        },\n        \"down\": {\n          \"uv\": [7, 7, 13, 13],\n          \"texture\": \"#wire\"\n        }\n      }\n    }\n  ]\n}复制代码\n和一个代表连接状态的 wire_part.json：\n\n{\n  \"ambientocclusion\": false,\n  \"textures\": {\n    \"wire\": \"fedemo:block/wire_core_part\",\n    \"particle\": \"fedemo:block/wire_core_part\"\n  },\n  \"elements\": [\n    {\n      \"from\": [6, 6, 0],\n      \"to\": [10, 10, 7],\n      \"faces\": {\n        \"north\": {\n          \"uv\": [3, 3, 7, 7],\n          \"texture\": \"#wire\"\n        },\n        \"east\": {\n          \"uv\": [6, 3, 13, 7],\n          \"texture\": \"#wire\"\n        },\n        \"west\": {\n          \"uv\": [6, 3, 13, 7],\n          \"texture\": \"#wire\"\n        },\n        \"up\": {\n          \"uv\": [3, 6, 7, 13],\n          \"texture\": \"#wire\"\n        },\n        \"down\": {\n          \"uv\": [3, 6, 7, 13],\n          \"texture\": \"#wire\"\n        }\n      }\n    }\n  ]\n}复制代码\n两个 JSON 引用的是同一个材质（见下图 wire_core_part.png）：\n\n\n\n\n\n\nimage-7.png (41.99 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n最后别忘了添加描述物品材质的 JSON：\n\n{\n  \"parent\": \"fedemo:block/wire_core\"\n}复制代码\n现在我们可以打开游戏看看效果了：\n\n\n\n\n\n\nimage-8.png (204.15 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n方块碰撞箱和选择框\n\n由于导线是不完整方块，因此我们需要指定方块的碰撞箱和选择框的形态。\n\n我们先从碰撞箱开始，我们需要覆盖 getCollisionShape 方法：\n\n@Nonnull\n@Override\n@SuppressWarnings(\"deprecation\")\npublic VoxelShape getCollisionShape(@Nonnull BlockState state, @Nonnull IBlockReader world, @Nonnull BlockPos pos, @Nonnull ISelectionContext context)\n{\n    return VoxelShapes.empty();\n}复制代码\n这里设置的是没有碰撞箱，读者也可以根据自己的喜好设置成其他的碰撞箱。\n\n然后是选择框，我们在这里这里需要覆盖 getShape 方法：\n\n@Nonnull\n@Override\n@SuppressWarnings(\"deprecation\")\npublic VoxelShape getShape(@Nonnull BlockState state, @Nonnull IBlockReader world, @Nonnull BlockPos pos, @Nonnull ISelectionContext context)\n{\n    return Block.makeCuboidShape(4, 4, 4, 12, 12, 12);\n}复制代码\n我们已经在第二讲接触过碰撞箱的相关内容了，这里的设置大同小异。\n\n这里设置的选择框比导线核心大了一圈，现在可以打开游戏看看了。\n\n\n\n\n\n\nimage-9.png (218.67 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n代码清单\n\n这一部分添加的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/block/FEDemoWireBlock.javasrc/main/java/com/github/ustc_zzzz/fedemo/tileentity/FEDemoWireTileEntity.javasrc/main/resources/assets/fedemo/blockstates/wire.jsonsrc/main/resources/assets/fedemo/models/block/wire_core.jsonsrc/main/resources/assets/fedemo/models/block/wire_part.jsonsrc/main/resources/assets/fedemo/models/item/wire.jsonsrc/main/resources/assets/fedemo/textures/block/wire_core_part.png\n\n这一部分修改的文件有：\n\nsrc/main/resources/assets/fedemo/lang/en_us.json\n\n\n\n\n欢迎来到整个系列教程中最难的一讲。本讲将侧重于介绍如何为传统意义上的导线实现能量传输。\n\n和现实世界不同，在游戏中实现传统意义上的导线，要比无线充电等其他实现方式困难得多。因此读者如果实在无法完整实现传统意义上的导线，那也可以退而求其次，去实现其他的能量传输形式。导线之外的能量传输形式往往也是会受到玩家欢迎的。\n\n导线连通网络\n\n一个最朴素的想法是让每根导线每 tick 都将附近导线的能量传输过来。实际上一些 Mod（比方说 RailCraft 等）也正是这么做的。\n\n但这样做无疑从游戏体验上就存在一个问题：如果是一根长长的导线，那么每 tick 能量自然只能传输一格，如果导线长达几百根，那毫无疑问需要数秒甚至十多秒的时间才能将能量从一头传到另一头。如果考虑到游戏性能的话，问题更大了：所有的导线都需要每 tick 更新一次，那势必导致世界上每 tick 都更新的方块实体数量大大增加。\n\n所以，一个非常重要的原则就是：不要为代表导线的方块实体实现 ITickableTileEntity 接口。那我们应当什么时候执行导线相关的逻辑呢？\n\n部分 Mod 会为导线指定一个中心方块（比如说 AppliedEnergistics2 的 ME 控制器），这不失为一个好的选择：我们只需要为中心方块实现 ITickableTileEntity，并由它接管所有能量相关的逻辑即可。但是，我们需要实现的是传统意义上的导线，换言之，我们要实现的能量传输系统没有中心方块，对每一根导线而言，它们都是相互平等的。\n\n为了解决这一问题。我们必须为每个世界单独提供一个管理能量传输的导线连通网络，并且自动接管导线的通断相关逻辑。为了方便进一步的操作，我们可以从每一组互相连通的导线（又称一个连通域）中挑选一个代表方块，然后使用该方块代表整组导线。当然，导线的通断会导致一组导线分裂成两组，或是两组导线合并成一组，这些都是我们需要考虑的。\n\n我们现在将接口声明如下：\n\npublic interface IBlockNetwork\n{\n    int size(BlockPos node);\n\n    BlockPos root(BlockPos node);\n\n    void cut(BlockPos node, Direction direction, ConnectivityListener afterSplit);\n\n    void link(BlockPos node, Direction direction, ConnectivityListener beforeMerge);\n\n    @FunctionalInterface\n    interface ConnectivityListener\n    {\n        void onChange(BlockPos primaryNode, BlockPos secondaryNode);\n    }\n}复制代码\nsize 返回的是导线所处连通域含有的导线数量，如果导线没有和其他导线连通，那么返回值为 1。root 返回的是导线所处连通域的代表导线，也有可能是该导线自身（比方说未和其他导线连通的时候）。cut 指将某根导线的某个方向切断。切断导线如果会导致一个连通域分裂成两个，那么会在分裂后调用 afterSplit 的相关方法。link 指将某根导线在某个方向上实施连接。连接导线如果会导致两个连通域合并为一个，那么会在合并前调用 beforeMerge 的相关方法。onChange 方法将在连通域发生变化时调用，其中第一个参数是主连通域（其代表导线不会发生变化），而第二个参数是次连通域（会由于合并而消失，或由于分裂而新出现）。\n\n如何实现这个接口呢？本讲将提供相对简单直观的实现，该实现可以达到 O(N) 的时间复杂度。高效的实现可以做到多项式对数级（O(polylog N)）的时间复杂度，但过于复杂：感兴趣的读者可以通过阅读 Wikipedia（英文页面）加以了解。\n\n实现的思路很简单：除了维护所有连接外，我们只需要对每个方块维护一个连通域的相关集合就好了，而集合的第一个元素自然便是连通域的代表方块：\n\npublic class SimpleBlockNetwork implements IBlockNetwork\n{\n    private final Map<BlockPos, Set<BlockPos>> components;\n    private final SetMultimap<BlockPos, Direction> connections;\n\n    public SimpleBlockNetwork()\n    {\n        this.components = Maps.newHashMap();\n        this.connections = Multimaps.newSetMultimap(Maps.newHashMap(), () -> EnumSet.noneOf(Direction.class));\n    }\n\n    @Override\n    public int size(BlockPos node)\n    {\n        return 1; // TODO\n    }\n\n    @Override\n    public BlockPos root(BlockPos node)\n    {\n        return node; // TODO\n    }\n\n    @Override\n    public void cut(BlockPos node, Direction direction, ConnectivityListener afterSplit)\n    {\n        // TODO\n    }\n\n    @Override\n    public void link(BlockPos node, Direction direction, ConnectivityListener beforeMerge)\n    {\n        // TODO\n    }\n}复制代码\n上面的代码中，components 自然是方块到连通域（Set<BlockPos>）的映射，而 connections 中存储着所有连接。\n\n我们先从 size 和 root 方法的实现开始：\n\n@Override\npublic int size(BlockPos node)\n{\n    return this.components.containsKey(node) ? this.components.get(node).size() : 1;\n}\n\n@Override\npublic BlockPos root(BlockPos node)\n{\n    return this.components.containsKey(node) ? this.components.get(node).iterator().next() : node.toImmutable();\n}复制代码\n两个实现都十分直观，且都考虑到了有连通域和无连通域的情况。唯一需要注意的是我们需要 toImmutable 方法把 BlockPos 转为不可变的，这样后续我们才能将相应 BlockPos 直接存入 Set 或 Map 中。\n\n接下来我们实现 cut 和 link 两个方法。\n\n导线连通域的合并\n\n我们再来实现 link 方法：\n\n@Override\npublic void link(BlockPos node, Direction direction, ConnectivityListener beforeMerge)\n{\n    BlockPos secondary = node.toImmutable();\n    if (this.connections.put(secondary, direction))\n    {\n        BlockPos primary = node.offset(direction);\n        this.connections.put(primary, direction.getOpposite());\n        Set<BlockPos> primaryComponent = this.components.get(primary);\n        Set<BlockPos> secondaryComponent = this.components.get(secondary);\n        if (primaryComponent == null && secondaryComponent == null)\n        {\n            Set<BlockPos> union = Sets.newLinkedHashSet();\n            beforeMerge.onChange(secondary, primary);\n            this.components.put(secondary, union);\n            this.components.put(primary, union);\n            union.add(secondary);\n            union.add(primary);\n        }\n        else if (primaryComponent == null)\n        {\n            beforeMerge.onChange(secondaryComponent.iterator().next(), primary);\n            this.components.put(primary, secondaryComponent);\n            secondaryComponent.add(primary);\n        }\n        else if (secondaryComponent == null)\n        {\n            beforeMerge.onChange(primaryComponent.iterator().next(), secondary);\n            this.components.put(secondary, primaryComponent);\n            primaryComponent.add(secondary);\n        }\n        else if (primaryComponent != secondaryComponent)\n        {\n            beforeMerge.onChange(primaryComponent.iterator().next(), secondaryComponent.iterator().next());\n            Set<BlockPos> union = Sets.newLinkedHashSet(Sets.union(primaryComponent, secondaryComponent));\n            union.forEach(pos -> this.components.put(pos, union));\n        }\n    }\n}复制代码\n我们一段一段地来分析：\n\nBlockPos secondary = node.toImmutable();\nif (this.connections.put(secondary, direction))复制代码\n这一段是将 BlockPos 和对应 Direction 添加到 connections 中，如果在这之前 connections 中并不存在该连接，那么 put 方法将返回 true，如果不存在，那么自然就没有进行下一步的意义了。\n\nBlockPos primary = node.offset(direction);\nthis.connections.put(primary, direction.getOpposite());复制代码\n如果连接不存在的话，那么我们还需要找到连接到的 BlockPos，为其相反方向添加连接。\n\nSet<BlockPos> primaryComponent = this.components.get(primary);\nSet<BlockPos> secondaryComponent = this.components.get(secondary);复制代码\n我们试图获取两个 BlockPos 所处的连通域，至此我们需要分三种情况：\n\n两个连通域都不存在，那我们需要新创建一个连通域，然后把两个 BlockPos 加上去。一个连通域存在，另一个不存在，那我们需要把对应的 BlockPos 加到相应的连通域中。两个连通域都存在，那如果它们不相同，我们需要把两个连通域相互合并，然后应用到所有相关节点上去。\n\nif (primaryComponent == null && secondaryComponent == null)\n{\n    Set<BlockPos> union = Sets.newLinkedHashSet();\n    beforeMerge.onChange(secondary, primary);\n    this.components.put(secondary, union);\n    this.components.put(primary, union);\n    union.add(secondary);\n    union.add(primary);\n}复制代码\n这对应两个连通域都不存在的情况：创建一个新连通域（union），然后把两个 BlockPos 加上去。别忘了调用 beforeMerge 的相关方法。\n\nelse if (primaryComponent == null)\n{\n    beforeMerge.onChange(secondaryComponent.iterator().next(), primary);\n    this.components.put(primary, secondaryComponent);\n    secondaryComponent.add(primary);\n}复制代码\n这对应第一个连通域不存在而第二个存在的情况，我们需要把第一个 BlockPos 加上去。\n\nelse if (secondaryComponent == null)\n{\n    beforeMerge.onChange(primaryComponent.iterator().next(), secondary);\n    this.components.put(secondary, primaryComponent);\n    primaryComponent.add(secondary);\n}复制代码\n这对应第一个连通域存在而第二个不存在的情况，我们需要把第二个 BlockPos 加上去。\n\nelse if (primaryComponent != secondaryComponent)\n{\n    beforeMerge.onChange(primaryComponent.iterator().next(), secondaryComponent.iterator().next());\n    Set<BlockPos> union = Sets.newLinkedHashSet(Sets.union(primaryComponent, secondaryComponent));\n    union.forEach(pos -> this.components.put(pos, union));\n}复制代码\n这对应两个连通域都存在且不相同的情况，我们需要创建一个连通域把两个连通域合并到一起，然后应用到两个连通域中的所有节点上。\n\n最后我们注意到，只有两种情况下我们不会调用 beforeMerge 的 onChange 方法：\n\n试图添加的连接已存在。添加了连接同一个连通域的连接。\n\n导线连通域的分裂\n\n最后我们实现 cut 方法。cut 方法是整个接口中最难实现的一个，因此在动手写代码时，我们首先需要了解相关原理。\n\n我们知道删除某个连接有可能将一个连通域分裂成两半，也有可能不会为一个连通域带来变化。为了检查这两件事，我们需要从被删除的连接所对应的两个 BlockPos 开始，分别进行广度优先搜索，并在以下两个条件中的任何一个达成时同时终止搜索：\n\n当一方搜索到的某个节点已经在另一方搜索到的节点列表中，则代表连通域并未分裂。当一方已经遍历了所有能够遍历的节点，则代表连通域已被分裂为两半，搜索完成的一方代表其中的一半。\n\n为此，我们需要首先实现一个基于广度优先搜索的 Iterator：\n\npublic class BFSIterator implements Iterator<BlockPos>\n{\n    private final Set<BlockPos> searched = Sets.newLinkedHashSet();\n    private final Queue<BlockPos> queue = Queues.newArrayDeque();\n\n    public BFSIterator(BlockPos node)\n    {\n        node = node.toImmutable();\n        this.searched.add(node);\n        this.queue.offer(node);\n    }\n\n    @Override\n    public boolean hasNext()\n    {\n        return this.queue.size() > 0;\n    }\n\n    @Override\n    public BlockPos next()\n    {\n        BlockPos node = this.queue.remove();\n        for (Direction direction : SimpleBlockNetwork.this.connections.get(node))\n        {\n            BlockPos another = node.offset(direction);\n            if (this.searched.add(another))\n            {\n                this.queue.offer(another);\n            }\n        }\n        return node;\n    }\n\n    public Set<BlockPos> getSearched()\n    {\n        return this.searched;\n    }\n}复制代码\n广度优先搜索的实现很简单，上面的代码也很清晰，这里就不展开讲解了。\n\n接下来我们使用 BFSIterator 实现 cut 方法：\n\n@Override\npublic void cut(BlockPos node, Direction direction, ConnectivityListener afterSplit)\n{\n    if (this.connections.remove(node, direction))\n    {\n        BlockPos another = node.offset(direction);\n        this.connections.remove(another, direction.getOpposite());\n        BFSIterator nodeIterator = new BFSIterator(node), anotherIterator = new BFSIterator(another);\n        while (nodeIterator.hasNext())\n        {\n            BlockPos next = nodeIterator.next();\n            if (!anotherIterator.getSearched().contains(next))\n            {\n                BFSIterator iterator = anotherIterator;\n                anotherIterator = nodeIterator;\n                nodeIterator = iterator;\n                continue;\n            }\n            return;\n        }\n        Set<BlockPos> primaryComponent = this.components.get(node), secondaryComponent;\n        BlockPos primaryNode = primaryComponent.iterator().next();\n        Set<BlockPos> searched = nodeIterator.getSearched();\n        if (searched.contains(primaryNode))\n        {\n            secondaryComponent = Sets.newLinkedHashSet(Sets.difference(primaryComponent, searched));\n            primaryComponent.retainAll(searched);\n        }\n        else\n        {\n            secondaryComponent = searched;\n            primaryComponent.removeAll(searched);\n        }\n        if (secondaryComponent.size() <= 1)\n        {\n            secondaryComponent.forEach(this.components::remove);\n        }\n        else\n        {\n            secondaryComponent.forEach(pos -> this.components.put(pos, secondaryComponent));\n        }\n        if (primaryComponent.size() <= 1)\n        {\n            primaryComponent.forEach(this.components::remove);\n        }\n        afterSplit.onChange(primaryNode, secondaryComponent.iterator().next());\n    }\n}复制代码\n我们在这里还是一段一段地讲解：\n\nif (this.connections.remove(node, direction))复制代码\n这里将移除对应边，如果对应边在移除前存在，那么该方法返回 true。\n\nBlockPos another = node.offset(direction);\nthis.connections.remove(another, direction.getOpposite());复制代码\n如果连接存在的话，那么我们还需要找到连接到的 BlockPos，为其相反方向删除连接。\n\nBFSIterator nodeIterator = new BFSIterator(node), anotherIterator = new BFSIterator(another);\nwhile (nodeIterator.hasNext())\n{\n    BlockPos next = nodeIterator.next();\n    if (!anotherIterator.getSearched().contains(next))\n    {\n        BFSIterator iterator = anotherIterator;\n        anotherIterator = nodeIterator;\n        nodeIterator = iterator;\n        continue;\n    }\n    return;\n}复制代码\n然后我们为两边的 BlockPos 分别创立 BFSIterator，轮流实施迭代过程。\n\n若当前 BFSIterator 已遍历完所有能够遍历得到的 BlockPos（hasNext 为 false）则循环结束。否则，如果另一个 BFSIterator 包含当前节点，那说明它们仍然在同一个连通域，直接 return。最后，如果另一个 BFSIterator 不包含当前节点，那么把两个节点相交换，继续循环过程。\n\nSet<BlockPos> primaryComponent = this.components.get(node), secondaryComponent;\nBlockPos primaryNode = primaryComponent.iterator().next();\nSet<BlockPos> searched = nodeIterator.getSearched();\nif (searched.contains(primaryNode))\n{\n    secondaryComponent = Sets.newLinkedHashSet(Sets.difference(primaryComponent, searched));\n    primaryComponent.retainAll(searched);\n}\nelse\n{\n    secondaryComponent = searched;\n    primaryComponent.removeAll(searched);\n}复制代码\n如果我们证实我们的连通域会分裂成两半，并且已经搜索到了其中一半（searched），那么接下来我们需要定主连通域和次连通域。主连通域自然是当前节点所在连通域，但我们刚刚遍历收集到的，到底是不是主连通域呢？我们需要 searched.contains(primaryNode) 这一表达式加以判断：\n\n如果是（返回 true），那么我们需要构造一个未遍历到的 BlockPos 集合作为次连通域，然后我们在主连通域中只保留归属于 searched 的 BlockPos（retainAll 方法）。如果不是（返回 false），那么我们可以直接将 searched 作为次连通域，然后把主连通域中已经从属于 searched 的 BlockPos 全去掉（removeAll 方法）。\n\nif (secondaryComponent.size() <= 1)\n{\n    secondaryComponent.forEach(this.components::remove);\n}\nelse\n{\n    secondaryComponent.forEach(pos -> this.components.put(pos, secondaryComponent));\n}\nif (primaryComponent.size() <= 1)\n{\n    primaryComponent.forEach(this.components::remove);\n}\nafterSplit.onChange(primaryNode, secondaryComponent.iterator().next());复制代码\n接下来就要把这两个集合应用到每一个从属于它们的 BlockPos 了。注意如果该连通域中只有一个 BlockPos，那么可以直接将其从 components 中删除。\n\n最后我们调用了 afterSplit 的 onChange 方法。\n\n导线能量网络\n\n我们现在可以基于连通网络实现能量网络了。除了连通网络外，我们还需要存储什么呢？\n\n每个连通域都会存储一定能量用于能量传输，因此我们需要为每个连通域存储这个。导线并不一定只连着导线，还可能连着机器，因此我们需要把所有和机器有关的连接单独储存。导线的连接和切断和能量存取会导致数据变化，因此我们需要记录所有变化的区块，从而保证它们能够保存进存档中。\n\n关于能量存储这里补充一点：我们只需要为每个连通域的代表方块存储能量值，而由于能量值一定是非负整数，因此这里使用 Multiset 将十分适合。\n\npublic class SimpleEnergyNetwork\n{\n    private final IWorld world;\n    private final IBlockNetwork blockNetwork;\n    private final Queue<Runnable> taskCollection;\n    private final Multiset<BlockPos> energyCollection;\n    private final SetMultimap<ChunkPos, BlockPos> chunkCollection;\n    private final SetMultimap<BlockPos, Direction> machineCollection;\n\n    private SimpleEnergyNetwork(IWorld world, IBlockNetwork blockNetwork)\n    {\n        this.world = world;\n        this.blockNetwork = blockNetwork;\n        this.taskCollection = Queues.newArrayDeque();\n        this.energyCollection = HashMultiset.create();\n        this.chunkCollection = Multimaps.newSetMultimap(Maps.newHashMap(), Sets::newHashSet);\n        this.machineCollection = Multimaps.newSetMultimap(Maps.newHashMap(), () -> EnumSet.noneOf(Direction.class));\n    }\n}复制代码\n除了上面提到的这些和 world 外，我们还额外添加了一个 taskCollection 字段，稍后我们监听 tick 事件时用得着。\n\n我们还需要考虑一个问题：刚刚我们提到过，我们的能量网络是相对于某个世界的，因此对于某个特定的世界而言，导线的能量数据是全局存储的，但我们应如何把数据放到存档里呢？以连通域为单位存储在这里显然不适合，因为连通域会合并和分裂，从而使得维护存档中导线和连通域之间的关系成为非常困难的工作（在内存中这很容易）。一个很不错的解决方案是：我们可以把能量放到导线里均摊储存，这样不管连通域如何合并和分裂，最终都将落实到每根导线和存档的交互上。为了实现这一解决方案，我们需要声明四个方法：\n\ngetNetworkSize：获取导线所处连通域的导线数量。getNetworkEnergy：获取导线所处连通域的整体能量。getSharedEnergy：获取导线所处连通域均摊到当前导线的能量。addEnergy：调整导线所处连通域的能量（正数为增加，负数为减少）。\n\n这四个方法的实现都非常简单。Guava 的 Multiset 和 Multimap 在实现上为我们带来了极大的方便：\n\npublic int getNetworkSize(BlockPos pos)\n{\n    return this.blockNetwork.size(pos);\n}\n\npublic int getNetworkEnergy(BlockPos pos)\n{\n    BlockPos root = this.blockNetwork.root(pos);\n    return this.energyCollection.count(root);\n}\n\npublic int getSharedEnergy(BlockPos pos)\n{\n    int size = this.blockNetwork.size(pos);\n    BlockPos root = this.blockNetwork.root(pos);\n    int total = this.energyCollection.count(root);\n    return root.equals(pos) ? total / size + total % size : total / size;\n}\n\npublic void addEnergy(BlockPos pos, int diff)\n{\n    if (diff >= 0)\n    {\n        this.energyCollection.add(this.blockNetwork.root(pos), diff);\n    }\n    else\n    {\n        this.energyCollection.remove(this.blockNetwork.root(pos), -diff);\n    }\n}复制代码\n这里唯一需要指出的是能量的分摊方式，也就是在整体能量除以连通域导线数量除不开的时候，问题是如何解决的：\n\n如果当前导线是连通域的代表导线，那么把余数都分摊到该导线上。如果当前导线不是连通域的代表导线，那么照常除就可以了，不必考虑余数。\n\n在 tick 事件中增删导线\n\n我们现在声明用于删除导线的 disableBlock 方法，和用于添加导线的 enableBlock 方法。但是，这两个方法的实现并没有那么直接，因为我们需要把相关行为托管到 tick 事件中执行。\n\n为什么我们不能立刻增删导线？这是因为在增删导线的时候，我们需要检查导线和周围方块的连通性，而很多时候导线是在世界加载阶段加载的，因此如果在世界加载时获取周围方块的相关信息，将会极易导致死锁。因此我们需要把增删导线的相关逻辑放到 tick 事件中，这正是 taskCollection 字段的存在意义。\n\npublic void disableBlock(BlockPos pos, Runnable callback)\n{\n    this.taskCollection.offer(() ->\n    {\n        // TODO\n        callback.run();\n    });\n}\n\npublic void enableBlock(BlockPos pos, Runnable callback)\n{\n    this.taskCollection.offer(() ->\n    {\n        // TODO\n        callback.run();\n    });\n}\n\nprivate void tickStart()\n{\n    for (Runnable runnable = this.taskCollection.poll(); runnable != null; runnable = this.taskCollection.poll())\n    {\n        runnable.run();\n    }\n}复制代码\n我们为 disableBlock 和 enableBlock 两个方法添加了 Runnable 作为回调函数，并在 tickStart 方法调用时调用。我们稍后便会在 tick 事件的监听器里调用 tickStart 方法。\n\n向能量网络增删导线\n\n我们先来实现删除导线：\n\npublic void disableBlock(BlockPos pos, Runnable callback)\n{\n    this.taskCollection.offer(() ->\n    {\n        this.chunkCollection.remove(new ChunkPos(pos), pos);\n        for (Direction side : Direction.values())\n        {\n            this.blockNetwork.cut(pos, side, this::afterSplit);\n        }\n        this.machineCollection.removeAll(pos);\n        callback.run();\n    });\n}\n\nprivate void afterSplit(BlockPos primaryNode, BlockPos secondaryNode)\n{\n    int primarySize = this.blockNetwork.size(primaryNode), secondarySize = this.blockNetwork.size(secondaryNode);\n    int diff = this.energyCollection.count(primaryNode) * secondarySize / (primarySize + secondarySize);\n    this.energyCollection.remove(primaryNode, diff);\n    this.energyCollection.add(secondaryNode, diff);\n}复制代码\n除了调用回调函数外，删除导线主要做三件事：\n\n记录导线所归属的区块。切断导线在六个方向的所有连接。切断导线在所有方向上和机器的连接。\n\n切断导线连接时需要传入 ConnectivityListener，这里声明并实现了 afterSplit 方法，并传入方法引用作为实现。afterSplit 方法所做的事很简单：把当前连通域的整体能量按所拥有的导线数量分离一部分出来给一个新的连通域。\n\n然后我们再来实现添加导线：\n\npublic void enableBlock(BlockPos pos, Runnable callback)\n{\n    this.taskCollection.offer(() ->\n    {\n        this.chunkCollection.put(new ChunkPos(pos), pos.toImmutable());\n        for (Direction side : Direction.values())\n        {\n            if (this.hasWireConnection(pos, side))\n            {\n                if (this.hasWireConnection(pos.offset(side), side.getOpposite()))\n                {\n                    this.machineCollection.remove(pos, side);\n                    this.blockNetwork.link(pos, side, this::beforeMerge);\n                }\n                else\n                {\n                    this.machineCollection.put(pos.toImmutable(), side);\n                    this.blockNetwork.cut(pos, side, this::afterSplit);\n                }\n            }\n            else\n            {\n                this.machineCollection.remove(pos, side);\n                this.blockNetwork.cut(pos, side, this::afterSplit);\n            }\n        }\n        callback.run();\n    });\n}\n\nprivate boolean hasWireConnection(BlockPos pos, Direction side)\n{\n    return false; // TODO\n}\n\nprivate void beforeMerge(BlockPos primaryNode, BlockPos secondaryNode)\n{\n    int diff = this.energyCollection.count(secondaryNode);\n    this.energyCollection.remove(secondaryNode, diff);\n    this.energyCollection.add(primaryNode, diff);\n}复制代码\n除了调用回调函数外，添加导线主要做的也是三件事：\n\n记录导线所归属的区块。添加导线和其他导线之间的连接。添加导线和机器的连接。\n\n和删除导线相比，添加导线还需要检查周围方块是否能够与其相互连接，因此实现会稍加复杂：\n\n如果导线在某个方向上不和相邻方块连接，那自然既不考虑连通网络，也不考虑机器了。如果导线在某个方向上和相邻方块连接，且连接的方块是在相反方向上连接的导线，那么将该导线添加到连通网络。如果导线在某个方向上和相邻方块连接，且连接的方块不是在相反方向上连接的导线，那么将该导线连接的方块视为机器。\n\n我们现在实现 hasWireConnection 方法：\n\n@SuppressWarnings(\"deprecation\")\nprivate boolean hasWireConnection(BlockPos pos, Direction side)\n{\n    if (this.world.isBlockLoaded(pos))\n    {\n        BlockState state = this.world.getBlockState(pos);\n        return state.getBlock().equals(FEDemoWireBlock.BLOCK) && state.get(FEDemoWireBlock.PROPERTY_MAP.get(side));\n    }\n    return false;\n}复制代码\n这里需要额外注意 isBlockLoaded 方法的调用。如果我们不事先进行 isBlockLoaded 这一检查，那么 getBlockState 方法在检查未加载的方块坐标时，将会自动将该方块坐标所处的区块予以加载，而加载会导致连接状态的变化，因此如果世界上有一长链导线，这会导致途径的所有区块全部加载，这显然是没有必要的。更为重要的是，游戏会在加载区块后试图卸载不必要的区块，而卸载区块同样会导致连接状态的变化，这一变化又会反过来加载区块，因此区块会不断地在加载和卸载之间循环，这显然会带来不必要的性能损失。稍后我们会在其他方法再次调用 isBlockLoaded 方法进行方块是否已加载的检查。\n\n增删导线的逻辑到这里就彻底写完了。接下来我们要写另一处需要在 tick 事件中执行的逻辑。\n\n在 tick 事件中输送能量\n\n在编写发电机的时候我们曾经提到，能量的流动应由发电机控制，而发电机实现了 ITickableTileEntity 接口，因此可以在实现该接口的 tick 方法时输送能量。刚刚我们提到，导线能量网络是以世界为单位的，因此我们同样需要监听世界的 tick 事件完成这件事。我们把这一行为写进 tickEnd 方法：\n\n@SuppressWarnings(\"deprecation\")\nprivate void tickEnd()\n{\n    for (Map.Entry<BlockPos, Direction> entry : this.shuffled(this.machineCollection.entries()))\n    {\n        Direction direction = entry.getValue();\n        BlockPos node = entry.getKey(), root = this.blockNetwork.root(node);\n        if (this.world.isBlockLoaded(node.offset(direction)))\n        {\n            TileEntity tileEntity = this.world.getTileEntity(node.offset(direction));\n            if (tileEntity != null)\n            {\n                tileEntity.getCapability(CapabilityEnergy.ENERGY, direction.getOpposite()).ifPresent(e ->\n                {\n                    if (e.canReceive())\n                    {\n                        int diff = this.energyCollection.count(root);\n                        this.energyCollection.remove(root, e.receiveEnergy(diff, false));\n                    }\n                });\n            }\n        }\n    }\n}\n\nprivate <T> List<T> shuffled(Iterable<? extends T> iterable)\n{\n    List<T> list = Lists.newArrayList(iterable);\n    Random rand = this.world.getRandom();\n    Collections.shuffle(list, rand);\n    return list;\n}复制代码\n该方法的实现很简单：遍历所有的机器（在遍历前打乱了一遍次序），然后如果机器可以接收能量，那么便向其输送能量。注意 isBlockLoaded 方法的调用，因为我们并不希望向未加载的区块中的方块实体输送能量。\n\n标记需要保存的区块\n\n我们需要在保存存档的时候标记所有需要保存的区块。我们声明一个 markDirty 方法，并在该方法内部实现相应的逻辑：\n\n@SuppressWarnings(\"deprecation\")\nprivate void markDirty()\n{\n    for (ChunkPos chunkPos : this.chunkCollection.keys())\n    {\n        BlockPos pos = chunkPos.asBlockPos();\n        if (this.world.isBlockLoaded(pos))\n        {\n            this.world.getChunk(pos).setModified(true);\n        }\n    }\n}复制代码\n稍后我们会监听保存世界存档的事件，然后调用这一方法。\n\n导线能量网络的管理\n\n我们需要一个全局化的管理类，我们决定让它成为 SimpleEnergyNetwork 的嵌套类：\n\n@Mod.EventBusSubscriber(bus = Mod.EventBusSubscriber.Bus.FORGE)\npublic static class Factory\n{\n    private static final Map<IWorld, SimpleEnergyNetwork> INSTANCES = Maps.newIdentityHashMap();\n\n    public static SimpleEnergyNetwork get(IWorld world)\n    {\n        return INSTANCES.computeIfAbsent(world, k -> new SimpleEnergyNetwork(k, new SimpleBlockNetwork()));\n    }\n\n    @SubscribeEvent\n    public static void onSave(WorldEvent.Save event)\n    {\n        if (INSTANCES.containsKey(event.getWorld()))\n        {\n            INSTANCES.get(event.getWorld()).markDirty();\n        }\n    }\n\n    @SubscribeEvent\n    public static void onUnload(WorldEvent.Unload event)\n    {\n        INSTANCES.remove(event.getWorld());\n    }\n\n    @SubscribeEvent\n    public static void onWorldTick(TickEvent.WorldTickEvent event)\n    {\n        if (LogicalSide.SERVER.equals(event.side))\n        {\n            switch (event.phase)\n            {\n                case START:\n                {\n                    Factory.get(event.world).tickStart();\n                    break;\n                }\n                case END:\n                {\n                    Factory.get(event.world).tickEnd();\n                    break;\n                }\n            }\n        }\n    }\n}复制代码\n该类提供了构造并返回 SimpleEnergyNetwork 方法，并且有三个事件监听器：\n\n在世界开始保存存档时调用 markDirty 方法。在世界准备卸载时移除已经持有的 SimpleEnergyNetwork 实例。在世界的 tick 事件触发时调用 tickStart 和 tickEnd 方法。\n\n到这里，整个 SimpleEnergyNetwork，就完全实现完了，我们稍后会在导线的方块实体类里调用里面的相关方法。\n\n为导线实现 Capability\n\n我们现在为代表导线的方块实体添加 Capability：\n\nprivate final LazyOptional<IEnergyStorage> lazyOptional = LazyOptional.of(() -> new IEnergyStorage()\n{\n    private final SimpleEnergyNetwork network = SimpleEnergyNetwork.Factory.get(FEDemoWireTileEntity.this.world);\n\n    @Override\n    public int receiveEnergy(int maxReceive, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(500, Math.min(this.getMaxEnergyStored() - energy, maxReceive));\n        if (!simulate)\n        {\n            this.network.addEnergy(FEDemoWireTileEntity.this.pos, diff);\n            if (diff != 0)\n            {\n                FEDemoWireTileEntity.this.markDirty();\n            }\n        }\n        return diff;\n    }\n\n    @Override\n    public int extractEnergy(int maxExtract, boolean simulate)\n    {\n        int energy = this.getEnergyStored();\n        int diff = Math.min(500, Math.min(energy, maxExtract));\n        if (!simulate)\n        {\n            this.network.addEnergy(FEDemoWireTileEntity.this.pos, -diff);\n            if (diff != 0)\n            {\n                FEDemoWireTileEntity.this.markDirty();\n            }\n        }\n        return diff;\n    }\n\n    @Override\n    public int getEnergyStored()\n    {\n        return Math.min(this.getMaxEnergyStored(), this.network.getNetworkEnergy(FEDemoWireTileEntity.this.pos));\n    }\n\n    @Override\n    public int getMaxEnergyStored()\n    {\n        return 1_000 * this.network.getNetworkSize(FEDemoWireTileEntity.this.pos);\n    }\n\n    @Override\n    public boolean canExtract()\n    {\n        return true;\n    }\n\n    @Override\n    public boolean canReceive()\n    {\n        return true;\n    }\n});\n\n@Nonnull\n@Override\npublic <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, Direction side)\n{\n    boolean isEnergy = Objects.equals(cap, CapabilityEnergy.ENERGY);\n    return isEnergy ? this.lazyOptional.cast() : super.getCapability(cap, side);\n}复制代码\n由于导线既可以输入能量，也可以输出能量，因此 canExtract 和 canReceive 都应返回 true，剩下的实现和之前的发电机和用电器都大同小异，这里就不展开了。\n\n导线本身的加载与卸载\n\nMinecraft 原版和 Forge 共为 TileEntity 提供了三个方法用于描述方块实体的加载和卸载过程：\n\nonLoad 方法将在方块实体加载时（包括手动放置对应方块和以及区块加载）触发。onChunkUnloaded 方法将在方块实体所在区块被卸载时触发。remove 方法将在方块实体被拆除时触发。\n\n我们还需要覆盖读取 NBT 里会调用的 read 方法和写入 NBT 时会调用的 write 方法。我们先实现这两个方法：\n\nprivate Integer tmpEnergy = null;\n\n@Override\npublic void read(@Nonnull CompoundNBT compound)\n{\n    this.tmpEnergy = compound.getInt(\"WireEnergy\");\n    super.read(compound);\n}\n\n@Nonnull\n@Override\npublic CompoundNBT write(@Nonnull CompoundNBT compound)\n{\n    SimpleEnergyNetwork network = SimpleEnergyNetwork.Factory.get(this.world);\n    compound.putInt(\"WireEnergy\", network.getSharedEnergy(this.pos));\n    return super.write(compound);\n}复制代码\n我们可以注意到一件事：write 方法是直接从导线能量网络里获取均摊能量，而 read 方法却写入到了一个临时值，为什么要这样做？这是因为，read 方法第一次调用的时机特别特别早，甚至方块实体还没有被加载到世界中，因此我们甚至连方块实体所处的世界都无法获取得到，更逞论获取导线能量网络中的均摊能量了。因此，我们只能先写入一个临时值，然后在 onLoad 方法里读取这个临时值：\n\n@Override\npublic void onLoad()\n{\n    if (this.world != null && !this.world.isRemote)\n    {\n        SimpleEnergyNetwork network = SimpleEnergyNetwork.Factory.get(this.world);\n        if (this.tmpEnergy != null)\n        {\n            int diff = this.tmpEnergy - network.getSharedEnergy(this.pos);\n            network.addEnergy(this.pos, diff);\n            this.tmpEnergy = null;\n        }\n        network.enableBlock(this.pos, this::markDirty);\n    }\n    super.onLoad();\n}复制代码\n注意该方法设置能量的方式：通过添加差额能量的方式设置。\n\n最后我们还剩下 onChunkUnloaded 和 remove 两个方法。我们现在实现这两个方法：\n\n@Override\npublic void onChunkUnloaded()\n{\n    if (this.world != null && !this.world.isRemote)\n    {\n        SimpleEnergyNetwork network = SimpleEnergyNetwork.Factory.get(this.world);\n        network.disableBlock(this.pos, this::markDirty);\n    }\n    super.onChunkUnloaded();\n}\n\n@Override\npublic void remove()\n{\n    if (this.world != null && !this.world.isRemote)\n    {\n        SimpleEnergyNetwork network = SimpleEnergyNetwork.Factory.get(this.world);\n        network.disableBlock(this.pos, () ->\n        {\n            int diff = network.getSharedEnergy(this.pos);\n            network.addEnergy(this.pos, -diff);\n            this.markDirty();\n        });\n    }\n    super.remove();\n}复制代码\n和 onChunkUnloaded 相比，remove 方法额外多做了一件事：把导线连通网络里当前位置的能量清零。这可以避免在该位置重新添加导线时附带残留能量。\n\n到这里，整个导线的方块实体相关代码，就全部实现完了。但我们还有一件事没处理：如果导线附近的方块发生变化了怎么办？\n\n导线附近方块的变化\n\n如果导线附近添加了新的机器，那么我们应当将这件事通知能量网络。这可以通过覆盖 Block 类的 neighborChanged 方法来实现。\n\n我们在方块类（FEDemoWireBlock）写下以下代码：\n\n@Override\n@SuppressWarnings(\"deprecation\")\npublic void neighborChanged(@Nonnull BlockState state, @Nonnull World world, @Nonnull BlockPos pos, @Nonnull Block fromBlock, @Nonnull BlockPos fromPos, boolean isMoving)\n{\n    if (!world.isRemote)\n    {\n        TileEntity tileEntity = world.getTileEntity(pos);\n        if (tileEntity instanceof FEDemoWireTileEntity)\n        {\n            SimpleEnergyNetwork.Factory.get(world).enableBlock(pos, tileEntity::markDirty);\n        }\n    }\n}复制代码\n很好，关于导线的一切我们都已经写完了。\n\n\n\n\n\n\nimage-10.png (262.59 KB, 下载次数: 0)\n\n下载附件\n\n2020-5-1 14:50 上传\n\n\n\n\n\n\n代码清单\n\n这一部分添加的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/util/IBlockNetwork.javasrc/main/java/com/github/ustc_zzzz/fedemo/util/SimpleBlockNetwork.javasrc/main/java/com/github/ustc_zzzz/fedemo/util/SimpleEnergyNetwork.java\n\n这一部分修改的文件有：\n\nsrc/main/java/com/github/ustc_zzzz/fedemo/block/FEDemoWireBlock.javasrc/main/java/com/github/ustc_zzzz/fedemo/tileentity/FEDemoWireTileEntity.java\n\n",
    "replies": [
        {
            "author": "1649367534",
            "timestamp": 1588484040,
            "txt_content": "求大佬告知用什么启动器可以玩"
        },
        {
            "author": "sanbing",
            "timestamp": 1588518420,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "清风叹",
            "timestamp": 1588520340,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "kuchazi",
            "timestamp": 1588555560,
            "txt_content": "感谢大佬"
        },
        {
            "author": "E.T.星落辰",
            "timestamp": 1588567980,
            "txt_content": " 本帖最后由 E.T.星落辰 于 2020-5-4 12:54 编辑 \n\n给土球球比心（）\n感觉FE系统现在还是用的人少啊，不愧蝙蝠那一句苏联笑话2333"
        },
        {
            "author": "金额锦江",
            "timestamp": 1588595220,
            "txt_content": "一脸懵逼的我来走了，正如我一脸懵逼的来了"
        },
        {
            "author": "故乡味俱全",
            "timestamp": 1588632720,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "我系切糕qwq",
            "timestamp": 1588693080,
            "txt_content": "好像很厉害awa 话说哪里能玩到qaq"
        },
        {
            "author": "craos",
            "timestamp": 1588754220,
            "txt_content": "？为什么我没看懂这是个什么 是太硬核了吗"
        },
        {
            "author": "lpokilpoki",
            "timestamp": 1588770060,
            "txt_content": "66666666666刷起来"
        },
        {
            "author": "lpokilpoki",
            "timestamp": 1588770060,
            "txt_content": "66666666666刷起来"
        },
        {
            "author": "lpokilpoki",
            "timestamp": 1588770120,
            "txt_content": "66666666666刷起来"
        },
        {
            "author": "lpokilpoki",
            "timestamp": 1588770180,
            "txt_content": "lpokilpoki 发表于 2020-5-6 21:02\n66666666666刷起来\n66666666666刷起来"
        },
        {
            "author": "lpokilpoki",
            "timestamp": 1588770300,
            "txt_content": "66666666666刷起来"
        },
        {
            "author": "2xiaoxiao",
            "timestamp": 1588781880,
            "txt_content": "6666666666666"
        },
        {
            "author": "Adora-",
            "timestamp": 1588791420,
            "txt_content": "感谢分享哇～"
        },
        {
            "author": "458277",
            "timestamp": 1588791900,
            "txt_content": "大佬nb66666"
        },
        {
            "author": "206946354",
            "timestamp": 1588830840,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "hyd77778888",
            "timestamp": 1588893180,
            "txt_content": "1649367534 发表于 2020-5-3 13:34\n求大佬告知用什么启动器可以玩\n应该是hmcl"
        },
        {
            "author": "kuchazi",
            "timestamp": 1588947840,
            "txt_content": "感谢大佬"
        },
        {
            "author": "2724478006",
            "timestamp": 1589020320,
            "txt_content": "MCBBS有你更精彩"
        },
        {
            "author": "qwerzxcvplm",
            "timestamp": 1589036460,
            "txt_content": "呃！膜拜大佬!看得我一脸懵!"
        },
        {
            "author": "花园粑粑",
            "timestamp": 1589074620,
            "txt_content": "emmmmmmmmmmmmmm"
        },
        {
            "author": "DaiBM1",
            "timestamp": 1589077020,
            "txt_content": "E.T.星落辰 发表于 2020-5-4 12:53\n给土球球比心（）\n感觉FE系统现在还是用的人少啊，不愧蝙蝠那一句苏联笑话2333 ...\nFE是电量单位吗？就像EU，RF一样"
        },
        {
            "author": "Lovelyhamster",
            "timestamp": 1589278140,
            "txt_content": "emmm.....虽然我看不懂，但看起来好厉害的样子"
        },
        {
            "author": "xiaohongyi",
            "timestamp": 1589332140,
            "txt_content": "完全看不懂大佬发的代码....可能是因为我是小白的原因吧."
        },
        {
            "author": "deskdeskhome",
            "timestamp": 1589341320,
            "txt_content": "捕捉土球！"
        },
        {
            "author": "Bear_Spirits",
            "timestamp": 1589413740,
            "txt_content": "666666666666"
        },
        {
            "author": "し不懂丶装懂つ",
            "timestamp": 1589476560,
            "txt_content": "mcbbs有你更精彩"
        },
        {
            "author": "zymzdgm",
            "timestamp": 1589508900,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "zymzdgm",
            "timestamp": 1589508900,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "zymzdgm",
            "timestamp": 1589509020,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "lop201",
            "timestamp": 1589515500,
            "txt_content": "MCBBS有你们更精彩"
        },
        {
            "author": "Bear_Spirits",
            "timestamp": 1589530980,
            "txt_content": "666666666666666666666"
        },
        {
            "author": "949151128",
            "timestamp": 1589557440,
            "txt_content": "感谢带佬的分享，，已阅"
        },
        {
            "author": "Goyon",
            "timestamp": 1589608320,
            "txt_content": "感觉很牛逼的样子  就是怕看都看不懂。。。"
        },
        {
            "author": "mcliugepi",
            "timestamp": 1589609100,
            "txt_content": "eeeeeeeeee....."
        },
        {
            "author": "mcliugepi",
            "timestamp": 1589609340,
            "txt_content": "这是什么，       \n"
        },
        {
            "author": "DouTea_0418",
            "timestamp": 1589626260,
            "txt_content": "感觉好厉害"
        },
        {
            "author": "youyihj",
            "timestamp": 1589639520,
            "txt_content": " 本帖最后由 友 于 2020-5-17 00:36 编辑 \n\n我想说个关于例子的错误。\n\nAE2的管道从来不需要控制器。"
        },
        {
            "author": "套你瘊子",
            "timestamp": 1589690640,
            "txt_content": "我学了好久 终于会了"
        },
        {
            "author": "110278995",
            "timestamp": 1589697180,
            "txt_content": "啦啦啦啦啦啦啦啦"
        },
        {
            "author": "qq2479976168",
            "timestamp": 1590026160,
            "txt_content": "好像很厉害awa 话说哪里能玩到qaq"
        },
        {
            "author": "qq852810523",
            "timestamp": 1590799920,
            "txt_content": "好评！高大上的样子！收藏了"
        },
        {
            "author": "ACE滑稽",
            "timestamp": 1590802500,
            "txt_content": "感谢感谢"
        },
        {
            "author": "三角函数zfz",
            "timestamp": 1590830820,
            "txt_content": "mcbbs有你更好了"
        },
        {
            "author": "xyq680303",
            "timestamp": 1590891360,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "3491638801",
            "timestamp": 1590895320,
            "txt_content": "adasdsadassda"
        },
        {
            "author": "华夏后人",
            "timestamp": 1590917460,
            "txt_content": " MCBBS有你更精彩~"
        },
        {
            "author": "wenlonglong",
            "timestamp": 1593755340,
            "txt_content": "MCBBS有你更精彩~"
        }
    ]
}