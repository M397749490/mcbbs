{
    "title": "[已解决]一个Event不检查Cancelled的插件,如何用另一个插件阻止其处理事件?",
    "author": "SakuraKooi",
    "replyCount": 5,
    "timestamp": 1474079340,
    "txt_content": " 本帖最后由 wujinze 于 2016-9-17 13:41 编辑 \n\n我正在写一个修复某插件的BUG的插件....\n但翻了下那货源代码发现一个蛋疼的问题....\n那货并没有检查isCancelled(),我setCancelled(true)也完全没用\n一触发事件就执行Task\nso....怎么办才能不让它执行?\n或者..能否让其不接收到这次事件?\n\n嘛...用了一个丧心病狂的方法解决了\n虽然有没有bug还需要测试..",
    "replies": [
        {
            "author": "tdiant",
            "timestamp": 1474086300,
            "txt_content": "把你的监听器调到LOWEST级，然后监听到事件以后就把他的那个监听器类给unregister\n\n事件Event类.unregister( 他那个类 );"
        },
        {
            "author": "SakuraKooi",
            "timestamp": 1474089420,
            "txt_content": "tdiant 发表于 2016-9-17 12:25\n把你的监听器调到LOWEST级，然后监听到事件以后就把他的那个监听器类给unregister\n\n事件Event类.unregister ...\n但其监听器内还有其他事件...我只需要处理掉BlockBreakEvent就ok了\nunregister后不就不能监听了么...我只是想在检测到触发Bug的情况下处理,正常情况下事件还是需要传过去的"
        },
        {
            "author": "寂",
            "timestamp": 1474090500,
            "txt_content": "蛋疼。。\n如果能获取到源码的话，可以考虑重新编译一下那个插件。。。"
        },
        {
            "author": "jiongjionger",
            "timestamp": 1474115280,
            "txt_content": "你要取消其他插件的BlockBreakEvent。这还是很容易的。\n因为PlayerInteractEvent的优先级更高，你取消掉PlayerInteractEvent，自然BlockBreakEvent就被取消了。"
        },
        {
            "author": "jiongjionger",
            "timestamp": 1474115400,
            "txt_content": "很多插件都没有判断事件有没有取消，也是醉人，想写个插件做兼容都不太容易。\n我以前给某插件做兼容就遇到过这样的问题，他混淆得太厉害了反编译后简直无法看，别说类型缺失，大量代码只能转回字节码。最后基于字节码给他加了判断是否取消的代码。"
        }
    ]
}