{
    "title": "【懒人专用|不定期更新|1.9】【CBL·pca】逻辑框架",
    "author": "pca006132",
    "replyCount": 3,
    "timestamp": 1447587000,
    "txt_content": " 本帖最后由 pca006132 于 2015-11-28 23:23 编辑 \n\n简写、特殊格式:\n由于我写了一个生成器，并且平常的习惯关系，所以我这个教程会用到一些简写，以下是简写及其全写\ngt: gametick，游戏刻，一般为0.05秒，为MC里最小的时间单位(微观延迟就是1gt内的执行顺序)\nscb: scoreboard，记分板\ncb: command block，命令方块\nicb: impulse command block，特指普通命令方块\nccb: chain command block，连锁CB\nrcb: repeating command block，循环CB(会自动激活)\nAS: ArmorStand，盔甲架，经常用于标记坐标\n\n例子中可能用到的格式(其实是我生成器的格式来的)\nicb:/rcb: 该命令是放在icb/rcb里\nmark:名字 tag : 以一个指定名字、tag的AS来标记下一个CB的位置\ninit: 该指令只是在生成OCS的时候执行\ncond: conditional，1.9CB的模式\n简介: \n这个帖子是继我上一个帖子——\"无延迟\"else、else if 及嵌套(不需scb)，之后的一个关于1.9CB的逻辑研究。\n在我们弄系统的时候，我们可能会使用if、else、while等的逻辑，如果需要嵌套的话，使用scb是比较麻烦的。\n有一天，乾坤问我如何在预览版不用scb就可以做到if、else等逻辑，我就开始研究，研究到一定水平之后我就到论坛那里发帖了。然而，发帖后一天发现该方法无法解决某些问题，比如while嵌套、if里的命令需要多点时间执行等，那么就会出现时序上的问题了。\n因此，我用了几天时间测试、思考等等，和CBL及新人群里的人讨论了一段时间之后，发展出这个框架，虽然不是优化得很好，但是相信比每次使用这类逻辑的时候都要重新想一次方便。如果大家发现什么漏洞、错误、更好的解决方法的话，不妨告诉我，谢谢大家！\n————————————————————————————————\nCCB的特性:\n在了解如何做到if那些控制之前，你需要明白CCB的一些特性，不然的话是不能够明白那个系统的原理的。\n首先，CCB是会把之前指着它的CB的信号延续下去，无论它有没有被激活/conditional的条件是否满足。\n只要对着它的ICB(普通CB)，RCB(自带高频的CB)有被激活(有没有成功执行命令是完全没关系的)，或者对着它的CCB有信号传过来，它就会传递信号\n第二，CCB在激活了(有红石信号激活/auto)并且满足条件(见下)的情况下就会执行命令\n第三，CCB在以下情况下被称之为\"条件满足\"\n    不是conditional模式\n    conditional模式下，前一个CB箭头对着它的箭头尾端，并且前一个CB在传递信号的时候成功执行命令\n————————————————————————————————\n模块概念:\n一个模块就是一堆命令，或者是逻辑，在系统里可能会经常用到/不直接放在一起的，就是一个模块。所以其实并没有什么必须拆分模块的情况这里，我们说的模块开头就是一个以AS标记的icb(命令为blockdata ~ ~ ~ {auto:0b})，透过把其auto设置为1，然后设置回去，就可以向后方的ccb发出信号。\n激活的方法很简单，就是execute那个AS blockdata ~ ~ ~ {auto:1b}就可以了\n一般来说呢，这个框架内，大部分模块都会\"返回\"一个信号给\"上一层\"的模块，就是用作模块之后的命令。因此，上面提到的激活命令之后一般都会有一个以AS标记的icb(命令也是blockdata ~ ~ ~ {auto:0b})，用以接收那个信号，并传递给之后的ccb。\n至于为什么要使用模块呢，在这个框架里，就是因为里面的指令可能会执行失败，如果用cond:串子连在一起的话，后面的cb则不能执行，因此会放在模块里。\n————————————————————————————————\n框架的核心概念:\n把逻辑中if、else、while等地方分拆出来，成为一个独立的\"模块\"\n只是在if、while完结之后的地方放置一个普通的命令方块提供一个把信号暂停，等待if/while执行完毕之后继续执行之后的命令的方法。\n比如说\nif (testfor @a[r=5])\n{\n    say hi\n}\nelse\n{\n    say bye\n}\n我们会把say hi、say bye分拆出来，总共会有三个模块，在最后一个}的位置，我们会放下一个普通的命令方块并且以盔甲架标记，say hi/say bye的模块中最后的位置我们会用execute那个指定的盔甲架blockdata ~ ~ ~ {auto:1b}，以激活后面的命令。\n这个概念在接下来的例子会详细介绍。\n————————————————————————————————\nif的框架:\nif(只有if，并且那些命令没有延迟):\n    条件\n    cond:必然能执行的命令\n    之后的指令。\n\nif(有else):\n    重置这个if的所有的else\n    条件\n    cond:把else部分auto:0b\n    cond:启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    mark: (代表else的AS)\n    启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    mark: (代表if结束)\n    icb:blockdata ~ ~ ~ {auto:0b}\n    之后的指令。\n\nif(有else if和else等)\n    重置这个if的所有的else\n    条件\n    cond:把else部分auto:0b\n    cond:启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    mark: (代表else if的AS)\n    条件\n    cond:把else部分auto:0b\n    cond:启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    .(else if的就只需要跟随之前的模式，不停重复就好)\n    .\n    .\n    mark: (代表else的AS)\n    启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    mark: (代表if结束)\n    icb:blockdata ~ ~ ~ {auto:0b}\n    之后的指令。\n\n注意:\n那个模块/那些命令，最后必须是execute (代表if结束的AS) ~ ~ ~ blockdata ~ ~ ~ {auto:1b}。不然的话后续的指令将不能执行。\n如果if执行的命令不需要激活模块，并且不是循环，则不需要加入代表if结束的AS、该icb及那些命令不需要execute (代表if结束的AS) ~ ~ ~ blockdata ~ ~ ~ {auto:1b}。这样子可以优化那个系统，使其cb数及AS数更少。\n如果你需要嵌套，那么启动模块的指令之后则需要放置一个盔甲架及icb，模块最后则auto:1该icb，详见模块概念\n而且，需要嵌套的话，注意不同层次、模块的AS名字/tag不要相同，不然会造成不可预计的后果\n如果地图内有多个if，起名方面则需要小心一点。\n\n原理:\n这个的原理是透过ccb在auto:0b/条件不满足的时候会传递信号，当前面的条件不满足，就会传递信号给后面的ccb。但是如果条件满足了，就会把else的部分关闭，令其无法执行命令。\n————————————————————————————————\nwhile的框架:\n    mark:(名字) while\n    icb:blockdata ~ ~ ~ {auto:0b}\n    execute代表else的AS blockdata ~ ~ ~ {auto:1b}\n    条件\n    cond:execute代表else的AS blockdata ~ ~ ~ {auto:0b}\n    cond:execute代表while开头的AS blockdata ~ ~ ~ {auto:1b}\n    cond:启动模块(如果是肯定能执行的命令，则执行那些命令，需要注意的是所有都需要cond:，\n         并且执行失败会导致之后的命令全部不能执行)\n    mark:代表else的AS\n    execute代表while完结的AS blockdata ~ ~ ~ {auto:1b}\n\n注意:\n如果while是在最外层(不是被别的模块启动的话)而且之后没有命令需要执行的话，则不用代表while完结的AS，也不用最后那条指令\n如果地图内有多个while，起名方面则需要小心一点。\n如果是do while(先执行后检测)，只需要把启动模块的指令调到条件前方就可以了\n\n原理:\n其实是一个\"变形\"了的if，当if成功，则执行里面的指令并且重启while，否则就执行之后的命令。\n\n不用rcb的最主要原因是rcb有一个特性，关闭后依然会输出多一次的信号，不太靠谱\n————————————————————————————————\n模块的框架:\n    mark:模块名字\n    icb:blockdata ~ ~ ~ {auto:0b}\n    .(命令)\n    .\n    .\n    execute代表模块完结的AS blockdata ~ ~ ~ {auto:1b}\n\n启动模块的方法其实很简单，就是execute 代表模块的AS blockdata ~ ~ ~ {auto:1b}之后就放置一个代表模块完结的AS，icb:blockdata ~ ~ ~ {auto:0b}\n\n公用模块可以建立一个常用的模块当作\"公用模块\"，其建立方法一样，然而启动模块的方法就会变成\n启动模块(和上面一样)\nscoreboard players tag 后面的AS add 模块_end\nmark:不是返回模块结束信号的AS名字\nicb:blockdata ~ ~ ~ {auto:0b}\nscoreboard players tag 后面的AS remove 模块_end\n以下是一个例子\n比如:\n//启动while\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_2] add while0_end\n//while的结束\nmark:if_test_5 end_while0_2_2\nicb:blockdata ~ ~ ~ {auto:0b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_2] remove while0_end\n\n//模块while0的开始\nmark:if_test_5 while0\nicb:blockdata ~ ~ ~ {auto:0b}\n//把else重置\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0_else] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//条件\ntestfor @a[r=10]\n//把else关闭\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=while0_else] ~ ~ ~ blockdata ~ ~ ~ {auto:0b}\n//把while0重新激活(准备下一个循环)\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=while0] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//命令(也可以是激活模块)\ncond:say someone here\n//else\nmark:if_test_5 while0_else\n//回到while的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0_end] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n\n这样子便不会造成混乱的情况。\n\n注意:\n模块如果被红石块激活，则需要清除掉红石块之后才能再次执行(废话23333)\n如果是\"最外层\"的模块，则不需要最后那个\"execute代表模块完结的AS blockdata ~ ~ ~ {auto:1b}\"\n\n原理:\nicb被blockdata ~ ~ ~ {auto:1b}之后会传出一次的信号，来激活后续的ccb\n————————————————————————————————\n例子:\n/*\nif (testfor @e[type=Arrow])\n{\n    say yoo\n    if (testfor @e[type=Item])\n    { \n        say arrow and item\n    }\n    else\n    {\n        say arrow\n    }\n    while (testfor @a[r=10])\n    {\n        say someone here\n    }\n}\nelse\n{\n    say oh\n    if (testfor @e[type=Item])\n    { \n        say item\n    }\n    while (testfor @a[r=10])\n    {\n        say someone here\n    }\n    say nope\n}\nsay ok\n*/\n以上就是那个伪代码了\n第一层if 就是检测有没有箭，有的话就说yoo；然后检测有没有物品，有的话就说arrow and item，没的话就说arrow；最后当玩家在某个地方的10格范围内就说someone here。\n如果没有箭，就说oh；然后检测有没有物品，有就说item；然后就当玩家在某个地方的10格范围内就说someone here。\n\n以下就是那个命令(那个特殊格式就请参照开始的格式部分。此部分可以直接放进我的生成器来生成OCS放进地图)\n//就是重置所有的else(此层的else)\nicb:execute @e[type=ArmorStand,name=if_test_5,tag=1_1_else] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//这里就是条件\ntestfor @e[type=Arrow]\n//把else关闭\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=1_1_else] ~ ~ ~ blockdata ~ ~ ~ {auto:0b}\n//启动2_2模块\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=2_1] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//else\nmark:if_test_5 1_1_else\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_2] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//if的结束\nmark:if_test_5 1_1_end_if\nicb:blockdata ~ ~ ~ {auto:0b}\n//if之后的指令\nsay ok\n/*\n这部分就是最\"外层\"的部分，以伪代码表示就是这样\nif (testfor @e[type=Arrow])\n{\n    激活2_1\n}\nelse\n{\n    激活2_2\n}\nsay ok\n*/\n\n//2_1 模块的开始\nmark:if_test_5 2_1\nicb:blockdata ~ ~ ~ {auto:0b}\n//第一条命令\nsay yoo\n//进入if阶段，把else重置\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_1_else] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//条件\ntestfor @e[type=Item]\n//把else关闭\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=2_1_else] ~ ~ ~ blockdata ~ ~ ~ {auto:0b}\n//启动3_1模块\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=3_1] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//else\nmark:if_test_5 2_1_else\n//启动3_2模块\nexecute @e[type=ArmorStand,name=if_test_5,tag=3_2] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//if的结束\nmark:if_test_5 2_1_end_if\nicb:blockdata ~ ~ ~ {auto:0b}\n//启动while\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_1] add while0_end\n//while的结束\nmark:if_test_5 end_while0_2_1\nicb:blockdata ~ ~ ~ {auto:0b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_1] remove while0_end\n//回到上一层的if的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=1_1_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n\n/*\n伪代码:\nsay yoo\nif (testfor @e[type=Item])\n{ \n    激活3_1\n}\nelse\n{\n    激活3_2\n}\n激活while\n*/\n\n//2_2 模块的开始\nmark:if_test_5 2_2\nicb:blockdata ~ ~ ~ {auto:0b}\n//第一条命令\nsay oh\n//进入if阶段，把else重置\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_2_else] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//条件\ntestfor @e[type=Item]\n//把else关闭\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=2_2_else] ~ ~ ~ blockdata ~ ~ ~ {auto:0b}\n//启动3_3模块\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=3_3] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//else\nmark:if_test_5 2_2_else\n//启动end_if(接下来那个)\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_2_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//if的结束\nmark:if_test_5 2_2_end_if\nicb:blockdata ~ ~ ~ {auto:0b}\n//启动while\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_2] add while0_end\n//while的结束\nmark:if_test_5 end_while0_2_2\nicb:blockdata ~ ~ ~ {auto:0b}\nscoreboard players tag @e[type=ArmorStand,name=if_test_5,tag=end_while0_2_2] remove while0_end\n//while后的命令\nsay nope\n//回到上一层的if的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=1_1_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n/*\n伪代码:\nsay oh\nif (testfor @e[type=Item])\n{ \n    激活3_3\n}\n激活while\nsay nope\n*/\n\n//模块3_1的开始\nmark:if_test_5 3_1\nicb:blockdata ~ ~ ~ {auto:0b}\n//命令\nsay arrow and item\n//回到上一层的if的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_1_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n\n//模块3_2的开始\nmark:if_test_5 3_2\nicb:blockdata ~ ~ ~ {auto:0b}\n//命令\nsay arrow\n//回到上一层的if的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_1_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n\n//模块3_3的开始\nmark:if_test_5 3_3\nicb:blockdata ~ ~ ~ {auto:0b}\n//命令\nsay item\n//回到上一层的if的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=2_2_end_if] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n\n//模块while0的开始\nmark:if_test_5 while0\nicb:blockdata ~ ~ ~ {auto:0b}\n//把else重置\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0_else] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//条件\ntestfor @a[r=10]\n//把else关闭\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=while0_else] ~ ~ ~ blockdata ~ ~ ~ {auto:0b}\n//把while0重新激活(准备下一个循环)\ncond:execute @e[type=ArmorStand,name=if_test_5,tag=while0] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n//命令(也可以是激活模块)\ncond:say someone here\n//else\nmark:if_test_5 while0_else\n//回到while的结束\nexecute @e[type=ArmorStand,name=if_test_5,tag=while0_end] ~ ~ ~ blockdata ~ ~ ~ {auto:1b}\n/*\nwhile (testfor @a[r=10])\n{\n    say someone here\n}\n*/\n\n复制代码\n命令里的\n//\n或者是\n/*\n*/，就是那些指令的解释。//就是解释下面的指令，而/*至*/就是解释上一个模块的功能\n\n可能有人会骂我这例子的优化差，确实这个例子是很多地方可以优化的，比如根本就可以使用一个模块完成，命令数相对来说也会大幅减少，或者是第二层那些if根本就没必要弄个end_if。然而，由于我需要给大家看到一个最基本的、模块化的结构，所以我就把他们强行拆出来了。\n如果只是看着那些指令的解释看到有点不舒服的话，可以去对照一下上面的标准，及下方/**/里的伪代码，相信会清晰很多。\n\n大家可以看到，我那个例子中的AS名字全部都是if_test_5，只是tag不同而已。因为我是把名字视作namespace，而tag就是其实际功能。这样子，即使是不同作品里用到同一个模块，我只需要把那个AS的名字修改一下，放在同一个地图的时候便不会造成混乱，不会发生错误激活的情况了。\n那个tag，前方可能会看到一个奇怪的东西 x_y，这里我是把x视作层数，y视作那个层数的第y个if，这样子就对我来说比较清晰(虽然也有人说这样很麻烦)，总之大家用一个东西标记不同部分就好了√\n————————————————————————————————\n结尾:\n毕竟这个只是一个框架，你使用这个框架会让你实现逻辑的时候方便一点，然而所需的命令数也会多一点，实体数也会多一点，所以需要根据实际情况去优化那个系统。这个框架重点在于较为简单以及没有什么延迟，你如果需要很大的优化，我就不建议你使用本框架，因为这个框架的优化程度确实严重不足。\n\n以下是使用本框架的作品:\nhttp://www.mcbbs.net/thread-522701-1-1.html\n\nOOC生成器(能使用上面说过的格式，转化为OOC直接变成CB组放进地图中):\nhttp://pan.baidu.com/s/1dD0mueH\n\n最后更新: 16-11-2015 11:40\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "秋一",
            "timestamp": 1447587060,
            "txt_content": "终于发了√ 马克一下慢慢看等下再评论"
        },
        {
            "author": "青格大D",
            "timestamp": 1447587120,
            "txt_content": "多看一眼我内分泌都要失调了。\n\n今天CBL高产似什么！！！大声告诉我！！！"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1447650960,
            "txt_content": "你的例子优化差！[滑稽][滑稽]"
        }
    ]
}