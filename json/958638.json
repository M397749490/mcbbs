{
    "title": "【CBL|00ll00】[1.15]用最自然的方法画画 | L-系统与分形 | 拆解字符串",
    "author": "00ll00",
    "replyCount": 13,
    "timestamp": 1581593520,
    "txt_content": " 本帖最后由 00ll00 于 2020-3-2 12:32 编辑 \n\n用最不圆润的方法画画\n模拟自然的系统：L-System\n\n\n\nL-System画分形曲线（MC | C4D）\n\n\n\n        Lindenmayer System，简称L-System，是由荷兰Utrecht大学的生物学和植物学家，匈牙利裔的林登麦伊尔（Aristid Lindenmayer）于1968年提出的有关生长发展中的细胞交互作用的数学模型，尤其被广泛应用于植物生长过程的研究。——百度\n\n\n        简单地说L-System就是通过迭代函数绘制分形图案的系统，通过设置参数、前提和迭代规则可以快速地创建出如树枝、雷电、雪花等图案。这次在MC里实现的是一个弱化的L-System，能完成基础的一些绘制操作，通过书与笔录入配置，完全交互式操作，通透。\n\n\n\n\n\n\n\n1.L-System\n\n部分内容简要地摘自Houdini L-System节点介绍，点击查看原文\n\n    L-System（Lindenmayer System），能通过简单的递归来创建分形几何体。\n    其主体分为两大部分：迭代系统 和 生成器\n\n  迭代系统\n\n    这里的迭代系统是一种针对字符的迭代，或者称为重写机制。举个例子，如果初始字符串（Premise）为\"b\"，而迭代规则（Rules）为\"b=a\"和\"a=ab\"，在第一次重写中就会把初始字符串中的所有字符\"b\"替换为字符\"a\"，所有的字符\"a\"替换为\"ab\"，因此第一次迭代后得到的字符串为\"a\"。若要进行下一次迭代，则把\"a\"作为初始字符串，于是得到\"ab\"，以此类推。\n\n\n刚才那个例子的迭代示意图\n\n    然而实际上L系统的迭代器还有其他的功能，这里只进行了最低限度的模拟，即只允许以“字符=字符串”的格式来书写迭代规则，具体写法见下一节。\n\n\n生成器\n\n    L系统的生成器是一只Turtle，它根据收到的Turtle命令来决定自己的动作，比如F表示前进并画线，f表示前进但不画线，+表示左转90°，-表示右转90°（这里的参数是可以配置的）……于是我们可以使用简单的字符串来让Turtle画出一个“L”形状：\n\n\n命令“FFF+F+FF-F+F+FF”执行过程\n\n    Turtle命令也有一大堆，这里只实现了最少量的实用命令，具体见下一节。\n\n结合\n\n    看到这里，你大概已经猜到整个L系统是怎样运行的了：\n\n设置一个初始字符串，以及迭代次数、规则等迭代字符串把得到的字符串作为Turtle命令用于生成图形\n\n\n一个迭代一次就多走一步并左转的L系统\n\n    这里可以使用Turtle命令规定以外的字符作为一个重写的标志，这些字符在最后会被Turtle略过，如上图的\"A\"。当然在MC里能解析的字符有限，所以不能乱写，具体见下一节。\n这是分形二次科赫岛（quadratic Koch island）的L系统实现：\n\n初始字符串 (premise)F-F-F-F重新规则F = F-F+F+FF-F-F+F角度90\n  \n\n这里是三次迭代中这个图形的生长过程，可以看出有分形的影子，但严格的说这并不是分形。如果将这个迭代进行无限次，那将成为真正的分形（大概？）\n\n\n    而自然中很多地方都有分形的影子：一个树枝可以与一棵树有相似的结构，一道闪电取出其中一个分叉也是一道小闪电……所以这里说L系统是模拟自然的系统完全不过分。（其实L系统的发明者Aristid Lindenmayer本来就是把它视为模拟植物生长的数学模型）\n\n\n2.使用方法与示例\n下载并安装好数据包后输入/function lsys:init复制代码你会获得一个萝卜钓竿（L-System）和一本书（Setting）\n在书的第一页写上L系统的参数、第二页写上L系统的迭代规则，保存，拿着书与笔F键，等待系统进行解析，解析完成后用萝卜钓竿对着方块右键，L系统就会从那个方块的位置开始绘图。\n\n这个L系统支持的参数有\n\nGenerations：迭代次数（正整数|次）（至少为1）Step：默认步长（正整数|0.1格）Angle：默认角度（正整数|度）Premise：初始命令（字符串）\n\n支持的Turtle命令有    可以参考这个来理解\n\nF(l)：前进一个步长l并绘图（l为正整数，若省略则为一个默认步长）f(l)：前进一个步长l但不绘图（l为正整数，若省略则为一个默认步长）+(a)：左转一个角度a（a为正整数，若省略则为一个默认角度）-(a)：右转一个角度a（a为正整数，若省略则为一个默认角度）&(a)：上仰一个角度a（a为正整数，若省略则为一个默认角度）^(a)：俯倾一个角度a（a为正整数，若省略则为一个默认角度）\\(a)：顺时针滚动一个角度a（a为正整数，若省略则为一个默认角度）/(a)：逆时针滚动一个角度a（a为正整数，若省略则为一个默认角度）[：开启一个分支，用于创建分叉]：闭合一个分支，与\"[\"成对使用\n\n第一页参数定义写法示例\n#Parameters\n\nGenerations=3\nStep=50\nAngle=60\nPremise=//F(40)+A-B\n注释以\"#\"开头，为避免解析出错，不要整个页面为空\n换行以回车符为准\n可以有空行\n参数定义行中不能有空格，写法必须为“参数名=值”\n\n如\"F\",\"+\"等命令带参数的写法为“命令(正整数)”\n第二页迭代规则写法示例\n#Rules\n\nA=FFB\nB=AAA\n注释以\"#\"开头，为避免解析出错，不要整个页面为空\n换行以回车符为准\n可以有空行\n规则写法必须为“字符=字符串”\n\n\n需要注意的是，这套字符串解析系统只支持了英文字母、英文标点以及换行符，若出现其他字符会导致解析错误\n另外避免出现10个及以上的连续空格，原因见后文\n\n经典的参考示例（可直接复制粘贴）    更多有趣的示例看这里\n  1.L-System 默认树（植物）      第一页#Default Tree\n\nGenerations=7\nStep=30\nAngle=28\nPremise=FFFA\n     第二页#Rules\n\nA=[B]////[B]////[B]\nB=&FFFA\n  2.谢尔宾斯基三角（分形）      第一页#Sierpinski Arrowhead\n\nGenerations=5\nStep=30\nAngle=60\nPremise=YF\n      第二页#Rules\n\nY=XF+YF+X\nX=YF-XF-Y\n\n  3.平面希尔伯特曲线（分形）      第一页#Hilbert Curve\n\nGenerations=4\nStep=30\nAngle=90\nPremise=X\n      第二页#Rules\n\nX=-YF+XFX+FY-\nY=+XF-YFY-FX+\n\n  4.草（植物）\n      第一页\n#++\n\nGenerations=1\nStep=10\nAngle=90\nPremise=FFF[+F(70)][-F(70)]FF[+F(40)-FF][-F(40)+FF]ff[+F(40)-FF][-F(40)+FF]ff[+FF[-F(40)]FF][-FF[+F(40)]FF]ff[+F(60)]-F(60)      第二页\n#wwwww\n所以Rules可以不写但是必须写点注释占位（艹\n\n  5.科赫雪花（分形）\n      第一页\n#Von Koch Snowflake\n\nGenerations=3\nStep=30\nAngle=60\nPremise=F++F++F      第二页\n#Rules\n\nF=F-F++F-F\n\n\n\n3.核心原理（粗解）\n    在MC里实现L系统主要涉及到MC的列表操作（用于实现迭代器和Turtle命令解析）、矩阵运算和解三角函数（用于计算Turtle的方向），考虑到用tellraw或者用容器做键盘实在麻烦，于是用了一个还算热乎的技术——拆解字符串\n\n    列表操作矩阵运算之类的好像没啥好说的，比较容易实现，那就主要讲一下拆解字符串的原理（run\n\n列表操作\n\n    主要用到了列表中元素的添加，删除和比对\n    添加删除即data modify storage nsp path append ... 和data remove ...\n    对比A和B即先把C set为A，再用execute store success ... run C赋值为B，若成功则A!=B，若失败则A==B\n\n\n矩阵运算\n\n    这里只用到了矩阵乘法，用于计算Turtle的转向操作\n    实现起来就是一堆计分板乘法\n\n\n解三角函数\n\n    用于计算旋转矩阵，具体计算方法有许多大佬解释过了\n    这里是用的刷实体取坐标的那种\n\n\n\n拆解字符串    原作者为McTsts，为了添加对换行符的支持所以我重写了\n\n\n    所谓的拆解，实际上是在拼凑：将可能出现的字符逐个试出来，于是需要将多个字符拼凑为字符串和逐个字符比较的手段，于是就要用到两个指令的骚操作：enchant 和 tag list\n\n   借助一个例子来解释整个过程：假设有一个字符串为\"123\"，我们现在想要把他拆解为字符列表[\"1\",\"2\",\"3\"]。\n\n   Step1.把这个字符串用nbt组件的方式写到一个告示牌上，再转存到盔甲架[A]的CustomName里，同时我们在允许的字符范围里随便猜一个字符（实际做法是二分法）假设是\"0\"，用同样的方法把他转存到盔甲架[B]的CustomName里，然后分别让两个cb对A和B跑错误的enchant指令把JSON文本拍扁，此时这两个cb的LastOutput的结构为：\n1：{enchant错误,\"with\":\"123\",...}\n2：{enchant错误,\"with\":\"0\",...}   \n\n    enchant指令在执行出现某些错误（比如执行对象不支持附魔、执行对象无手持物品）的时候会返回含有执行对象的输出信息，而这个信息与众不同的地方是里面出现的执行对象名称是被拍扁为字符串的，而其他命令返回含有执行对象的名字时是以JSON文本的形式。比如说有一个盔甲架，借助告示牌修改了它的{CustomName:'{\"nbt\":\"string\",\"storage\":\"ps:test\",\"interpret\":true}'}，其中ps:test有{string:\"123\"}，enchant执行错误的返回中会包含有字符串\"123\"，而其他指令执行返回中则是包含\"text\":\"{name:\\'{\\\\\"nbt\\\\\":\\\\\"string\\\\\",\\\\\"storage\\\\\":\\\\\"ps:test\\\\\",\\\\\"interpret\\\\\":true}'}\"之类的信息。所以我们可以用enchant的返回来拍扁拼凑出的字符串。而要获取到这个返回信息则需要在命令方块里运行这个命令，这与丢人钟大概是必须存在的最后的理由了吧。\n\n\n    Step2.清空AB的CustomName，用data modify的方式把这两个命令方块的LastOutput添加到B的Tags里，再分别给A添加三个tag:\"a\",\"b\",\"c\"，B添加一个tag:\"a, b, c\"然后同时对A和B执行tag list（也在cb里，因为要获取返回信息）。tag list指令在执行时会将执行对象的所有tag按字符顺序进行排序，这也就是用于判断我们猜的字符与实际字符的大小的方法。所以为了控制变量，我们必须要使AB的tag数量一致而添加这些奇奇怪怪的tag。这时对AB执行tag list的cb返回信息结构分别为：\n3：[时间] 这玩意有3个标签:a, b, c                                                                                       \n4：[时间] 这玩意有3个标签:a, b, c, {enchant错误,\"with\":\"0\",...}, {enchant错误,\"with\":\"123\",...}\n可以看出，第二个cb中已经对tag进行了排序，最后两个tag之间的差异仅为那两个字符串，所以实际上对排序造成影响的就是我们猜的那个\"0\"和源字符串的第一个字符\"1\"的先后顺序。那么如何知道这个排序的结果呢？\n\n    Step3.将上一步中第二个cb的返回值经过告示牌转存到B的CustomName中，然后在告示牌中把cb3、1、2的LastOutput按顺序拼起来，其中添加一些标点什么的使结构与cb4的LastOutput结构一致，再转存到A的CustomName里。此时再次用两个enchant把AB拍扁，得到的输出结构为：\n5：{enchant错误,\"with\":\"[时间] 这玩意有3个标签:a, b, c, {enchant错误,\"with\":\"123\",...}, {enchant错误,\"with\":\"0\",...}\",...}\n6：{enchant错误,\"with\":\"[时间] 这玩意有3个标签:a, b, c, {enchant错误,\"with\":\"0\",...}, {enchant错误,\"with\":\"123\",...}\",...}\n由于tag list的排序与我们固定的顺序不一样，所以这两个返回信息也不相同。如果我们第一步猜的字符在\"1\"之后，则可以得到完全相同的输出信息。\n    Step4.用data merge把cb5的输出set到cb6里，发现成功了（因为值不相同），所以我们就可以知道源字符串的第一个字符排在字符\"0\"的后面。这样我们就再猜一个\"0\"之后的字符继续循环。这里处理的字符总共不超过100个，用二分法把这个循环跑8次便能准确地猜出一个字符，也就是说在8次循环后我们只剩字符\"1\"了，于是把\"1\"固定下来，使用告示牌拼贴的方式添加要猜的第二个字符，继续循环。\n\n    一些细节.\n        1.可以看到，在每次获取LastOutput的时候都会有一个时间戳，虽然实际运行的时候这些cb都是在1tick里跑完一次比较，但是也不排除时间戳在其中发生改变的可能，于是还要在用到cb之前和用完cb之后分别添加一个cb，内容随意但是相同，用于判断在这个过程中时间戳是否改变，即此次比较结果是否可靠。\n        2.实际在比较的时候在拍扁这一步中字符串之后还有一串以引号开头内容，这串有可能对tag list排序这一步造成影响，于是解决方法是分别在源字符串和拼凑的字符串后方加上一长串（10个）空格，因为在这里空格貌似是排在最小的字符，这样相当于把后面的那串内容隔开了。所以如果源字符串里出现了10个以上的连续字符串就可能使比较结果出错。\n\n\n4.数据包下载&调试命令&参考资料\n下载\n\n\n\nL-SYS_01.zip\n(52.22 KB, 下载次数: 15)\n\n\n\n2020-3-2 12:23 上传\n点击文件名下载附件\nL-System数据包\n\n\n\n\n\n这个数据包是从PSINMC里强行抠出来的，很有些杂乱（各种意义上）\n\n调试命令\n\n/function lsys:init复制代码为执行者初始化/function lsys:stop复制代码终止当前所有绘画/function lsys:showresult复制代码输出迭代结果\n\n参考资料\n\n    1.L系统的各种规则：Houdini L-System 节点使用说明\n    2.很多有趣和实用的L系统预设：L-System User Notes -- Paul Bourke\n    3.拆解字符串原作者的数据包：Minecraft-String-Utilities\n\n\n\n\n感谢SPG告诉我MC能拆字符串的事，以及SPG是世界第一好用的数据包插件！！！的开发者！！！\n感谢小豆提供的数学_运算包（小豆在不在论坛来着\n\n",
    "replies": [
        {
            "author": "18000569211",
            "timestamp": 1581605220,
            "txt_content": "我表示我完全没看懂"
        },
        {
            "author": "Xiao2",
            "timestamp": 1581640260,
            "txt_content": "岂不是相当于mc界面内的简单编程系统！！\n我认为书与钓竿的处理是相当的棒"
        },
        {
            "author": "2782429220",
            "timestamp": 1581646080,
            "txt_content": "我表示有点难awa我表示看懂很难"
        },
        {
            "author": "(=°ω°)丿",
            "timestamp": 1581648780,
            "txt_content": " 本帖最后由 隐退 于 2020-2-14 11:13 编辑 \n\n这次的内容的确挺有意思的（\n不过感觉可能在一般的建筑中用不太到（\nPSINMC 相比于 实用 感觉更偏向于 技术（\n看似在咕咕咕，实则……的确在咕咕咕 SPG是世界第一好用的数据包插件！！！的开发者！！！\n我同意（\n论坛底色好像是 rgb(251, 242, 219) 也就是 #FBF2DB\n最近想到了一个复制粘贴的功能（\n先用胡萝卜钓竿选择两个点，然后将计算后的结果存储到结构方块里。\n如果选择的范围太大，则考虑使用多个结构方块。\n还考虑过跨存档转移建筑。\n不过懒癌晚期就是了（\n我都不知道我在说什么（"
        },
        {
            "author": "00ll00",
            "timestamp": 1581650100,
            "txt_content": " 本帖最后由 00ll00 于 2020-2-14 11:19 编辑 \n隐退 发表于 2020-2-14 10:53\n这次的内容的确挺有意思的（\n不过感觉可能在一般的建筑中用不太到（\nPSINMC 相比于 实用 感觉更偏向 ...\n这个还只能算做了一半，因为实际上我是打算用他来种树（或者其他植物（或者啥啥的\n见鬼  好像卡出bug了，这条评论能删么qwq"
        },
        {
            "author": "00ll00",
            "timestamp": 1581650160,
            "txt_content": "隐退 发表于 2020-2-14 10:53\n这次的内容的确挺有意思的（\n不过感觉可能在一般的建筑中用不太到（\nPSINMC 相比于 实用 感觉更偏向 ...\n这个还只能算做了一半，因为实际上我是打算用他来一键种树（或者其他植物（或者啥啥的\n就是打算能做到带半径和材质的\n不过还是好复杂……但是应该会实用\n\n结构方块这个想法还是头一回见\n有空试试（咕咕"
        },
        {
            "author": "时之虫",
            "timestamp": 1582045080,
            "txt_content": "分型、迭代、…可以，这很数学"
        },
        {
            "author": "(=°ω°)丿",
            "timestamp": 1582258980,
            "txt_content": " 本帖最后由 隐退 于 2020-2-21 14:40 编辑 \n\n关于复制粘贴的功能，我补充了一下细节：\n存储结构：用胡萝卜钓竿选择两个方块，以此作为一个长方体的两个对角顶点，将这两个点的坐标带入记分板计算，将结果存入结构方块，并激活。\n加载结构：用胡萝卜钓竿选择一个方块，在这个方块上放置结构方块并激活。\n突破结构方块的尺寸限制：如果我们选择了一个尺寸较大的长方体，我们可以通过算法，将其分割成几个小长方体。然后用结构方块一一储存，加载时一一调用即可。（我猜应该可以把记分版的分数存为结构名称）这个功能可以用于跨存档搬运建筑。\n当然，也可以结合结构方块自带的旋转、翻转、结构完整性等功能。"
        },
        {
            "author": "咕哒子寿司",
            "timestamp": 1582259580,
            "txt_content": "原来这样啊，我懂了，谢谢楼主！"
        },
        {
            "author": "muhei",
            "timestamp": 1582274700,
            "txt_content": "有点难，勉强懂了"
        },
        {
            "author": "kongbaiyo",
            "timestamp": 1583202420,
            "txt_content": "强 摸鱼了这么久原来拆分字符串的技能被开发出来了吗"
        },
        {
            "author": "w279179736",
            "timestamp": 1583204340,
            "txt_content": "兄弟加油期待好作品啊"
        },
        {
            "author": "鑫鑫超帅",
            "timestamp": 1583204940,
            "txt_content": "兄弟加油期待好作品啊兄弟加油期待好作品啊"
        }
    ]
}