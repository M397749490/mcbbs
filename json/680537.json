{
    "title": "BlockRedstoneWire源代码文档",
    "author": "a1017752020",
    "replyCount": 0,
    "timestamp": 1489476180,
    "txt_content": " 本帖最后由 a1017752020 于 2017-3-14 15:25 编辑 \n\nBlockRedstoneWire\n包结构net.minecraft.block\n继承树BlockRedstoneWire-> Block -> Impl<T> extends IForgeRegistryEntry<T> >\n成员变量\n   变量名      描述     NORTH\n    复合枚举类，由给定多个枚举对象集合构建，代表北\n    EAST\n    代表东\n    SOUTH\n    代表南\n    WEST\n    代表西\n    POWER\n    可以提供的红石信号强度\n    REDSTONE_WIRE_AABB\n    红石的包围盒集合，包含16种\n    canProvidePower\n    是否能够向外提供红石信号\n    blocksNeedingUpdate\n    包含需要更新的方块集合\n  方法\n   方法名      描述     public BlockRedstoneWire()\n    默认构造函数,规定红石的材质为Material.CIRCUITS（电路）\n    public AxisAlignedBB getBoundingBox(IBlockState state,  IBlockAccess source, BlockPos pos)\n    通过getAABBIndex获得下标，并将包围盒返回\n    private static int getAABBIndex(IBlockState state)\n    根据方块状态获得包围盒下标\n    public IBlockState getActualState(IBlockState state,  IBlockAccess worldIn, BlockPos pos)\n    获得事实上的方块状态，获得的数据事实上是方块状态中不包含的，像红石之间是否连接，围栏的连接\n    private BlockRedstoneWire.EnumAttachPosition getAttachPosition(IBlockAccess  worldIn, BlockPos pos, EnumFacing direction)\n    获得红石与一条边的连接结果，返回结果有NONE没有连接，SIDE正常，UP向上连接\n    public AxisAlignedBB getCollisionBoundingBox(IBlockState  blockState, World worldIn, BlockPos pos)\n    返回碰撞包围盒，当前返回NULL_AABB\n    public boolean isOpaqueCube(IBlockState state)\n    返回是否为不透明方块，返回false\n    public boolean isFullCube(IBlockState state)\n    是否为充满的方块，返回false\n    public boolean canPlaceBlockAt(World worldIn, BlockPos pos)\n    是否可以放置红石到目标位置，默认方块下是充满的方块或者荧石就可以\n    private IBlockState updateSurroundingRedstone(World worldIn,  BlockPos pos, IBlockState state)\n    调用calculateCurrentChanges计算状态并更新，之后调用notifyWireNeighborsOfStateChange通知周围红石\n    private IBlockState calculateCurrentChanges(World worldIn,  BlockPos pos1, BlockPos pos2, IBlockState state)\n    计算当前红石的状态，并将状态返回\n    private void notifyWireNeighborsOfStateChange(World worldIn,  BlockPos pos)\n    通知周围的红石进行状态更新\n    public void onBlockAdded(World worldIn, BlockPos pos,  IBlockState state)\n    在周围放置方块时调用，内部先调用updateSurroundingRedstone更新周围红石状态，再依次通知垂直、水平方向红石进行状态变化，再遍历水平方向的方块，如果isNormalCube（）就通知该方块上方，如果不是就通知下方方块进行状态变化\n    public void breakBlock(World worldIn, BlockPos pos,  IBlockState state)\n    破坏pos位置的红石，之后会进行周围状态更新\n    private int getMaxCurrentStrength(World worldIn, BlockPos pos,  int strength)\n    返回目标pos处最强的红石信号强度\n    public void neighborChanged(IBlockState state, World worldIn,  BlockPos pos, Block blockIn)\n    当周围方块发生变化时被调用，用以进行当前方块状态改变，像红石信号改变，仙人掌掉落\n    public Item getItemDropped(IBlockState state, Random rand, int  fortune)\n    获得当前方块被收集时所掉落的物品\n    public int getStrongPower(IBlockState blockState, IBlockAccess  blockAccess, BlockPos pos, EnumFacing side)\n    返回当前方块可以提供的红石信号强度，对canProvidePower进行判断，能提供时返回getWeakPower函数的返回值\n    public int getWeakPower(IBlockState blockState, IBlockAccess  blockAccess, BlockPos pos, EnumFacing side)\n    经过复杂计算返回当前方块的红石信号强度，但是明明包含上一个函数的canProvidePower判断，结果又判断了一次\n    private boolean isPowerSourceAt(IBlockAccess worldIn, BlockPos  pos, EnumFacing side)\n    返回值是此处红石信号强度是否来自于目标方位，side是pos位置方块的相对位置，判断side是否是pos位置红石信号强度的来源\n    protected static boolean canConnectUpwardsTo(IBlockAccess  worldIn, BlockPos pos)\n    静态方法，判断当前红石线能否与pos目标连接\n    protected static boolean canConnectTo(IBlockState blockState,  @Nullable EnumFacing side, IBlockAccess world, BlockPos pos )\n    上个函数将调用此函数，此函数side指定了方向，增加了对红石中继器等的判断\n    public boolean canProvidePower(IBlockState state)\n    return this.canProvidePower;\n    public static int colorMultiplier(int p_176337_0_)\n    名称是生成颜色的，测试发现R值很高，应该是根据红石信号产生绘制颜色\n    public void randomDisplayTick(IBlockState stateIn, World  worldIn, BlockPos pos, Random rand)\n    随机选定tick产生粒子动画\n    public ItemStack getItem(World worldIn, BlockPos pos,  IBlockState state)\n    返回包含一个红石的物品堆\n    public IBlockState getStateFromMeta(int meta)\n    将meta信息写入POWER中\n    public BlockRenderLayer getBlockLayer()\n    获得方块渲染层，返回值有SOLID(无Alpha测试,有Mipmap)、CUTOUT_MIPPED(有Alpha测试,有Mipmap)、CUTOUT(有Alpha测试,无Mipmap)和TRANSLUCENT(开启混合)参考：OpenShader月报 #0 \n    public int getMetaFromState(IBlockState state)\n    把POWER转成Meta，实际上红石线就这一个信息\n    public IBlockState withRotation(IBlockState state, Rotation  rot)\n    旋转\n    public IBlockState withMirror(IBlockState state, Mirror  mirrorIn)\n    反转\n    protected BlockStateContainer createBlockState()\n    返回一个新BlockStateContainer(具体是啥...）\n  内部类\nstatic enum EnumAttachPosition implements IStringSerializable{    \n    UP(\"up\"),//上方\n    SIDE(\"side\"),//边\n    NONE(\"none\");//没有\n    private final String name;\n    private EnumAttachPosition(String name){\n        this.name = name;\n    }    public String toString(){\n        return this.getName();\n    }    public String getName(){\n        return this.name;\n    }\n}\n\n\n\n\n\n\n\n\n\n\nBlockRedstoneWire.zip\n\n\n2017-3-14 15:22 上传\n点击文件名下载附件\n\n\n\n\n6.14 KB, 下载次数: 10\n\n\nhtml版\n\n\n\n",
    "replies": []
}