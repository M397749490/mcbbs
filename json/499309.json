{
    "title": "【万年坑】【本章完结】Java高手训练营第五章：面向对象（上）",
    "author": "ufof",
    "replyCount": 16,
    "timestamp": 1441430700,
    "txt_content": " 本帖最后由 ufof 于 2017-3-8 15:06 编辑 \n\n\n5.1 面向对象思想\n\n\n5.1.1  面向过程思想概述\n\n这一章我们不讲任何Java，就来讲讲编程思想。\n面向过程思想是最传统的编程思想，思考方式与人的思考方式相违背。在面向过程编程中，“过程”或“函数”最大。程序的流程就是一个函数调用另外一个函数、另外一个函数又调用另一个函数。\n上渣图：\n\n\n简单地说，面向过程是把动词写在名词前面。例如“吃.西瓜”。\n\n这种编程思想大家只是了解一下，我们要真正开始学习的是面向对象思想。\n\n5.1.2 面向对象思想概述\n\n在面向对象思想中，“类”最大。通过对类的实例化创建对象。类相当于图纸，对象相当于你通过这个图纸生产出来的事物。例如我的类是狗类。我实例化这个狗类，就得出了一只小狗来。这只小狗有许多行为，写法就是“小狗.吃骨头”、“小狗.睡觉”等。所以说面向对象思想中，名词在动词前，这与面向过程相对。\n\n万物都有两个部分：属性和行为。狗类的属性有体型、皮肤颜色等；狗类的行为有吃骨头、看家、狗吠等。属性和行为都被封装在类当中。所以说类是图纸。\n\n\n\n但是真正使用的不是图纸，是你通过图纸创造出来的对象。只有实例化一个对象才可以调用其的属性以及行为。\n\n我们人类说话的方式也是先说主语再说动词，例如“我写字”、“你画画”等。所以说，面向对象思想更加符合人类的原始思考方式。这样编程也更加优秀。\n\n本章小结：\n面向过程注重于动作；面向对象注重于事物面向过程通过对函数的调用实现；面向对象通过实例化类来实现面向过程与人类思考方式违背；面向过程符合人类思考方式\n\n\n\n\n5.2 类的成员\n\n\n5.2.1  类和成员概述\n\n上一节课已经阐明了，在面向对象思想中，类是图纸。也就是说明一种对象的属性以及方法都定义在类当中。\n类的定义方法如下：\n若干个修饰符 class  类名{\n}复制代码类名一般用大驼峰命名法。\n那么类中有什么？对象的属性相对于代码中的成员变量/成员常量（统称字段）；对象的行为对应代码中的方法。\n\n除了字段和方法之外，类还有以下成员：\n构造方法内部类\n初始化块\n\n5.2.2 字段\n\n我们之前学定义变量常量都是在方法中定义的。在方法中的变量常量称之为局部变量/局部常量。这两种量的生命周期仅存于方法的开始到方法的结束。\n\n现在，我们要在类当中、方法之外定义变量常量。这种量叫做成员变量/成员常量，统称字段。他们的生命周期比局部变量长。\n\n例如：\nclass Dog{\n    String name;  //名称\n    int age;         //年龄\n    int height;      //身高\n}复制代码\n注：字符串String我们还没有学到。这里简单的说一下。字符串可以存储若干个字符。是引用数据类型。\n\n5.2.3  方法\n\n狗有看家、吃骨头、狗吠的行为。行为对应的是代码中的方法。这也同样被定义在类当中：\n注意：这里的方法就不要声明为static了！理由我们在讲static静态的时候会讲。\n\nclass Dog{\n    String name;  //名称\n    int age;         //年龄\n    int height;      //身高\n\n    void lookAfterHouse(){ //看家方法\n        System.out.println(\"看家\");\n    }\n    void eatBone(){   //吃骨头\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){    //狗吠\n        System.out.println(\"汪\");\n    }\n}复制代码\n\n好的，狗类基本上已经定义完了。图纸定义完了，如何通过这个图纸真正的制造出一个实实在在的对象呢？请看下一章。\n\n本章小结：\n类的成员有：字段、方法、构造方法和内部类字段对应的是对象的属性；方法对应的是对象的行为\n\n\n\n5.3 对象的实例化以及调用其成员\n\n\n5.3.1 实例化方法\n\n图纸已经画完了，如何通过这个图纸生产出一个实实在在的对象呢？这个过程叫做实例化。\n\n实例化语法：\n类名 实例名;\n实例名 = new 类名();复制代码\n可简写为：\n类名 实例名 = new 类名();复制代码\n实例名一般用小驼峰命名法。\n这里我们实例化狗类。\n\nclass Dog{\n    String name;  //名称\n    int age;         //年龄\n    int height;      //身高\n\n    void lookAfterHouse(){ //看家方法\n        System.out.println(\"看家\");\n    }\n    void eatBone(){   //吃骨头\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){    //狗吠\n        System.out.println(\"汪\");\n    }\n}\n\nclass InstantiationDemo{\n    public static void main(String[] args){\n        Dog myDog = new Dog();  //实例化Dog类\n    }\n}复制代码\n注：对，一个.java文件可以放多个类。但是编译之后会有多个.class文件。\n\n在这个程序中，myDog叫做对象的实例。\n这个在内存中具体是什么样的请看下一章。\n\n好的，现在我们已经有一个实例了，如何调用其的字段以及方法？\n\n5.3.2  调用实例的字段以及方法\n\n调用字段的语法：\n实例.字段名;复制代码\n调用方法的语法：\n\n实例.方法名(方法要求的参数);复制代码\n在这个例子当中：\n\nclass Dog{\n    String name;  //名称\n    int age;         //年龄\n    int height;      //身高\n\n    void lookAfterHouse(){ //看家方法\n        System.out.println(\"看家\");\n    }\n    void eatBone(){   //吃骨头\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){    //狗吠\n        System.out.println(\"汪\");\n    }\n}\n\nclass InstantiationDemo{\n    public static void main(String[] args){\n        Dog myDog = new Dog();     //实例化\n        myDog.name = \"小狗狗\";      //把myDog的字段name赋值为\"狗狗\"\n        System.out.println(\"我家的狗的名字是\"+myDog.name);   //打印myDog.name\n        myDog.bark();   //让myDog叫一下\n    }\n}复制代码结果：\n\n\n\n好的，这就是如何调用实例的成员了。\n实例也称引用。两者完全相同。\n\n5.3.3 引用数据类型\n\n在第二章中，我们已经学习过了基本数据类型。我们今天学的实例化所得到的实例是引用数据类型的一种。这种通过实例化类的方式得到的实例叫做“类类型”。\n\n引用数据类型还有两种，分别是数组和接口，我们以后会接触到。\n\n\n\n5.3.4 null\n\nnull是一个关键字，也是一个字面量。\nnull可以赋给任意一种引用数据类型。当一个实例被赋为null时，其将不会指向堆内存中的任何对象。详见下一章。\nDog d = null;复制代码当一个实例被置为null时，不能调用其的字段/方法，不然会抛出NullPointerException异常。\n\n\n本章小结：\n实例化的方法为“类名 实例名 = new 类名()”可以通过“实例.字段”调用其的字段可以通过“实例.方法()”调用其的方法被null赋值的实例不指向任何对象\n\n\n\n\n5.4 堆内存\n\n\n5.4.1 实例化的具体过程\n\n我们在讲方法的时候讲过了栈内存。相信也不难理解。现在我们再来学习另外一种内存的规划，叫做堆内存。\n\n栈内存用于存储局部变量/实例，堆内存用于存储对象。\n\nDog myDog = new Dog();复制代码我们来开始解析这一句话：\n\n首先“Dog myDog”是经典的“类型 变量名”格式，这个和我们声明基本数据类型的方法也一样。myDog这个实例是在栈内存中被存储的：\n\n\n这和局部变量/常量没有任何区别。\n\n那么new Dog()在内存中是什么样子呢？这里就用到了堆内存。\n\n\n\n在堆内存当中，新建了一个Dog类的对象。里面的内容其实就是Dog类中的成员。\n\n那么这两者是如何关联起来的呢？大家可以发现“Dog myDog = new Dog();”中间有一个等号。\n\n栈内存中的实例指向了堆内存中的对象。\n\n\n这下就用该明白了实例化在内存中具体是如何实现的。\n堆内存还有一个特点：里面的所有值都是由默认值的，所以类的字段一般不需要赋值。\n\n本章小结\n堆内存用于存储对象当对类进行实例化时，该实例指向了堆内存中的对象\n\n\n\n5.5 static静态\n\n\n5.5.1  static概述\n\n我们之前在定义字段或者方法时都必须要实例化其所在的类才可以调用。因为这些字段和方法属于实例。\n在讲静态之前，先举一个例子：\n每一个学生都有自己的课本和笔，但是他们都共用教室里的饮水机。假如说学生是一个类，课本和笔这两个字段是属于实例的、饮水机是大家公用的，所以属于类。\n\nstatic是一个修饰符。如果一个类的字段/方法属于整个类而非单个实例，可以用static修饰。\n没有被声明为static的成员叫做实例成员、反之称之为静态成员。\n被声明为static的成员有以下特点：\n类一旦被加载、其也被加载静态成员优先于实例成员静态成员多了一种被调用的方式：类名.字段名/类名.方法名\n\n5.5.2 static实例\n\nclass Resource{\n    static int staticNum = 2;      //定义静态字段\n    int num = 7;                       //定义实例字段\n}\n\nclass StaticDemo{\n    public static void main(String[] args){\n        //打印staticNum字段\n        System.out.println(Resource.staticNum);  //通过“类名.字段”格式访问静态字段staticNum\n        //打印num字段\n        Resource mc = new Resource();\n        System.out.println(mc.num);                   //通过实例mc调用实例字段num\n    }\n}复制代码结果：\n\n\n\n在Resource类当中，定义了一个静态字段叫做staticNum以及一个实例字段num。在主方法中，使用了\"Resource.staticNum\"格式直接访问了staticNum这个静态字段。没有被声明为static的实例字段num只能通过传统的先实例化然后通过实例访问的方式来访问。\n\n学生提问：既然被声明为static的字段/方法能如此方便的被调用，干脆全部声明为static可以吗？\n\n答：不现实。再引用一下刚才学生的例子。如果每一个学生都给一个饮水机，会很占空间。所以说是否声明为static需要判断这个成员到底是共享的还是实例的。\n再写一个静态方法的实例：\n\nclass Resource{\n    static void staticMethod(){\n        System.out.println(\"我是静态方法\");\n    }\n    void instanceMethod(){\n        System.out.println(\"我是实例方法\");\n    }\n}\n\nclass StaticDemo{\n    public static void main(String[] args){\n        Resource.staticMethod();  //通过“类名.方法”格式调用staticMethod\n        Resource r = new Resource();\n        r.instanceMethod();       //通过实例化类然后用实例调用instanceMethod方法\n    }\n}复制代码结果：\n\n\n\n和刚才字段的例子一样。staticMethod()是静态方法，所以他可以直接被“Resource.staticMethod()”的方式调用。instanceMethod()是实例方法，必须实例化Resource类然后通过实例才能调用它。\n\n5.5.3 内存中的静态\n\n当一个成员被声明为静态后，其就不会出现在堆内存之中了。其会被调往内存共享区。\n而且，静态成员在内存中只有一个实体。不可能像实例成员那样每实例化一个对象就出现一个新的实体。\n\n堆内存中的对象自动获得内存共享区的静态成员。\n\nclass Resource{\n    static int staticNum = 30;\n    int num = 20;\n}\n\nclass StaticDemo{\n    public static void main(String[] args){\n        Resource r1 = new Resource();    //实例化\n        Resource r2 = new Resource();\n        Resource r3 = new Resource();\n    }\n}复制代码这个程序在内存中是这样的：\n\n\n\n5.5.4 注意事项\n\n实例成员不能被“类名.成员”方式调用；静态成员也可以被“实例.成员”方式调用，但是不建议这样做。因为饮水机是大家的，不是你的；静态方法只能调用静态方法。因为静态方法更加早加载，那个时候实例方法还没有出生呢；（现在大家可以明白我们在讲方法的时候为什么直接被主方法调用的方法也得要是static了）实例方法既可以调用静态方法也可以调用实例方法。因为实例方法出生的晚，其他人早就都存在了；局部变量/常量（就是在方法中定义的变量/常量）不能被声明为静态。因为他的生命周期仅局限于方法当中。不足以被共享。\n\n本章小结：\nstatic是一个修饰符。如果一个字段或方法被static修饰，他就成为了一个静态字段/静态方法被声明为静态的成员多了一种被调用的方式：“类名.成员”被静态修饰的成员会被调往内存共享区\n静态这个知识点有许多的注意事项\n\n\n\n5.6 权限修饰符：public和private\n\n\n5.6.1 权限修饰符概述\n\n我们人有许多的信息，这些信息有些是可以对外暴露的，有些是保密的。对外暴露的有姓名、性别等；保密的有年龄（对于女孩来讲）、工资等。\n\n在Java中，也有对类成员进行权限设置的修饰符。权限修饰符一共有四种：private、default、protected、public。由于default和protected涉及到包以及子父类的概念，这里先不讲解。\n\n5.6.2 权限修饰符应用\n\n权限修饰符可以修饰类中的字段、方法、构造方法。\n被声明为private的成员只能在本类中使用，称之为私有；\n被声明为public的成员拥有最高的访问权限，称之为公有。\n没有声明的话即是default。\n\nclass PermissionDemo{\n    public static void main(String[] args){\n        Human h = new Human();\n        h.name = \"Adam\";\n        h.gender = \"Man\";\n        h.age = 28;            //非法\n        h.salary = 7000;    //非法\n    }\n}\n\nclass Human{\n    public String name;     //公有字段name\n    public String gender;    //公有字段gender\n    private int age;        //私有字段age\n    private int salary;     //私有字段salary\n}复制代码结果：\n\n\n\n由于被声明为private的字段只能在本类中使用，PermissionDemo主类不能访问被private修饰的age和salary字段，所以报错。\n\n但是本类中就可以调用这两个私有字段：\n\nclass Human{\n    public String name;     //公有字段name\n    public String gender;    //公有字段gender\n    private int age;        //私有字段age\n    private int salary;     //私有字段salary\n    \n    void introduce(){\n        System.out.println(\"我的名字是\"+name);\n        System.out.println(\"我\"+age+\"岁了\");          //合法\n        System.out.println(\"我的工资是\"+salary);     //合法\n    }\n}复制代码由于introduce()方法和两个private的字段都是在同一个类中，所以说是合法的。\n权限修饰符照样可以修饰方法，毕竟方法也是成员之一：\n\nclass Human{\n    public String name;\n    private int salary;\n    private void showSalary(){\n        sallary = 7000;\n        System.out.println(salary);\n    }\n    public void showName(){\n        name = \"Adam\";\n        System.out.println(name);\n    }\n}\n\nclass PermissionDemo{\n    public static void main(String[] args){\n        Human h = new Human();\n        h.showName();    //合法\n        h.showSalary();//非法\n    }\n}复制代码结果：\n\n\n\n\n本章小结\n权限修饰符用于修饰类成员。可以对其的访问权限进行设置权限从小到达依次为“private、default、protected、public”被声明为private的成员仅能在本类中使用；public是最高权限，即使不同包的类也可以使用\n\n\n\n5.7 匿名对象\n\n\n5.7.1  匿名对象：访问成员\n\n我们之前如果要访问类中的字段或者方法，必须要实例化这个类的一个对象。无论要访问多少次，都得要实例化。如果我只需要访问一次，可能稍微显得有一些麻烦。\n\n假如说我想要访问Dog类的bark()方法：\nclass AnonymousObjectDemo{\n        public static void main(String[] args){\n            Dog dog = new Dog();   //实例化\n            dog.bark();                   //访问方法\n        }\n}\n\nclass Dog{\n    String name;\n    int age;\n    int height;\n\n    void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    void eatBone(){\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){\n        System.out.println(\"汪\");\n    }\n}复制代码结果：\n\n\n\n仅仅访问一个方法，就得要实例化一个实例。这样的做法实在有一些麻烦。\n\n匿名对象是指，在创建对象的时候不指向任何实例。可以通过这个对象来直接访问方法。但是由于其没有指向任何实例，Java把它视为垃圾。其过一段时间后会被垃圾回收器清除掉。\n\n上面这个例子可以简化为：\nclass AnonymousObjectDemo{\n        public static void main(String[] args){\n            new Dog().bark();   //创建匿名对象\n        }\n}\n\nclass Dog{\n    String name;\n    int age;\n    int height;\n\n    void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    void eatBone(){\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){\n        System.out.println(\"汪\");\n    }\n}复制代码结果：\n\n\n\n在new Dog()后面直接加上.bark()访问bark方法。这样做不需要创建实例，所以可以节省栈内存中的空间。\n如果要访问多个方法，还是得要实例化对象。\n\n注意：\n使用匿名对象来对字段进行赋值是没有意义的。比如说：\nnew Dog().age = 5;\n复制代码好的，你把他的age字段给改了，但是你以后可以用得上吗？你刚刚new出来的对象因为没有实力已经在内存中找不到了或被垃圾处理器给清除了。所以说对字段进行赋值是没有意义的。\n\n\n5.7.2 匿名对象：参入参数\n\n如果说一个方法需要一个对象来作为参数的话，一般的做法是先实例化，然后将实例传入。例如：\n\nclass AnonymousObjectDemo{\n    public static void main(String[] args){\n        MyClass mc = new MyClass();                //实例化\n        Demo.aMethod(mc);                        //传入实例\n    }\n}\n\nclass Demo{\n    public static void aMethod(MyClass mc){        //创建静态方法，参数为MyClass对象\n        System.out.println(\"Method runs\");\n    }\n}\n\nclass MyClass{}复制代码结果：\n\n\n\n可以在调用函数的时候不用传入实例。可以这样简化：\n\nclass AnonymousObjectDemo{\n    public static void main(String[] args){\n        Demo.aMethod(new MyClass());            //传入匿名对象\n    }\n}\n\nclass Demo{\n    public static void aMethod(MyClass mc){        //创建静态方法，参数为MyClass对象\n        System.out.println(\"Method runs\");\n    }\n}\n\nclass MyClass{}复制代码结果：\n\n\n\n在主方法中调用aMethod()方法时，传入的是new MyClass()，这样做是将匿名对象传入方法中。这样的做法不需要创建实例，节省了栈内存。\n\n本章小结\n匿名对象是指在创建对象的时候不让其指向任何实例匿名对象可以用于：\n调用方法/字段一次作为参数传入方法\n\n\n\n5.8 面向对象三特点：封装\n\n\n5.8.1  封装概述\n\n封装是面向对象三个特点之一，在编程中十分重要，必须要掌握。\n举一个例子：我们在用电脑的时候，只有显示器是可视化的。电脑中的硬件我们是不能访问的，而且我们也不知道。虽说不知道，不影响我们对电脑的使用。如果让用电脑的人自由去拆开电脑去鼓捣硬件的话，最大的问题是安全性。由于客户不了解硬件，电脑很可能会坏。\n编程的时候，客户也不能直接访问类中的成员。隐藏对象的属性以及细节的过程，叫做封装。\n\n我们通过一个实际例子来了解为什么一些细节不能被用户直接访问：\n\nclass EncapsulationDemo{\n    public static void main(String[] args){\n        Dog d = new Dog();\n        d.age = -1;        //将-1赋给年龄\n    }\n}\n\nclass Dog{\n    String name;\n    int age;\n    int height;\n\n    void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    void eatBone(){\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){\n        System.out.println(\"汪\");\n    }\n}复制代码\n在这个例子当中，用户实例化了Dog类之后将年龄设置成了-1。这样做不会引起任何错误，因为-1在int范围当中。可是从逻辑层面来讲，-1岁是不可能的。这样的漏洞是由于对字段的访问“太过自由”导致的。\n\n5.8.2 实现封装\n\n引用刚才的例子。解决这个漏洞最好的方法是不让用户通过实例来访问字段，而是通过一个方法来设置/获取字段。\n首先，不让用户通过实例来访问字段的实现方法是将字段声明为private：\nclass EncapsulationDemo{\n    public static void main(String[] args){\n        Dog d = new Dog();\n        d.age = -1;        //将-1赋给年龄\n    }\n}\n\nclass Dog{\n    private String name;\n    private int age;\n    private int height;\n\n    void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    void eatBone(){\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){\n        System.out.println(\"汪\");\n    }\n}复制代码用private修饰完之后，现在这个字段已经完全不对外暴露了。用户永远无法访问它。现在我们要通过方法来获取/改变这三个字段。\n一般来讲，用于获取/设置private字段的方法的名称一般为setXXX()或getXXX()。一般用public修饰，因为这毕竟是完全安全的。\n\n对于setXXX()方法，一般会接收一个和XXX字段类型相同的参数。方法中把参数赋给字段即可。\n对于getXXX()方法，直接把XXX字段return即可。\n\n在Dog类后面加入这几个方法。\npublic void setName(String str){   //接收String类型\n    name = str;                           //将参数str赋给name字段\n}\npublic String getName(){\n    return name;                          //返回name字段\n}\n    \npublic void setAge(int a){             //接收int类型\n    age = a;                                //将参数a赋给age字段\n}\n\npublic int getAge(){\n    return age;                             //返回age字段\n}\n//下面的方法都是同理\npublic void setHeight(int h){\n    height = h;\n}\npublic int getHeight(){\n    return height;\n}\n复制代码\n在setXXX()方法中，是将方法的参数赋值个其所对应的字段。由于这些方法在本类当中，就算被声明为private，其也可以被访问。\n在getXXX()方法中，是将字段返回。\n\n不过问题还是没有解决。我这样做照样通过setAge()方法可以把年龄设置为-1。但是前面做的只是铺垫。我们可以在方法中对传进来的参数进行判断是否大于0，然后赋值：\n\n    public void setAge(int a){\n        if(a>0){        //比较是否大于0\n            age = a;    //如果满足就赋值\n        }\n        else\n        {\n            System.out.println(\"非法非法！必须大于0！赋值失败\");\n        }\n    }复制代码\n好的！现在如果我们还将其赋值为-1：\n\nclass EncapsulationDemo{\n    public static void main(String[] args){\n        Dog d = new Dog();\n        d.setAge(-1);    //调用setAge方法\n    }\n}\n\n//省略Dog类\n复制代码结果：\n\n\n\n现在，这几个字段被我们封装完毕了！我们之后学了异常，还可以在年龄为负数的时候抛出异常呢！\n\n本章小结\n封装是指隐藏对象的属性和实现细节一般对于类的字段不用实例来调用，而是通过方法来设置/获取一定要把字段声明为private！\n\n\n\n5.9 this\n\n\n5.9.1 this概述\n\nthis是一个关键字。this也是一个量，每一个非static的方法都会被分配一个这样的变量。\nthis这个变量的值是调用其所在的方法的实例。\n\nclass MyClass{\n    void method(){}\n}\n\nclass ThisDemo{\n    public static void main(String[] args){\n        MyClass mc1 = new MyClass(); \n        mc1.method();\n        \n        MyClass mc2 = new MyClass();\n        mc2.method();\n        \n        MyClass mc3 = new MyClass();\n        mc3.method();\n    }\n}复制代码在这个程序当中，MyClass类中的method的this是会变化的。mc1调用method()时，this的值会变成mc1；mc2调用method()时，this的值会变成mc2......  以此类推。换句话说，this相当于是一个万能语句，谁调用该方法，它的值就会变成这调用这个方法的实例。\n\n我们都知道，直接打印一个实例，结果会是一个实例的“类名+@+地址值”。this由于指向的是实例，直接打印this也会是这样。为了更方便与演示，我把刚才的程序改变一下。\n\nclass MyClass{\n    void method(){\n        System.out.println(this);                    //将this打印输出\n    }\n}\n\nclass ThisDemo{\n    public static void main(String[] args){\n        MyClass mc1 = new MyClass();\n        mc1.method();\n        \n        MyClass mc2 = new MyClass();\n        mc2.method();\n        \n        MyClass mc3 = new MyClass();\n        mc3.method();\n    }\n}复制代码结果：\n\n\n\n根据这个结果，我们可以看出this的值是变化的。第一行是打印mc1的结果；第二行是打印mc2的结果；第三行是打印mc3的结果。现在大家应该对this的意义有比较深刻的了解了。但是，this究竟有什么用呢？\n\n5.9.2 调用this的成员\n\n我们在讲实例化的时候，曾说过可以通过实例访问类的成员。既然this的值是实例，我们是否可以通过this来访问其对应的实例的成员呢？\n\nthis访问字段的语法如下（很容易！）：\nthis.字段名;复制代码访问方法的语法也不言而喻：\nthis.方法(要求的参数);复制代码\n我们写一个程序验证：\nclass MyClass{\n    int num;                                    //num字段\n    \n    void method(){\n        System.out.println(this.num);        //打印输出this的num字段\n    }\n}\n\nclass ThisDemo{\n    public static void main(String[] args){\n        MyClass mc1 = new MyClass();\n        mc1.num = 1;        //将mc1实例的num字段设置为1\n        mc1.method();\n        \n        MyClass mc2 = new MyClass();\n        mc2.num = 2;        //将mc2实例的num字段设置为2\n        mc2.method();\n        \n        MyClass mc3 = new MyClass();\n        mc3.num = 3;        //将mc3实例的num字段设置为3\n        mc3.method();\n    }\n}复制代码结果：\n\n\n\n可以发现，主方法中的三个实例的num都是不同的，分别为1、2、3。打印this.num就相当于是打印了mc1、mc2、mc3的num值。\n一般来讲，开发中this最常用的用途是区分成员变量和局部变量。我们在上一节讲封装的时候，setXXX的参数名和其设置的字段不一样。\n\npublic void setAge(int a){\n    age = a;\n}复制代码\n这样做可读性很差：我怎么知道你设置的字段是age而不是a！\n\n不过，如果参数的名字是age，就会和字段age冲突。系统会认为你在把age赋给自己（age=age）。现在，我们可以用this.age指向调用setAge方法的实例的age字段，来解决这个问题。\n\npublic void setAge(int age){\n    this.age = age;\n}复制代码这样做可读性可以提升，我们知道你设置的字段是age了，而且也不会冲突。这个问题就完美解决了。\n\n大家要注意一点：this不能在静态方法中使用。我们已经重复很多遍了：this的值是调用其所在的方法的实例。静态方法是通过类调用的，而非实例，那么this在静态方法中有值吗？显而易见。\n\n本章小结\nthis永远指向调用其所在的方法的实例可以使用this调用实例的字段：this.字段名/this.方法(要求的参数)\nthis不能在静态方法中使用\n\n\n\n5.10 构造方法\n\n\n5.10.1 构造方法概述\n\n构造方法是指在对象被创建的时候（即new出来的时候）直接调用的方法。这种方法一般用于在创建对象时直接对字段进行设置。\n我们再来看一下之前讲过的实例化语法：\n类名 实例名 = new 类名();复制代码我相信大家早就很好奇括号是干什么用的了。括号中填的是构造方法的参数。\n构造方法的定义：\n权限修饰符 类名(参数){\n    \n}复制代码\n构造方法没有名字，在定义的时候类名是什么就写什么。\n如果一个类没有构造方法，其会自动有一个无参数无代码的构造方法。\n\n5.10.2 构造方法实例\n\n我们为Dog类写一个构造方法。要求的参数是所有字段：\nclass Dog{\n    private String name;\n    private int age;\n    private int height;\n\n    //省略其他方法\n    public Dog(String name, int age, int height){    //定义构造方法\n        this.name = name;\n        this.age = age;\n        this.height = height;\n    }\n}\n\nclass ConstructorDemo{\n    public static void main(String[] args){\n        Dog d = new Dog(\"狗狗\",2,1);\n        System.out.println(d.getName());\n        System.out.println(d.getAge());\n        System.out.println(d.getHeight());\n    }\n}复制代码结果：\n\n\n\n学生提问：this关键字不是指向其所在的方法的实例吗？在构造方法中使用都还没有实例吧，怎么用this呢？\n\n答：构造方法中的this是由特殊含义的。在构造方法中的this指向的是即将要被创建的对象。\n在Dog类中定义了一个构造方法，参数类型是String、int和int。在主方法中实例化对象的时候括号中必须要填写其所要求的参数。因为字段已经被赋值了，直接打印也是有结果的。\n\n构造方法照样可以重载。\n\nclass Dog{\n    private String name;\n    private int age;\n    private int height;\n\n    //省略其他方法\n    public Dog(){\n        \n    }\n    public Dog(String name, int age, int height){\n        this.name = name;\n        this.age = age;\n        this.height = height;\n    }\n}\n\nclass ConstructorDemo{\n    public static void main(String[] args){\n        Dog d = new Dog();\n        Dog d1 = new Dog(\"狗狗\",2,1);\n    }\n}复制代码\n在Dog类中，有两个构造方法。一个是没有参数的，一个是有三个参数的。所以在实例化对象的时候，要么不写参数，要么写三个。\n\n本章小结\n构造方法是在对象被创建时自动调用的方法一般用于提前设置字段构造方法中的this指向的是即将被创建的对象\n构造方法也可以重载\n\n\n\n5.11 面向对象三特点：继承\n\n\n5.11.1  生活中的继承\n\n我们将生活中的任意两个事物放在一起，总能找到一些共性。例如苹果和桃子都有种子、铅笔和圆珠笔都可以用来写字、小说和散文都有文字......如果我们向上抽取，让苹果和桃子都在水果类下，“有种子”属性可以定义在水果类中，这样的话苹果和桃子自然而然也有了种子，而不需要在独立的定义一次。\n\n在思考关于继承的问题时，应当明确哪些行为是继承行为，哪些是特有行为。例如动物类中有吃饭和睡觉行为，狗类自然而然也有这两个行为。这种行为叫做继承行为。狗可以看家、啃骨头，这两个行为是动物类没有的，这种行为叫做特有行为。\n\n\n\n在编程当中，善用继承特性可以提高代码的复用性以及弹性。减少多余的代码。\n\n5.11.2 Java中应用继承\n\nclass Dog{\n    //继承行为\n    public void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n    //特有行为\n    public void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    public void bark(){\n        System.out.println(\"汪\");\n    }\n    \n}\n\nclass Cat{\n    //继承行为\n    public void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n    //特有行为\n    public void catchMouse(){\n        System.out.println(\"抓老鼠\");\n    }\n}复制代码\n可以发现，sleep()和eat()方法显得重复。我们可以定义一个Animal父类，在其中定义sleep()和eat()，让Dog类和Cat类继承Animal类，这两个子类就自动拥有了Animal类中的方法。\n在Java中，通过关键字extends来实现继承，格式为：\nclass 子类名 extends 父类{\n//一些代码\n}复制代码\n我们刚才的例子可以写成：\nclass Animal{\n    public void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n}\n\nclass Dog extends Animal{\n    //特有行为\n    public void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    public void bark(){\n        System.out.println(\"汪\");\n    }\n    \n}\n\nclass Cat extends Animal{\n    //特有行为\n    public void catchMouse(){\n        System.out.println(\"抓老鼠\");\n    }\n}复制代码这样一做，只需要在类中定义特有行为就行了，继承行为自动就会有了。\n我们在主方法中创建Dog和Cat的匿名对象，调用继承行为：\nclass InheritanceDemo{\n    public static void main(String[] args){\n        new Dog().sleep();\n        new Cat().eat();\n    }\n}\nclass Animal{\n    public void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n}\n\nclass Dog extends Animal{\n    //特有行为\n    public void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    public void bark(){\n        System.out.println(\"汪\");\n    }\n    \n}\n\nclass Cat extends Animal{\n    //特有行为\n    public void catchMouse(){\n        System.out.println(\"抓老鼠\");\n    }\n}复制代码结果：\n\n\n\n虽然说Cat和Dog类没有定义这两个方法，但是因为其继承了Animal方法，自动拥有了sleep()和eat()类，所以调用完全不成问题。\n字段也一样会被继承过来：\nclass InheritanceDemo{\n    public static void main(String[] args){\n        System.out.println(new Dog().x);\n        new Cat().eat();\n    }\n}\nclass Animal{\n    int x = 5;\n    public void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    public void eat(){\n        System.out.println(\"吃\");\n    }\n}\n\nclass Dog extends Animal{\n    //特有行为\n    public void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n    public void bark(){\n        System.out.println(\"汪\");\n    }\n    \n}\n\nclass Cat extends Animal{\n    //特有行为\n    public void catchMouse(){\n        System.out.println(\"抓老鼠\");\n    }\n}复制代码结果：\n\n\n\nDog类中并没有定义字段x，而是从Animal类中继承过来的。因此可以通过Dog实例访问这个字段。\n\n本章小结\n两个或多个有相似行为的类可以被提取成一个父类，令其子类继承父类及自动拥有父类有的方法和字段通过extends关键字实现继承继承可以提高代码的复用性和弹性\n\n\n\n5.12 继承的成员特点\n\n\n5.12.1 继承中的字段和方法\n\n如果子类和父类的方法或者字段名称冲突，若为父类实例执行父类的字段/方法；如果子类实例执行子类的字段/方法。相当于子类把父类的字段/方法覆盖了。\n\nclass InheritanceConflict{\n    public static void main(String[] args){\n        SuperClass superclass = new SuperClass();        //实例化父类\n        System.out.println(superclass.num);                //打印父类的num字段\n        superclass.print();                                //调用父类的print()方法\n        \n        SubClass subclass = new SubClass();                //实例化子类\n        System.out.println(subclass.num);                //打印子类的num字段\n        subclass.print();                                //调用子类的print()方法\n    }\n}\n\nclass SuperClass{\n    int num = 7;\n    void print(){\n        System.out.println(\"我是父类\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    int num = 8;\n    void print(){\n        System.out.println(\"我是子类\");\n    }\n}复制代码结果：\n\n\n\n在这个小实例当中，可以发现如果通过父类实例调用字段/方法则执行父类的；如果通过子类实例调用字段/方法则执行子类的。\n\n这种机制叫做复写。在开发当中，永远永远不要去改源代码。应当是通过写一个子类继承原本的类来复写其的字段/方法。因为如果你直接在原本的类当中改代码，其他的类会受到牵连。\n\n而且，有的时候子类虽然继承了父类，但是执行的结果是不一样的。比如说鸟类都可以飞，企鹅是鸟的子类，但是它就不能飞。我们可以在企鹅类当中复写鸟类的飞方法，已达到重写。\n\nclass OverrideDemo{\n    public static void main(String[] args){\n        Penguin p = new Penguin();\n        p.fly();\n    }\n}\n\nclass Bird{\n    void fly(){\n        System.out.println(\"飞\");\n    }\n}\n\nclass Penguin extends Bird{\n    void fly(){\n        System.out.println(\"我不能飞\");\n    }\n}复制代码结果：\n\n\n\n注意：如果子类要重写父类的方法，返回值、方法名和参数列表必须完全一样。不然编译器会认为你是在子类中建立一个特有的方法，而非复写。而且，复写的方法的访问权限必须大于等于被复写的方法。\n\n5.12.2 构造方法\n\n我们都知道，要先有父类才有子类。比如说要先有父亲才会有儿子。所以说在Java当中，创建一个子类对象时，会先调用父类的构造方法，然后再调用自己的构造方法。\n\nclass InheritanceConstructor{\n    public static void main(String[] args){\n        new SubClass();\n    }\n}\n\nclass SuperClass{\n    SuperClass(){\n        System.out.println(\"父类构造方法执行\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    SubClass(){\n        System.out.println(\"子类构造方法执行\");\n    }\n}复制代码结果：\n\n\n\n本章小结\n父类对象调用父类字段/方法；子类对象调用子类字段/方法子类对父类的成员的更改叫做重写创建子类对象时先调用父类构造方法，然后调用本身的构造方法\n\n\n\n5.13 super\n\n\n5.13.1 super的使用\n\n我们在上一章中学到了子类对父类的字段/方法复写。复写之后如果我想要调用父类的未被复写的方法/字段是没有办法的。Java为此给我们提供一个叫做super的关键字。\n\nsuper用于调用父类的方法、字段和构造方法。\n语法如下：\nsuper.字段\nsuper.方法\nsuper(父类构造方法参数)  //调用父类的构造方法复制代码注：super()必须是构造方法中的第一个语句。\n\n实例如下：\nclass SuperDemo{\n    public static void main(String[] args){\n        new SubClass().show();\n    }\n}\n\nclass SuperClass{\n    int num = 10;\n}\n\nclass SubClass extends SuperClass{\n    int num = 5;\n    \n    void show(){\n        System.out.println(super.num);\n    }\n}复制代码结果：\n\n\n\n可以看出来，super.num调用的不是SubClass中的字段num，而是SuperClass中的字段num。\n\nsuper一样可以调用方法：\nclass SuperDemo{\n    public static void main(String[] args){\n        new SubClass().print();\n    }\n}\n\nclass SuperClass{\n    int num = 10;\n    void show(){\n        System.out.println(\"我是父类\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    int num = 5;\n    \n    void show(){\n        System.out.println(\"我是子类\");\n    }\n    void print(){\n        super.show();\n    }\n}复制代码结果：\n\n\n\n虽然子类复写了show()方法，但是print方法中通过super调用了父类的show()方法。所以打印出来的是“我是父类”。\n\nclass SuperDemo{\n    public static void main(String[] args){\n        new SubClass();\n    }\n}\n\nclass SuperClass{\n    SuperClass(){\n        System.out.println(\"父类构造方法\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    SubClass(){\n        super();\n        System.out.println(\"子类构造方法\");\n    }\n}复制代码结果：\n\n\n\n我们已经讲过了，子类中的构造方法是先调用父类的构造方法的。所以说其实在SubClass类的构造方法中的第一句加入了一个super()。如果你不写这个super()，依旧会给你写上一个。\n\n本章小结\nsuper用于调用父类的字段、方法、构造方法格式如下：super.字段、super.方法、super()\n\n\n\n5.14 用final修饰类和方法\n\n\n5.14.1  继承机制造成的问题\n\n继承的复写特征为程序带来了许多益处。不过这也带来了一个安全隐患：你写一个很重要的方法，别人一复写，你这个方法就可以被别人随意的更改。\n\nclass FinalDemo{\n    public static void main(String[] args){\n        new SubClass().aMethod();\n    }\n}\n\nclass SuperClass{\n    void aMethod(){\n        System.out.println(\"这是一个重要的方法\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    void aMethod(){        //重写aMethod()\n        System.out.println(\"呵呵\");\n    }\n}复制代码结果：\n\n\n\n在这个例子当中，SuperClass中的aMethod()方法可以被子类复写。如果aMethod()被认为很重要，不应该被复写，怎么办呢？\n\n所以说可以从中得出结论：继承性是对安全性的一个挑战。\n我们要解决的方式就是不让一个类被继承或不让一个方法被复写。\n\n5.14.2 通过final修饰类\n\nfinal关键字不仅仅可以修饰变量，也可以修饰类和方法。\n被final修饰的类不能被继承。\n\nclass FinalDemo{\n    public static void main(String[] args){\n        new SubClass().aMethod();\n    }\n}\n\nfinal class SuperClass{\n    void aMethod(){\n        System.out.println(\"这是一个重要的方法\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    void aMethod(){        //重写aMethod()\n        System.out.println(\"呵呵\");\n    }\n}复制代码结果：\n\n\n\n在这个实例当中，SuperClass被声明为final。当SubClass继承了SuperClass时，会抛出错误。\n所以说final类会强制其不被继承。如果连子类都没有，我怎么复写呢？这样一来，安全性被提高了。\n\n5.14.3 用final修饰方法\n\n再上一节当中，被final修饰的类不能被继承。但是我希望一个类里面有一些方法可以被复写，有一些不可以。解决方法是通过final修饰方法。\n当一个方法被修饰为final时，其不能被复写。\n\nclass FinalDemo{\n    public static void main(String[] args){\n        SubClass sc = new SubClass();\n        sc.aMethod();\n        sc.anotherMethod();\n    }\n}\n\nclass SuperClass{\n    final void aMethod(){\n        System.out.println(\"这是一个重要的方法\");\n    }\n    \n    void anotherMethod(){\n        System.out.println(\"这是另一个方法\");\n    }\n}\n\nclass SubClass extends SuperClass{\n    void aMethod(){        //重写aMethod()\n        System.out.println(\"呵呵\");\n    }\n    \n    void anotherMethod(){\n        System.out.println(\"呵呵\");\n    }\n}复制代码结果：\n\n\n\n在SuperClass类中，定义了一个final方法aMethod()，以及一个非final方法anotherMethod()。当SubClass继承SuperClass之后对两个方法都进行重写，anotherMethod()是没事的，不过由于aMethod()是final方法，对其进行复写会抛出错误。\n\n本章小结\nfinal除了可以修饰变量外，可以修饰方法和类继承带来了安全隐患，随时随地都可以对方法进行复写被final声明的类不能被继承被final声明的方法不能被复写\n\n\n\n5.15 抽象类\n\n \n5.15.1 抽象类概述\n\n假如说有一个玩家类，玩家类有两个子类：一个生存玩家，一个红石玩家。两个子类都有玩的方法，但是玩的内容具体不一样。这该如何在父类中定义呢？\n\n可以在父类中写一个play()方法，方法体内什么代码都没有。但是这样做子类不复写也行，所以说有一定问题的。\n\n为了解决“有这个方法但是内容不一样”的问题，Java为我们提供抽象机制。\n\n5.15.2  定义抽象方法和类\n\n抽象方法通过修饰符声明，修饰符为abstract。\n格式如下：\n其他修饰符 abstract 方法名(参数列表);复制代码要注意，最后方法是通过分号结尾的。\n有抽象方法的类也必须被abstract修饰。\n其他修饰符 abstract 类名{\n//代码\n}复制代码abstract类不能创建对象。因为我如果创建对象调用抽象方法是没有意义的。\n\n好的，现在我们会定义抽象方法和类了，我们来解决刚才玩家类的问题：\nclass AbstractDemo{\n    public static void main(String[] args){\n        new SurvivalPlayer().play();\n        new RedstonePlayer().play();\n    }\n}\n\nabstract class Player{\n    abstract void play();\n}\n\nclass SurvivalPlayer extends Player{\n    void play(){            //复写抽象方法play()\n        System.out.println(\"玩生存模式\");\n    }\n}\n\nclass RedstonePlayer extends Player{\n    void play(){            //复写抽象方法play()\n        System.out.println(\"玩红石\");\n    }\n}复制代码结果：\n\n\n\n在这个实例中，Player类被声明为abstract，其中有abstract方法play()。SurvivalPlayer和RedstonePlayer分别继承Player类并复写play()方法。\n\n如果一个类没有复写其父类的所有抽象方法，子类成为抽象类。这样就可以“逼着”程序员必须复写抽象方法，子类必须复写，问题就解决了。\n\n本章小结\n抽象机制用于解决“子类都有这个方法但是内容不一样”的问题抽象方法和抽象类通过abstract修饰子类必须复写其父类的所有抽象方法，不然子类也成为抽象方法\n\n\n\n5.16 接口\n\n\n5.16.1 接口概述\n\n大家对于接口的理解有可能只是“插槽”，但是并非这样片面。严格意义来讲，接口是插槽的规范。如果你的插槽是我的这个接口，你就得要遵循我的规范。\n\n例如现实生活中的接口有PCI接口、AGP接口等。PCI接口是给插槽的规范。比方说这个插槽长度、宽度等属性，都由PCI接口定义。AGP接口是对显卡的规范。比方说AGP接口的显卡都有固定的工作频率等。\n\n上述的两种接口大家不需要很深的了解。但是总结的来讲接口是为一类事物提供一个规范。\n\n5.16.2  定义接口\n\n在Java中，通过这样的语法定义接口：\n\n若干个修饰符 interface 接口名{\n    //some codes\n}复制代码那么，interface里究竟该定义什么？其和类有一样，可以定义字段和方法。但是接口中的字段和方法有固定的修饰符。\n\npublic static final（字段的固定修饰符）\npublic abstract（方法的固定修饰符）复制代码在定义字段/方法时，如果漏掉了若干个修饰符没有关系。会自动帮你补上。\n而且千万注意，字段一定要被赋值过。因为既然接口提供的是一个规范，所以其的值一定要是固定的。\n\n我们来定义一个接口，接口中有一个字段和抽象方法：\ninterface MyInterface{\n    public static final int NUM = 10;\n    public abstract void print();\n}复制代码在这个小接口当中，NUM字段被赋值为10。而且其中定义了一个抽象方法print()。\n好的，现在我的小接口定义完了。现在我想要让我的一类事物去用这个接口。这该怎么做呢？\n\n5.16.3  类对接口的实现\n\n类与类之间的关系叫做继承，类与接口之间的关系叫做实现。\n实现的方式如下：\n若干修饰符 class 类名 implements 接口1,接口2,接口n{\n    \n}复制代码注：对，虽说一个类只能继承一个类，但是多实现是可以的。\n当一个类实现一个接口后，其必须复写其中的所有抽象方法。\nclass InterfaceDemo {\n    public static void main(String[] args) {\n        new MyClass().print();\n    }\n}\n\nclass MyClass implements MyInterface{\n    public void print(){\n        System.out.println(\"Hello, interface\");\n    }\n}\n\ninterface MyInterface{\n    public static final int NUM = 10;\n    public abstract void print();\n}复制代码结果：\n\n\n\n在这个小例子当中，MyClass类实现了MyInterface接口。其复写了print()方法。在主方法中创建匿名对象调用MyClass类的print()方法，输出结果即为Hello, interface。\n\n现在想必大家可能稍微理解了为什么接口是给予一个规范了。这是因为只要是实现了我这个接口的类，必须复写我的方法。我就为这个类提供了一个规范。但是只要是我的范围之内，你这个方法想怎么写都行，反正要复写就是了。\n\n5.16.4  接口与接口的继承\n\n接口与接口之间可以继承，还可以多继承。语法和类的继承差不多：\n若干个修饰符 interface 接口名 extends 接口1,接口2,接口n{\n    \n}复制代码\n子接口自动获得到父接口中的所有字段和方法。所以说如果类中实现了有父接口的子接口，其也得要复写父接口中的所有方法。\n\ninterface SubInterface extends SuperInterface{\n    void method1();\n}\n\ninterface SuperInterface{\n    void method2();\n}\n\nclass Demo implements SubInterface{\n    public void method1(){\n        System.out.println(\"method 1\");\n    }\n    public void method2(){\n        System.out.println(\"method 2\");\n    }\n}复制代码在这个例子当中，SubInteface继承了SuperInterface。SubInterface中定义了method1()，SuperInterface定义了method2()。由于Demo类实现了SubInterface且其继承了SuperInteface，其必须复写method1()和method2()。\n\n接口中的字段照样可以复写。（方法当然也可以复写但是没有意义，反正也没有方法体）\nclass InterfaceInheritanceDemo {\n    public static void main(String[] args) {\n        new Demo().method1();\n    }\n}\n\ninterface SubInterface extends SuperInterface{\n    int NUM = 0;\n    void method1();\n}\n\ninterface SuperInterface{\n    int NUM = 1;\n}\n\nclass Demo implements SubInterface{\n    public void method1(){\n        System.out.println(SubInterface.NUM);\n    }\n}复制代码结果：\n\n\n\n在这个例子当中，SuperInterface和SubInterface同时拥有NUM字段。在Demo类中复写method1()输出SubInterface中的NUM，在主方法中创建匿名对象调用method1()，结果为0。可以看出来，子接口中的NUM复写了父接口中的NUM。\n\n本章小结\n接口对类提供规范类要用一个接口需要实现这个接口，通过implements关键字实现如果一个类实现一个接口，其必须复写其所有方法类可以多实现接口接口可以继承其他接口，子接口自动获得父接口中的方法接口可以多继承接口\n\n(两天没更新了抱歉)\n\n\n\n5.17 面向对象三特点：多态\n\n\n5.17.1 多态概述\n\n多态是面向对象编程中最后一个特征。在程序中运用多态可以提高程序的扩展性。\n\n假如说狗类继承了动物类。此时大街上跑来一只小狗，你可以说“这只小狗好可爱”、或者说“这只动物好可爱”、或者更加丧心病狂“这个生物好可爱”，从逻辑层面来讲，都可以。可以说狗既具备狗的形态，也具备动物的形态，也具备生物的形态。\n\n这就是多态一个简单的了解。多态的定义是一个类具有多个形态。\n\n5.17.2 子类对象指向父类引用\n\n我们以前在实例化类的时候，都是“类名 实例名 = new 类名()”。一般情况来说，两边的类名必须完全一致。但是根据多态，可以子类对象指向父类引用。\n\nclass PolymorphismDemo {\n    public static void main(String[] args) {\n        Animal a = new Dog();    //子类对象指向父类引用\n    }\n}\n\nclass Animal{\n    void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    void eat(){\n        System.out.println(\"吃东西\");\n    }\n}\n\nclass Dog extends Animal{\n    void bark(){\n        System.out.println(\"汪\");\n    }\n}\n复制代码请大家注意程序的第三行。“Animal a = new Dog()”，很明显，左边的类名是父类，右边的是子类。这样做是合法的。\n\n那么这样做具体有什么用呢？请看下一节。\n\n5.17.3 多态的具体应用\n\n我们先定义一个体系：\nabstract class Animal{\n    void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    void eat(){\n        System.out.println(\"吃东西\");\n    }\n    abstract void sound();\n}\n\nclass Dog extends Animal{\n    void sound(){\n        System.out.println(\"汪\");\n    }\n}\n\nclass Cat extends Animal{\n    void sound(){\n        System.out.println(\"喵\");\n    }\n}\n复制代码由于Animal类的子类的叫法都不一样，但是都得叫，所以把sound()方法定义为抽象。让Dog和Cat复写sound()方法。\n现在，我们在主方法中新建Dog和Cat匿名对象调用sound()方法。\n\nclass PolymorphismDemo {\n    public static void main(String[] args) {\n        new Dog().sound();\n        new Cat().sound();\n    }\n}\n\nabstract class Animal{\n    void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    void eat(){\n        System.out.println(\"吃东西\");\n    }\n    abstract void sound();\n}\n\nclass Dog extends Animal{\n    void sound(){\n        System.out.println(\"汪\");\n    }\n}\n\nclass Cat extends Animal{\n    void sound(){\n        System.out.println(\"喵\");\n    }\n}复制代码结果：\n\n\n\n因为Dog和Cat的sound()方法内容不一样，所以输出结果必定不同。\n但是发现sound()方法被调用过多。为了提高复用性，定义letsHear()方法。\n\nclass PolymorphismDemo {\n    public static void main(String[] args) {\n        letsHear(new Dog());\n        letsHear(new Cat());\n    }\n    public static void letsHear(Dog d){\n        d.sound();\n    }\n    public static void letsHear(Cat c){\n        c.sound();\n    }\n}\n//省略定义Animal、Dog、Cat类复制代码在这个例子当中，letsHear方法被定义两次重载。一个接收的是Dog类，一个接收的是Cat类。但是如果过了一段时间我有了仓鼠类，我是不是又得要定义另一个letsHear()方法来接收仓鼠类？这样做程序的扩展性很差。\n\n此时，多态的特性就可以使用了。\nclass PolymorphismDemo {\n    public static void main(String[] args) {\n        letsHear(new Dog());\n        letsHear(new Cat());\n    }\n    public static void letsHear(Animal a){\n        a.sound();\n    }\n}复制代码结果：\n\n\n\n在这里，letsHear方法接受的参数是Animal类！就算来了仓鼠，因为其也是Animal类的子类，letsHear()照样可以接收！这样程序的扩展性就被大大的提高了。\n\n再传参数的时候，其实就是把方法参数中的new Dog()或new Cat()指向了Animal a实例。这就是我刚才说的“子类对象指向父类引用”的用法。\n\n可以发现，在编译时期，letsHear()方法中的Animal a实例拥有Animal的特点；在运行时期可以使用Cat/Dog的方法。这个实例既具备Animal的特点，也具备Cat/Dog的特点。这就是多态。由于实例a在编译时期拥有Animal特点，Animal叫做a的编译时类型。Cat/Dog即为a的运行时类型。\n\n5.17.4 接口的多态\n\n父类实例可以指向子类对象。虽说接口不能被实例化，但是接口的实例也可以指向其实现类的对象。\n接口 实例名 = new 实现类(构造方法参数);复制代码我们可以用这个接口的实例来调用实现类的成员。我们写一个示范：\n\nclass InterfacePolymorphism {\n    public static void main(String[] args){\n        MyInterface m = new MyClass();           //接口多态\n        m.method();                                       //用接口的实例调用MyClass的method()方法\n    }\n}\n\ninterface MyInterface{\n    void method();\n}\n\nclass MyClass implements MyInterface{\n    public void method(){\n        System.out.println(\"method() runs\");   //复写\n    }\n}\n复制代码结果：\n\n\n\n可以看出来，虽说是接口的实例，但是真正调用的是MyClass的method()方法。\n\n本章小结\n多态是面向对象编程的最后一个特征，是指一类的事物可以有多个形态子类对象可以指向父类实例在定义方法时，其要求的引用类型参数可以传入其子类的对象“父类 实例名 = new 子类()”当中，父类是实例的编译时类型；子类是实例的运行时类型\n接口实例也可以指向实现类对象\n\n\n\n5.18 向上转型以及向下转型\n\n\n5.18.1 向上转型\n\n上一小节我们讲述了多态的应用。这一节我们来学习多态的具体。\n大家还记不记得第二章讲的数据转换？那是针对基本数据类型的。现在我们介绍引用数据类型的转换。\n\n\n“父类 实例名 = new 子类()”是不是很像基本数据类型的隐式转换？就像是把short赋给int，永远不会溢出。在这个例子当中，是把子类的对象赋给了父类的实例。其实在这个过程中，系统自动帮你把子类转换成父类了。在继承树上，父类在子类上面，所以说这种转型叫做向上转型。\n\n\n\n但是在上一节的例子中，sound()方法在Animal类中是抽象方法。那么Animal实例是怎么调用抽象方法的呢？\n其实，在运行的时候，调用的是其的子类的sound()，而非父类的抽象方法sound()，不然肯定会报错。在编译的时候是侧重于父类的。简单的来说，编译看实例化的左边，运行看右边。\n\n5.18.2 向下转型\n\n向下转型就会稍微有一些出错的可能。相当于基本数据类型中的显式转换。\n我们先稍微修改一下我们之前定义过的体系。给Dog类和Cat类定义一个特有的方法：\n\nabstract class Animal{\n    void sleep(){\n        System.out.println(\"睡觉\");\n    }\n    void eat(){\n        System.out.println(\"吃东西\");\n    }\n    abstract void sound();\n}\n\nclass Dog extends Animal{\n    void sound(){\n        System.out.println(\"汪\");\n    }\n    void lookAfterHouse(){\n        System.out.println(\"看家\");\n    }\n}\n\nclass Cat extends Animal{\n    void sound(){\n        System.out.println(\"喵\");\n    }\n    void catchMouse(){\n        System.out.println(\"抓老鼠\");\n    }\n}复制代码Dog类中有特有方法lookAfterHouse()，Cat类有特有方法catchMouse()。\n现在，我想要在letsHear()方法中不止调用sound()方法，还想要调用两个子类的特有方法。这里就涉及到向下转换。我们需要把方法中的Animal实例a强制转换成Cat/Dog：\n\npublic static void main(String[] args) {\n        letsHear(new Dog());\n}\npublic static void letsHear(Animal a){\n    a.sound();\n    Dog d = (Dog)a;\n    d.lookAfterHouse();\n}复制代码结果：\n\n\n\n在本程序中的第六行，我把方法中的参数a强制转换成了Dog类。其语法和基本数据类型的强制转换一样。\n转换之后，可以用Dog实例d来调用Dog类的特有方法lookAfterHouse()。\n\n但是猫呢？如果我给里面传一个猫会怎么样？\npublic static void main(String[] args) {\n    letsHear(new Cat());\n}\npublic static void letsHear(Animal a){\n    a.sound();\n    Dog d = (Dog)a;\n    d.lookAfterHouse();\n}复制代码结果：\n\n\n\n喵是正常被打印了。但是在强制转换的时候就不干了。因为方法体中是强制转换成狗类，而我传进去的参数是猫类。当然会报出错误。\n\n如果可以先判断参数Animal a实例是哪一类的对象，是不是就好办了呢？上伪代码：\n\npublic static void letsHear(Animal a){\n    a.sound();\n    if(a是Dog类的对象的引用){\n        Dog d = (Dog)a;\n    }\n    else{\n        Cat c = (Cat)a;\n    }\n}复制代码\nJava中的确给我们提供判断实例是哪个类的对象的运算符。我就先留一个悬念，下一节讲。\n\n本章小结\n向上转型是将子类的对象转换成父类的引用。在使用多态的实例化方法时，系统会自动帮你转换向下转型是将父类强制转换成子类实例\n\n\n\n5.19 instanceof\n\n\n5.19.1 instanceof概述\n\ninstanceof是一个二元运算符。参与运算的是一个实例和一个类。简单的来说如果这个实例是这个类的实例，其会返回true；反之亦然。\n\n我们在上一节中提到了，要对实例进行判断是哪个类的，然后才能向下转型，不然会报出ClassCastException。这节课我们先学习instanceof的用法，然后在把上一节中的问题解决了。\n\n5.19.2 instanceof用法\n\ninsanceof语法如下：\n实例 instanceof 类复制代码其返回的是布尔类型。\n具体结果如下：\n如果实例就是这个类的实例，返回true如果实例是参与运算的类的父类的实例，返回false如果实例是参与运算的类的子类的实例，返回true如果参与运算的实例和类一点关系都没有，报错\n\n注：在多态中，无论用实例和编译时还是运行时类型比较，都返回true。\n\n上述第一种情况实例：\n\n<font size=\"3\">class InstanceofDemo {\n    public static void main(String[] args) {\n        MyClass mc = new MyClass();\n        System.out.println(mc instanceof MyClass);\n    }\n}\n\nclass MyClass{}</font>复制代码在这个例子当中，实例化了MyClass类。用实例mc与MyClass类进行instanceof比较，返回的必定是true。因为mc就是MyClass的实例。\n\n第二种情况：\npublic class InstanceofDemo {\n    public static void main(String[] args) {\n        SuperClass sc = new SuperClass();\n        System.out.println(sc instanceof SubClass);\n    }\n}\n\nclass SuperClass{}\nclass SubClass extends SuperClass{}复制代码SuperClass有子类SubClass。实例化SuperClass后，用其与SubClass做instanceof运算，符合第二种情况，返回false。\n\npublic class InstanceofDemo {\n    public static void main(String[] args) {\n        SubClass sc = new SubClass();\n        System.out.println(sc instanceof SuperClass);\n    }\n}\n\nclass SuperClass{}\nclass SubClass extends SuperClass{}复制代码体系没有变化。这次是用子类的实例和父类进行instanceof运算。符合第三种情况，输出true。\n\npublic class InstanceofDemo {\n    public static void main(String[] args) {\n        Class1 sc = new Class1();\n        System.out.println(sc instanceof Class2);\n    }\n}\n\nclass Class1{}\nclass Class2{}复制代码\n因为Class1和Class2没有任何关系，实例化Class1让其与Class2做instanceof运算，将会报错。\n\n5.19.3  用instanceof解决多态向下转型问题\n\n现在我们基本上会用instanceof运算符了。所以说我们可以用它来解决我们的问题。\n我们的问题是什么来着？那就是要对letsHear()方法中的Animal类实例a判断其运行时类型。我们可以用instanceof解决：\n\npublic static void letsHear(Animal a){\n    a.sound();\n    if(a instanceof Dog){\n        Dog d = (Dog)a;\n        d.lookAfterHouse();\n    }\n    else{\n        Cat c = (Cat)c;\n        c.catchMouse();\n    }\n}\n\npublic static void main(String[] args){\n    letsHear(new Dog());\n    letsHear(new Cat());\n}复制代码结果：\n\n\n\n好的，这个问题被我们圆满的解决了！以后我们在向下转型时，一定要对实例进行instanceof运算，以避免ClassCastException。\n\n5.19.4 用instanceof判断实例的类是否实现一个接口\n\ninstanceof也可以用来判断一个实例的类是否实现了一个接口。显而易见，如果实现了，返回true；反之亦然。格式也一样：\n\n实例 instanceof 接口复制代码我们写一个小程序：\n\nclass InstanceOfDemo{\n    public static void main(String[] args){\n        MyClass mc = new MyClass();        //实例化MyClass\n        System.out.println(mc instanceof MyInterface);        //判断实例mc的类，也就是MyClass是否实现了MyInterface接口\n    }\n}\n\nclass MyClass implements MyInterface{}\n\ninterface MyInterface{}复制代码结果：\n\n\n\n本章小结\ninstanceof是一个运算符，一个实例和一个类会参与运算如果实例为这个类的实例，返回true在向下转型时要对实例进行instanceof运算来避免出错\n\n\n\n\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "亓憩",
            "timestamp": 1442244360,
            "txt_content": "深入浅出，入门必备。"
        },
        {
            "author": "dust_of_heart",
            "timestamp": 1442268840,
            "txt_content": "oier路过\n不断调用函数岂不是浪费时间，还不如在一段程序里解决\n强迫症受不了啊"
        },
        {
            "author": "Innovators",
            "timestamp": 1465654860,
            "txt_content": " 本帖最后由 Innovators 于 2016-6-12 14:16 编辑 \n\n楼主新问题!在权限修饰符这一章,被声明private的成员只能被本类中使用,如果通过实例化调用公有方法呢?已解决{:10_493:}\n\n"
        },
        {
            "author": "pangdundun",
            "timestamp": 1486895880,
            "txt_content": " 本帖最后由 pangdundun 于 2017-2-12 21:12 编辑 \n\n对于“5.3 对象的实例化以及调用其成员（9/5/15更）”这一节中的以下代码\n\nclass Dog{\n    String name;  //名称\n    int age;         //年龄\n    int height;      //身高\n\n    void lookAfterHouse(){ //看家方法\n        System.out.println(\"看家\");\n    }\n    void eatBone(){   //吃骨头\n        System.out.println(\"吃骨头\");\n    }\n    void bark(){    //狗吠\n        System.out.println(\"汪\");\n    }\n}\n\nclass InstantiationDemo{\n    public static void main(String[] args){\n        Dog myDog = new Dog();     //实例化\n        myDog.name = \"小狗狗\";      //把myDog的字段name赋值为\"狗狗\"\n        System.out.println(\"我家的狗的名字是\"+myDog.name);   //打印myDog.name\n        myDog.bark();   //让myDog叫一下\n    }\n}复制代码\n\n中有两个class{}，请问低一格class{}就不需要定义主类main吗？\n我复制了全部的代码，javac过了，但是java过不了这是怎么回事呢？\n\n（两小时后再次编辑的白菜）好的吧······问题解决了！~\n问题在于应该输入java exShiLiHua而不是java exdog ······\n哎哎，这么关键易错的地方搂住咋不指出来捏。之前javac、java的对象都是第一个class{}结果这次也···惯性啊\n诶？！不对！这可不怪咱！都怪世臣！！！哼~"
        },
        {
            "author": "1823399231",
            "timestamp": 1486898220,
            "txt_content": "好复杂啊"
        },
        {
            "author": "子德",
            "timestamp": 1497877320,
            "txt_content": "一个初二C++党，花了2小时看到+做到这里。\n算不算快？我觉得不算。"
        },
        {
            "author": "Yaossg",
            "timestamp": 1497914160,
            "txt_content": "dust_of_heart 发表于 2015-9-15 06:14\noier路过\n不断调用函数岂不是浪费时间，还不如在一段程序里解决\n强迫症受不了啊 ...\n1.Java都没有函数这个概念，即使说Java8有，它也不是真正的函数\n2.如果一切如你所说地在一个函数(或者说是方法)中完成，那么相同的模块修改起来有多麻烦？\n3.成如你所言，那就别调用标准库了，自己在一段程序里解决多好？\ndalao 观众席:@langyo_v3"
        },
        {
            "author": "enderbracket",
            "timestamp": 1549256940,
            "txt_content": "zide888@qq.com 发表于 2017-6-19 21:02\n一个初二C++党，花了2小时看到+做到这里。\n算不算快？我觉得不算。\nc++党学Java当然快\n大部分C++操作和java一样的"
        },
        {
            "author": "子德",
            "timestamp": 1549266240,
            "txt_content": "enderbracket 发表于 2019-2-4 13:09\nc++党学Java当然快\n大部分C++操作和java一样的\n妈呀 你这挖了多久之前的坟 而我居然还在"
        },
        {
            "author": "enderbracket",
            "timestamp": 1549271520,
            "txt_content": "zide888@qq.com 发表于 2019-2-4 15:44\n妈呀 你这挖了多久之前的坟 而我居然还在\n233，我现在是初三c++OIer"
        },
        {
            "author": "朗天",
            "timestamp": 1558586940,
            "txt_content": "希望能更加深入介绍protected和default"
        },
        {
            "author": "Headphone_Sang",
            "timestamp": 1584975720,
            "txt_content": "我感觉对于抽象类的讲解缺失了一个很重要的讲解，就是讲一下为什么偏要定义为抽象类而不是让子类去复写父类的方法\n我认为这里可以这样解释,因为防止在子类的调用方法时忘记复写父类的属性或方法，但是编译并不会报错,功能出现缺失甚至不能使用,所以使用抽象方法强制重写父类方法，可以避免复写忽略造成的bug(因为父类是抽象类，子类不进行抽象方法的复写，编译就会报错)"
        },
        {
            "author": "逗比M",
            "timestamp": 1590591120,
            "txt_content": "迄今为止，看过最好的教程"
        },
        {
            "author": "逗比M",
            "timestamp": 1590591960,
            "txt_content": "最后为什么还要写一个class呢 一个class里面解决不行么"
        },
        {
            "author": "AuroraCruiser",
            "timestamp": 1590638880,
            "txt_content": "深入浅出，入门必备。"
        },
        {
            "author": "AuroraCruiser",
            "timestamp": 1590762780,
            "txt_content": "之前自学的时候一直认为implements关键字后面也是继承的父类 看了这个教程终于明白了/(ㄒoㄒ)/~~"
        }
    ]
}