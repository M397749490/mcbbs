{
    "title": "PVPIN教程RL--如何调用NMS实现附魔台上的随机附魔",
    "author": "William_Shi",
    "replyCount": 0,
    "timestamp": 1593847320,
    "txt_content": " 本帖最后由 William_Shi 于 2020-7-4 15:22 编辑 \n\n本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引\n本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\n本教程不仅仅会教你怎么调用这些方法\n还会教你怎么硬看Notch名（就是直接反编译Spigot等SDK看到的那些 命名为a、b的方法和 var0 var1 的参数）\n\n之所以想写这个奇奇怪怪的东西\n是因为之前我在@深拥v 的服务器群里看群友聊天\n然后听他们说附魔居然一次消耗30级经验\n而技术说这是“混淆附魔”插件的问题\n我一开始想的是直接发window包去欺骗玩家\n后来想到你发包也无法修改玩家客户端暴力破解出来的随机种子\n于是就有了这个教程\n\n我们的目标是根据NMS的源码去实现随机附魔\n众所周知附魔的概率是复杂的\n不仅有权重，还有神奇的限制（比如说附魔台附魔钻石剑，最大的等级为4）\n那么自己去写附魔概率的计算就过于费力\n所以就有必要去看一看NMS的实现了\n\n我们的突破口是什么呢？当然是使用jd-gui直接在SpigotSDK内搜索关键字 enchant\n\n那么我们看到了类ContainerEnchantTable\n接下来该怎么做呢？记不记得事件监听循环？\n我们都看过javadoc，在这里\nhttps://bukkit.windit.net/javadoc/org/bukkit/event/enchantment/EnchantItemEvent.html\n那么按下Ctrl+F搜索enchantitemevent\n\n得到我们需要的\nEnchantItemEvent event = new EnchantItemEvent((Player)paramEntityHuman.getBukkitEntity(), (InventoryView)getBukkitView(), this.containerAccess.getLocation().getBlock(), (ItemStack)item, this.costs[paramInt1], enchants, paramInt1);\n\n直接看构造器\nhttps://bukkit.windit.net/javadoc/org/bukkit/event/enchantment/EnchantItemEvent.html#EnchantItemEvent-org.bukkit.entity.Player-org.bukkit.inventory.InventoryView-org.bukkit.block.Block-org.bukkit.inventory.ItemStack-int-java.util.Map-int-\n那么什么是最后一个参数 int i 呢？\n看Bukkit源码\n\n  private final int button;\n  \n  public EnchantItemEvent(@NotNull Player enchanter, @NotNull InventoryView view, @NotNull Block table, @NotNull ItemStack item, int level, @NotNull Map<Enchantment, Integer> enchants, int i) {\n    super(view);\n    this.enchanter = enchanter;\n    this.table = table;\n    this.item = item;\n    this.level = level;\n    this.enchants = new HashMap<>(enchants);\n    this.cancelled = false;\n    this.button = i;\n  }\n  \n  public int whichButton() {\n    return this.button;\n  }\n  \n  复制代码\n\n看doc的解释https://bukkit.windit.net/javadoc/org/bukkit/event/enchantment/EnchantItemEvent.html#whichButton--\n\npublic int whichButton()\n获取玩家点击的附魔的按钮。\n原文: Which button was pressed to initiate the enchanting.\n返回:按钮的序号 (0, 1, 2).\n\n也就是说NMS传参的paramInt1，就是点击的附魔的按钮\n（附魔台界面右侧三个按钮）\n\n关键的附魔代码如下\n\n\n    ItemStack itemstack1 = this.enchantSlots.getItem(1);\n\n//xxx\n\n            ItemStack itemstack2 = paramItemStack1;\n            List<WeightedRandomEnchant> list = a(paramItemStack1, paramInt1, this.costs[paramInt1]);\n//xxx\n\n            Map<Enchantment, Integer> enchants = new HashMap<>();\n            for (WeightedRandomEnchant obj : list) {\n              WeightedRandomEnchant instance = obj;\n              enchants.put(Enchantment.getByKey(CraftNamespacedKey.fromMinecraft(IRegistry.ENCHANTMENT.getKey(instance.enchantment))), Integer.valueOf(instance.level));\n            } \n复制代码\n那么逻辑就是调用了一个a方法，产生了一个列表，然后遍历列表进行附魔添加\n\n\n  private List<WeightedRandomEnchant> a(ItemStack itemstack, int i, int j) {\n    this.h.setSeed((this.i.get() + i));\n    List<WeightedRandomEnchant> list = EnchantmentManager.b(this.h, itemstack, j, false);\n    if (itemstack.getItem() == Items.BOOK && list.size() > 1)\n      list.remove(this.h.nextInt(list.size())); \n    return list;\n  }复制代码\n\n又出现了一些东西，EnchantmentManager\n此时我们直接翻mcp\n\n看来就是这个参数形式了\n\n此时，注意到上面有一个看起来更不错的方法\n\n  public static ItemStack a(Random var0, ItemStack var1, int var2, boolean var3) {\n    List<WeightedRandomEnchant> var4 = b(var0, var1, var2, var3);\n    boolean var5 = (var1.getItem() == Items.BOOK);\n    if (var5)\n      var1 = new ItemStack(Items.ENCHANTED_BOOK); \n    for (WeightedRandomEnchant var7 : var4) {\n      if (var5) {\n        ItemEnchantedBook.a(var1, var7);\n        continue;\n      } \n      var1.addEnchantment(var7.enchantment, var7.level);\n    } \n    return var1;\n  }\n  复制代码\n没错，静态方法！\n只需要搞清楚到底传啥参就可以搞定了！（实际上我研究花的时间远比这多\n我们看看参数的形式，类比b方法，参数如下\n    List<WeightedRandomEnchant> list = EnchantmentManager.b(this.h, itemstack, j, false);\n看调用b方法的时候，参数是\n  private List<WeightedRandomEnchant> a(ItemStack itemstack, int i, int j) \n具体传参在\n    List<WeightedRandomEnchant> list = a(paramItemStack1, paramInt1, this.costs[paramInt1]);\n好的，我们现在知道传入什么参数了\n就是要传costs数组的东西作为int，boolean传false\n回到最初\n\nEnchantItemEvent event = new EnchantItemEvent((Player)paramEntityHuman.getBukkitEntity(), (InventoryView)getBukkitView(), this.containerAccess.getLocation().getBlock(), (ItemStack)item, this.costs[paramInt1], enchants, paramInt1);\n\n那么根据事件构造器可知， this.costs[paramInt1] 就是 int level\n让我们看看https://bukkit.windit.net/javado ... l#getExpLevelCost--\n也就是说，这个int level 就是10、20、30\n\n要想调用a方法，我们需要的是\n  public static ItemStack a(Random var0, ItemStack var1, int var2, boolean var3) \n\n其中这个Random直接new就可以了，随机本身没必要再强行去获取玩家种子什么的生成了\n\n因为 ContainerEnchantTable中\n\n  private final Random h;\n  \n55行\n\n    this.h = new Random();\n\n所以这里的Random直接new 就可以了\n\nItemStack 是被附魔的物品堆\n\nvar2 是附魔等级（10、20、30）\n\nboolean 传入 false 以与NMS附魔台的代码相一致\n\n最终测试代码如下（仅为测试使用）\n\n\n可以看到成功了，完美的随机附魔\n使用时你可以根据需要调整其等级，不必拘泥于30\n比如说你可以在EnchantItem事件里取getExpCost\n或者你可以随便自己编一个附魔等级\n当然了，太高的等级也没什么意义，毕竟30级其实已经非常高了\n\n后记：\n其实有一堆旁枝末节的东西\n我甚至最初往LootInfo的方面在想\n大家还是按照我最后总结出来的主线走吧\n至于为什么突然看到一个a方法更好\n因为ContainerEnchantTable那些方法全都与玩家对象相关的\n那个静态方法只需要一个随机就足够了\n",
    "replies": []
}