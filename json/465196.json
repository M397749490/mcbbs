{
    "title": "[CBL∫2b]指令方块进阶教程——模块 §3 : 或|| 与 且&&",
    "author": "⭐✔️",
    "replyCount": 6,
    "timestamp": 1436329500,
    "txt_content": " 本帖最后由 贰逼 于 2015-7-9 13:46 编辑 \n\n条件语句下一页为 或 与 且 概念条件语句是模块中的一个重要指令它用于判断事件是否成立，若成立则输出；若不成立则跳过。\n\n条件语句将会涉及到execute条件与变量相对性\ntestfor\n关于枚举多个条件输出\n或|| 与 且&&或||且&&或且结合\n!非的表达!非 单个变量!非 多个执行体\n条件嵌套条件嵌套相对性条件嵌套与变量子条件detect\n全索引链接\n上一篇（关于枚举与多个条件输出）--下一篇（!非的表达）\n§3.4 或|| 与 且&&\n下一页为 或 详解\n        3.4.1 基本概念\n在枚举条件的过程中，除了可以使用满足单个条件的条件判断外，\n也可以使用满足多个条件的条件判断：\n\n条件1 或者 条件a → 输出1\n条件2 而且 条件b → 输出2\n条件3 或者 （条件c 而且 条件α） →输出3\n┊\n条件n 或/且 条件s（条件x） → 输出n\n\n也就是说条件与条件之间也可以做到使用逻辑关联。\n其中两个逻辑关联便是 或|| 和 且&&。\n        3.4.2 或|| 概念\n或代表两个条件不需要全部满足，\n满足其一便可以输出。\n\n\n例如：\n条件1 或者 条件a → 输出\n\n那么我只满足了条件1会输出；\n只满足条件a也会输出；\n满足了全部仍然会输出。\n\n        3.4.3 且&& 概念\n或代表两个条件需要同时存在全部满足，\n满足全部才可以输出。\n\n\n例如：\n条件1 而且 条件a → 输出\n\n那么我只满足了条件1是不会输出的；\n只满足条件a也是不会输出的；\n只有满足了全部才会输出。\n\n\n\n        3.4.4 或||\n下一页为 且 详解\n要做到：\n或条件1 或者 或条件2 → 输出\n\n可以转化成：\n或条件1 → 相同输出\n或条件2 → 相同输出\n或条件n → 相同输出\n\n而且要使输出只执行一次，可以使用以下两种方式：\n实体选择器自带（错误示范）\n   1.这是一个max和min的或（相反范围）\n拿变量举例，\n@e[score_x_min=10,score_x=1]\n而此处表达且的关系，所以并不能\n转存计分板\n使用与条件不同的计分板进行转存变量，\n\n例如（按照执行顺序）：\n或条件1 → 转存变量x\n或条件2 → 转存变量x\n或条件n → 转存变量x\n条件变量x → 输出\n清空计分板\n\n\n比如说\n或条件1是：f的a变量值>=2\n或条件2是：f的a变量值<=-2\n\n那么可以得到以下的指令：\n\n\n\n在所有指令之前模拟fill执行：\n/fill ~1 ~ ~ ~4 ~ ~ redstone_block复制代码接着按照顺序执行以下指令；\n/execute @e[name=f,score_a_min=2] ~ ~ ~ \n/scoreboard players set @e[name=f,r=0] b 1 \n/execute @e[name=f,score_a=-2] ~ ~ ~ /scoreboard players set @e[name=f,r=0] b 1\n/execute @e[name=f,score_b_min=1,score_b=1] ~ ~ ~ /say 1\n/execute @e[name=f,score_b_min=1,score_b=1] ~ ~ ~ /scoreboard players reset @e[name=f] b复制代码\n效果：\n\n\n\n\n\n\n\n\n\n\n\n\n可以看到：\nf的a为3、-3、-15、111 由于都在>=2或者<=-2的范围内，所以均有输出；\n然而f的a为1、0、-1 则不在范围内，没有输出。\n\n分析指令：\n首先如果f的a符合 或条件1，\n则将f的b设成1；\n如果f的a符合 或条件2，\n则也将f的b设成1；\n那么只要符合 或条件1 和 或条件2 其中之一的\nf的b都是1；\n只要判断f的b为1，则输出，且将b清空以便于下一次输入。\n\n标准格式：\n\n*转存或\n/execute <或条件1> /scoreboard players set <转存实体选择器> <转存计分板> 1 /execute <或条件2> /scoreboard players set <转存实体选择器> <转存计分板> 1\n┊\n/execute <或条件n> /scoreboard players set <转存实体选择器> <转存计分板> 1\n*输出或\n/execute [转存实体选择器(score_<转存计分板>_min=1,score_<转存计分板>=1)] <相对坐标> 输出1\n/execute [转存实体选择器(score_<转存计分板>_min=1,score_<转存计分板>=1)] <相对坐标> 输出2\n┊\n/execute [转存实体选择器(score_<转存计分板>_min=1,score_<转存计分板>=1)] <相对坐标> 输出n\n*清空转存\n/execute [转存实体选择器(score_<转存计分板>_min=1,score_<转存计分板>=1)] <相对坐标> /scoreboard players reset <转存实体选择器> <转存计分板>\n\n\n\n附加部分练习：按照上面的方法，再制作一个或的例子（熟练掌握转存）；教程部分使用的是条件变量，没有介绍相对性；按照上面的方法，制作一个相对性的例子（了解或与相对性的兼容性）。\n\n        3.4.5 且&&\n下一页为 或且结合\n要做到：\n且条件1 而且 且条件2 → 输出\n\n可以分为：\n且条件1 + 且条件2 + …… + 且条件n = 输出\n\n做到这一点，可以有两种方式：\n实体选择器自带\n   1.这是一个min和max的且（相对范围）\n拿变量举例，\n@e[score_x_min=1,score_x=10]\n就是x的值>=1且<=10\n\n那么\n@e[score_x_min=1,score_x=1]\n就代表>=1且<=1，也就是1\n\n这是一个十分简单的过程，完全是实体选择器自带的分项\n其他的分项也有类似且关系。\n\n   2.并列关系，多个分项的且\n@e[score_x_min=1,score_x=10,r=1]\n他同时满足三个变量，\n所以三个选择器分项需要同时并列，\n也就是x>=1,x<=10,r=1三个且条件全部满足才能判断。\n\n\n转存计分板\n（区别于实体选择器的自带，不依赖于选择器）\n使用与条件不同的计分板，和或差不多。\n\n例如（按照执行顺序）：\n且条件1 → 变量x++\n且条件2 → 变量x++\n且条件n → 变量x++\n条件变量nx → 输出\n清空计分板\n\n与或不同的是这不是一个恒等的过程，\n而是一个连加的过程。\n达到全部满足后才有判断输出。\n\n\n比如说\n且条件1是：玩家脚下的方块是白色羊毛\n且条件2是：f的a变量值>=-2\n\n那么可以得到以下的指令：\n\n\n在所有指令之前模拟fill执行：\n/fill ~1 ~ ~ ~4 ~ ~ redstone_block复制代码\n接着按照顺序执行以下指令；\n\n/execute @e[name=f,score_a_min=2] ~ ~ ~ /scoreboard players add @e[name=f,r=0] b 1 \n/execute @p ~ ~ ~ detect ~ ~-1 ~ minecraft:wool 0 /scoreboard players add @e[name=f,c=1] b 1\n/execute @e[name=f,score_b_min=2,score_b=2] ~ ~ ~ /say 1\n/scoreboard players reset @e[name=f] b复制代码（detect以后会讲到）\n\n效果：\n\n\n\n\n\n\n\n\n\n可以看到：\n只要f的a为1 由于不在>=2的范围内，所以没有输出；\n我在空中，由于不在羊毛上没有输出。\n只有我在羊毛上，f的a>=2，才有输出。\n\n分析指令：\n首先如果f的a符合 且条件1，\n则将f的b自身加1；\n如果f的a符合 且条件2，\n则将f的b自身再加1；\n那么只有符合 且条件1 和 且条件2 全部的\n也就是说f的b是2；\n只有判断f的b为2，才输出，且将b清空以便于下一次输入。\n\n标准格式：\n\n*转存且\n/execute <且条件1> /scoreboard players add <转存实体选择器> <转存计分板> 1 \n/execute <且条件2> /scoreboard players add <转存实体选择器> <转存计分板> 1\n┊\n/execute <且条件n> /scoreboard players add <转存实体选择器> <转存计分板> 1\n*输出且\n/execute [转存实体选择器(score_<转存计分板>_min=n,score_<转存计分板>=n)] <相对坐标> 输出1\n/execute [转存实体选择器(score_<转存计分板>_min=n,score_<转存计分板>=n)] <相对坐标> 输出2\n┊\n/execute [转存实体选择器(score_<转存计分板>_min=n,score_<转存计分板>=n)] <相对坐标> 输出n\n*清空转存\n/execute [转存实体选择器(score_<转存计分板>_min=n,score_<转存计分板>=n)] <相对坐标> /scoreboard players reset <转存实体选择器> <转存计分板>\n\n\n\nexecute条件嵌套\n以后讲解。\n\n\n        3.4.6 或且结合 \n前面我们学习了 或与且 的单个逻辑关系，\n在本篇我们需要学习 或与且 的综合逻辑关系。\n\n或与且的综合关系比如：\n（a 或 b） 且 c\n（a 且 b） 或 c\n（a 且 b） 或 （a 且 c）\n（a 或 b） 且 （a 或 c）\n……\n都属于组合逻辑关系，\n这个可以利用逻辑电路进行表达，\n而今天我们要使用 或与且 的条件操作进行表达。\n\n算法标准表达\n遇到这种较复杂的逻辑组其实不用探讨别的算法，\n依旧和前面讲到的算法一样：\n遇到或——计分板set；\n遇到且——计分板add（或remove）。\n只不过综合关系中如果有n(n>1)组括号就必须创建n个转存计分板；并且将括号划分级别*（最先执行的为一级）。\n最后再判断转存计分板的关联。\n（当然除了创建多计分板外，也可以使用多实体储存多变量）\n\n\n比如上面举到的例子（x,y,z表示变量，a,b,c表示条件）\n（按顺序执行）\n1.\na → x=1\nb → x=1\nc → x+1\n清空x\n最后只需要判断x是否等于2；\n2.\na → x+1\nb → x+1\nc → x=2\n清空x\n最后只需要判断x是否等于2；\n3.\na → x+1\nb → x+1\na → y+1\nc → y+1\nx=2 → x=-1    //判断转存计分板的或关联（由于x,y计分板值被判断的并非范围，所以可以直接改变自身的值表示true）\ny=2 → x=-1\n清空x,y\n最后只需判断x是否等于-1；\n4.\na → x=1\nb → x=1\na → y=1\nc → y=1\nx=1 → x=-1    //判断转存计分板的且关联（由于x,y计分板值被判断的并非范围，所以可以直接改变自身的值表示true）\ny=1 → x-1     //由于顺序，必然先x=-1。若无执行x=-1，x-1，x的值则会为1；若无执行x=-1，执行x-1，x的值则为0；只有都执行了才为-2\n清空x,y\n最后只需要判断x是否等于-2；\n\n指令标准格式\n和算法差不多，将4中的算法表达成指令：（此处变量x为实体f的计分板a的变量；变量y为实体f的计分板b的变量）\n条件a就是检测Cow；\n条件b就是检测Sheep；\n条件c就是检测Chicken；\n（未用到条件变量）\n\n那么有9个条件满足\na；\naa；ac；ab；bc；\nabc；aac；aab；\nabac；\n\n此时我们不需要枚举9个条件；\n使用以下指令\n\n\n\n在所有指令之前模拟fill执行：\n/fill ~1 ~ ~ ~9 ~ ~ redstone_block复制代码\n接着按照顺序执行以下指令；\n*逻辑检测\n\n/execute @e[type=Cow] ~ ~ ~ /scoreboard players set @e[name=f,c=1] a 1 \n/execute @e[type=Sheep] ~ ~ ~ /scoreboard players set @e[name=f,c=1] a 1 \n/execute @e[type=Cow] ~ ~ ~ /scoreboard players set @e[name=f,c=1] b 1复制代码*条件输出\n/execute @e[name=f,score_a=-2] ~ ~ ~ /say 1 复制代码*清空\n\n/scoreboard players reset @e[name=f] a \n/scoreboard players reset @e[name=f] b  复制代码\n效果：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n上面列举的九种情况都有输出；\n\n\n\n\n如果b或c单独出现没有输出。\n\n分析指令：\na → x set 1\nb → x set 1\na → y set 1\nc → y set 1\nx==1 → x set -1    //判断转存计分板的且关联（由于x,y计分板值被判断的并非范围，所以可以直接改变自身的值表示true）\ny==1 → x remove 1     //由于顺序，必然先x=-1。若无执行x=-1，x-1，x的值则会为1；若无执行x=-1，执行x-1，x的值则为0；只有都执行了才为-2\n清空x,y\n（完全是按照之前的算法来的）\n\n标准格式：（'{}'标示层次关系，无实际意义）\n\n一级：变量x（且与或条件数量分别为m,n）\n{\n*转存一级且\n/execute <一级且条件1> /scoreboard players add <转存实体选择器> <转存计分板x> 1 \n/execute <一级且条件2> /scoreboard players add <转存实体选择器> <转存计分板x> 1\n┊\n/execute <一级且条件n> /scoreboard players add <转存实体选择器> <转存计分板x> 1\n*转存一级或\n/execute <一级或条件1> /scoreboard players set <转存实体选择器> <转存计分板x> n /execute <一级或条件2> /scoreboard players set <转存实体选择器> <转存计分板x> n\n┊\n/execute <一级或条件m> /scoreboard players set <转存实体选择器> <转存计分板x> n\n                二级：变量y（且与或条件数量分别为i,j）\n                {\n                 *转存二级且\n                 /execute <二级且条件1=n> /scoreboard players add <转存实体选择器> <转存计分板y> 1\n                 /execute <二级且条件2=n> /scoreboard players add <转存实体选择器> <转存计分板y> 1\n                 ┊\n                 /execute <二级且条件i=n> /scoreboard players add <转存实体选择器> <转存计分板y> 1\n                 *转存二级或                 \n                 /execute <二级或条件1=n> /scoreboard players set <转存实体选择器> <转存计分板y> i \n                 /execute <二级或条件2=n> /scoreboard players set <转存实体选择器> <转存计分板y> i\n                 ┊\n                 /execute <二级或条件j=n> /scoreboard players set <转存实体选择器> <转存计分板y> i\n                 …………………………\n                                  a级：变量a（且与或条件数量分别为a级变量1,a级变量2）                                                 {\n                                   *转存a级且\n                                   /execute <a级且条件1=a-1级变量1> /scoreboard players add <转存实体选择器> <转存计分板a> 1 \n                                   /execute <a级且条件2=a-1级变量1> /scoreboard players add <转存实体选择器> <转存计分板a> 1\n                                   ┊\n                                   /execute <a级且条件的a级变量1=a-1级变量1> /scoreboard players add <转存实体选择器> <转存计分板a> 1\n                                   *转存a级或                 \n                                   /execute <a级或条件1=a-1级变量1> /scoreboard players set <转存实体选择器> <转存计分板a> a级变量1 \n                                   /execute <a级或条件2=a-1级变量1> /scoreboard players set <转存实体选择器> <转存计分板a> a级变量1\n                                   ┊\n                                   /execute <a级或条件m的a级变量2=a-1级变量1> /scoreboard players set <转存实体选择器> <转存计分板a> a级变量1\n                                  }\n                 }\n}\n*输出\n/execute [转存实体选择器(score_<转存计分板a>_min=a级变量1,score_<转存计分板a>=a级变量1)] <相对坐标> 输出1\n/execute [转存实体选择器(score_<转存计分板a>_min=a级变量1,score_<转存计分板a>=a级变量1)] <相对坐标> 输出2\n┊\n/execute [转存实体选择器(score_<转存计分板a>_min=a级变量1,score_<转存计分板a>=a级变量1)] <相对坐标> 输出n\n*清空转存\n/execute [转存实体选择器(score_<转存计分板a>_min=a级变量1,score_<转存计分板a>=a级变量1)] <相对坐标> /scoreboard players reset <转存实体选择器> <转存计分板x~a级变量1>\n\n\n附加部分练习：按照上面的方法，再制作一个或的例子（熟练掌握）；使用其他的条件制作或且结合。\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "mwdybls",
            "timestamp": 1436329740,
            "txt_content": "好厉害的样子！可惜看不懂.."
        },
        {
            "author": "BakaSullivan",
            "timestamp": 1436329740,
            "txt_content": "晕了晕了"
        },
        {
            "author": "崔C氏",
            "timestamp": 1436331240,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "lzs1234",
            "timestamp": 1436333760,
            "txt_content": " 本帖最后由 lzs1234 于 2015-7-24 21:17 编辑 \n\n原来2B用的记分板啊…我都是用的逻辑门……\n或就是只要一个条件满足就设为1，然后探测1\n且就是满足一个条件就+1，直到加到某特定数值"
        },
        {
            "author": "丢失的钥匙",
            "timestamp": 1438831920,
            "txt_content": "MCBBS有你，世界更精彩!"
        },
        {
            "author": "langyo",
            "timestamp": 1439005440,
            "txt_content": "detect？\n\n什么鬼……\n\n且（&&）才是我最需要的判断模式你居然给了个让我们看不懂的Q.Q\n\n也找不到讲这货的链接233333……"
        }
    ]
}