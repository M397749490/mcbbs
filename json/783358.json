{
    "title": "[Tutorial][G-Second][应该全核心]从零开始的MC特效",
    "author": "602723113",
    "replyCount": 22,
    "timestamp": 1519141200,
    "txt_content": " 本帖最后由 602723113 于 2018-5-20 15:33 编辑 \n\n从零开始的MC特效目录:\n导读数学与Minecraft的融合利用数学在Minecraft中画一个圆利用数学在Minecraft中画一个球\n\n导读本教程需要读者有一定的空间想象能力(因为我也懒得画图了233)\n本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 核心\n在阅读之前请确保你具有高中数学必修4和Java基础的知识\n(没有我也会适当的解释的)\n\n<初中生>: 如果你是初中的话，别慌，你有函数的概念就可以读懂本教程(应该吧...)\n<高中生>: 如果你还未学到关于上面的两本书，别慌学到了再来看也行233 (雾\n数学与Minecraft的融合首先我们都知道Minecraft是一个3D游戏，所以它就有了XYZ这三个轴，那么我们可以看如下的一张图来了解一下\n\n\n\n本教程暂不涉及关于Y轴的相关内容，所以我们可以先从平面直角坐标系来分析\n\n利用数学在Minecraft中画一个圆以下内容需要sin函数与cos函数的相关知识！\n首先呢我们先来看一张图（自己用word画的2333）\n\n\n\n分析: \n     首先这个坐标系有一个单位圆(半径为1的圆)，然后我们看到角α为30°，之后点P的横坐标为 √3/2 纵坐标为 1/2，\n\n然后我们再看下图\n\n那么我们是否可以这么认为，点P的横坐标其实是 cos(30°) 而纵坐标就是 sin(30°)呢？\n> PI 代表圆周率π, 之后π = 180° (别问我为什么，课堂上自己学去233)\nP(cos(30°), sin(30°))， 弧度制: P(cos(PI/6), sin(PI/6))\n那么P的横坐标和纵坐标都是可以利用函数 cos和sin 求出，那么我们为什么不可以遍历一下把360°全部都给算出呢？所以我看写出下方的代码这样我们就可以把一周角里所有的角度都给遍历了一便，并且我们都算出了每个角度所对应的cos值和sin值吧，然后我们需要把他们作用到Minecraft当中\n\n// 我们把玩家脚下的location作为是原点O\nLocation location = player.getLocation();\nfor (int degree = 0; degree < 360; degree++) {\n    double radians = Math.toRadians(degree);\n    double x = Math.cos(radians);\n    double y = Math.sin(radians);\n}\n那么在上图的for循环语句块中我们有两个变量 x y，也就是 P(x, y) 吧，之后我们回头看一下for循环语句块外的那个变量location，那个我们可以理解成是在上图中的原点O，那么我们做个假设，我们需要把点P转换成MC中的Location要怎么做？，其实很简单\n\nlocation.add(x, 0, y);\n我们把location的X轴假想为0, Z轴假想为0（这里的X轴和Z轴指的是Minecraft中的那两个轴）即图中原点O为(0, 0)，那么在Minecraft中不可能任何时候原点的X Z轴都是0，所以我们需要做相加的操作\n*（上面可能会听得一头雾水，简单来说当原点O不为(0, 0)时，假设为(2, 2)，那么我们要做的是给玩家的周围建立圆吧，那么这时候点P的坐标应该为 P(2 + x, 2 + y)）\n\n> 要是还听不懂的话那就去喝杯茶，洗个澡吧2333\n\n那么我们可以做以下的操作了location.add(x, 0D, y);\n// 播放粒子\nlocation.getWorld.playEffect(location, Effect.HAPPY_VILLAGER, 1);\n// 为什么要减？因为我们要确保原点是不变的状态才可以哦~\nlocation.subtract(x, 0D, y);\n复制代码\n游戏内效果:\n\n完整代码:\n\n// 我们把玩家脚下的location作为是原点O\nLocation location = player.getLocation();\nfor (int degree = 0; degree < 360; degree++) {\n    double radians = Math.toRadians(degree);\n    double x = Math.cos(radians);\n    double y = Math.sin(radians);\n    location.add(x, 0, y);\n    location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);\n    location.subtract(x, 0, y);\n}\n\n\n利用数学在Minecraft中画一个球首先我们来观察一下sin的函数图像，具体如下\n\n图 2-1\n从上图可以看出 sin函数 始终在 1~-1 之间徘徊，所以我们认为它是有周期性的，那么这跟球的生成有什么联系呢？我们看下图\n图 2-2\n首先这是一个球对吧，然后呢我在球上画了几个横截面(才不是什么旋风)出来，那么通过上图我们是不是可以得出一个结论，一个球体其实是由无数个圆构成的？只是它们的半径不同对吧。那这跟sin函数有啥联系呢？\n\n首先我们回到sin的函数图像，我们看当x在0~π之间时连起来的y轴是不是像一个半圆啊？而且它们的半径(这里的半径可以理解为sin函数中的y轴)也是不同的，那么我们是不是可以这么认为，我们只需要 0 ~ π 之间的x值，然后代入函数当中就可以求出对应的y轴的值了？\n\n那么 0 ~ π 是什么值呢？其实在上面的圆中我就讲过 π=180°，所以我们求得其实就是 sin(0 ~ 180°)。\n\n那么有了上面的思路我们可以求出每个圆的半径对吧，那么我们写出下面的代码for (double i = 0; i < 180; i++) {\n    double radians = Math.toRadians(i);\n    double radius = Math.sin(radians);\n}\n在上方的代码当中我们求出了一个球中每个圆的半径, 但是我们还需要考虑一件事，我们是不是要规定一下每个圆之间的距离啊？\n\n那么我们引入cos的函数图像\n\n\n图 2-3 \n从上图可以看出 f(x) = cos(x), \n当x=0时, f(x)则为1.\n当x=π时，f(x)则为-1.\n\n那么我跟sin的函数图像联系一下, 在上面的代码中我们发现，radius的值是从小到大再到小，那么我们想一下，如果半径是小的那么那个圆是也是小的，而我们要画的圆是从上往下画的（观察图 2-2）对吧，所以我们是不是要给那个最小的圆的y轴是最高的？（没看懂？喝杯茶吧）而cos函数就可以帮我们达到这一点，所以我们写出以下的代码\n\ndouble y = Math.cos(radians);\n那么这样我们就可以获得当前for循环时那个圆的高度了。\n\n在上面的结构中我们得到了当前圆的半径和高度，那么我们要怎么通过这两个东西画出来呢？\n\n我们在第三章画圆时曾经做过这么一个操作\nfor (int degree = 0; degree < 360; degree++) {\n    double radians = Math.toRadians(degree);\n    double x = Math.cos(radians);\n    double y = Math.sin(radians);\n}\n上方的代码中我们只能制造出一个半径为1的圆，那么我们想扩大它的半径需要怎么做？\n\n我们这里又引入一个函数 y=Asin(ωx + φ) (这里的sin也可以为cos)，其实这个函数跟sin函数差不多只不过多了几个变量，那么这里我们只需要考虑A的值，\n\n为什么呢？我们来看一下这个函数在数学上的定义：\nφ（初相位）：决定波形与X轴位置关系或横向移动距离（左加右减）ω：决定周期（最小正周期T=2π/|ω|）A：决定峰值（即纵向拉伸压缩的倍数）\n\n由于这里我们只考虑A所以我们可以把上方的函数简写为 y = Asin(x)，假设我们的A为2，那就是sin(x) * 2了，那么反应在函数图像上是这样的\n\n\n那么有了上面的概念我们不妨使用 Math.cos(x) * 半径 来扩大本次循环时所对应的半径，所以我们写出以下的代码\nfor (double j = 0; j < 360; j ++) {\n    // 依然需要做角度转弧度的操作\n    double radiansCircle = Math.toRadians(j);\n    double x = Math.cos(radiansCircle) * radius;\n    double z = Math.sin(radiansCircle) * radius;\n}\n那么这样就可以控制好本次循环我们需要这个圆多少半径了，那么我们写好之后就可以放在Minecraft中看看效果\n完整代码:\n\nfor (double i = 0; i < 180; i++) {\n    // 依然要做角度与弧度的转换\n    double radians = Math.toRadians(i);\n    // 计算出来的半径\n    double radius = Math.sin(radians);\n    double y = Math.cos(radians);\n    for (double j = 0; j < 360; j++) {\n        // 依然需要做角度转弧度的操作\n        double radiansCircle = Math.toRadians(j);\n        double x = Math.cos(radiansCircle) * radius;\n        double z = Math.sin(radiansCircle) * radius;\n        location.add(x, y, z);\n        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);\n        location.subtract(x, y, z);\n    }\n}\n游戏内的效果:\n然后你就会发现你的游戏卡得一匹2333，因为我们是在360°全方位的进行渲染粒子的操作2333，但实际业务中我们可能并不需要做这种需求，那么我们就需要做一个关于跳跃的操作呗，我们看下面的代码\nfor (double i = 0; i < 180; i += 180 / 6) {\n    // 依然要做角度与弧度的转换\n    double radians = Math.toRadians(i);\n    // 计算出来的半径\n    double radius = Math.sin(radians);\n    double y = Math.cos(radians);\n    for (double j = 0; j < 360; j += 180 / 6) {\n        // 依然需要做角度转弧度的操作\n        double radiansCircle = Math.toRadians(j);\n        double x = Math.cos(radiansCircle) * radius;\n        double z = Math.sin(radiansCircle) * radius;\n        location.add(x, y, z);\n        location.getWorld().playEffect(location, Effect.HAPPY_VILLAGER, 1);\n        location.subtract(x, y, z);\n    }\n}\n跟上面的代码不同的是我在遍历的时候修改了步长(step)，那这一个有什么讲究呢？我们在每一次循环给 i 和 j就加的是30了对吧，而不是自加1，\n\n那么我们看第一层循环，这一层循环控制的步长其实是我们其实需要多少圈，为什么呢？我们看下面的图来理解一下\n\n\n\n这里我为了方便读者理解我把图 2-1 旋转了一下，上图我们假想黑点是玩家的location，那么那几个红点就是我们把步长修改后所得到的产物\n\n那么第二层循环我修改的步长又是什么意思呢？我们也拿张图来理解一下\n\n\n\n上图中每个角的度数都是30°，那么我修改了步长之后是不是我只会在这几个黑点上面做playEffect()的操作了？（看不懂的话喝口水再来看233）\n\n修改了步长后游戏内的效果:\n\n\n\n结语内容依然是挺少的。。希望能教给读者一些东西吧233 \n\n莫老搞事，只搞真实\n                                                                      —— 撰写: 一个来自普高文科的学生\n转载请站内PM\n[groupid=1401]G-Second:China[/groupid]",
    "replies": [
        {
            "author": "liuyipeng001",
            "timestamp": 1519142700,
            "txt_content": "location不是不可变类，这一点也不函数式编程（逃"
        },
        {
            "author": "leavessoft",
            "timestamp": 1519181820,
            "txt_content": "挺好的，今天去研究下怎么用"
        },
        {
            "author": "阴阳师元素祭祀",
            "timestamp": 1519394160,
            "txt_content": "location.add(x, 0D, y);\n// 播放粒子\nlocation.getWorld.playEffect(location, Effect.HAPPY_VILLAGER, 1);\n// 为什么要减？因为我们要确保原点是不变的状态才可以哦~\nlocation.subtract(x, 0D, y);\n能不能可以改成\nlocation.clone.add(x,0,y).getWorld().PlayerEffect(...);\n啊qwq"
        },
        {
            "author": "602723113",
            "timestamp": 1519469760,
            "txt_content": "阴阳师元素祭祀 发表于 2018-2-23 21:56\n能不能可以改成\nlocation.clone.add(x,0,y).getWorld().PlayerEffect(...);\n啊qwq\n这个是随意的, 反正播放梨子的方法也不之一个，不过建议还是使用ProtocolLib通过发包来做粒子播放的效果(卡客户端就行了233)"
        },
        {
            "author": "498525451",
            "timestamp": 1519554960,
            "txt_content": "JAVA刚刚学了一天。又看你发这教程，函数什么的。。。又想骗我学数学。。"
        },
        {
            "author": "弱鸡绿毛怪",
            "timestamp": 1519644660,
            "txt_content": "挠头\n满怀欣喜地过来瞅了两眼 结果第一行开始就看不懂了\n果然还是我数学太渣了吗。。。。（滑稽）"
        },
        {
            "author": "土球球",
            "timestamp": 1523123400,
            "txt_content": "球面上的采样建议使用Fibonacci采样算法，能够生成很好看的均匀格点。\n如果是基于经纬度的采样，那么最终会使得南北极点的采样点密度远远高于赤道。\n\n这是在线的演示（好玩的部分）：https://www.openprocessing.org/sketch/41142\n这是论文（根本看不懂的部分）：http://lgdv.cs.fau.de/uploads/pu ... cci_mapping_opt.pdf\n这是代码（还能看得懂的部分）：https://stackoverflow.com/questi ... r/26127012#26127012"
        },
        {
            "author": "woshilaji",
            "timestamp": 1523141100,
            "txt_content": "[应该全核心]\n\n应该?"
        },
        {
            "author": "弱鸡绿毛怪",
            "timestamp": 1525957680,
            "txt_content": "感谢莫老大佬的教程\n话说有续篇吗\n比如什么正方体圆台之类的粒子效果"
        },
        {
            "author": "RainIFunS",
            "timestamp": 1526088240,
            "txt_content": "高中数学学习顺序:\n必修1，必修4，必修5，必修2，必修3\n按照这个时间，应该学到必修2了"
        },
        {
            "author": "zeus2333",
            "timestamp": 1530509520,
            "txt_content": "莫老太强了"
        },
        {
            "author": "Takej",
            "timestamp": 1530524940,
            "txt_content": "6666666666"
        },
        {
            "author": "凛弦",
            "timestamp": 1530935940,
            "txt_content": "谢谢楼主的教程，顶一下"
        },
        {
            "author": "隔壁老吕",
            "timestamp": 1530940800,
            "txt_content": "根据莫老的教程和自己的理解就做出了翅膀粒子效果，谢谢莫老！"
        },
        {
            "author": "Not102",
            "timestamp": 1534645380,
            "txt_content": "这个小学能看懂？初中呢"
        },
        {
            "author": "RainIFunS",
            "timestamp": 1534675740,
            "txt_content": "602723113 发表于 2018-2-24 07:56\n这个是随意的, 反正播放梨子的方法也不之一个，不过建议还是使用ProtocolLib通过发包来做粒子播放 ...\n+1，服务器才是上帝，要卡就卡客户端"
        },
        {
            "author": "guo1060924736",
            "timestamp": 1552885140,
            "txt_content": "hhhh~楼主可以当高中教师了。相信特效开发时学数学比课堂上高效多了。不过还要提醒学生党的坛友搞编程要先学好数学噢~"
        },
        {
            "author": "s9hy_sky",
            "timestamp": 1562652840,
            "txt_content": "看不懂的话一直喝茶喝的都要尿频了#(滑稽)"
        },
        {
            "author": "南京扛把子",
            "timestamp": 1562692560,
            "txt_content": "感谢大佬分享"
        },
        {
            "author": "南京扛把子",
            "timestamp": 1562692800,
            "txt_content": "教程很详细 感谢大佬分享"
        },
        {
            "author": "【NightSky】",
            "timestamp": 1565332320,
            "txt_content": "支持作者！"
        },
        {
            "author": "1357207485",
            "timestamp": 1565576520,
            "txt_content": "完全看不到咋办，只能慢慢学"
        }
    ]
}