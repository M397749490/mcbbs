{
    "title": "[技术分享]关于MinecraftForge声音播放和加载机制的深入研究",
    "author": "LambdaNirvana",
    "replyCount": 6,
    "timestamp": 1428172320,
    "txt_content": "征呢忽然听闻就跑来决定顶一下话说AC现在什么情况了",
    "replies": [
        {
            "author": "DeathWolf96",
            "timestamp": 1428200100,
            "txt_content": "标题: [技术分享]关于MinecraftForge声音播放和加载机制的深入研究 本帖最后由 DeathWolf96 于 2015-4-5 10:47 编辑 \n\n\nLambda Innovation倾情奉献=3=\n\nyahoo，这里是狼的说，一只普通的modder~\n之前在写mod的过程中，还没有深究过Minecraft的声音系统，而是按照标准的创建json索引声音信息、再对World实例调用world.playSound(...)的一般方法来实现的。\n这种方法虽然很简便，但是在功能上也很简陋。比如说咱想实现一个循环播放多少时间然后自动停止的声音，然而根本没有看到这样的接口……\n出于种种原因，今天咱打算深入分析一遍MC的声音播放机制，顺便锻炼代码阅读能力（雾）。\n也希望自己的这次研究能对各位modder有所助益，少走手动反混淆和乱造轮子的弯路～～\n好啦，我们开始吧！\n\nP.S.本篇文章属于略微高级的主题。请确认你有基本的OO编程、Mod编程的知识。\nP.S.S.本篇文章比起教程来说还是更加具有参考或者杂文的风格。如果你需要学习声音的简单播放，看完【World接口分析】部分就好了。不过如果能看完整个部分的话，绝对会对mc的声音加载机制有深刻的理解的，当做一次小小的精神旅行又有什么不好呢？^^\n\n注：本贴中的一切代码研究都基于MinecraftForge 10.12.2.1121开发环境，不对所有的版本具有普遍性。\n\n1、普通的声音加载和播放方法回顾\n在1.7后，Minecraft的声音加载机制发生了比较大的变化。\n首先，你需要在你的mod包中的assets/xxx/中添加一个sounds.json，来索引（预加载）声音文件，它看起来大概是这样的：\n\n{\n\"deny\": {\"category\": \"master\", \"sounds\": [{\"name\": \"deny\", \"stream\": false}]},\n\"elec.weak\": {\"category\": \"master\", \"sounds\": [{\"name\": \"elec/arc_weak\", \"stream\": false}]},\n\"elec.strong\": {\"category\": \"master\", \"sounds\": [{\"name\": \"elec/arc_strong\", \"stream\": false}]},\n\"elec.mineview\": {\"category\": \"master\", \"sounds\": [{\"name\": \"elec/mineview\", \"stream\": false}]},\n...\n}\n复制代码\n之后，如果需要播放声音的话，只需要在有任一一个Entity或者World实例的情况下，调用它们的\nplaySoundXXX(String sndName, ...)复制代码\n方法即可。\n注册的每一个声音的名称是\"<namespace>:<sound_name>\"，其中namespace是你mod的资源命名空间的名字（在上面的实例中是xxx），sound_name是json里面每一个元素的键名(\"deny\", \"elec.weak\", ...)。\n\nEntity提供的接口：\nentity.playSound(String name, float volume, pitch)\n在实体的位置播放声音，后两个参数分别是音量和音高。\n展开它的源代码，可以发现它调用的其实是World.playSoundAtEntity(...)。\n注意：其实EntityPlayer进行了一个重载，它调用的是World.playSoundToNearExcept(...)。所以实际上，如果你在服务端调用这个函数的话，在自己的客户端是听不到声音的。（谁知道为什么这么设计呢╮(╯▽╰)╭）\n\nWorld提供的接口：\nWorld.playSoundAtEntity(Entity entity, String name, float volume, float pitch)\n在实体的位置播放一个声音。\n\nWorld.playSound(double x, double y, double z, String name, float volume, float pitch, boolean wtf)\n在指定的位置播放一个声音，但是多出了一个奇怪的布尔参数，并且forge没有给出注释。我们等会会详细考察这个参数的用途。\n\nWorld.playSoundEffect(double x, double y, double z, String name, float volume, float pitch)\n在指定的位置播放一个……声音效果？但是声音效果又是什么？它和声音又有什么区别呢？\n\nWorld.playSoundToNearExcept(EntityPlayer player, String name, double x, double y, double z, float volume, float pitch)\n玩家实例特化的播放声音方法。好像不会对玩家本身所在的客户端产生声音播放的样子。\n\n可以看到，从这里开始就已经产生歧义了。如果我要播放一个声音，到底是该用playSound还是playSoundEffect呢？如果两个都可以用，它们之间有什么区别呢？playSound函数中的那个奇怪的布尔参数是干什么用的呢？playSoundAtEntity和playSoundEffect的效果会不会有区别呢？莫慌，接下来让我们从最顶层的代码开始，一步一步深入，了解MC的声音播放机制是怎么实现的。\n\n1、从零开始：World接口分析\n那么，我们还是直接从和客户端程序员进行交互的World实例提供的方法开始研究。\n首先，你应该有关于C/S模型的基本知识。在Minecraft游戏的时候，不论是单人还是多人，总有两个World实例在同时运行。一个是客户端的World，负责还原世界的视觉效果等；一个是服务端的World，负责处理世界的”真正“计算。声音最终肯定是在客户端播放的，因此我们可以做出如下的推测：服务端的声音播放不会真正的干事，它只会通知所有客户端的世界去进行播放声音的工作；而客户端的世界真正执行播放声音的工作。有了这点基本假设，我们就可以开始阅读代码了。\n客户端的世界类是WorldClient，服务端的是WorldServer，它们的基类是World。进一步观察可以发现，WorldServer没有覆盖World的任何方法。因此，我们只需要注意两个地方：World和WorldClient。\n\n·World.playSound方法\n首先看World类，惊了：它的playSound方法居然是空的！这也就直接意味着，在服务端调用playSound方法是什么都不会发生的。\n然而，在WorldClient端有它的一个重载。这是经过手动反混淆之后的客户端声音播放代码：\n\n    public void playSound(double x, double y, double z, String name, float volume, float pitch, boolean delay)\n    {\n        double distSq = this.mc.renderViewEntity.getDistanceSq(x, y, z); //计算当前玩家到播放声音的位置的距离\n        PositionedSoundRecord psr = new PositionedSoundRecord(new ResourceLocation(name), volume, pitch, (float)x, (float)y, (float)z); //创建声音播放实例信息\n\n        if (delay && distSq > 100.0D) { //如果声音播放有延迟，并且声音距离和玩家距离大于10\n            double d = Math.sqrt(d3) / 40.0D;\n            this.mc.getSoundHandler().playDelayedSound(psr, (int)(d * 20.0D)); //回调soundHandler，在(距离*0.5）tick后播放声音\n        } else {\n            this.mc.getSoundHandler().playSound(psr); //回调soundHandler，播放声音\n        }\n    }\n复制代码\n现在我们知道那个奇怪的布尔参数是啥了：是否延迟播放声音。\n可以看到，这段代码已经开始调用到一个名叫SoundHandler的类了。所有关于声音的进一步处理都会在SoundHandler类里进行。\n总结：World.playSound在server端没有意义，在client端则会进一步执行播放动作。\n\n·World.playSoundEffect方法\n这个方法在WorldClient也没有被覆盖，所以它在客户端和服务端的行为是一致的。……真的是这样么？\n我们看看playSoundEffect的代码吧：\n\n    public void playSoundEffect(double x, double y, double z, String name, float volume, float pitch)\n    {\n        for (int i = 0; i < this.worldAccesses.size(); ++i) { //遍历所有worldAccess实例\n            ((IWorldAccess)this.worldAccesses.get(i)).playSound(name, x, y, z, volume, pitch);\n        }\n    }\n复制代码\n可以看到，这段代码自己并没有做什么有意思的事。相对的，它把锅丢给了自己所拥有的IWorldAccess，让它执行了播放声音这个具体的动作。\nIWorldAccess只是一个接口，实现它的又是什么东西呢？笔者在客户端和服务端分别打印了World.worldAccesses列表的内容，发现是这样的：\n客户端：[net.minecraft.client.renderer.RenderGlobal]\n服务端：[net.minecraft.world.WorldManager]\n哦。所以，这个方法在客户端和服务端的行为还是有很大不同的。在服务端，它调用了WorldManager.playSound；在客户端，它调用了RenderGlobal.playSound。\n让我们接下来看看这两个类的playSound又具体干了什么吧——\n服务端：\n这是WorldManager里的代码：\n\n    public void playSound(String name, double x, double y, double z, float volume, float pitch) {\n        this.mcServer.getConfigurationManager().sendToAllNear(x, y, z, volume > 1.0F ? (double)(16.0F * volume) : 16.0D, this.theWorldServer.provider.dimensionId, new S29PacketSoundEffect(name, x, y, z, volume, pitch));\n    }\n复制代码\n可以看到，这个方法的本质是发送packet（网络包）到附近的客户端，让它们播放声音。它创建了一个S29PacketSoundEffect包（包含声音播放的一切必要信息），然后把它发送给了那个x, y, z位置附近的玩家。\n那么这个包被谁处理了呢？经过一番跳转，发现在NetHandlerPlayerClient类里做了这个包的处理（也仅有这个类做了）：\n\n    public void handleSoundEffect(S29PacketSoundEffect p_147255_1_) {\n        this.gameController.theWorld.playSound(p_147255_1_.func_149207_d(), p_147255_1_.func_149211_e(), p_147255_1_.func_149210_f(), p_147255_1_.func_149212_c(), p_147255_1_.func_149208_g(), p_147255_1_.func_149209_h(), false);\n    }\n复制代码\n我就不反混淆了，这有点心塞。。总之，接到这个包以后，mc在客户端调用了world.playSound方法。\n\n客户端：\n这是RenderGlobal里的代码：（吐槽：这取名方式，渲染器为啥要处理音效播放啊天啊噜）\n\npublic void playSound(String par1Str, double par2, double par4, double par6, float par8, float par9) {}\n复制代码\n惊了，再次惊了。RenderGlobal里的playSound竟然是一个空方法！\n这也就意味着，你在客户端调用World.playSoundEffect是毫无意义的！\n\n总结：World.playSoundEffect在client端没有意义，在server则会进行发包，让所有附近的client都被调用World.playSound方法。\n·playSoundAtEntity方法\n这个方法中可以看到这样的代码：\n\n    for (int i = 0; i < this.worldAccesses.size(); ++i) {\n        ((IWorldAccess)this.worldAccesses.get(i)).playSound(par2Str, par1Entity.posX, par1Entity.posY - (double)par1Entity.yOffset, par1Entity.posZ, par3, par4);\n    }\n复制代码\n那么可以明白，这个方法只是绕了个弯子调用了IWorldAccess.playSound方法而已，它和World.playSoundEffect方法完全相同，因此可以忽略它。\n\n·playSoundToNearExcept方法\n用和之前相似的分析可以发现，这个方法在client端不进行任何动作，在server端则是对除调用玩家实例以外的附近玩家发送了一个S29PacketSoundEffect包。所以，它的功能和playSoundEffect是相近的，只不过它确实会不让声音在那个玩家处播放。\n\n是不是有点晕了？停几分钟总结一下吧。基本上：\nplaySoundAtEntity和playSoundToNearExcept可以忽略，而playSoundEffect只在服务端有动作（发包），playSound只在客户端有动作。\n吐槽：Forge你什么鬼畜命名方式！！这么起名字谁知道用哪个啊！不分析肯定会用错啊摔！\n\n2、渐入佳境：SoundHandler和SoundManager\n经过上面对World的分析，我们知道了这么几件事：\n·要播放声音，你应该在客户端调用World.playSound，或在服务端调用World.playSoundEffect。\n·不论哪种播放方式，调用链最终都会到达WorldClient.playSound，在那里，Minecraft.getSoundHandler().playSound(...)方法会被调用。\n也就是说，我们接下来只需要研究getSoundHandler()返回值所代表的类——SoundHandler就可以了。\n\n而SoundHandler专注丢锅100年：\n\n    /**\n     * Play a sound\n     */\n    public void playSound(ISound isound) {\n        this.sndManager.playSound(isound);\n    }\n复制代码\n它直接把ISound实例丢给了自己保存的sndManager，其他啥都没干。\n等等，ISound是啥？\n回到之前WorldClient的代码：\n\nPositionedSoundRecord psr = new PositionedSoundRecord(new ResourceLocation(name), volume, pitch, (float)x, (float)y, (float)z); //创建声音播放实例信息\n复制代码\n哈，这样就明白了。PositionSoundRecord是一个实现了ISound的类，而MC用这个类来处理一般的声音播放信息，所以传过来的时候，就已经是一个ISound接口了。\n\n看看ISound接口提供了什么信息：\n\npublic interface ISound\n{\n    ResourceLocation getPositionedSoundLocation();\n    boolean canRepeat();\n    int getRepeatDelay();\n    float getVolume();\n    float getPitch();\n    float getXPosF();\n    float getYPosF();\n    float getZPosF();\n    ISound.AttenuationType getAttenuationType();\n}\n复制代码\n声音的ResourceLocation，坐标，音量音高。等等，貌似还有些有趣的参数……衰减类型、是否重复播放、重复播放的延迟？卧槽声音系统还可以干这些事啊！\n研究到这里咱也是有些小期待了，如果能用mc自带的接口做循环播放什么的那真是事半功倍啊。好了，继续继续~\n\n接下来我们回到正题，看SoundManager的playSound方法。\n呃，这个方法……很臭很长，所以我们不贴代码了，直接贴简化过的伪代码。这样可以更清楚看到调用的过程：\n*注意：略去了一些无关紧要的错误检测。尽管如此代码还是很令人烦躁，你可以直接略过看分析，影响不大。\n\npublic void playSound(ISound snd) {\n    SoundEventAccessorComposite accessor = this.sndHandler.getSound(snd.getPositionedSoundLocation());\n    if (accessor == null) {\n        警告输出：未注册的声音;\n    } else {\n        SoundPoolEntry entry = accessor.getEntry(); //***从之前的accessor获取声音的 资源文件\n        if (entry == SoundHandler.missing_sound) {\n             警告输出：注册了声音，但是没有找到;\n        } else {\n            float volume = snd.getVolume();\n            float wtf = 16.0F; //谜之参数，可能是衰减系数之类？\n            if (volume > 1.0F) wtf *= volume;\n            SoundCategory category = accessor.getSoundCategory(); //获取声音分类\n            float normalizedVolume = this.getNormalizedVolume(snd, entry, category); //获取标准化后的音量\n            double normalizedPitch = (double)this.getNormalizedPitch(snd, entry); //获取标准化后的音高\n            ResourceLocation res = entry.getSoundPoolEntryLocation(); //获取声音资源路径\n            if (normalizedVolume == 0.0F) {\n                logger.debug(marker, \"Skipped playing sound {}, volume was zero.\", new Object[] {res});\n             } else {\n                boolean isLooping = snd.canRepeat() && snd.getRepeatDelay() == 0; //这个声音是否需要一直不停的循环\n                String randUUID = UUID.randomUUID().toString(); //*****获取一个随机的UUID，作为这次声音播放的唯一标识符\n                //Create the buffer for this rand UUID.\n                if (entry.isStream()) { //这个声音需要作为流播放（较长的声音，比如唱片）\n                    this.sndSystem.newStreamingSource(false, randUUID, getURLForSoundResource(res), res.toString(), isLooping, snd.getXPosF(), snd.getYPosF(), snd.getZPosF(), snd.getAttenuationType().getTypeInt(), wtf);\n                    MinecraftForge.EVENT_BUS.post(new PlayStreamingSourceEvent(this, snd, randUUID));\n                } else { //这个声音直接丢入缓存被播放（一般声音，音效）\n                     this.sndSystem.newSource(false, randUUID, getURLForSoundResource(res), res.toString(), isLooping, snd.getXPosF(), snd.getYPosF(), snd.getZPosF(), snd.getAttenuationType().getTypeInt(), wtf);\n                     MinecraftForge.EVENT_BUS.post(new PlaySoundSourceEvent(this, snd, randUUID));\n                }\n\n                logger.debug(marker, \"Playing sound {} for event {} as channel {}\", new Object[] {entry.getSoundPoolEntryLocation(), accessor.getSoundEventLocation(), randUUID});\n                //设置声音系统的状态\n                this.sndSystem.setPitch(randUUID, (float)normalizedPitch);\n                this.sndSystem.setVolume(randUUID, normalizedVolume);\n                this.sndSystem.play(randUUID);\n                \n                //更新一些查询信息（当前播放的声音表等）\n                this.playingSoundsStopTime.put(randUUID, Integer.valueOf(this.playTime + 20));\n                this.playingSounds.put(randUUID, snd);\n                this.playingSoundPoolEntries.put(snd, entry);\n                 if (category != SoundCategory.MASTER) {\n                    this.categorySounds.put(category, randUUID);\n                }\n                if (snd instanceof ITickableSound) {\n                     this.tickableSounds.add((ITickableSound)snd);\n                }\n            }\n        }\n    }\n}\n复制代码\n实际上，所有的播放动作就在这一个函数中被完成了。尽管代码有点长，但是我们还是归纳出了它大概干了什么。有几点是我们必须注意到的：\n1 它从SoundHandler中获取了一个SoundEventAccessorComposite，并且由它来进行一些资源存在性的判断。\n2 它使用一个UUID来标示每一个播放事件。\n3 它将这个播放的声音的信息更新到了一些表上，这表明它后面应该还需要检查并且更新播放信息。\n4 它使用getURLForSoundResource来获取**真正的**声音文件流，传递给声音系统。\n\n我们首先来看看2和3。进一步观察SoundManager类，发现在updateAllSounds()里会更新当前播放的声音的信息，伪代码大概是这样的：\n\npublic void updateAllSounds() {\n遍历tickableSounds表，并且更新所有TickableSound的声音信息（如果停止播放了，则循环播放或移除）;\n遍历playingSounds表，并且更新所有playingSound的信息（如果停止播放了，则循环播放或移除);\n遍历delayedSounds表，如果某个声音打达到了播放的时间，开始播放;\n}\n复制代码\n果然和我们在3中的猜测相符。注意到里面的TickableSound处理。这也就意味着我们可以在任意时刻改变一个声音的特性，包括音量和音高。以及，一般的Sound和TickableSound都可以循环播放（虽然有可能很麻烦，不过mc提供了这样的接口）。\n\n那么，声音系统在明面上干的事大概就到此为止了。然而，我们还有最后的一根线没有串联起来：疑点1。SoundEventAccessorComposite是什么？它是在哪里创建的？这个疑点也把它和最初的”声音缓存“的概念联系起来。json文件是在哪里处理的？处理以后变成了什么？\n接下来，我们就会步入声音系统分析的最后一个部分：一般声音的加载方法。\n\n3、柳暗花明：一般声音的加载方法。\n于是，我们开始追踪SoundEventAccessorComposite这个类的来龙去脉。其实楼主在这个逻辑里绕了半天，曾一度被mc的代码所困而不可自拔……总之，很绕啦。所以我们还是直接看分析的结果吧：\n首先，SoundHandler.getSound(ResourceLocation src)会回调它的sndRegistry实例的getObject(src)方法。这个方法会直接查一个HashMap，返回对应的结果。\n其次，我们发现这个sndRegistry在SoundHandler的注册事件中被修改了：在SoundHandler.onResourceManagerReload(IResourceManager par1ResourceManager)方法中，它打开了每一个资源空间所对应的sounds.json，并且遍历加载了里面的所有声音，其核心调用代码是：\n\nthis.loadSoundResource(new ResourceLocation(s, (String)entry.getKey()), (SoundList)entry.getValue());\n复制代码\n当然，这之前已经用了Gson的反序列化机制，把json的声音列表还原成SoundList对象了。\nSoundList对象本身并没有什么神奇的，就是一个存放声音信息的列表：\n\nprivate final List<SoundEntry> sounds = new ArrayList<SoundEntry>(); //声音列表\nprivate boolean replaceExisting; //是否替换已经存在的声音\nprivate SoundCategory category; //声音类别\n复制代码\n所以，soundList被传到了loadSoundResource方法中，这个方法又干了什么呢？\n它的代码又臭又长，这时候我们就要请出伪代码大法：　\n\n    private void loadSoundResource(ResourceLocation location, SoundList soundList) {\n        SoundEventAccessorComposite soundeventaccessorcomposite;\n\n        if (this.sndRegistry.containsKey(location) && !soundList.canReplaceExisting()) { //如果该声音已经存在\n            soundeventaccessorcomposite = (SoundEventAccessorComposite)this.sndRegistry.getObject(p_147693_1_);\n        } else {\n            soundeventaccessorcomposite = new SoundEventAccessorComposite(location, 1.0D, 1.0D, soundList.getSoundCategory());\n            this.sndRegistry.registerSound(soundeventaccessorcomposite); //如果是新创建的SEAC，注册到sndRegistry里\n        }\n\n        for (final SoundList.SoundEntry soundentry : soundList) { //遍历soundList\n            Object object = 根据soundentry的EntryType，创建一个正确的ISoundEventAccessor;\n            soundeventaccessorcomposite.addSoundToEventPool((ISoundEventAccessor)object); //加入\n        }\n    }\n复制代码\n总结一下：获取（如果已经存在并且不覆盖）或者创建一个SoundEventAccessorComposite，遍历这个SoundList里的所有entry，并且将它们正确加载以后加入这个composite当中。并且，这个SoundEventAccessorComposite被加入sndRegistry的表中，以供之后每次播放的查询。\n到此为止，整个声音播放路径的分析就告一段落了，而SoundEventAccessorComposite的作用也变得明晰：它允许存储一堆真正（真的代表一个声音路径）的ISoundEventAccessor，并且在实际播放的时候随机的返回一个声音。如果你往更深的地方探究，这里的随机算法实际上是有权重的，不过咱们就先不深究了>)\n\n总结，未完问题的探究\n到这里，我们终于对Minecraft的声音播放机制有了一个完整的认识。它的调用路径大概如下：\n（服务端：World.playSoundEffect）->客户端：World.playSound->Minecraft.sndHandler.playSound->SoundHandler.sndManager.playSound->从sndRegistry获取注册好的SoundEventAccessorComposite，用它随机获取一个音效进行播放\n注册链：SoundHandler.loadSoundResource(...)->Json反序列化->一堆<ResourceLocation, SoundList->推送到SoundHandler.sndRegistry\n更新和回收链：SoundHandler.updateAllSounds()->各个表的更新\n\n不深入探究的话或许永远没有办法看到事物背后的本质。尽管笔者研究了一晚上肝到凌晨两点，不过能把这一整个系统梳理通感觉还是非常开心的。不知道乃看到这里的时候感觉如何呢？\n最后，我们来解决一下我们一开始留下的问题吧：\n如何实现一个循环播放多少时间然后自动停止的声音？\n\n由现在的知识，我们知道，Minecraft自己已经提供了一个循环播放的接口。然而，我们却没有明确的通过World访问这个接口的方法。要使用循环播放功能，我们必须实现一个自己的ISound接口，并且在canRepeat()方法处返回true。当然，这带来一个很显然的问题：\n·你没法使用MC原生的网络同步，也就是说，你要么只在本机播放自定义声音，要么自己写同步的逻辑。\n所以，要写一个自定义声音的同步就意味着你得自己写一个信息包……开始变得有些烦人了呢。不过，即便如此，上面的工作还是在理论上变得可行了。并且通过对系统完整的分析，我们基本可以确定这是最简单的方法。\n\n实际上，对于MC自己的自定义声音，它也是这么处理的，比如说MovingSoundMinecart，就只是在客户端被播放的。\n\n之前在说updateAllSounds的时候，我们提到了一个遍历tickableSounds表的动作，却没有提到它具体处理的是什么。\n实际上，它处理的是ITickableSound对象。ITickableSound是一类可以每个tick进行一定更新动作的声音。它可以更新自己的音量和音高，并且声音系统会实时的将这些更新更新到SoundSytem中。\nMC原生的矿车移动的音效就是这么实现的（在每个tick判断矿车移动的速度，并且提升或降低音量）。\n用这个接口可以实现一些比较复杂的声效，但是代价是，你得自己写同步，或者完全放弃同步。\n\n于是到这里，这个帖子基本可以告一段落了。我们从最上层的World的声音调用接口开始，一路分析到了SoundHandler的播放机制和声音加载机制。MC的代码并不是完美的，比如说自定义声音得全部自己处理同步，就是它的缺陷之一。相信读到这里的你，已经对MC的声音播放系统有了全面的了解~嘛嘛，应该会觉得有所收获的吧？\n\n那么，这篇分析贴就到此为止了~以后有时间的话咱还会陆续写一些类似的技术分享的哟！民那桑，再会~\n\n最后：黑MC\n你知道矿车的音效是怎么处理的么？？？？\n\n    /**\n     * Called when a player mounts an entity. e.g. mounts a pig, mounts a boat.\n     */\n    public void mountEntity(Entity par1Entity)\n    {\n        super.mountEntity(par1Entity);\n\n        if (par1Entity instanceof EntityMinecart)\n        {\n            this.mc.getSoundHandler().playSound(new MovingSoundMinecartRiding(this, (EntityMinecart)par1Entity));\n        }\n    }\n复制代码\n说真的，看到这段代码的时候我差点没把桌子掀了。\n对于初学者来说这可能是绝对合理的代码，但是如果是对面向对象有经验的人，绝对会捂脸爆头痛哭……\n·这段代码耦合度极高。\n·这段代码将不相关的内容（坐上实体和播放声音）强行揉到了一起。\n对于只有一个实体有自定义声音的情况，那可能还好。但是万一以后你要增加更多的有自定义声音的实体呢？\n\nif(entity instanceof EntityA) {\n...\n} else if(entity instanceof EntityB) {\n...\n} else if(entity instanceof EntityC) {\n...\n} else if(entity instanceof EntityC) {\n...\n}\n...\n复制代码\n你不会真的想写这样的代码吧。\n这样的代码的最大坏处就是你把执行同一功能的代码分散到了许多难以维护的地方。假设某一天你需要删掉这个声音的功能，你真的能想起来它在【坐上实体的函数】里么？\nMC的代码有的时候写的真的很糟糕，所以参考需谨慎。\nC++大法好，退mod坑保平安。（雾\n总之，大家在modding的时候还是要注意自己的代码的简洁清晰度，在制作内容的时候也务必养成作为一个程序员的好代码习惯哦~~\n\nFin\n如果这篇文章的内容对乃有所帮助的话，还请支持一下哟~~=3=\n"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1428200520,
            "txt_content": "神清气爽的感觉www 睡觉~"
        },
        {
            "author": "lichi2050",
            "timestamp": 1428200940,
            "txt_content": "DeathWolf96 发表于 2015-4-5 03:22\n神清气爽的感觉www 睡觉~\n我看到最后脑子好像热了一下，介绍的真详细 真不愧是一只”普通的modder“。\n准备下吃喝，然后重新认真阅读下。。。 丰富的经验啊~"
        },
        {
            "author": "GTVZDH123",
            "timestamp": 1428219840,
            "txt_content": "哇！真是的，这么会编程，我都不会唉..."
        },
        {
            "author": "zero28",
            "timestamp": 1428271440,
            "txt_content": "阅..................╮(╯▽╰)╭好吧我承认我没认真看完"
        },
        {
            "author": "硫酸泡吊",
            "timestamp": 1556962680,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽\n"
        }
    ]
}