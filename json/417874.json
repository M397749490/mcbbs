{
    "title": "MC1.7.2客户端启动源代码学习",
    "author": "cisumer",
    "replyCount": 1,
    "timestamp": 1425350220,
    "txt_content": "        昨天的帖子被无情的删除了{:10_528:}，那今天就直接进入主题吧，这样应该不会误导新人了吧。关于MCP和eclipse请不会配置的同学自行在论坛查找相关教程。PS：我也是边读源代码边写，会不定期的更新后续部分，所以不作为教程，欢迎大家讨论。零基础慎入！\n        得到MC的源代码后，MCP提供了一个Start类模拟启动器，作用是调用MC真正的主类Main：\npublic static void main(String[] args)\n{\nMain.main(concat(new String[] {\"--version\", \"mcp\", \"--accessToken\", \"0\", \"--gameDir\", \"jars\"}, args));\n}复制代码       这个代码的意义相当于在命令行下把启动参数传给了Main，那这些参数有什么意义呢，我们进入到Main的代码来看一看     OptionParser op = new OptionParser();\n        op.allowsUnrecognizedOptions();\n        op.accepts(\"demo\");\n        op.accepts(\"fullscreen\");\n        ArgumentAcceptingOptionSpec<String> serverOp = op.accepts(\"server\").withRequiredArg();\n        ArgumentAcceptingOptionSpec<Integer> portOp = op.accepts(\"port\").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(25565), new Integer[0]);\n        ArgumentAcceptingOptionSpec<File> gameDirOp = op.accepts(\"gameDir\").withRequiredArg().ofType(File.class).defaultsTo(new File(\".\"), new File[0]);\n        ArgumentAcceptingOptionSpec<File> assetsDirOp = op.accepts(\"assetsDir\").withRequiredArg().ofType(File.class);\n        ArgumentAcceptingOptionSpec<File> resourcePackDirOp = op.accepts(\"resourcePackDir\").withRequiredArg().ofType(File.class);\n        ArgumentAcceptingOptionSpec<String> proxyHostOp = op.accepts(\"proxyHost\").withRequiredArg();\n        ArgumentAcceptingOptionSpec<Integer> proxyPortOp = op.accepts(\"proxyPort\").withRequiredArg().defaultsTo(\"8080\", new String[0]).ofType(Integer.class);\n        ArgumentAcceptingOptionSpec<String> proxyUserOp = op.accepts(\"proxyUser\").withRequiredArg();\n        ArgumentAcceptingOptionSpec<String> proxyPassOp = op.accepts(\"proxyPass\").withRequiredArg();\n        ArgumentAcceptingOptionSpec<String> usernameOp = op.accepts(\"username\").withRequiredArg().defaultsTo(\"Player\" + Minecraft.getSystemTime() % 1000L, new String[0]);\n        ArgumentAcceptingOptionSpec<String> uuidOp = op.accepts(\"uuid\").withRequiredArg();\n        ArgumentAcceptingOptionSpec<String> accessTokenOp = op.accepts(\"accessToken\").withRequiredArg().required();\n        ArgumentAcceptingOptionSpec<String> versionOp = op.accepts(\"version\").withRequiredArg().required();\n        ArgumentAcceptingOptionSpec<Integer> widthOp = op.accepts(\"width\").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(854), new Integer[0]);\n        ArgumentAcceptingOptionSpec<Integer> heightOp = op.accepts(\"height\").withRequiredArg().ofType(Integer.class).defaultsTo(Integer.valueOf(480), new Integer[0]);\n        NonOptionArgumentSpec localNonOptionArgumentSpec = op.nonOptions();\n        OptionSet localOptionSet = op.parse(par0ArrayOfStr);复制代码       MC使用了OptionParser来解析启动参数，这个类是JOptSimple提供的。关于这个工具大家可以自行百度/谷歌。\n        这么多参数为什么Start类只写了三个？我们在Start的代码中把\"--version\", \"mcp\", 删掉，然后执行，控制台输出：\n        Missing required option(s) ['version']\n        这说明version这个参数是必须的，在解析参数的代码中仔细看就会发现，只有version和accessToken加了required()，这就表示它们是必须的。而gameDir是游戏路径，默认是当前路径（在eclipse中是项目的根目录）。其实最小的启动项只需要两个，但是因为一般从MCP反编译过来的游戏路径是Jars文件夹，所以这个也不能省略{:10_523:}。\n        回到Main类，解析好参数后，就是获取参数值，然后初始游戏设置。首先做的是设置代理\nProxy proxy = Proxy.NO_PROXY;\n\n        if (proxyHost != null){\n            try{\n                proxy = new Proxy(Type.SOCKS, new InetSocketAddress(proxyHost, ((Integer)localOptionSet.valueOf(proxyPortOp)).intValue()));\n            }\n            catch (Exception e){\n            }\n        }\n\n        final String proxyUser = (String)localOptionSet.valueOf(proxyUserOp);\n        final String proxyPass = (String)localOptionSet.valueOf(proxyPassOp);\n\n        if (!proxy.equals(Proxy.NO_PROXY) && isNotEmpty(proxyUser) && isNotEmpty(proxyPass))\n        {\n            Authenticator.setDefault(new Authenticator()\n            {\n                private static final String __OBFID = \"CL_00000828\";\n                protected PasswordAuthentication getPasswordAuthentication()\n                {\n                    return new PasswordAuthentication(proxyUser, proxyPass.toCharArray());\n                }\n            });\n        }复制代码       上面的代码为Java的网络连接设置好代理服务器，当然了没有配置代理的话这里就会直接跳过。\n        接下来是分别获取窗口宽、高，全屏，游戏路径等等。再下面的代码就是最关键的两句\nSession session = new Session((String)usernameOp.value(localOptionSet), uuid, (String)accessTokenOp.value(localOptionSet));\n        Minecraft mc = new Minecraft(session, width, height, isFullScreen, isDemo, gameDir, assetsDir, resourcepacksDir, proxy, version);复制代码       分别实例化了Session对象和Minecraft对象，Session对象用于保存用户信息，而Minecraft对象就是游戏的主体对象，负责加载资源、启动和管理游戏线程。我们可以看到最后一行是mc.run();复制代码       就是真正的启动了游戏线程。\n        现在回到Start类把version重新加上，然后我们直接运行，控制台输出：\n[09:54:00] [main/INFO]: Setting user: Player43\n[09:54:00] [main/INFO]: (Session ID is token:0:Player43)\n[09:54:00] [Client thread/INFO]: LWJGL Version: 2.9.0\n[09:54:02] [Client thread/INFO]: Reloading ResourceManager: Default\n\nStarting up SoundSystem...\nInitializing LWJGL OpenAL\n    (The LWJGL binding of OpenAL.  For more information, see http://www.lwjgl.org)\nOpenAL initialized.\n\n[09:54:03] [Sound Library Loader/INFO]: Sound engine started\n[09:54:04] [Client thread/INFO]: Created: 512x256 textures/blocks-atlas\n[09:54:05] [Client thread/INFO]: Created: 256x256 textures/items-atlas\n[09:54:08] [MCO Availability Checker #1/ERROR]: Couldn't connect to Realms\n复制代码        熟悉的游戏界面也打开了\n         到这里MC启动部分的源代码就学习完了，有兴趣的同学可以研究启动器了，其实就是用于拼接启动参数的一个程序。PS：我下载的MC自带了MHCL2.1.9，运行时可以发现它生成了一个bat文件，而这个bat文件里就是java 命令+启动参数拼接。",
    "replies": [
        {
            "author": "普通HIM",
            "timestamp": 1425352620,
            "txt_content": "不错QwQ\n我本来想到这找几个人拉进小组的..."
        }
    ]
}