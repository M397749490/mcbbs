{
    "title": "[CBL∫2b]Loottable - 创造一个看脸看玄的世界 Ⅱ实例与详解",
    "author": "⭐✔️",
    "replyCount": 20,
    "timestamp": 1470915240,
    "txt_content": " 本帖最后由 贰逼 于 2018-8-29 22:26 编辑 \n\nLoottable（可抢夺物品列表）是1.9+中的一个新特性，主要靠调用外置json文件实现对物品奖励获取的随机.\n第二章内将会向各位介绍Loottable中的实例与详解\n\nChm版本：http://pan.baidu.com/s/1c1U4804 （若.chm遇到问题下载压缩文件）\n全部章节总索引\n上一章 结构与标签下一章 技术性提示\n\n人生第一个Loottable\n看了之前结构与标签的基本介绍，我们现在就可以写一个简单的Loottable了：\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码没错，这就是最简单的一个Loottable，下面我们来逐步分析一下这个Loottable讲了什么.\n\n首先随机池列表中只有一个随机池，这个随机池里的项目列表中只有一个项目——石头.\n唯一的随机池只从它的项目列表中选取一次物品，并且项目列表中唯一的项目石头的权重为1.\n所以实际效果就是该Loottable的结果必然是一个石头.\n\n建立Loottable文件夹\n如果我们要在游戏中调用Loottable，我们先必须学会如何建立一个Loottable文件夹，以便调用Loottable\n首先我们需要找到存档的文件夹\n\n\n\n\n1.png (14.06 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:13 上传\n\n\n\n\n\n进入存档文件中的data文件夹\n\n\n\n\n2.png (8.91 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:13 上传\n\n\n\n\n\n新建一个名为“loot_tables”的文件夹\n\n\n\n\n3.png (1.52 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:13 上传\n\n\n\n\n\n\n在其中创建一个子文件夹，在loot_tables文件夹里一个子文件夹就代表一个命名空间（此时命名空间为“test”）\n\n\n\n\n4.png (2.47 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:06 上传\n\n\n\n\n\n\n在命名空间内新建一个json文件，并粘贴之前的Loottable作为内容.该json文件名是Loottable的名字（此时名字为“a”）\n当然也可以在这个命名空间再建子文件夹，子文件夹中建立Loottable，也是允许的.\n\n新建json文件可以靠代码编写软件，也可以直接新建一个文本文档并将.txt改成.json.\n\njson可以直接靠打开方式选择记事本打开.\n\n调用Loottable\n进入该存档，接下来介绍如何调用Loottable\n\n首先我们要知道Loottable路径表达式怎么写.\n标准写法：\n[命名空间]:[Loottable名] 或者 [命名空间]:[子文件夹名]/[Loottable名]\n例如刚才的示例：\ntest:a\n就是路径表达式.（当然这是第一种写法）\n值得一提的是如果没有命名空间，默认命名空间就是minecraft.例如entities/creeper，代表默认的爬行者掉落物.\n\n接下来我们可以靠NBT调用Loottable了.\n有两个NBT：LootTable(string)和DeathLootTable(string)\n第一个LootTable标签用于大部分容器，而第二个DeathLootTable标签用于实体.\n后面的string处需要填写的就是Loottable路径表达式.\n/setblock ~ ~ ~ minecraft:chest 附加值 模式 {LootTable:\"test:a\"}复制代码\n\n\n\n\n21.png (49.13 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:09 上传\n\n\n\n\n\n/summon Zombie ~ ~ ~ {DeathLootTable:\"test:a\"}复制代码\n\n\n\n\n22.png (118.94 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:17 上传\n\n\n\n\n\nFunction 1 随机附魔/随机等级附魔/烤熟的物品\nenchant_randomly随机附魔\n    ┕ enchantments（列表）：能够附上的魔 （默认为能与对应物品匹配的附魔）<blockquote>{复制代码\n\n\n\n\n31.png (53.65 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:19 上传\n\n\n\n\n\n随机结果预览这个标签不会规定附魔的等级，随机的等级范围也只是该附魔的最大等级（在非NBT修改的情况下）\nenchant_with_levels随机附魔的等级\n    ┕ treasure（布尔）：是否能随机到宝藏附魔（例如冰霜行者和修理）    ┕ levels（整型）：随机附魔的等级    ┕ levels（列表）：随机附魔的等级范围        └ min（整型）：随机附魔的最小级        └ max（整型）：随机附魔的最大等级\n<blockquote>{复制代码\n\n\n\n\n2016-07-30_15.07.28.png (50.49 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:11 上传\n\n\n\n\n\n结果预览这个等级不是附魔等级，而是能够附魔所需要的经验等级.所以你只能随机到普通附魔.如果开启treasures，那么宝藏附魔也能够被随机到.\nfurnace_smelt\n无子项目，内容：将被烤熟的物品\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:fish\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:furnace_smelt\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n\n\n\n\n2016-07-30_15.14.29.png (45.09 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:19 上传\n\n\n\n\n所有能被冶炼/烤熟的物品都能被这个功能涉及.（例如土豆或者原木或者钻石原矿）Function 2 抢夺附魔数量影响/物品属性\nlooting_enchant数量影响（适用于实体）\n    ┕ limit（整型）：抢夺附魔后额外最大掉落的数量    ┕ count（整型）：抢夺附魔后额外掉落的数量    ┕ count（列表）：抢夺附魔后额外掉落的数量范围        └ min（整型）：抢夺附魔后掉落最小的数量        └ max（整型）：抢夺附魔后掉落最大的数量\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:wool\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:looting_enchant\",\n                            \"count\": 1,\n                            \"limit\": 3\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n掉落羊毛，初始1个，抢夺后额外1个，最大3个.\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:wool\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:looting_enchant\",\n                            \"count\": {\n                                \"min\": 3,\n                                \"max\": 5\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n掉落羊毛，初始1个，抢夺后额外3~5个，没有限制.\n\nset_attributes物品属性修改器\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:diamond_sword\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_attributes\",\n                            \"modifiers\": [\n                                {\n                                    \"attribute\": \"generic.attackDamage\",\n                                    \"name\": \"Damage\",\n                                    \"amount\": {\n                                        \"min\": 1.0,\n                                        \"max\": 1.5\n                                    },\n                                    \"operation\": \"addition\",\n                                    \"slot\": [\n                                        \"mainhand\",\n                                        \"offhand\"\n                                    ]\"id\": \"00000000-0000-0001-0000-000000000001\"\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\nNBT和具体效果就不讲解了，和原来的属性NBT相同，除了amount增加了最小和最大的选项.（详情站内本版内搜索物品属性）\n\nFunction 3 数量/工具损害值/物品附加值\nset_count数量\n    ┕ count（整型）：物品的具体数量    ┕ count（列表）：物品的随机数量范围        └ min（整型）：物品最小的数量        └ max（整型）：物品最大的数量\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_count\",\n                            \"count\": 10\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n\n\n\n\n2016-07-31_09.26.31.png (32.79 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:23 上传\n\n\n\n\n\n也就是一定产出十个石头（排列不一定整齐）\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_count\",\n                            \"count\": {\n                                \"min\": 10,\n                                \"max\": 20\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n\n\n\n\n2016-07-31_09.29.30.png (52.31 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:23 上传\n\n\n\n\n也就是一定产出10~20个石头（排列不一定整齐）图中一共14个\nset_damage损害\n    ┕ damage（浮点）：物品（工具）的剩余耐久的比率.也就是剩余的耐久/最大耐久.（1.0就是是没有损害，0.0就是没耐久了）    ┕ damage（列表）：剩余耐久的比率的范围        └ min（浮点）：剩余耐久比率最小值        └ max（浮点）：剩余耐久比率最大值\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:iron_sword\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_damage\",\n                            \"damage\": {\n                                \"min\": 0.5,\n                                \"max\": 1\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n\n\n\n\n2016-07-31_09.37.36.png (40.97 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:15 上传\n\n\n\n\n一定有一把铁剑，但它耐久值是从125~250之间随机的.\nset_data物品附加值\n    ┕ data（整型）：物品（非工具）的附加值    ┕ data（列表）：附加值的范围        └ min（整型）：附加值的最小值        └ max（整型）：附加值的最大值\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:wool\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_data\",\n                            \"data\": {\n                                \"min\": 0,\n                                \"max\": 15\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n\n\n\n\n2016-07-31_09.42.58.png (25.31 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:23 上传\n\n\n\n\n\n这个就是随机一个颜色的羊毛（附加值0~15）\n值得一提的是这里的附加值并不能作为工具的附加值（也就是damage），所以如果要给工具设置damage，必须靠set_damage.Function 4 NBT和自定义NBT\nset_nbt数据标签\n    ┕ tag（字符串）：物品的tag标签后的内容\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:\"a\",Lore:[\"b\"]}}\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]}}\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n两个是一样的，都是名为a，信息为b的石头.只是如果你在其中使用了需要转义的字符必须使用转义符.\n这里的tag其实也支持自定义NBT比如我加了一个对原版无任何影响的NBT：a\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]},a:1}\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n刷出来的结果：\n\n\n\n\n2016-07-31_10.16.41.png (47.01 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:18 上传\n\n\n\n\n\n如果使用\n\n/testfor @e[type=Item,c=1] {Item:{tag:{a:1}}}复制代码\n\n\n\n\n2016-07-31_10.17.30.png (206.44 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:26 上传\n\n\n\n\n该自定义NBT的物品可以被检测.\nCondition 1 实体死亡/实体分数\n在了解Condition之前需要知道下面三个选择器：\nthis、killer和killer_player\n\nthis代表附上Loottable的实体，也就是死亡的实体；\nkiller就是杀死该实体的实体，不只是玩家；\nkiller_player必须是玩家.\n（在Condition中不提供图片演示） （主要是条件不好模拟出来← ←）\n\nentity_properties死亡条件\n\n    ┕ entity（字符串）：选择器，选择实体    ┕ properties（复合）：满足条件        ┕ on_fire（布尔）：选择的实体是否着火下面通过这个Condition来演示Condition三种情况\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]}}\"\n                        }\n                    ]\n                }\n            ],\n            \"conditions\": [\n                {\n                    \"condition\": \"minecraft:entity_properties\",\n                    \"entity\": \"this\",\n                    \"properties\": {\n                        \"minecraft:on_fire\": true\n                    }\n                }\n            ]\n        }\n    ]\n}复制代码这个conditions条件列表在A Pool下，控制该随机池的调用\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]}}\"\n                        }\n                    ],\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:entity_properties\",\n                            \"entity\": \"killer\",\n                            \"properties\": {\n                                \"minecraft:on_fire\": true\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码这个conditions条件列表在A Entry下，控制该项目的调用\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]}}\",\n                            \"conditions\": [\n                                {\n                                    \"condition\": \"minecraft:entity_properties\",\n                                    \"entity\": \"killer_player\",\n                                    \"properties\": {\n                                        \"minecraft:on_fire\": true\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n复制代码\n这个conditions条件列表在A Function下，控制该功能的使用回到这个Condition的写法上，on_fire填true或false就是判定是不是着火entity后面只能填之前说的三个选择器.如果on_fire填true，那么分别判定该实体、击杀该实体的实体和击杀该实体的玩家是不是着火的，如果着火就调用条件列表的父级.\nentity_scores实体分数\n    ┕ entity（字符串）：选择器，选择实体    ┕ scores（复合）：满足分数    ┕ A score（整型）：一个具体分数，把'A score'改成计分板名.    ┕ A score（复合）：一个范围分数，把'A score'改成计分板名.        ┕ min（整型）：值域中最小值        ┕ min（整型）：值域中最大值\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:cobblestone\",\n                    \"weight\": 1,\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:entity_scores\",\n                            \"entity\": \"killer_player\",\n                            \"scores\": {\n                                \"b\": 1,\n                                \"a\": {\n                                    \"min\": 5,\n                                    \"max\": 10\n                                }\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n复制代码\n满足的条件就是b计分板分数=1，a计分板分数在5和10之间（包括5和10）Condition 2 被玩家杀死\nkilled_by_player被玩家杀死\n\n    ┕ inverse（布尔）：是否反向选择，判断不是被玩家杀死的\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:cobblestone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:furnace_smelt\",\n                            \"conditions\": [\n                                {\n                                    \"condition\": \"minecraft:killed_by_player\",\n                                    \"inverse\": false\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}\n复制代码\n判断是被玩家杀死的.\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:cobblestone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:furnace_smelt\",\n                            \"conditions\": [\n                                {\n                                    \"condition\": \"minecraft:killed_by_player\",\n                                    \"inverse\": true\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n判断不是被玩家杀死得，包括被其他实体杀死和自然死亡（摔死淹死等）\n\nCondition 3 二次随机点数\nrandom_chance随机几率\n\n    ┕ chance（浮点）：此处填写一个0.0~1.0的数值（叫做点数）.系统会生成一个0.0~1.0的随机数，与这里填写的数值比较.若小于该数值则成功.比如填写1.0，那么必然成功.如果填写0.8，只有80%的概率.{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"quality\": 3,\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:random_chance\",\n                            \"chance\": 0.5\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:diamond\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n尽管随机的权重为1，但只有50%几率得到石头\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:furnace_smelt\",\n                            \"conditions\": [\n                                {\n                                    \"condition\": \"minecraft:random_chance\",\n                                    \"chance\": 0.5\n                                }\n                            ]\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n在这个实例里，首先有一个石头，虽然权重为1，但只有50%几率获得.另外一个石头权重也是1.因此我们可以算算获得石头的概率：没有石头-首先抽中了第一个石头，也就是50%概率.接着点数大于0.5，又是50%概率，所以几率为25%.1个-第一种情况是抽中第一个石头，点数没有大于0.5，25%几率；第二种情况是抽中了第二个石头，因为是必得，所以总的来说50%几率；加起来75%几率.\n之所以叫该条件为稳定二次随机，是因为在一个项目下该条件点数可以结合权重实现更精确的概率微调；\n如果该条件和一个随机池结合，那么随机池也是靠点数来调用；同理一个功能也是如此.Condition 3 二次随机（抢夺）\nrandom_chance_with_looting抢夺影响判定\n\n    ┕ chance（浮点）：此处填写一个0.0~1.0的数值（叫做基础点数）.    ┕ looting_multiplier:（浮点）：抢夺等级的乘数系统会生成一个0.0~1.0的随机数，与下面公式算出来的值比较.若小于则成功.chance + looting_level * looting_multiplier\n\n也就是：基础点数+抢夺附魔等级*等级乘数\n\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:furnace_smelt\",\n                            \"conditions\": [\n                                {\n                                    \"condition\": \"minecraft:random_chance_with_looting\",\n                                    \"chance\": 0.2,\n                                    \"looting_multiplier\": 0.1\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n此处使用抢夺3附魔，掉落石头的概率就是：0.2+3*0.1=0.5\n\n该condition也是稳定二次随机，相比之下引入了抢夺.\n\nEntry 1 物品\n作为随机项目，主要是针对物品。\n事实上在前面我们已经举了很多例子，现在我们需要用上所有Entry中使用的结构来完整的呈现一个物品列表：\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"quality\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft: set_count\",\n                            \"count\": {\n                                \"min\": 0,\n                                \"max\": 1\n                            }\n                        }\n                    ],\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft: killed_by_player\"\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft: diamond\",\n                    \"weight\": 1,\n                    \"quality\": 3,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_count\",\n                            \"count\": {\n                                \"min\": 0,\n                                \"max\": 1\n                            }\n                        }\n                    ],\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:killed_by_player\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n下面来分析这个Loottable\n首先只有一个随机池，随机池只会选择一次物品；\n物品列表两个物品，一个是石头，一个是钻石；\n石头的权重为1，权重增值为1；钻石权重为1，权重增值为3（也就是当你幸运2时，石头真实权重为3，钻石却变成了7）\n两者获得条件都是被玩家击杀，而且两者都有50%数量为0（也就是无）.\n\nEntry 2 空\n将项目设为空，可以帮助我们初步的稳定概率，所以可以说属于是稳定一次随机.\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"empty\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n这个实例里，我们抽中石头的几率只是50%，另外50%为空.\n\n空，是Entry中一个补位，用于控制随机，可以结合后面的内容稳定概率.\n比如实体如果要让物品随机掉落，请注意控制Entry适当为空的几率，否则将必然掉落物品；\n\nEntry 3 随机概率计算\n为了平衡物品，难免必须用到概率计算，在学习计算之前，再来总结总结一次随机和二次随机.\n也许你还对之前提到的一次随机，二次随机不了解，下面就来总结总结：\n一次随机\n是对项目列表中项目的第一次随机，也就是靠真实权重来判定的随机：\n真实权重=（权重+权重增值*幸运值）\n\n二次随机\n是进一步对该项目的取舍随机，例如Function中set_count，和Condition中的random_chance/random_chance.\n\n下面进入正式计算阶段，来看两个例子：\n抽中一个项目的概率\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:stone\",\n                    \"weight\": 1,\n                    \"quality\": 3,\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:random_chance\",\n                            \"chance\": 0.5\n                        }\n                    ]\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:diamond\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码这个就是之前Condition3中的例子，引入了权重增值.\n\n如果你要计算抽中一个项目的概率，你可以使用下面的方法：\n先来看一次随机，石头权重就是=（1+3*幸运值），而钻石始终为1，\n那么一次随机中石头概率为(1+3*幸运值)/(2+3*幸运值)\n接着来看二次随机，此处二次随机是随机点数，所以石头只有50%概率不为空.\n那么总共石头的概率就是(1+3*幸运值)/(4+6*幸运值).\n\n公式：\n      一个项目的真实权重=（该项目权重+该权重增值*幸运值）\n      random_chance = 随机点数【随机点数】或者（基础点数+抢夺附魔等级*等级乘数）【抢夺判定】\n      一个项目的概率=（一个项目真实权重/项目列表真实权重总和）* random_chance * (1-set_count中选中0的概率)\n*注解：set_count选中0的概率靠这样计算：例如min:0,max:10，那么一共可能有11种数量结果，那么选中0的概率就是1/11.\n当然，这种方法也可以用于三次随机（function中的condition），也就是继续在后面乘上随机点数：\n      带功能的一个项目的概率=（一个项目真实权重/项目列表真实权重总和）* random_chance【对于Entry】 * (1-set_count中选中0的概率) * random_chance【对于Function】\n抽一个项目后某一个数量的概率\n公式套用前面的，只是略微改动：（设这个数量为n）\n\n      一个项目的概率=（一个项目真实权重/项目列表真实权重总和）* random_chance * (中选中n的概率)\n\n      带功能的一个项目的概率=（一个项目真实权重/项目列表真实权重总和）* random_chance【对于Entry】 * (set_count中选中n的概率) * random_chance【对于Function】\nPool 随机抽取原理\n在一个随机池中，只能有一个项目列表，每次从项目列表中抽取一个项目.\nroll的次数就是抽取次数.\n而项目列表中项目的weight和quality决定了该项目抽到的几率.\n\n结合function和condition，也许抽取的项目为空，或者貌似多个项目；或者下面讲到调用loottable，事实上都是一个项目.\n\n一个项目≠一个物品，一个项目只是抽取的结果.\n\n\n\n\n30.png (1.39 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:26 上传\n\n\n\n\n\n\n（每次抽取的项目也许包含n个子项目，也可能继续随机抽取）\n\n所以打破该误区之后，将会在下面loottable一节中运用这种概念来完成更复杂的随机列表.\n\nPool 随机列表滚动值\n你可以理解为一个骰子，每滚动一次最后随机抽取一个点数.\n当然滚动值不是这个滚动所得点数，也不是权重，更不能理解成为项目中物品数量翻多少倍\n滚动值就是投掷骰子的次数，近似的理解为抽取多少项目（可重复），\n准确来说是抽取项目列表中一个项目的次数.\n\nrolls:1\n就是抽取一次（滚动值默认为0）\nrolls:10\n就是抽取十次\n\nbonus_rolls就是幸运值对滚动值的影响\n最终真实滚动值实际上是向下取整（rolls+bonus_rolls*幸运值）\nrolls:3 本来抽取3次\nbonus_rolls:1.5之后\n如果幸运值=1，就是抽取4次。如果幸运值=2，就是抽取6次。\n\nLoottable嵌套\n一个标准嵌套实例\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:b/a\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:a\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n嵌套中调用的loottable分别是命名空间test中文件夹b的a和a\n两者随机到的权重相同\n\n意义\n从逻辑上使结构更清晰\n从技术上避免了冗杂的填写物品，可以将多物品进行打包（建立一个loottable）操作\n\n嵌套解析\n比如loottable1嵌套了一个loottable2\n我们知道了loottable选取一个项目的步骤是：\nLootable→所有Pools→选取Entry\n\n那么嵌套一个loottable，事实上就是将这个过程*2\n\nLootable1→所有loottable1的Pools→选取loottable2→所有loottable2的Pools→选取Entry\n\nLoottable循环嵌套\n既然Loottable支持嵌套，那么如果Loottable1套着Loottable2，而Loottable2又有Loottable1会怎么样呢：\n以上所述的Loottable2都是：\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable1\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n\n有三种情况\n项目无限循环\n如果Loottable2作为项目，物品在另一个池中\nLoottable1:\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable2\",\n                    \"weight\": 1\n                }\n            ]\n        },\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:wool\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n那么Loottable1无限调用，直到溢出：（实体掉落未尝试，也许会崩，也许什么事也没发生）\n\n\n\n\nQQ图片20160810112901.png (9.62 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:38 上传\n\n\n\n\n\n\n普通调用\n如果项目和调用Loottable在同一个池中\nLoottable1:\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable2\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:wool\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n那么在嵌套调用过程中，如果抽中了物品将会停止无限循环\n也就是最后只有一个物品\n\n\n\n\nQQ图片20160810113723.png (4.34 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:38 上传\n\n\n\n\n\n容器\nLoottable1:\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:chest\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{LootTable:test:loottable2}\"\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n那么容器会不断调用Loottable1,也就是无限箱子\n\n\n\n\nQQ图片20160810113819.png (4.96 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:38 上传\n\n\n\n\n\n\n\n\n\nQQ图片20160810113821.png (2.99 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:38 上传\n\n\n\n\n\n\nLoottable与多个池与溢出\n多个池\n\n\n\n\n\n34.png (3.99 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:37 上传\n\n\n\n\n\nPool在LootTable中是并列的，每个Pool必然会选中（若无条件）\nEntry在Pool中是独立的，只能选中一个\n多个池支持让Loottable更丰富\n\nLoottable嵌套与多个池\n嵌套进入多个池，能使一个Loottable调用多个Loottable\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:b/a\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable3\",\n                    \"weight\": 1\n                }\n            ]\n        },\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable3\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n这样该loottable就调用了loottable2和3.\n\n而如果Loottable1中有n个随机池，每个随机池中都有必然选中的Entry，且该项目是Loottable2，Loottable2中，那么就有了一个溢出的问题。\n\n溢出（实体掉落无此问题）\n在前面的问题中，loottable1中n个随机池都调用loottable，如果lootable2中项目是m个，\n那么总物品数量≥mn个，如果总物品超过容器容量上限，那么保留的物品有什么原则？\n溢出后的物品只取Lootable中从上至下的顺序所选取的项目的物品.\n\n因为每次选择项目时给其中每个物品都分配一个随机的slot，\n从上至下顺序是读取json的顺序，那么每次读取一个项目，都有一个上面的分配过程，直到分配物品超过随机slot.\n\n在写loottable中一定要留意父子级的调用造成的溢出给随机物品带来的影响，尤其是在一个loottable中出现总物品较多的情况下.\nLoottable防溢出和分配物品\n因为有溢出物品规则的存在，如果随机的物品总数大于了容器单元总数，所的物品仍旧不是随机的.\n\n为了防止溢出，我们可以对Pools中随机池的总数，以及Pool中的Rolls进行控制，\n首先我们需要检测是否存在溢出的可能：\nRolls总数=该Loottable或所有调用的底Loottable（最低级）的Rolls（Rolls_max）总数\n如果一个Loottable的Rolls总数＞容器单元总数，那么总有溢出的可能.\n\n对于溢出，有两种方法分配物品：\n1.将多个并列Pool中的Entry合并\n2.减少Rolls次数\n\n\n\nLoottable作为项目中物品的概率\n计算概率是平衡物品一个十分重要的过程，再看本片之前首先要看前面的Entry3\n\n事实上作为嵌套，随机概率的算法也是嵌套的.\n公式：对于n个嵌套loottable\n\n    一个项目的真实权重[n]=（该项目权重+该权重增值*幸运值）\n      random_chance[n] = 随机点数【随机点数】或者（基础点数+抢夺附魔等级*等级乘数）【抢夺判定】\n      一个loottable的概率=（一个项目真实权重[n]/项目列表真实权重总和[n]）* random_chance[n] * (1-set_count中选中0的概率[n])\n*注解：set_count选中0的概率靠这样计算：例如min:0,max:10，那么一共可能有11种数量结果，那么选中0的概率就是1/11.\n总的来说，概率的算法就是（loottable1中抽到loottable2的概率）*（loottable2中抽到loottable3的概率）*……*（loottablen-1中抽到loottablen的概率）\nLoottable概率调整及平衡物品\n如果一个物品破坏了地图的平衡性，我们可以通过调整概率来平衡物品.\n比如以下三个Loottable嵌套关系：\nLoottable0\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable1\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"empty\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}\nLoottable1\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"test:loottable2\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"empty\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}\nLoottable2\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:diamond\",\n                    \"weight\": 1\n                },\n                {\n                    \"type\": \"empty\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n这里随机到钻石的概率是0.125，如果我想时概率降低到0.1，先要计算出所有非底级Loottable中随机到该Loottable的概率：\n0.25\n接着通过理想概率/这个值的到该物品理想权重比例：\n0.1/0.25=0.4\n接着计算出项目列表中其他项目权重总和：\nempty总和为1\n接着用其他项目权重总和/(1-理想权重比例)*理想权重比例得出最后权重：\n1/(1-0.4)*0.4≈0.67\n\nLoottable文件夹管理\n当你建立一个复杂的loottable体系时，嵌套是不可或缺的.\n\n而Loottable文件夹的管理，关系到了往复调用中是否能够逻辑清晰：\n\n\n\n\n35.png (47.11 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-11 19:40 上传\n\n\n\n\n\n地心之路中使用的物品loottable，由于loottable只能支持二级文件，路径不能无限子文件夹，因此你可以把文件夹分细一点.（地心之路loottable嵌套级别为3）（目前支持无限子文件夹了）\n例如在此处我将每一种类物品都归纳进入一个命名空间，这样再调用的时候结构分明.\n（每一个子loottable的内容都只有一个权重为1的对应物品）\n\n做完了这个步骤，再可以写更高一级的loottable\n\nLoottable父子调用与完整Loottable包的制作\n拿地心之路作为例子；\n子：\n一把剑\n{\n    \"pools\": [\n        {\n            \"rolls\": {\n                \"min\": 1,\n                \"max\": 1\n            },\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:iron_sword\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"set_damage\",\n                            \"damage\": {\n                                \"min\": 0.02,\n                                \"max\": 0.02\n                            }\n                        },\n                        {\n                            \"function\": \"set_nbt\",\n                            \"tag\": \"{Unbreakable:1,AttributeModifiers:[{Operation:0,UUIDLeast:1,UUIDMost:1,Amount:5.5,AttributeName:generic.attackDamage,Name:Attack},{Operation:0,UUIDLeast:1,UUIDMost:1,Amount:0,AttributeName:generic.attackSpeed,Name:Speed}],ench:[{id:16,lvl:1}],HideFlags:63,display:{Name:\\u00a77\\u00a7l\\u94c1\\u5251,Lore:[\\u00a77\\u00a7n\\u524d\\u4eba\\u7684\\u9057\\u7269]}}\"\n                        },\n                        {\n                            \"function\": \"set_count\",\n                            \"count\": {\n                                \"min\": 1,\n                                \"max\": 1\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n必得物品.\n\n父：\n{\n    \"pools\": [\n        {\n            \"rolls\": {\n                \"min\": 1,\n                \"max\": 1\n            },\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"supply_food:1\",\n                    \"weight\": 1\n                }\n            ]\n        },\n        {\n            \"rolls\": {\n                \"min\": 1,\n                \"max\": 1\n            },\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"weapon_dagger:a\",\n                    \"weight\": 6\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"weapon_sword:a\",\n                    \"weight\": 3\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"weapon_gun:1\",\n                    \"weight\": 1\n                }\n            ]\n        },\n        {\n            \"rolls\": {\n                \"min\": 1,\n                \"max\": 1\n            },\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"supply_medicine:1\",\n                    \"weight\": 1\n                }\n            ]\n        }\n    ]\n}复制代码\n随机中随机到的（weapon_sword:a）几率只有3/10\n\n顶级：\n{\n    \"pools\": [\n        {\n            \"rolls\": {\n                \"min\": 1,\n                \"max\": 1\n            },\n            \"entries\": [\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"supply:a\",\n                    \"weight\": 5\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"weapon:a\",\n                    \"weight\": 4\n                },\n                {\n                    \"type\": \"loot_table\",\n                    \"name\": \"ragbag:a\",\n                    \"weight\": 2\n                }\n            ]\n        }\n    ]\n}复制代码\n概率（weapon:a）是4/11\n\n那么随机到该剑的概率只有：3/10*4/11=6/55\n\n完整包的制作\n结合前面文件夹管理，嵌套n级（顶级）→嵌套n-1级→……→嵌套子级（底级）\n\n如果需要平衡物品，结合前面的概率计算出所有物品的实际概率，接着改变顶级中的概率（如果改变底级的概率将会造成对于其他调用中波动很大）\n\n关于Seed\n如果你不想每一次更新Loottable都是随机的物品，那么你可以用一个Seed来规定调用loottable时的随机种子，让Loottable按相同种子随机.\n也就是说每次随机的物品都是确定且相同的.\n\n例如：\nsetblock ~ ~1 ~ minecraft:chest 0 0 {LootTable:\"minecraft:chests/jungle_temple\",LootTableSeed:100L}复制代码\n那么每次从jungle_temple中抽取物品不是随机的，而是依靠随机种子100L的物品.\n\n下面分析以下两个标签：\nLootTableSeed：长整型，是对于容器来说Loottable的随机种子.\nDeathLootTableSeed：长整型，是对于实体来说Loottable的随机种子.\n如果后面填0L，那么相当于没有种子，依旧是完全随机.\n\nSeed的用途就是让随机产生的物品成为一个种子产生的特定物品，而不是每次更新了容器、实体都完全随机.\n\n关于幸运值\n幸运值由下面几个项目来呈现：\nluck药水效果、unluck药水效果、物品属性generic.luck、海之眷属附魔.\n最终幸运值公式：\nOperation:2（属性的效果为提升百分比）：(luck药水效果-unluck药水效果)*generic.luck+海之眷属附魔；\nOperation:0（属性的效果为提升值）：luck药水效果-unluck药水效果+generic.luck+海之眷属附魔；\n\n*注：海之眷属附魔只适用于钓鱼机制.\n\n结合指令1 实体抽奖机\n顾名思义，通过Loottable的实体随机掉落来制作抽奖机.\n尽管要调用外置资源，但是待抽取的物品十分丰富，只需要拟写一份Loottable即可.\n\nRoll:\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"diamond\",\n                    \"weight\": 5\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"gold_ingot\",\n                    \"weight\": 10\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"iron_ingot\",\n                    \"weight\": 25\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"coal\",\n                    \"weight\": 60\n                }\n            ]\n        }\n    ]\n}复制代码\n接着\n/summon Zombie ~ ~ ~ {DeathLootTable:\"Roll:Roll\",CustomName:\"Roll\",Silent:1b}复制代码\n按下一次按钮就\n/kill @e[type=Zombie,name=Roll]复制代码\n即可\n\n\n\n\n2016-08-20_10.14.06.png (271.42 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-20 09:43 上传\n\n\n\n\n\n\n\n\n\n2016-08-20_10.14.53.png (283.74 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-20 09:45 上传\n\n\n\n\n\n注意不要关闭实体掉落\n\n结合指令2 随机器\n刷怪笼拟写很麻烦，@r随机器需要进行实体列阵穷举，由于Loottable也是随机性，可以结合指令制作一个随机器\nRoll:\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"diamond\",\n                    \"weight\": 5\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"gold_ingot\",\n                    \"weight\": 10\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"iron_ingot\",\n                    \"weight\": 25\n                },\n                {\n                    \"type\": \"item\",\n                    \"name\": \"coal\",\n                    \"weight\": 60\n                }\n            ]\n        }\n    ]\n}复制代码\n这个随机器就有四个穷举对象，物品：钻石，金锭，铁锭，煤.\n概率分别是5% 10% 25% 60%\n\n利用实体抽奖机的方法，\n/summon Zombie ~ ~ ~ {DeathLootTable:\"Roll:Roll\",CustomName:\"Roll\",Silent:1b}复制代码\n随机一次就\n/kill @e[type=Zombie,name=Roll]复制代码\n接着检测掉落物\n\n然后产生输出\n\n\n\n\n2016-08-20_10.19.40.png (243.23 KB, 下载次数: 0)\n\n下载附件\n\n2016-8-20 09:46 上传\n\n\n\n\n\n/testfor @e[type=Item] {Item:{id:\"minecraft:coal\"}}复制代码cond:/execute @p say 1复制代码\n结合指令3 判定条件死亡\n因为有DeathLootTable，在实体死亡后可以调用Loottable产生掉落物，结合Conditions我们可以进行复杂的死亡条件检测.\n{\n    \"pools\": [\n        {\n            \"rolls\": 1,\n            \"entries\": [\n                {\n                    \"type\": \"item\",\n                    \"name\": \"minecraft:potato\",\n                    \"weight\": 1,\n                    \"functions\": [\n                        {\n                            \"function\": \"minecraft:set_nbt\",\n                            \"tag\": \"{display:{Name:a,Lore:[b]}}\"\n                        },\n                        {\n                            \"function\": \"minecraft:furnace_smelt\"\n                        }\n                    ],\n                    \"conditions\": [\n                        {\n                            \"condition\": \"minecraft:killed_by_player\",\n                            \"inverse\": false\n                        },\n                        {\n                            \"condition\": \"minecraft:entity_properties\",\n                            \"entity\": \"this\",\n                            \"properties\": {\n                                \"minecraft:on_fire\": true\n                            }\n                        }\n                    ]\n                }\n            ]\n        }\n    ]\n}复制代码\n这样，只需要检测一个名为a，附注为b的烤土豆就能知道这个实体在着火的情况下被玩家杀死：\n/scoreboard players tag @e[type=Item] add tag {Item:{id:\"baked_potato\",tag:{display:{Name:a,Lore:[b]}}}}\ncond:操作\n/kill @e[tag=tag]复制代码\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "Olurbo",
            "timestamp": 1470915840,
            "txt_content": "看脸？毕竟我脸好"
        },
        {
            "author": "leavessoft",
            "timestamp": 1470917940,
            "txt_content": "没看懂，被1.9新特性吓退了已经"
        },
        {
            "author": "NeverC",
            "timestamp": 1470918060,
            "txt_content": "这....我什么都看不懂，这个是CB的么？"
        },
        {
            "author": "无奈丶屮艸",
            "timestamp": 1470925980,
            "txt_content": "只玩1.8以下的表示一脸懵逼"
        },
        {
            "author": "彪悍的新手",
            "timestamp": 1471047180,
            "txt_content": "看起来不错\n学习一下"
        },
        {
            "author": "chyx",
            "timestamp": 1471358100,
            "txt_content": "目录有一行错位了 请修理"
        },
        {
            "author": "chyx",
            "timestamp": 1471358820,
            "txt_content": "\n\nLoottable循环嵌套这一节我没有重复出无限调用 可能是因为我在1.10 moj不让循环引用了\n\n\n普通调用也是有的时候没有物品 而不是总有物品"
        },
        {
            "author": "chyx",
            "timestamp": 1471359120,
            "txt_content": "而且 我有一个疑问\nset_attributes在1.9快照时期被加入了\n但您举得\n\n\n“Loottable父子调用与完整Loottable包的制作” 中的地心之路的例子却在nbt里指定了属性 这是否说明nbt优先于这个function？还是并列的？附魔属性和setnbt又有什么关系？"
        },
        {
            "author": "ruhuasiyu",
            "timestamp": 1474891020,
            "txt_content": "function1 的第一段代码挂了"
        },
        {
            "author": "fengjingMC",
            "timestamp": 1475416260,
            "txt_content": "现在1.10.2里可以很多层嵌套了，反正我试了一下八层没问题……希望lz改一下\n{LootTable:start:one/two/three/four/five/six/seven/eight/end}复制代码"
        },
        {
            "author": "jimmy1234",
            "timestamp": 1475577060,
            "txt_content": "我竟然看懂了！\n太不可思议了！\n好像总索引的名字和这个不一样\n看脸讲玄 or 看脸看玄？"
        },
        {
            "author": "_Rainbow_",
            "timestamp": 1501496940,
            "txt_content": "原来是自己创么。。一脸黑线"
        },
        {
            "author": "ShiGuangChong",
            "timestamp": 1502456400,
            "txt_content": "(⊙v⊙)嗯......很简单的表示"
        },
        {
            "author": "BlackCB.",
            "timestamp": 1502940420,
            "txt_content": "制造看脸看玄的世界？？（一脸懵逼）\n\n然而连计分板都不太懂的我表示看不懂。。。"
        },
        {
            "author": "MC北辰",
            "timestamp": 1512626700,
            "txt_content": "感谢，MCBBS有你更精彩~"
        },
        {
            "author": "Hytrophoton",
            "timestamp": 1518067500,
            "txt_content": "箱子无限嵌套是不是少了一个BlockEntityTag"
        },
        {
            "author": "5352",
            "timestamp": 1581865440,
            "txt_content": "你这是写的1.12的吗？1.13的呢"
        },
        {
            "author": "5352",
            "timestamp": 1582429500,
            "txt_content": "怎么加多个函数？"
        },
        {
            "author": "Skyngard",
            "timestamp": 1582440540,
            "txt_content": "脸黑啊，awa qwq\n"
        },
        {
            "author": "wangduo110",
            "timestamp": 1582450860,
            "txt_content": "一脸懵逼的进来 一脸懵逼的出去"
        }
    ]
}