{
    "title": "[Wiki][PCD][[/]]Spigot Wiki 翻译 & 插件开发指南",
    "author": "海螺螺",
    "replyCount": 7,
    "timestamp": 1501165800,
    "txt_content": " 本帖最后由 754503921 于 2017-8-7 02:07 编辑 \n\nSpigot Wiki 翻译\n原地址\n顶部目录字体可点！！\n\n\n大坑开始于 2017-7-14\n目前字数统计 Total 23619 汉字\n@754503921 19921 汉字\n@Smokey_Days 983 汉字\n@1345979462 2715 汉字\n我决定提前发，要翻译什么可以回复，我会优先翻译\n否则就是从上到下顺序翻译\n注：代码由于论坛新特性，不是第一页的代码都很爆炸，不怪我\n关于 Spigot原文\n\n什么是 SpigotMC？\n成立于 2012，SpigotMC.org 是 Minecraft 最大的服务器软件项目背后的社区，提供了给包括服务器主在内的所有人一个寻求帮助、互相支持、展示自己的平台。我们提供了网络论坛、聊天室和维基百科，提供了支持和项目构建的服务，并希望你也能加入这个巨大且不断扩张的、超过300000 个成员的大家庭。\n\n我们提供什么软件？\nSpigotMC 团队致力于维护和支持很多用于建设一个 Minecraft 服务器的重要软件。我们所有的软件都是完全免费并且开源的，在我们的 Stash 和 GitHub 都可以查看。我们受到了很多志愿的支持，并希望有一天你也能这么做。\n\nSpigot 安装\n就如名字一样，Spigot 是我们原始的、也是使用最广泛的软件。这是一个修改过的 Minecraft 服务器，基于 CraftBukkit，提供了更多的性能优化、配置选项和特性，这些都是和已有的插件兼容的，并且包括了原版 Minecraft 的所有游戏机制。\n目前一共有 150 个 Spigot 仅有的提升，包括了 BungeeCord 支持、很多如作物生长速率、饥饿、实体跟踪、地图种子、增强的看门狗和性能检测用于捕捉插件问题、更多的重量元素如生物活动和漏斗、重写的区块加载、卸载和保存的服务器值，还包括了一些附加的有用的开发者API。\n如果你非常有耐心，你也可以在这里查看完整的列表，但是找到 Spigot 提供了什么的最好方法还是亲自动手尝试！\n\nBungeeCord 安装\nBungeeCord 是 完完全全的原始的 SpigotMC 作品，以一个代理的作用允许你一起连接对个不同的 Minecraft 服务器，并使用任意方法在这些服务器之间传送，无论是命令、传送门、背包菜单或者是任何你自己独创的方式。使用 BungeeCord 你就不需要将自己限制在一个服务器，而是连接10个甚至是100个不同的模式、不同的游戏规则的服务器到一起。BungeeCord 给所有顶尖的 Minecraft 服务器注入了验证的拓展性，允许你制作最多数的服务器资源。它也拥有一个完整的插件API，开发者可以听他们来编写插件，如聊天和队伍插这类功能跨越您的整个网络的插件。\n\nCraftBukkit\n自从 2014 年 Q3 Bukkit.org 项目停止后，SpigotMC 接手了这项提供支持和更新、并保留兼容性的重要工作。CraftBukkit 是一个修改的 Minecraft 服务器，允许运行 Bukkit 插件。这个项目的主要目标是提供一个和原版尽量相似的服务器环境，保证插件支持。这也是为什么CraftBukkit 仍然留有一些有用的优化，如异步区块加载，也修复了一些严重的原版漏洞和BUG。所有通过 BuildTools 构建的 Spigot jar 也会同时生成一个 CraftBukkit jar 文件，这让你使用  CraftBukkit 而不是 Spigot （虽然我们并不想这样）。\n\nBukkit\n作为 CraftBukkit 的附属，我们仍然维护 Bukkit，这也是插件开发者用于开发服务器插件的API。在过去的几年里，我们添加了许多新的特性和变更，以支持更新的 Minecraft 版本，但是很多老的 Bukkit 文档仍然适合作为开发者的入门教材。更多关于如何使用 SpigotAPI 的信息可以在之后的 Wiki 找到。\n\n总结\n现在你对 SpigoMC.org 了解更多了，我们也希望你使用我们的软件，并加入我们的论坛和聊天社区。如果你需要帮助，你甚至可以询问合适的板块，那里会有人乐意帮助。\nBuildTools原文\n\n这是什么？\nBuildTools.jar 是我们构建 Bukkit、CraftBukkit、Spigot 和 SpigotAPI 的解决方案。所有的这一切都在您的电脑完成！一些工作是必要的，但是下方的构建向导将指引你所要做的一切。\n\n必要的准备\n你必须安装这两个应用程序：Git 和 Java\n\nWindows\n下方的是指引你在 Windows 上运行 BuildTools.jar。如果你需要一个一击即到的方式，请查看“Tools”栏\nGit - 为了在 Wimdowsz 上运行 BuidTools，你需要安装 Git。在 Windows 这是用 git-scm 分发的，可以在这里下载。在任意你喜欢的地方安装后，这将提供给你 git bash 脚本，用于运行 BuildTools.jar。你只需要点击下一步就可以完成 Git 的安装。\nJava - 下载 JavaRE 8 并安装。你只需要不断点击下一步即可完成安装。\n\nLinux\nGit 和 Java 都可以使用包管理器的单个命令完成安装。\nDebian/Ubuntusudo apt-get install git openjdk-7-jre-headless复制代码CentOS/RHELsudo yum install git java-1.7.0-openjdk-devel复制代码Archpacman -S jdk8-openjdk git复制代码Mac\nGit 可以在这里下载: http://sourceforge.net/projects/git-osx-installer/files/\nJava 可能需要从 Apple 分发的版本升级，即使升级过也需要连接作为脚本使用。\n请按照这里的步骤执行: https://gist.github.com/johan/10590467\n\n运行 BuildTools\n下载 BuildTools.jar 于 https://hub.spigotmc.org/jenkins ... get/BuildTools.jar.\n持续关注 https://hub.spigotmc.org/jenkins/job/BuildTools 获得最新的更新和BUG修复。\n如果你想要使用命令下载，你可以使用 curl -o BuildTools.jar <链接> 或 wget -O BuildTools.jar <链接>，使用上面提供的网址。\nBuildTools 目录地址中含有任何空格和特殊符号都可能破坏 BuildTools，推荐删除他们。\n如果你使用 Linux，打开你的终端，或是在 Windows 上打开 git bash。\nGit bash 可以右键文件夹或桌面点击 Git bash here 打开。\n跳转至你的 BuildTools.jar 的目录，或是直接在 BuildTools.jar 文件夹中右键选择 git bash here，就会打开终端。\n在终端中运行 BuildTools.jar，不要双击。\n在 Linux 运行命令 git config --global --unset core.autocrlf, 接着运行 java -jar BuildTools.jar。\n在 Windows 中，在打开的终端界面中运行:\njava -jar BuildTools.jar复制代码请注意你必须下载 BuildTools #35 以后的版本，老的版本不会生效。\n在 Mac 上运行以下命令:\nexport MAVEN_OPTS=\"-Xmx2G\"\njava -Xmx2G -jar BuildTools.jar复制代码设置 (所有系统) \n--rev 设置可以获得确切的 CraftBukkit / Spigot 版本。\n查看下方所有可用的版本\n(可选) 在 Windows 上创建一个 .bat 文件并写入以下信息:\n@echo off\nset startdir=%~dp0\nset bashdir=\"C:\\Program Files (x86)\\Git\\bin\\bash.exe\"\n%bashdir% --login -i -c \"java -jar \"\"%startdir%\\BuildTools.jar\"\"\"\npause复制代码这个脚本可以让你将文件拷贝到任何你想构建新版本的目录下。你只需要将脚本复制到 BuildTools 同一目录下，并确保 basedir 变量正确，这决定于你的操作系统，或是你的 Git 的安装位置。\n改变 BuildTools 使用的版本，你需要:\n将\n%bashdir% --login -i -c \"java -jar \"\"%startdir%\\BuildTools.jar\"\"\"复制代码改为\n%bashdir% --login -i -c \"java -jar \"\"%startdir%\\BuildTools.jar\"\" --rev <版本>复制代码这将告诉 BuildTools 你使用的版本，使用 --rev latest 获得最新的版本或是查看版本列表。\n等到构建你的 jar 文件，大约几分钟后，你就获得你的自己的新鲜的编译过的 jar 了。\n你可以在 BuildTools 文件夹内找到 CraftBukkit 和 Spigot，也可以在各自的文件夹内的 target 文件夹内找到 Spigot-API 和 CraftBukkit-API。\n享受你的新服务器吧！\n需要开启服务器的帮助？看看这里（目录：安装）。\n\n版本\nSpigot 的版本可以在 BuildTools 里指定你想要获得的版本，使用 --rev latest 设置。下面是支持的版本。\n最新\njava -jar BuildTools.jar --rev latest复制代码将会构建最新版本， CraftBukkit 和 Spigot jar 可以不用指定 --rev latest 而自动获得最后的版本。\n使用java -jar BuildTools.jar --rev 版本复制代码获得某版本的 Spigot\n\n常见问题\nThere's an error regarding jacobe.exe or jacobe being missing from BuildData/bin复制代码升级 BuildTools.jar\nBuildtools 出现错误java.io.FileNotFoundException: BuildData/mappings/bukkit-1.8-cl.csrg复制代码升级至最新的 BuildTools 避免这个问题\nException in thread \"main\" org.eclipse.jgit.api.errors.TransportException复制代码BuildTools 建立 Git 的安全连接时出现错误，这可能是你的反病毒软件拦截了连接。请将 https://hub.spigotmc.org 添加至你的反病毒软件白名单。\nSpigot's applyPatches.sh 出现 \"/bin/bash^M: bad interpreter\"\nSpigot's applyPatches.sh 出现 \"line 2: command not found\"\n复制代码在 Linux（偶尔在 Windows）上，当你开启了 Git 的 autoclf，将会出现此错误。运行git config --global --unset core.autocrlf复制代码并重新运行 BuildTools。\nSpigot's applyPatches.sh 出现 \"fatal: sha1 information is lacking or useless\"\nSpigot's applyPatches.sh 出现 \"Patch failed at ...\"复制代码在 Windows 上如果将 autoclf 设置为停用则会出现此问题，运行git config --global --replace-all core.autocrlf true复制代码并重新运行 BuildTools。\n如果是 Linux，运行git config --global --unset core.autocrlf复制代码并重新运行 BuildTools\nFailed to create log file: BuildTools.log.txt\nException in thread \"main\" org.eclipse.jgit.api.errors.JGitInternalException: Creating directories...复制代码保证你的文件夹内有写入权限\n[ERROR] ... The import gnu.trove.... cannot be resolved复制代码VIPRE 反病毒软件已知拥有此问题，其他的杀毒软件也可能拥有此问题或相似问题。关闭杀毒软件并重新运行 BuildTools。\n如果关闭杀毒软件后此问题继续，你可能需要通过删除 .m2 文件夹清空你的本地 Maven 仓库，打开你的用户文件夹（Win + R，打开 %userprofile%）并删除，然后尝试重新运行 BuildTools。\n（Windows 10 用户） fatal error in forked process - fork: can't reserve memory for parent stack复制代码这是一个已知的问题，当在 Win 10 运行 Git 会出现此问题。卸载 64 位的 Git，重新安装 32 位的Git。[ERROR] Exception in thread \"main\" org.eclipse.jgit.api.errors.JGitInternalException: Invalid ref origin/master specified复制代码这可能是个随机出现的问题。删除 BuildTools 创建的所有文件夹，重新运行。(Mac OS X 10.11 El Capitan users) xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun复制代码如果你从以前的 OS X 升级而来，那么El Capitan 损坏了 Xcode 的安装。运行 xcode-select --install 然后重新运行 BuildTools。\nGit bash Windows 不能选择文字\n点击 git bash 左上角 > properties > enable QuickEdit mode > 可以了\n左键拖动选择，右键一次复制\n单击右键也可以粘贴我可以在 CI 服务器构建它们吗?\n是的，CI 服务器可以用来运行简单的 bash 命令，你可以通过运行以下命令进行构建：\nwget https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar -O BuildTools.jar && java -jar BuildTools.jar复制代码请记住这些构建只能作为私人使用，不可以公开扩散传播。java.security.InvalidAlgorithmParameterException: the trustAnchors parameter must be non-empty复制代码你的服务器缺少了 Java 证书，或者你的防火墙 / 杀毒软件冻结了网络连接。\n安装 ca-certificates-java 或者通过添加 --disable-certificate-check 参数运行 BuildTools。\n\n工具\n这些工具都是社区成员制作的，它们不受到 SpigotMC 的任何形式的支持，如果你有疑问，请按照下方的指示操作。\nDemonWav 的 BuildToolsGUI\nBuildToolsGUI 将 Windows 上的 BuildTools 包装了用户界面，它兼容 Windows 7,8,8.1,10。它将自动处理 BuildTools 的所有依赖项目。你必须安装 .NET 4.5 才能使用，你可以在这里找到它们。\nBuildToolsGUI 将会在每次运行时自动检测更新，你也可以在这里下载它们，或是在这里查看源码。\n\n故障排除和支持\n如果你仍然有疑问，请在 IRC 上询问或是在这里看看你的问题是否已经出现过。\n请注意我们推荐你将编译的 jar 文件移出 BuildTools 文件夹来运行服务器，不这样做可能会将 BuildTools 文件夹搞混。\nMac OS 上的 Spigot 更新器原文\n自动在 Mac OS 创建/更新 Spigot 服务器\n \nSpigot 更新器 (macOS) 可以轻松安装和更新你的 Spigot 服务器。\n一旦设置好，你就只需要打开并使用 update.command 就可以自动更新你的 Spigot Minecraft 服务器，使用最新的 BuildTools。使用 start.command 来运行服务器。\n查看 GitHub 的 polarstoat/spigot-updater 获得下载和使用说明。\n\n需求\n你必须安装 Java（推荐 Java 8）\n\n安装\n将这个 repo 复制到新的 /Minecraft Server 文件夹下：\ngit clone https://github.com/polarstoat/spigot-updater.git 'Minecraft server'复制代码运行 update.command。这将花费一些时间，然后将会出现 spigot-X.X.X.jar 文件。\n运行 start.command。这将开启服务器。\n\n使用\nupdate.command: 下载最新的 BuildTools.jar，接着构建，并将 spigot-X.X.X.jar 复制到你的服务器文件夹。\nstart.command: 启动服务器\n\n下载\nGitHub repository: polarstoat/spigot-updater\n简介文档页面原文\n\n为 Spigot 添砖加瓦原文\n第一步：IDE\n开发任何软件的第一步就是一个你想要使用的开发环境。这是一份使用 IntelliJ IDEA 的指导，我们会使用这个 IDE，你可以在这里下载。\n你可以使用默认的设置，也可以尽情改变外观、安装插件。\n\nStash 权限 + 贡献\n第一步是阅读 给项目添砖加瓦 。确保你阅读了 CLA 部分，这是非常重要的。接下来获得 Stash 权限。\n\n提交 CLA？\n请耐心等待，但是如果超过了 24 小时，你可以前往 IRC 告诉一个工作人员。\n\nFork 一个需要的仓库？\n一旦你拥有了 Stash 的权限，你就可以 Fork 一个仓库而不是 clone。他将在你的 Stash 界面创建一个仓库。\n前往主仓库，选择想要 Fork 的仓库：\n\n\n比如我选择了 Bukkit 仓库，Fork 设置可以在左手边的菜单栏的 [...] 里找到。\n点击 Fork Repository\n\n接着你就可以在你的页面查看你的新的仓库了！\n\n你现在可以复制你的新的仓库了。\n\n\n使用 Maven pom.xml 导入一个项目？\nSpigot 使用一个叫 Maven 的依赖管理软件，这相当节省时间。你可以不用手动下载所有的依赖库，手动编译打包 Spigot Bukkit CraftBukkit，Maven 可以自动完成这一切。\n当你打开 IntelliJ，你可以选择新建项目或是导入项目，作为 Maven 安装，选择导入（Import Project）。\n\n现在你可以选择下方的 pom.xml 了，这将下载所有需要的依赖，并且允许你开发自己的 Spigot.jar，CraftBukkit.jar，Bukkit.jar 文件。\n\n构建 JAR 更加简单了，你不需要添加一个 Artifact，而是：\n前往 IntelliJ 的右手边的窗口，选择 Maven Project当你打开 Spigot 文件夹，你会看到 LifeCycle, Plugins 和 Dependencies.打开 LifeCycle 并找到 'Package'. 双击将会运行封包工具，并分离出一个 JAR 文件于 /Spigot/Spigot-Server/target/spigot-1.9-R0.1-SNAPSHOT.jar\n你可以使用这个 JAR 来测试变更。\n注意： 你也可以使用其他的包来运行测试，编译。\n测试你的新的 Spigot.jar\n选择 Run->Edit Configurations... 运行本地 Minecraft 服务器\n\n选择绿色的+, 输入 JAR, 选择 JAR Application\n\nJAR 的路径是新建的 Spigot.jar 的路径，看起来像：Spigot-Server\\out\\artifacts\\spigot_jar\n创建新的文件夹，这将是你的 Spigot 服务器文件夹，会有很多东西。\n可选：你可以添加 Build Artifacts 于 Before Launch，点击 Build \"spigot.jar\" artifacts 的 Activate tool window。\n\n如果你需要 Debug，你可以添加 Remote。\n注意：\n如果你按下 Run -> Spigot，然后你得到了\nno manifest attribute复制代码你需要移动 src/main/java/META-INF 至 src/main/resources 。\n\n\nBukkit\n不像 CraftBukkit，Bukkit 只有版本追踪，并且没有补丁系统。这让我们的工作更加轻松，因为不需要担心没有的文件。\n\n为 Bukkit 做贡献：\n像上方的教程，将 Bukkit Fork 到你的 Stash 界面。\n复制 Bukkit 到你的本地仓库\ngit clone https://Kato@hub.spigotmc.org/stash/scm/~kato/bukkit.git复制代码打开新复制的项目的 pom.xml\n查看一个新创建的分支，命名\ngit checkout -b tm_world_sleep_event复制代码应用你的更改到代码\ngit add src/\ngit commit -m \"Adds WorldSleepEvent\"\ngit push origin tm_world_sleep_event复制代码回到 Spigot 的 Stash 界面\n前往 Bukkit Stash\n点击 Pull Request\n选择你的 Fork 的仓库\n在右边选择你的分支（注意不是 master 分支）\n在左边选择 spigot repo\n右边一样\n添加介绍，JIRA 的说明，还有其他需要的东西\n将 reviewers 留空\n提交你的 Pull Request！\n\nCraftBukkit\nCraftBukkit 有补丁系统，这是我们管理版本的方法。\n按照上方步骤 Fork CraftBukkit 项目，编辑 [om.xml，以下是生成一个包和 Pull Request 的步骤：\nFork Craft Bukkit\n复制新的仓库\n下载 BuildTools.jar 并放在另一个文件夹，运行\n现在我们需要用一些命令获得全部的代码来获得用于编译构建的源码\n确保你在 CraftBukkit 的仓库文件夹中\n运行\n./applyPatches /path/to/buildtools/work/decompile-xxxx复制代码这将创建合适的 nms 文件和类。确保没有将其添加至版本控制，版本控制的代码应在 nms-patches/ 目录。\n你可以编辑 CraftBukkit 代码了。\n当你完成后，你需要运行以下命令创建新的 patch\n确保你在 CraftBukkit 的仓库文件夹中\n运行\n./makePatches /path/to/buildtools/work/decompile-xxxx\ngit add nms-patches\ngit commit -m \"Adds implementation of x\"\ngit push origin your_branch_name复制代码当你的更新全部上传后，你就可以创建新的 Pull Request 了\n\n使用 BuildTools！\n你可以在这里下载 BuildTools\n将文件移动到自己的文件夹，并使用命令。你必须安装了 Java。\n\n\n为项目添砖加瓦原文\nDevelopers\nWhilst the scripts are nice and easy to use, as a developer you may want a better insight into how they operate so that you can make your own changes, or do it by hand in case they don’t work as intended. Roughly put, the following steps are performed by the install scripts:\nClone the Bukkit, CraftBukkit and Spigot repositories from Atlassian Stash.\nDownload the required build depends: Maven, SpecialSource, Fernflower, Jacobe, Minecraft Server Jar, etc.\nApply the included deobfuscation mappings and access transformations to the Minecraft Server Jar.\nDecompile and format the decompiled code using fernflower and Jacobe.\nApply the included patches to the CraftBukkit source.\nCompile the whole thing using Maven!\nIf installing Spigot, run ./applyPatches and Maven as per usual.\nIf you require help making changes to Spigot or CraftBukkit, please stop by our development IRC channel on irc.spi.gt, #spigot-dev. In particular to regenerate the NMS patches, you need to use the ./makePatches.sh script in the CraftBukkit source. The argument to this script should be the clean decompiled directory which BuildTools generated, ie: ../work/decompile-bb26c12b\n\nWe are also very eager for enhancements and improvements to the build scripts, in particular there is not much support for custom forks, although once the deobfuscated jar has been installed the server can be compiled with Maven as per usual.\n\nStash Access\nAs a developer you are probably also interested in getting access to the Stash server so that you can make pull requests with all your awesome new features and enhancements.\n\nIn order to get this access you will first need to create an account on JIRA, and then submit our CLA.\nWhy a big scary CLA you might ask? Well first of all its not scary at all, it is substantially shorter and easier to read than many of the agreements you submit on a daily basis (think Apple, iTunes, and all those other terms and conditions). The reason for this document is to protect you, and to protect us. What the CLA does, is instead of licensing your code under [L]GPL, BSD, or whatever other licenses our projects may use, it licenses your code to us instead. This is a good thing, and in implementing it, we hope you will see the benefits behind our key reasons:\nIt is easy to understand: Previously when contributing to a LGPL license project you had to agree to both the GPL and LGPL licenses, which when combined represent nearly 6500 words of legal speak so complex that it requires in depth study by even experienced legal professionals. Our CLA on the other hand clocks in at around 1800 words, or four times less, and is written in language which we hope is easy to understand even for those whom English is not their first language.\nIt protects you as a developer: The CLA makes it completely clear, in writing, what rights you give us, and what rights you don’t. In particular, the right we are most concerned about is the right to use, and relicense your code. It also makes it abundantly clear that you give irrevocable consent to your contributions being used in Spigot / Bukkit.\nIt protects us as a project: By having a signed document stating that you give us the ability to license and use your code, it 1) prevents the idea that past contributions can be rescinded in any way, shape or form, and 2) enables us to relicense your code to better serve and preserve the long term goals of the project should that need arise in the future.\nIt eliminates ambiguities and hopefully encourages contributions from those who would not normally contribute. One of the biggest reasons (excuses) I have heard from developers not contributing to Spigot is “I don’t think I’m allowed to because of my NDA”. This document is hopefully the solution to all of those troubles, and by getting it cosigned by your employer there should be no issues and you can contribute to your heart's content! We can’t expect to advance further if the best developers don’t contribute as they are tied up elsewhere.\nWe provide Spigot, and now CraftBukkit as free and open source software which is free of charge. Almost all of you make a profit off your servers, and some of you make hundreds of thousands a year; we don’t. That’s ok, because we’re not focused on that. What we feel isn’t ok however is not contributing changes you make to our software back to us, especially changes which fix exploits and other critical bugs. It may seem far fetched, but this is the exact situation our team has had to deal with more than once in the last year.\n\nSo this is our plea to you larger server owners, if you have a developer, or a team of developers working on modified versions of our software, please do so in a public manner which we can work with. Doing so will only lead to a better software, with more API features and less bugs. We are able to provide any assistance you require in doing this, including providing dedicated organisations on our Stash instance. In particular I would like to draw upon the example of SportBukkit, which has been maintained as an open source project by the @@MonsieurApple and oc.tc servers for many year(s) now - in fact several Spigot API features are based on their work, kudos to them!\n\nFinally with regards to the CLA, if you are interested in any of the included content you should note that it has largely been based on the well known Harmony CLA, with a few minor alterations made by our lawyers. If you have any specific concerns about any of the wording within, please don’t hesitate to contact us and we will do our best to help.\n\nPlease note that the \"real name\" field on JIRA is public to all users. If you are not comfortable with this please set it to your username. All details in the CLA however must be correct.\nSubmit the CLA here: https://www.spigotmc.org/go/cla\n创建你的开发工作空间原文\n新的系统是怎么工作的\n由于法律原因，SpigotMC 不能直接提供可下载的 jar 文件，我们必须使用一个叫做 BuildTools 的程序来生成 JAR。\nBuildTools 下载所有相关的工具如 Maven（项目管理和构建），FermFlower（反编译）\n\nBuildTools 的工作原理\nBuildTools 首先检查是否是在 Mac 上运行，是否是在 bash 中运行，接着检查是否设置了 Git 用户名和密码。\n现在真正的工作开始了：\n保证“work”文件夹出现，如果没有就创建一个。检查 Bukkit 文件夹是否出现，如果没有就将 Bukkit 仓库复制进去。检查 CraftBukkit 文件夹是否出现，如果没有就将 CraftBukkit 仓库复制进去。检查 Spigot 件夹是否出现，如果没有就将 Spigot 仓库复制进去。检查 BuildData 件夹是否出现，如果没有就将 BuildData 仓库复制进去。这个文件夹包含了重要的信息包括原版 jar 的映射。\n记住这只是个空文件夹的初始化工作，我们将在下一分钟更新它们\ngit clone https://hub.spigotmc.org/stash/scm/spigot/bukkit.git Bukkit\ngit clone https://hub.spigotmc.org/stash/scm/spigot/craftbukkit.git CraftBukkit\ngit clone https://hub.spigotmc.org/stash/scm/spigot/spigot.git Spigot\ngit clone https://hub.spigotmc.org/stash/scm/spigot/builddata.git BuildData复制代码现在将会以系统为 Windows 或是 Linux 下载 Jacobe。\n接着将会解压 jacobe 到主文件夹。\n\n在 Linux 上你可以这样下载 Jacobe（在 Windows 你可以使用图形界面）\nwget -O jacobe.linux.tar.gz http://www.tiobe.com/content/products/jacobe/jacobe.linux.tar.gz\ntar xzvf jacobe.linux.tar.gz -C jacobe复制代码接下来将会确认 Maven 是否安装完成。\n\n常见问题原文\nSpigot/Bukkit\n\n什么是 Spigot？\nSpigot 既是一个修改版 Minecraft 服务器也是一个 API。Spigot 基于 Bukkit，添加了很多的改良的设置，都可以在 spigot.yml 进行设置。这个 API 允许开发者给原版服务器添加新的特性。\n\nSpigot 需要花费什么？\nSpigot 是完全免费并且开源的软件，但是请考虑给 Spigot 捐赠，这将帮助维持网站部署和软件开发，就在这里：ttps://www.spigotmc.org/#donate 非常感谢！\nBukkit 怎么了？\n之前有一场 DMCA 官司把 Bukkit 打垮了，现在 Spigot 正在维护 Bukkit。\n\n我从哪里得到 Spigot 或者 Bukkit 的 jar 文件？\n由于 DMCA，你必须自己编译服务器。幸运的是这很简单，查看 BuildTools 章节获得详细信息。\n\n我需要服务器的帮助！\n如果发生了错误，并且你又不知道怎样做，请前往论坛询问，那里有上千的成员帮助你。\n\nBungeeCord\n\n什么是 BungeeCord？\nBungeeCord 允许一个服务器连接多个子服务器，这意味着玩家不需要通过退出登录重新进入新的服务器。\n这就像一个代理服务器，一些著名的服务器就使用 BungeeCord，如 MinePlex，Hypixel 和其他的一些多服务器群组。\n\n我可以在哪里下载到 BungeeCord？\nBungeeCord 可以在公共构建服务器下载，这里是链接：\nhttp://ci.md-5.net/job/BungeeCord/\n\n我应该怎样使用 BungeeCord？\n查看 BungeeCord Wiki，那里可以帮助你！https://www.spigotmc.org/wiki/bungeecord/\n\n插件\n\n我可以在哪里下载插件？\n大多数 Bukkit 插件都在 http://dev.bukkit.org/bukkit-plugins/, Spigot 有一个插件资源栏 ttps://www.spigotmc.org/resources/ 里面有几千个插件！有的是免费的，有的是付费的。\n\n我自己制作了插件，如何上传？\n你可以在这里上传你的资源： https://www.spigotmc.org/resources/add\n\n为什么我不能让我的插件付费使用？\n请详细阅读这篇文章： https://www.spigotmc.org/threads ... e-guidelines.31667/\n\n如果我找到了一个恶意插件，我应该怎么办？\n很不幸人们有时会上传恶意插件，如果你确实找到了一个，或者怀有疑虑，请给 resources@spigotmc.org 或是使用插件页面的 report 按钮。\n\n如果有人出售给我一份坏插件，我应该怎么办？\n如果插件没有按照预期工作，请联系作者寻求帮助。\n请给作者一些时间修复，如果作者过了一周后仍然没有修复，请联系 esources@spigotmc.org.\n\n有人正在扩散我的插件，我应该怎么办？\n有时，插件的协议不阻止分发插件，这是合法的。其他的情况则不然：\n插件的协议不允许用户这样做。这是一份付费插件。\n如果插件没有在 SpigotMC 分发，我们无能为力，你只能联系网站的管理员。\n发送你的疑虑和证据到 resources@spigotmc.org，如果你能得到插件的一份拷贝，请一起发过来。\n\n服务与招聘\n\n我可以在哪里招募/出售开发、系统管理、图形制作或是建筑的技术？\n有一整个论坛版块都是干这个的，叫做 Services & Recruitment (S&R).\nhttps://www.spigotmc.org/forums/services-recruitment-v2.54/\n\n为什么我不能在 Services and Recruitment 论坛发帖？\n请注意，如果你要在这个版块发布消息，你必须：\n至少有 20 个回帖\n账户使用期超过一周\n这适用于招募或者应聘。\n如何学习 Spigot API ？原文\n  \n安装 Spigot原文Spigot 是 CraftBukkit 的一个分支，拥有更多的优化和更多的功能。安装是很简单的，你只需要将新的 Spigot jar 替换原有的 CraftBukkit jar 即可。\n如果你从原来的版本升级到 CraftBukkit 1.7.9+，请阅读 UUID 转换指南。\n请注意 Java 8 是任何 Minecraft 程序的推荐 Java 版本。\n\n安装\n\nWindows\n将下面的文字复制到一个文本文档里，保存为 start.bat\n@echo off\njava -Xms512M -Xmx1G -XX:+UseConcMarkSweepGC -jar spigot.jar\npause复制代码双击启动\nWindows （可选）\n这下面的代码也可以\n@echo off\n:restart\njava -Xms512M -Xmx1G -XX:+UseConcMarkSweepGC -jar spigot.jar\ngoto restart复制代码\nLinux\n作为先决条件，请先安装 Java\n使用 BuildTools 页面的指示编译 spigot jar\n将 jar 文件放入新的文件夹\n创建新的脚本文件（start.sh）来启动 spigot\n#!/bin/sh\njava -Xms512M -Xmx1G -XX:MaxPermSize=128M -XX:+UseConcMarkSweepGC -jar spigot.jar复制代码请注意 MaxPermSize 在 Java 8 已经不受支持，另外这段代码对 Debian 无效\n打开你的终端，使用：\nchmod +x start.sh复制代码运行脚本：\n./start.sh复制代码\nMac OS X\n作为先决条件，请先安装 Java\n使用 BuildTools 页面的指示编译 spigot jar\na. 创建一个 start.command\n#!/bin/sh\ncd \"$( dirname \"$0\" )\"\njava -Xms512M -Xmx1G -XX:MaxPermSize=128M -XX:+UseConcMarkSweepGC -jar spigot.jar复制代码b. 放入 BuildTools.jar\nc. 将脚本保存在 BuildTools 文件夹\nd. 使用命令 chmod a+x 来给自己权限，将命令脚本拖入终端窗口\ne. 双击脚本，等待 5 - 10 分钟的文件下载\n双击你的脚本\n\nMulticraft\n决定于 Minecraft 服务器提供商的设置，我们有两种方法启用 Spigot。\n如果已经存在 Spigot，选中它，重启即可。但是如果提供商没有及时更新最新的 Spigot，这样很不好。\n如果你可以使用 FTP 自定义上传 JAR，那么下载 Spigot JAR，进入文件夹，复制进去，在菜单中选中。\n如果你有你的个人服务器的权限，那么将 spigot.jar.conf 放入你的 daemon jar 文件夹，接着使用管理面板更新，现在这个 jar 应该是可选的了。\n\n安装后\n当 Spigot.jar 已经运行了一遍后，文件夹和配置将会创建，你需要编辑这些配置文件，让你的服务器正确工作。\nserver.properties\nbukkit.yml\nspigot.yml\n服务器图标\n如果服务器不正常工作，请确保你开放了端口，并且你按照上面的步骤做了、如果你有疑惑或是问题，请在 Spigot 论坛发布求助帖或是在 IRC 上联系我们。\n由于 Windows 和 Mac OS X 的 kernel 的低效率，我们不推荐在这些平台上部署严肃的/商业化的服务器。\n\n插件\n在几乎所有情况下，Bukkit 插件完全兼容 Spigot，除非开发者使用了 CraftBukkit 和 Minecraft 的内部代码。\n查看我们的资源栏或是查看 BukkitDev，来寻找各种各样的插件，如添加完全新的游戏模式的管理插件。如果你没有找到合适的，你可以在 Spigot 的 Services & Recruitment 论坛或是 Bukkit 的 Plugin Requests 论坛请求制作。请按照指示发布请求。\n你可以将下载的 jar 放入插件文件夹，然后重启服务器。如果这不管用或是出现了错误，请在 Spigot 论坛寻求帮助。\nLinux 上的 Spigot原文\n作为先决条件，请先安装 Java\n使用 BuildTools 页面的指示编译 spigot jar\n将 jar 文件放入新的文件夹\n创建新的脚本文件（start.sh）来启动 spigot\n#!/bin/sh\njava -Xms512M -Xmx1G -XX:MaxPermSize=128M -XX:+UseConcMarkSweepGC -jar spigot.jar复制代码请注意 MaxPermSize 在 Java 8 已经不受支持，另外这段代码对 Debian 无效\n打开你的终端，使用：\nchmod +x start.sh复制代码运行脚本：\n./start.sh复制代码\nMac OS X 上的 Spigot原文Mac OS X\n作为先决条件，请先安装 Java\n使用 BuildTools 页面的指示编译 spigot jar\na. 创建一个 start.command\n#!/bin/sh\ncd \"$( dirname \"$0\" )\"\njava -Xms512M -Xmx1G -XX:MaxPermSize=128M -XX:+UseConcMarkSweepGC -jar spigot.jar复制代码b. 放入 BuildTools.jar\nc. 将脚本保存在 BuildTools 文件夹\nd. 使用命令 chmod a+x 来给自己权限，将命令脚本拖入终端窗口\ne. 双击脚本，等待 5 - 10 分钟的文件下载\n\n需要注意的事情\n\n当你正在构建时，千万不要关闭！你可能会因此必须重新进行所有操作。\nMaven 是一个软件 API，用于有关 Java 的任何事情，包括 Bukkit 和 Minecraft 也在使用。\n\nWindows 上的 Spigot原文\n将下面的文字复制到一个文本文档里，保存为 start.bat\n@echo off\njava -Xms512M -Xmx1G -XX:+UseConcMarkSweepGC -jar spigot.jar\npause复制代码双击启动\nWindows （可选）\n这下面的代码也可以\n@echo off\n:restart\njava -Xms512M -Xmx1G -XX:+UseConcMarkSweepGC -jar spigot.jar\ngoto restart复制代码如果你在使用 Java 7，使用这个：\n@echo off\njava -Xms512M -Xmx1536M -XX:MaxPermSize=128M -jar spigot.jar\npause复制代码使用 Morphia 连接到 MongoDB原文\n简介\n在继续向这个 Wiki 挖掘之前，我非常建议你先看看 MongoDB Wiki 的最开头的一段，那里讲述了 NoSQL 的细节以及如何使用的方法。阅读到它讲到如何连接 MongoDB 之前，因为剩下的就是这里的 Wiki 的意义。\n\n什么是 Morphia？\nMorphia 是一个 MongoDB 开发的 API，用于让开发者轻松映射他们的对象至 MongoDB。你可以创建类，创建字段，并且直接存储你的对象到这个数据库。这让 MongoDB 成为了一个非常精简的处理过程，这也意味着你不需要头疼数据库的问题。\n\n将 Morphia 添加到项目\n为了在项目中使用 Morphia，我使用 Maven，这既可以将资源构建整合到最后的输出，也可以管理我的依赖项目。可能后面我会添加一种不是 Maven 的管理方式，但是现在就是 Maven。\n\n你要做的第一件事就是添加 dependencies 到你的项目。你需要添加 Maven 和 Morphia，所以将以下两段放入你的 pom.xml。\n<dependency>\n    <groupId>org.mongodb.morphia</groupId>\n    <artifactId>morphia</artifactId>\n    <version>1.3.2</version>\n</dependency>\n<dependency>\n    <groupId>org.mongodb</groupId>\n    <artifactId>mongo-java-driver</artifactId>\n    <version>3.4.2</version>\n</dependency>复制代码加入之后，你必须保证当你的插件编译后，Bukkit 知道如何找到你所需的库文件。有很多种方法做到这点，但是我选择了直接添加进我的插件。你只需要把这一段放入 pom.xml。\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-shade-plugin</artifactId>\n            <version>2.3</version>\n            <executions>\n                <execution>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>shade</goal>\n                    </goals>\n                    <configuration>\n                        <artifactSet>\n                            <includes>\n                                <include>org.mongodb</include>\n                                <include>org.mongodb.morphia</include>\n                            </includes>\n                        </artifactSet>\n                        <createDependencyReducedPom>false</createDependencyReducedPom>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>复制代码现在已经完成了！你只需要连接了！\n\n连接到 Mongo 和 Morphia\n有两种不同的方法连接到 MongoClient 和 Morphia，一种需要凭据，一种不需要。如果是本地主机，那么你可以直接关闭凭据，然后直接禁止远程连接。我将会演示这两种方法。\n使用凭据：\n    private MongoClient mc;\n    private Morphia morphia;\n\n    public DatabaseHandler(int i)\n    {\n        ServerAddress addr = new ServerAddress(\"hostname\", port);\n        List<MongoCredential> credentials = new ArrayList<>();\n        credentials.add(MongoCredential.createCredential(\"username\", \"database\", \"password\".toCharArray()));\n        mc = new MongoClient(addr, credentials);\n\n        morphia = new Morphia();\n    }复制代码不使用凭据：\n    private MongoClient mc;\n    private Morphia morphia;\n\n    public DatabaseHandler(int i)\n    {\n        mc = new MongoClient();\n\n        morphia = new Morphia();\n    }复制代码剩下的代码片段都是建立在你的 Mongo 客户端已经初始化完毕的前提下。\n\n创建你的对象\n我们一会儿还会回到你的 DatabaseHandler，但是现在，我们需要创建映射的对象。在这个例子里，我将会创建一个 User 类用于映射和保存。代码就在下方，我会解释每个注释的意义。\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.mongodb.morphia.annotations.Entity;\nimport org.mongodb.morphia.annotations.Id;\nimport org.mongodb.morphia.annotations.IndexOptions;\nimport org.mongodb.morphia.annotations.Indexed;\nimport org.mongodb.morphia.annotations.Property;\n\n@Entity(value = \"Users\", noClassnameStored = true)\npublic class User\n{\n\n    @Id\n    public int id;\n\n    @Indexed(options = @IndexOptions(unique = true))\n    public String uuid;\n\n    @Indexed\n    public String username;\n\n    public int ip;\n\n    public long connectionTime;\n\n    @Property(\"ip_history\")\n    public List<Integer> ipHistory = new ArrayList<>();\n\n    @Property(\"name_history\")\n    public List<String> nameHistory = new ArrayList<>();\n\n}复制代码\n注释\n下面的注释应该在合适的地方使用。\n@Entity  这个注释告诉 Morphia 这个对象将会存储在一个集合里。“value”参数声明了集合的名称，“noClassnameStored”参数告诉 Morphia，如果接下来你改变了类的名称，MongoDB 仍然允许你存储在同一个集合。这并不是必须的，但是非常推荐使用。\n@Id  这是标注每个不同的对象的唯一的 ID。你不需要自行声明，Morphia 将会在你没有声明的情况下自行创建，但是我喜欢用一个数字代表我的对象。\n@Indexed  这告诉 Morphia 你会搜索整个集合，并且希望快速搜索。尽管这不是必须的，它显著的提升了搜索的时间。我的使用 @IndexOptions(unique = true) 的参数告诉 Morphia 每次只有一个有该值的对象在数据库中。\n@Property  默认情况下，Morphia 将字段命名为你类中一样的名字，如果你想更改，那么使用 @Property。\n@Transient  这个注释告诉 Morphia 你不想将这个字段存入数据库。用更加技术性的话来说，transient 意味着这个字段不会被序列化。\n@Embedded  如果你想存贮的类不是下一节里支持的数据类型，你可以创建一个 Embedded 对象。你只需要将字段的类使用你想要的类型，并用 @Embedded 注释标记。接着，前往这个类，用注释将其中的字段全部标注。\n@Reference:  对于那些从 SQL 慕名而来的用户，你可能更加熟悉外键和连接。也就是这个类存储在一个不同的集合。就比如说你已经有一个存储的类了，你现在需要直接引用，而不用重新存储他们的 ID。\n想要阅读更加详细的注释资料，请自行百度。\n\n数据类型\nMorphia 不允许存储所有种类的数据，但是可以支持大多数，下面的都支持：\n所有的原始数据类型枚举（以 String 存储）java.util.Datejava.util.Locale\n更多的数据类型的说明都在这里。\n\n创建你的 DAO（注：DAO Data Access Object）\n这一步不是强制性的，但是会让处理工作变得简单，接下来的教程也将以拥有 DAO 作为前提。\n你将会创建每个对象的 DAO。作为示例，我将继续使用 User 类。\nimport org.mongodb.morphia.Datastore;\nimport org.mongodb.morphia.dao.BasicDAO;\n\npublic class UserDAO extends BasicDAO<User, String>\n{\n\n    public UserDAO(Class<User> entityClass, Datastore ds)\n    {\n        super(entityClass, ds);\n    }\n\n}复制代码我将在下一节详细介绍如何构造你的 DAO。另外请保证通用类型参数为 <MyClass, String>， DAO 参数为 (Class<MyClass>, Datastore).\n\n数据存储与映射\n现在你有了你的类、DAO，还有你的 MongoClient 和 Morphia，现在是时候创建你的数据存储了。数据存储就是你的实际的数据库的连接。\n    private MongoClient mc;\n    private Morphia morphia;\n    private Datastore datastore;\n    private UserDAO userDAO;\n\n    public DatabaseHandler(int i)\n    {\n        mc = ...;\n        morphia = new Morphia();\n\n        morphia.map(User.class);\n\n        datastore = morphia.createDatastore(mc, \"dbName\");\n        datastore.ensureIndexes();\n\n        userDAO = new UserDAO(User.class, datastore);\n    }复制代码就是这样了！你可以加入一些代码用于存储数据，我在下面放了一些代码片段基于我的示例，希望能让你更好的入门。\n\n代码片段\n获得一个 User：\n    public DUser getUserByPlayer(Player player)\n    {\n        DUser du = userDAO.findOne(\"uuid\", player.getUniqueId().toString());\n        if (du == null)\n        {\n            du = new DUser();\n            du.setUUID(player.getUniqueId().toString());\n            du.setIp(PlayerUtils.inetAddressAsInteger(player.getAddress().getAddress()));\n            du.setUsername(player.getName());\n            userDAO.save(du);\n        }\n        return du;\n    }复制代码保存一个 User：\n    public void saveUser(DUser user)\n    {\n        userDAO.save(user);\n    }复制代码获得全部 User：\n    public List<User> getAllUsers()\n    {\n        return userDAO.find().asList();\n    }复制代码\n插件代码片段原文\n这是什么？\n这个 Wiki 目录下的文章包含了用户贡献的片段，方便一些开发者希望共享一些片段来帮助你开发你的自己的插件。尽管他们可能很简单，但是他们旨在帮助你入门使用 Spigot API 编程，是制造更大更好的插件的垫脚石！通过参考代码片段或者这个目录下的指南，入门用户可以阅读所有的教程和指南，它们会教你好的编程习惯，提供一个有用的参考，让你浅尝 SpigotAPI 之美。\n\n我怎样可以做贡献？\n也想贡献你自己的代码？第一步，创建一个 Wiki 文章，包含你的示例代码，在 Spigot Plugin Development 论坛经过同行们的点评。我们只希望公开那些能演示好的习惯和方法、帮助开发者走上正确道路的代码。\n一旦你的代码经过了用户的点评后，请创建一个新的 Wiki 文章，将父节点设置为“Plugin Snippets”。如果你有任何问题，请在讨论版块发布帖子。\n\n异步连接数据库原文开始之前\n这个例子我们会使用 MongoDB，但是并不需要你有很多的 MongoDB 的知识。如果你确实希望了解 MongoDB，你可以看看前面的“使用 MongoDB”Wiki。我们也会创建一个命令，你可以在这里查看详情。\n\n什么是异步？\n所有的程序都有一个入口，程序就一行一行的执行，这也意味着每个任务必须在前一个任务完成后才能开始。但是你也可以开始一个新的任务，这样主程序运行时也可以同时进行这个任务。\n这些任务就叫做线程，系统和大多数的编程语言允许你使用它们。在有些情况下，比如你需要玩家输入聊天信息，但是你不想让整个程序在等待输入的时候完全停止，你就可以使用多个线程。线程也会被系统分配到每个 CPU 核心，这也意味着如果你有多核心的处理器，你甚至能够得到性能的提升，虽然 Minecraft 主循环使用一个 CPU 核心。\n异步是同步的反义词，并且当你在另一个线程完全独立的计算某个任务，并不和主任务互相干扰，你就可以叫其异步了。当你开始了一个任务，但是你必须等待启用这个任务的线程结束后才能开始，这就是同步。每种情况都有好有坏，使用要按照具体情况而定。\n\n创建一个 /playerinfo 命令\n这个教程假设你已经有了一个连接的数据库，并且已经存在一个储存玩家数据的集合。命令会提取玩家的名字或是 UUID。数据库内的玩家的文档示例：\n{\n    _id: ObjectId(\"564bff868ab04da7798b4569\"),\n    username: \"Wouto1997\",\n    lookupUsername: \"wouto1997\",\n    uuid: \"a44c33ce480e486f9f782d1f52db037b\",\n    money: 17500,\n    flying: true,\n    friends: [],\n    rank: \"DEVELOPER\",\n    lastSeen: ISODate(\"2015-11-18T11:33:10.852Z\"),\n    registered: ISODate(\"2014-08-14T21:15:10.152Z\")\n}复制代码所以我们立刻创建一个同步的 /playerinfo 命令：\npublic class CommandPlayerInfo implements CommandExecutor {\n\n    @Override\n    public boolean onCommand(CommandSender cs, Command cmnd, String label, String[] args) {\n        if (args.length < 1) {\n            cs.sendMessage(\"Usage:\");\n            cs.sendMessage(\"  /playerinfo <name>\");\n            cs.sendMessage(\"  /playerinfo <uuid>\");\n            return true;\n        }\n        String param = args[0];\n        String key = null;\n        if (param.length() <= 16 && param.length() >= 3) {\n            key = \"lookupUsername\";\n        } else {\n            param = param.replaceAll(\"-\", \"\");\n            if (param.length() != 32) {\n                cs.sendMessage(\"Invalid username or uuid\");\n                return true;\n            }\n            key = \"uuid\";\n        }\n        param = param.toLowerCase();\n        DBCollection playerCollection = DatabaseHelper.getPlayerDatabase();\n        DBObject result = playerCollection.findOne(new BasicDBObject(key, param));\n        if (result == null) {\n            cs.sendMessage(\"The specified player could not be found\");\n            return true;\n        }\n        cs.sendMessage( \"Information about \" + ((String) result.get(\"username\")) );\n        cs.sendMessage( \"UUID: \" + ((String) result.get(\"uuid\")) );\n        cs.sendMessage( \"money: \" + ((Integer) result.get(\"money\")) );\n        cs.sendMessage( \"Fly: \" + ((Boolean) result.get(\"fly\")).toString() );\n        cs.sendMessage( \"Friends: \" + ((BasicDBList) result.get(\"friends\")).size() );\n        cs.sendMessage( \"rank: \" + ((String) result.get(\"rank\")) );\n        cs.sendMessage( \"Last online: \" + ((Date) result.get(\"lastSeen\")).toLocaleString() );\n        cs.sendMessage( \"Registered: \" + ((Date) result.get(\"registered\")).toLocaleString() );\n        return true;\n    }\n\n}复制代码\n使用 Bukkit 的异步方法\n你要学习的第一个就是 Bukkit Scheduler，可以在任何地方使用 Bukkit.getScheduler() 获得一个实例。有三种不同的任何可以添加到 Scheduler，每种都有同步和异步的种类。\n需要特别注意的是，同步的任何是运行于每个 Minecraft tick 的，也不是通常叫的“线程”，并且推荐不要在异步线程内使用 BukkitAPI，但是你也可以在主线程外运行复杂的任务和连接数据库。\n我们将要使用 runTask 和 runTaskAsynchronously ，因为我们不需要延迟执行命令或是重复执行命令。当转换完所有的参数后，我们要做的就是“逃出”主线程并开启一个新的线程。\n        Bukkit.getScheduler().runTaskAsynchronously(plugin, new Runnable() {\n            @Override\n            public void run() {\n\n            }\n        });复制代码现在我们有一个异步的线程，我们可以用其存储读取数据。因为这个方法在命令之外执行，我们必须让每个变量 final，这样这个变量就不能够重新赋值了，但是变量的所有方法都可以执行。现在的代码应该像是这样：\n    @Override\n    public boolean onCommand(final CommandSender cs, Command cmnd, String label, String[] args) {\n        if (args.length < 1) {\n            cs.sendMessage(\"Usage:\");\n            cs.sendMessage(\"  /playerinfo <name>\");\n            cs.sendMessage(\"  /playerinfo <uuid>\");\n            return true;\n        }\n        String param = args[0];\n        String key = null;\n        if (param.length() <= 16 && param.length() >= 3) {\n            key = \"lookupUsername\";\n        } else {\n            param = param.replaceAll(\"-\", \"\");\n            if (param.length() != 32) {\n                cs.sendMessage(\"Invalid username or uuid\");\n                return true;\n            }\n            key = \"uuid\";\n        }\n        final String fparam = param.toLowerCase();\n        final String fkey = key;\n\n        Bukkit.getScheduler().runTaskAsynchronously(plugin, new Runnable() {\n            @Override\n            public void run() {\n                DBCollection playerCollection = DatabaseHelper.getPlayerDatabase();\n                DBObject result = playerCollection.findOne(new BasicDBObject(fkey, fparam));\n                if (result == null) {\n                    fcs.sendMessage(\"The specified player could not be found\");\n                    return;\n                }\n                fcs.sendMessage(\"Information about \" + ((String) result.get(\"username\")));\n                fcs.sendMessage(\"UUID: \" + ((String) result.get(\"uuid\")));\n                fcs.sendMessage(\"money: \" + ((Integer) result.get(\"money\")));\n                fcs.sendMessage(\"Fly: \" + ((Boolean) result.get(\"fly\")).toString());\n                fcs.sendMessage(\"Friends: \" + ((BasicDBList) result.get(\"friends\")).size());\n                fcs.sendMessage(\"rank: \" + ((String) result.get(\"rank\")));\n                fcs.sendMessage(\"Last online: \" + ((Date) result.get(\"lastSeen\")).toLocaleString());\n                fcs.sendMessage(\"Registered: \" + ((Date) result.get(\"registered\")).toLocaleString());\n            }\n        });\n\n        return true;\n    }复制代码注意我添加了 final 键值。现在唯一的错误就是我们在异步线程内使用了 bukkit 方法 sendMessage，尽管我可以保证这没有任何问题，但是我仍然建议你回到主线程，尤其是你要做的不只是向玩家发送信息。\n尽管现在我们已经在命令中创建了一个任务，但是再创建一个就会显得很麻烦，所以我们将在下一节讲述一个更加优雅的方法。\n\n回调\n创建回调是一个是完成一个或者多个任务后的返回的很优雅的方法。之前调度器内的 Runnable 类其实就是回调，每当 Minecraft tick 过去它们就被执行一次。\n创建自己的回调需要创建一个接口，我将其命名为 FindOneCallback，并且添加了查询完成后执行的方法，看起来像这样：\npublic interface FindOneCallback {\n\n    public void onQueryDone(DBObject result);\n\n}复制代码现在我们想要创建一个方法，包含所有的数据库操作，这看起来可能很混乱，但是这是为了离开主线程，第二次运行则是回到主线程。\n    public static void findPlayerAsync(final DBObject query, final FindOneCallback callback) {\n        // Run outside of the tick loop\n        Bukkit.getScheduler().runTaskAsynchronously(plugin, new Runnable() {\n            @Override\n            public void run() {\n                DBCollection playerCollection = DatabaseHelper.getPlayerDatabase();\n                final DBObject result = playerCollection.findOne(query);\n                // go back to the tick loop\n                Bukkit.getScheduler().runTask(plugin, new Runnable() {\n                    @Override\n                    public void run() {\n                        // call the callback with the result\n                        callback.onQueryDone(result);\n                    }\n                });\n            }\n        });\n    }复制代码\n重新规划命令\n现在我们要做的是打包我们的命令，让其看起来更加美观实用高效：\n    @Override\n    public boolean onCommand(final CommandSender cs, Command cmnd, String label, String[] args) {\n        if (args.length < 1) {\n            cs.sendMessage(\"Usage:\");\n            cs.sendMessage(\"  /playerinfo <name>\");\n            cs.sendMessage(\"  /playerinfo <uuid>\");\n            return true;\n        }\n        String param = args[0];\n        String key = null;\n        if (param.length() <= 16 && param.length() >= 3) {\n            key = \"lookupUsername\";\n        } else {\n            param = param.replaceAll(\"-\", \"\");\n            if (param.length() != 32) {\n                cs.sendMessage(\"Invalid username or uuid\");\n                return true;\n            }\n            key = \"uuid\";\n        }\n\n        BasicDBObject query = new BasicDBObject(key, param);\n\n        DatabaseHelper.findPlayerAsync(query, new FindOneCallback() {\n            @Override\n            public void onQueryDone(DBObject result) {\n                if (result == null) {\n                    cs.sendMessage(\"The specified player could not be found\");\n                    return;\n                }\n                cs.sendMessage(\"Information about \" + ((String) result.get(\"username\")));\n                cs.sendMessage(\"UUID: \" + ((String) result.get(\"uuid\")));\n                cs.sendMessage(\"money: \" + ((Integer) result.get(\"money\")));\n                cs.sendMessage(\"Fly: \" + ((Boolean) result.get(\"fly\")).toString());\n                cs.sendMessage(\"Friends: \" + ((BasicDBList) result.get(\"friends\")).size());\n                cs.sendMessage(\"rank: \" + ((String) result.get(\"rank\")));\n                cs.sendMessage(\"Last online: \" + ((Date) result.get(\"lastSeen\")).toLocaleString());\n                cs.sendMessage(\"Registered: \" + ((Date) result.get(\"registered\")).toLocaleString());\n            }\n        });\n\n        return true;\n    }复制代码\n总结\n使用异步编程是一种熟练地技巧，比如玩家数据加载或者是一个事件发生时，存储数据，都是推荐使用异步的。异步处理不仅仅只用于 MongoDB，它还适用于 SQL，文件读写、从网站传输、接受数据，以及其他的方面。\n\n基础聊天禁言原文\n基础\n最基础的入门方法是学习如何取消一个事件。这在一会儿会很有用，所以让我们先看看如何取消聊天事件。\n在这里，我们使用 AsyncPlayerChatEvent 事件，我们可以取消所有事件。这很有效率，会直接移除这条聊天。让我们看一看:\n@EventHandler\npublic void onAsyncPlayerChat(AsyncPlayerChatEvent event) {\n    event.setCancelled(true);\n}复制代码我们不会讨论如何注册这个监听器，但是如果你安装了这个插件，那么聊天将会停用。\n\n添加一个开关\n看起来每次你想要聊天的时候你都会觉得受到限制是吗？让我们添加一个命令来开关它！重新看看我们的监听器:\nprivate volatile boolean chatEnabled = true;\n@EventHandler\npublic void onAsyncPlayerChat(AsyncPlayerChatEvent event) {\n    if (!chatEnabled) {\n        event.setCancelled(false);\n    }\n}复制代码我们现在改变了检查的方式，并且添加了一个新的字段。注意 volatile 关键字是必要的，因为这个聊天事件是异步的(不在服务器线程运行)。\n现在我们可以添加命令处理器(添加命令到你的 plugin.yml 不在这个片段的讲述范围内)。假设你的监听器和插件是同一个类。\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n        // 检查输入的命令\n        if (cmd.getName().equalsIgnoreCase(\"mutechat\")) {\n            // 转换 chatEnabled 到相反的值\n            chatEnabled = !chatEnabled;\n            // See if the chatEnabled boolean is true if it is print the string 'Unmuted the chat' if not then 'Muted the chat'\n            sender.sendMessage(ChatColor.GREEN + (chatEnabled ? \"Unmuted the chat\" : \"Muted the chat\"));\n        }\n        // 返回值\n        return true;\n    }复制代码一旦这个插件开始运行，你就可以使用 /mutechat 来禁言聊天，重新使用解禁！就是这么简单！\n\n练习\n你可以怎样规划这个插件的结构呢？\n怎样可以让所有的消息都被处理，但是只有发送者能看见呢？\n注意我们没有包含任何权限检查。你可以怎样添加一个检查 /mutechat 命令的权限呢？\n如果你使用了 /mutechat，就算你是管理员也会被禁言。怎样才能添加管理员的覆盖呢？\n\n绕开玩家数量上限原文\n大多数小服务器全部都被玩家人数限制所限制，下面的例子将会展示跳过人数限制的方法。\n第一步，让我们创建一个主类。\npackage me.web.playerlimitbypass;\nimport org.bukkit.event.Listener;\nimport org.bukkit.plugin.java.JavaPlugin;\npublic class PlayerBypass extends JavaPlugin implements Listener {\n    @Override\n    public void onEnable() {\n    }\n}复制代码非常简单。\n接下来，创建我们的 EventHandler 并注册。\n    @EventHandler\n    public void onPlayerLoginEvent(PlayerLoginEvent event){\n    }\n    @Override\n    public void onEnable() {\n        // 注册事件\n        getServer().getPluginManager().registerEvents(this, this);\n    }复制代码下面的例子是最基础的。\n    @EventHandler\n    public void onPlayerLoginEvent(PlayerLoginEvent event){\n        // Checking if the reason we are being kicked is a full server\n        if (event.getResult() == PlayerLoginEvent.Result.KICK_FULL) {\n            // If the condition above is true, we execute the following code, that is allow the player on the server\n            event.allow();\n        }\n    }复制代码你可以优化这个基础，随便怎样都可以。比如检查玩家是否有权限。\n@EventHandler\n    public void onPlayerLoginEvent(PlayerLoginEvent event) {\n        // Checking if the reason we are being kicked is a full server\n        if (event.getResult() == PlayerLoginEvent.Result.KICK_FULL) {\n            // Checking if the player has the specified permission node\n            if (event.getPlayer().hasPermission(\"playerlimit.bypass\"))\n                // If the condition above is true, we execute the following code, that is allow the player on the server\n                event.allow();\n        }\n    }复制代码\n彩色粒子特效原文\n有 3 种粒子可以上色，但是看起来不是很明显。\nREDSTONE, SPELL_MOB 和 SPELL_MOB_AMBIENT 粒子可以使用自定义颜色，通过在生成时提供一些特殊的数据。\n你需要使用 Player.spawnParticle 方法，这含有粒子所需的全部参数。特别的，你需要判断 XYZ 的偏移量，\"extra\" 控制亮度，\"count\" 控制上色开关。\n这些参数的作用如下:\ncount: 必须设置为 0，这启用了粒子上色。注意这意味着你不能一次性生成多个彩色粒子(在一次命令/发包完成)。\nextra: 这控制了粒子颜色的亮度，一般情况下你设置为 1。\noffsetX: 在此输入 0 到 1 的值用于控制颜色的红色系数。\noffsetY: 在此输入 0 到 1 的值用于控制颜色的绿色系数。\noffsetZ: 在此输入 0 到 1 的值用于控制颜色的蓝色系数。\n所以生成绿色的红石粒子，你需要使用以下代码:\nplayer.spawnParticle(Particle.REDSTONE, x, y, z, 0, 0.001, 1, 0, 1);复制代码你可能注意到了红色系数没有设置为 0，这是因为一些特殊的客户端的原因，将其设置为 0 会一直渲染为红色 ....\n这只是红石粒子的特效，如果你想要完全的非红色，你可以使用 Float.MIN_VALUE 显示几乎没有红色。\n\n连接到 MySQL 数据库原文\n什么是数据库？\n当你进入了程序设计的深水区后，你会希望节省时间，将数据存储在表格里，方便开发者和用户，而不是创建各种包装类，hashmap，hashmap，无尽的 hashmap，等等。这就是数据库的由来。我可以保证我们中的大多数都听说过 \"数据库\"，而这也如其名一般:一个充满数据的库。但是它们是怎么存储的呢？他们必须使用一些高效的文件里而不是普通的文本。MySQL 服务器里的数据看起来就像这样:\n\n看着这张图，我想你大概对这有了一些理解。数据被整洁的保存为一行一行的，每种数据都被分类为每一列。在这个教程里，我将展示如何连接你的插件至数据库。但是请注意，你必须要有一些使用 MySQL 的经验。这里是一个很好的教程，我就是在这里学习这些基础的。\n现在回到正题，到底什么是数据库？在 MySQL 里的数据库是类似上面的表格，含有行和列。每一列都是一个数据类型，比如 Date，Int 等。基本的 SQL 数据类型都在这里。\n\n设置一个连接(Connection)\n首先，你必须准备这些东西:\nHostname - 域名。数据库的IP地址\nPort - 端口。数据库地址的端口\nDatabase - 数据库。使用的数据库名称，因为一个服务器可以有多个数据库\nUsername - 用户名。用于连接数据库\nPassword - 密码。与用户名相似，验证登录\n保证你有这五个东西，接着我们开始建立一个连接\npublic class Test extends JavaPlugin {\n    private Connection connection;\n    private String host, database, username, password;\n    private int port;\n    @Override\n    public void onEnable() {  \n        host = \"localhost\";\n        port = 3306;\n        database = \"BukkitCoding\";\n        username = \"root\";\n        password = \"123\";     \n    }\n    @Override\n    public void onDisable() {\n    }\n}复制代码这是你的插件的类里现在应该有的东西。注意域名，端口，数据库，用户名，密码只是示例，你需要将其改为你需要的信息。让这些数据可以配置是个不错的点子，这样你不用在数据库信息改变时都需要重新编译插件。如果你打算发布这个插件，那么你必须这样做。\n你可能注意到我声明的一个变量:\nprivate Connection connection;复制代码这是 'java.sql.Connection' 类，这也是我们用于连接的实例。在我们这样做之前，我们需要保证我们满足了所有连接 MySQL 服务器的要求。这里是一个可以返回 \"安全\" 的连接的方法:\npublic void openConnection() throws SQLException, ClassNotFoundException {\n    if (connection != null && !connection.isClosed()) {\n        return;\n    }\n    synchronized (this) {\n        if (connection != null && !connection.isClosed()) {\n            return;\n        } \n        Class.forName(\"com.mysql.jdbc.Driver\");\n        connection = DriverManager.getConnection(\"jdbc:mysql://\" + this.host+ \":\" + this.port + \"/\" + this.database, this.username, this.password);\n    }\n}复制代码这样做会检查系统是否安装了必须的 MySQL 的 jdbc 驱动。完成这个检查后，它将尝试使用 DriverManager 获得 Connection 实例，通过使用 'java.sql.DriverManager' 类的方法 getConnection 方法获得使用提供信息的连接。\n这个方法可以通过创建一个单独的类来控制所有的 MySQL 方法来让连接更加简单。\n现在你的主类应该是这样子的:\npublic class Test extends JavaPlugin {\n    private Connection connection;\n    private String host, database, username, password;\n    private int port;\n    @Override\n    public void onEnable() {\n        host = \"localhost\";\n        port = 3306;\n        database = \"TestDatabase\";\n        username = \"user\";\n        password = \"pass\";    \n        try {     \n            openConnection();\n            Statement statement = connection.createStatement();          \n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    @Override\n    public void onDisable() {\n    }\n    public void openConnection() throws SQLException, ClassNotFoundException {\n    if (connection != null && !connection.isClosed()) {\n        return;\n    }\n    synchronized (this) {\n        if (connection != null && !connection.isClosed()) {\n            return;\n        }\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        connection = DriverManager.getConnection(\"jdbc:mysql://\" + this.host + \":\" + this.port + \"/\" + this.database, this.username, this.password);\n    }\n}复制代码现在我们需要做的是连接到 MySQL 服务器。我们怎样可以发送命令来设置或是读取数据呢？现在就是 'java.sql.Statement' 实例的用处了。由你所见，我通过使用 connection.createStatement() 来获得了一个 Statement。这个方法会返回一个 statement，用于发送命令。注意到了现在你应该需要有如何使用 SQL 语言的经验。 \n\nStatements - 读取/存储数据\n你可以使用 statements 来执行命令，执行查询来接受存储在数据库里的数据，或是添加新的列，创建新的条目，或是编辑已有数据。\n\n获得数据\n假设我们有一个有两列的数据表， 'PLAYERNAME' 和 'BALANCE'。我们将要检索所有金钱为空的玩家。\nResultSet result = statement.executeQuery(\"SELECT * FROM PlayerData WHERE BALANCE = 0;\");\nList<String> bankruptPlayers = new ArrayList<String>();\nwhile (result.next()) {\n    String name = result.getString(\"PLAYERNAME\");\n    bankruptPlayers.add(name);\n}复制代码现在你会看到我通过执行 statement 对象的查询来创建了一个 ResultSet 对象。当处理查询时，这需要接收一个单独的  String 作为一个你必须包含在所有的查询中的参数。这将返回一个结果集。一个 ResultSet 是一个特殊的，包含所有查询返回的值的对象。我创建了一个 while 循环，并使用了 result.next() 方法作为条件。这个方法的作用是将你得到的结果集的迭代器向前加一。如果还有可用的条目则返回 true。注意当你创建 ResultSet 时，你需要执行 result.next() 方法来移动第一个条目。在循环中，我调用了  resultset.getString(\"PLAYERNAME\")。这将获得在 'PLAYERNAME' 下的一个玩家名。注意只有几个 get 方法才可以使用，用于接受可用的列的值。这是你从 MySQL 获得数据所需做的唯一一件事。\n\n设置数据\n使用这个教程相同的表，我们会设置一个玩家条目。不像是 getter，这更像是简单的一行代码。我们需要玩家的 String 名称，和 int 金钱。\nstatement.executeUpdate(\"INSERT INTO PlayerData (PLAYERNAME, BALANCE) VALUES ('Playername', 100);\");复制代码我们使用这个例子设置了 'Playername' 的玩家的金钱为 100。这就是向 MySQL 服务器存储数据的基本方法了。\n\n异步数据库交互\n异步的数据库交互对一个高效的插件是非常必要的。从数据库接受/存储信息会消耗时间，这是因为必须通过网络连接访问数据库，并且在主线程这样做会造成很大的延迟。\n所以，\"异步\" 究竟是什么呢？\n异步意味着不在主线程。主线程是游戏运行的循环，更新生物，破坏和放置方块。在主线程进行 IO(输入输出) 时，线程将会暂停直到输入输出完成。这就意味着当你等待 MySQL 发送数据，或者接受数据，服务器将不能进行任何事。这是造成卡顿的常见原因！\n异步执行就是不在主线程执行。这意味着当你等待数据发送接受时，所有的东西都会继续运行，不会停止。\n所以我要怎样做？\n异步执行是很简单的，你只需要创建一个新的 Runnable:\nBukkitRunnable r = new BukkitRunnable() {\n    @Override\n    public void run() {\n        //This is where you should do your database interaction\n    }\n}复制代码我们创建了一个新的 BukkitRunnable 实例。这是一个效用类，通过 Bukkit 的调度器让规划的任务更加简单执行。你只需要执行 BukkitRunnable#runTaskAsynchronously(Plugin) 方法就可以将其轻松的异步执行。\nr.runTaskAsynchronously(<Instance of your plugin>);复制代码你应该将 <Instance of your plugin> 替换为你的插件主类的实例，这可以通过一个变量储存或者如果你在主类里完成数据库交互，你只需要使用关键字 this。\n所以现在你需要做的就是把数据库交互的代码放进 run() 方法里。你的代码应该看起来像这样:\nBukkitRunnable r = new BukkitRunnable() {\n   @Override\n   public void run() {\n      try {\n         openConnection();\n         Statement statement = connection.createStatement();\n      } catch(ClassNotFoundException e) {\n         e.printStackTrace();\n      } catch(SQLException e) {\n         e.printStackTrace();\n      }\n   }\n};\nr.runTaskAsynchronously(this);复制代码一点也不难，但是你一定记住任何时候将数据库交互异步化都是极为重要的。\n当你知道如何使用它们的时候，MySQL 服务器是非常实用的工具。希望这篇文章可以带领你走向使用数据库的道路。\n\n提示\n如果你正在保存很多小的变化如经济更新，请在服务器使用缓存。避免发送过多的更新到 MySQL 服务器，因为这可能造成卡顿，尤其是你在主线程这样做的时候。\n\n创建一个简单的命令原文\n设计命令\n首先，你需要有一个已经想好的命令名，在这个片段，我们使用 \"/kit\"，然而你应该按照自己的情况使用合适的命令。\n通常情况下，推荐为每个新的命令创建一个新的类，这个类必须实现 CommandExecutor 接口。类文件看起来应该是这样的:\npublic class CommandKit implements CommandExecutor {\n    // This method is called, when somebody uses our command\n    @Override\n    public boolean onCommand(CommandSender arg0, Command arg1, String arg2, String[] arg3) {\n            return false;\n    }\n}复制代码重命名参数并填充方法，这是每个参数的意义:\nCommandSender 可以是是玩家， ConsoleCommandSender, 或 BlockCommandSender (一个命令方块)\nCommand 代表调用的命令是什么\nLabel 代表发送者输入的命令的第一个单词是什么 (不包括参数)\nArgs 是命令的剩余部分(不包括 label)，以空格分开并放入数组内\n在使用命令后给玩家物品之前，我们需要一个玩家对象。如果命令发送者为玩家，我们就可以执行，在这种情况，执行会给玩家物品。\n注意: CommandSender 对象有时不是玩家，有时需要检查是不是玩家执行的命令。如果你要做的只是发送消息，那么类型检查会让你的代码显得杂乱，并且降低实用性。\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n        if (sender instanceof Player) {\n            Player player = (Player) sender;\n            // Here we need to give items to our player\n        }\n        // If the player (or console) uses our command correct, we can return true\n        return true;\n    }复制代码接着我们给玩家物品，在这个例子中，我们给玩家 1 钻石和 20 砖。ItemStack 类代表一个物品，所以让我们创建一个新的 ItemStack，设置数量，最后，我们会将其给予玩家。\n我们的实例命令的代码看起来是这样的:\n    @Override\n    public boolean onCommand(CommandSender sender, Command cmd, String label, String[] args) {\n        if (sender instanceof Player) {\n            Player player = (Player) sender;\n            // Create a new ItemStack (type: diamond)\n            ItemStack diamond = new ItemStack(Material.DIAMOND);\n            // Create a new ItemStack (type: brick)\n            ItemStack bricks = new ItemStack(Material.BRICK);\n            // Set the amount of the ItemStack\n            bricks.setAmount(20);\n            // Give the player our items (comma-seperated list of all ItemStack)\n             player.getInventory().addItem(bricks, diamond);\n        }\n        // If the player (or console) uses our command correct, we can return true\n        return true;\n    }复制代码注意: 你也可以在创建物品的时候就设置数量，这样子会显得更简单，使用起来也更短。\nItemStack bricks = new ItemStack(Material.BRICK, 20);复制代码\n注册命令\n下一步，我们会注册我们的命令。通过在 onEnable() 方法中添加这一段代码就可以轻松完成:\n    @Override\n    public void onEnable() {\n        // Register our command \"kit\" (set an instance of your command class as executor)\n        this.getCommand(\"kit\").setExecutor(new CommandKit());\n    }复制代码添加至 plugin.yml\n最后一步是将我们的命令添加到 plugin.yml。打开它并加入这样一段，并测试你的插件。\n# Replace \"kit\" with the name of your command.\ncommands:\n  kit:\n    description: Your description\n    usage: /kit复制代码\n有一些需要注意的事:\n用于注册命令的字符串必须是你在 plugin.yml 使用的。\n你可以使用你的主类实例来初始化你的 CommamdExecutor 实例，如果有必要的话。\n如果你想收到你的 plugin.yml 设置的 usage 信息，将 onCommand() 方法返回 false。返回 true 代表执行成功。\n当一个无效的 CommandSender 试图执行命令，你可以抛出一个异常(比如控制台使用 /kit)。\n现在你已经完成了！我们希望你学会了创建命令的基础。\n\n1.9 以上的自定义物品模型原文\n目标\n在 1.9 更新中最令人激动的一件事就是物品现在可以有不同的，基于损坏值的模型了！这样我们就可以利用这个来给 Minecraft 添加 1000 种新的物品了。\n举个例子，下面的所有东西都是木锄头，使用不同的耐久值。\n\n\n代码\n这一部分相对来说简单一些。选择一个有耐久的物品(比如工具)，接着创建一个 ItemStack，设置耐久，在这个例子中我们设置为 1。\nItemStack customItem = new ItemStack(Material.WOOD_HOE, 1, (short)1);复制代码这会给你一个轻微损坏的木锄，像这样:\n\n但是我们显然不需要显示耐久条，并且也不希望这个物品使用后耐久变化。幸运的是，有一个标签就是做这个用的！\nhttps://hub.spigotmc.org/javadocs/s...ry/meta/ItemMeta.html#setUnbreakable(boolean)\nItemStack customItem = new ItemStack(Material.WOOD_HOE, 1, (short)1);\nItemMeta meta = customItem.getItemMeta();\nmeta.setUnbreakable(true); // On versions 1.11 and above\ncustomItem.setItemMeta(meta);复制代码这会给你这个:\n\n好，不再有损坏计了！但是如果我们想要创建自定义物品，我们可能不想要所有的原版的 lore。幸运的是，还有更多的 API！你可以添加隐藏 lore 的标签，像这样:\n        ItemStack customItem = new ItemStack(Material.WOOD_HOE, 1, (short)1);\n        ItemMeta meta = customItem.getItemMeta();\n        meta.spigot().setUnbreakable(true);\n        meta.addItemFlags(ItemFlag.HIDE_ATTRIBUTES, ItemFlag.HIDE_UNBREAKABLE);\n        customItem.setItemMeta(meta);复制代码太棒了，我们现在有了有耐久无损坏无介绍的物品了。\n这就是有关代码方面的东西了。你可能想要设置自定义名称和 lore，请自行决定。\n这个物品马上就要变为你梦想的自定义物品了，你只需要新的皮肤材质。\n\n资源包\n这里的东西变得有一些难懂了，如果你没有任何创建材质的经验，那么这就很简单。创建一个新的文件夹，放入看起来像这样的 pack.mcmeta 文件:\n{\n  \"pack\": {\n    \"pack_format\": 3,\n    \"description\": \"Official elMakers Magic Resource Pack\"\n  }\n}复制代码注意: Minecraft 1.10 或更低版本需要使用 pack_format: 2。\n像 \"assets/minecraft/models/item\" 一样添加子文件夹。\n在物品文件夹内，创建一个新的文件叫做 wooden_hoe.json。这将是你所有的自定义物品的 \"容器\"。这告诉了客户端应该在什么地方使用什么模型。\n这个文件看起来应该是这样的:\n{\n  \"parent\": \"item/handheld\",\n  \"textures\": {\n    \"layer0\": \"items/wood_hoe\"\n  },\n  \"overrides\": [\n    {\"predicate\": {\"damaged\": 0, \"damage\": 0.01666666666667}, \"model\": \"item/my_cool_custom_item\"}\n  ]\n}复制代码好吧，让我们拆开来讲。\n我们覆盖了木锄，但是拓展了新的版本。 \"parent\" 和 \"textures\" 告诉客户端使用原版模型。这意味着没有损坏的木锄看起来是原样。\n现在是新的物品了，\"overrides\" 让你给不同的货品使用依赖的物品模型。这些设置被称作 \"predicates\"，我们的目的是关注 \"damage\"  关键字。\n这将会将基于伤害值的模型多样化，如 0 - 1 的百分比。所以 \"0.016666\" 的值是来自于 \"1/60\" 的比率，因为这个物品最大的耐久为 60。\n查看 mc Wiki 中有关耐久的部分: http://minecraft.gamepedia.com/Hoe\n你也可以添加很多种 predicate，只要每次计算 \"x/60\" 的公式即可。\n你也可以使用这个工具来给物品一个特定的模板而不需要计算: http://accidentalgames.co\"/media/durabilityModels.php\n\n保存原始物品\n如果你仍然想用原版物品，那么这是可行的！\n添加另一行新的条目到你的模型中，看起来是这样的:\n{\n  \"parent\": \"item/handheld\",\n  \"textures\": {\n    \"layer0\": \"items/wood_hoe\"\n  },\n  \"overrides\": [\n    {\"predicate\": {\"damaged\": 0, \"damage\": 0.01666666666667}, \"model\": \"item/my_cool_custom_item\"},\n    {\"predicate\": {\"damaged\": 1, \"damage\": 0}, \"model\": \"item/wooden_hoe\"}\n  ]\n}复制代码最后，将你的自定义物品模型放入材质包中的同一位置，这里是 \"my_cool_custom_item.json\"。 (创建材质不是这个教程的目的，我认为已经有很好的教程和类似 Cubik 这样的工具了)\n将你的材质包压缩，放入 <minecraft>/resourcepacks 文件夹，你就可以加载并使用你的自定义材质了！\n如果还有疑惑，你可以看看我的GitHub上的材质包结构:\nhttps://github.com/elBukkit/MagicPlugin/tree/master/Magic/src/resource-pack/default\n\n最终总结\n一旦这些都可以正常使用后，你就应该考虑这些问题。\n更高等级的工具可以提供更多物品，比如钻石锄可以提供最高 1,562 的耐久度 (!)\n如果你想在服务器使用，你必须有个地方用于下载你的材质包！我认为 Dropbox 可以一试，只需要获得一个直链，然后添加到你的 server.properties 文件。\n如果你想要更新你的材质包，记得添加 SHA1 码到你的 server.properties 文件，或者每次都重命名你的材质包，否则客户端不会重新下载。\n另一个 1.9 的酷炫特性就是物品可以穿戴在头上并且会在游戏中显示！你需要添加一个 \"head\" 显示块到你的模型文件中，你可以在这里看看:\n\nhttps://github.com/elBukkit/MagicPl...ecraft/models/item/custom/magic_hat.json#L587\n我希望这可以帮到你，如果你在教程中找到了任何的问题，请务必让我知道！\n\n使用 Vault原文\n我们将会创建 3 个主命令:\nresetbalance - 设置玩家账户为 0givemoney - 将 100 放入玩家账户money - 查看玩家账户\n\n我们需要做的第一件事是下载 Vault，你可以在这里下载。\n接着，你需要将 \"Vault\" 添加到你的构建路径，不懂百度，或者看这篇Wiki。\n接着我们可以开始写代码了，你需要一个新的类，并且在 onEnable() 中连接到 Vault。\npackage me.yourpackage.vault;\nimport net.milkbowl.vault.economy.Economy;\nimport org.bukkit.java.JavaPlugin;\nimport org.bukkit.plugin.java.JavaPlugin;\npublic class Main extends JavaPlugin{\n    private static final Logger log = Logger.getLogger(\"Minecraft\");\n    public static Economy econ = null;\n    private static Permission perms = null;\n    private static Chat chat = null;\n    @Override\n    public void onEnable(){\nif (!setupEconomy()) {\n            log.severe(String.format(\"[%s] - Disabled due to no Vault dependency found!\", getDescription().getName()));\n            getServer().getPluginManager().disablePlugin(this);\n            return;\n        }\n        setupPermissions();\n        setupChat();\n    }\npublic void onDisable(){\nlog.info(String.format(\"[%s] Disabled Version %s\", getDescription().getName(), getDescription().getVersion()));\n}\n    private boolean setupEconomy() {\n        if (getServer().getPluginManager().getPlugin(\"Vault\") == null) {\n            return false;\n        }\n        RegisteredServiceProvider<Economy> rsp = getServer().getServicesManager().getRegistration(Economy.class);\n        if (rsp == null) {\n            return false;\n        }\n        econ = rsp.getProvider();\n        return econ != null;\n    }\n    private boolean setupChat() {\n        RegisteredServiceProvider<Chat> rsp = getServer().getServicesManager().getRegistration(Chat.class);\n        chat = rsp.getProvider();\n        return chat != null;\n    }\n    private boolean setupPermissions() {\n        RegisteredServiceProvider<Permission> rsp = getServer().getServicesManager().getRegistration(Permission.class);\n        perms = rsp.getProvider();\n        return perms != null;\n    }\n    public static Economy getEcononomy() {\n        return econ;\n    }\n    public static Permission getPermissions() {\n        return perms;\n    }\n    public static Chat getChat() {\n        return chat;\n    }\n}复制代码现在我们可以开始我们的第一个命令了。\n所以，我们在一个新的类做这件事，但是你必须先学会使用命令系统。\npublic boolean onCommand(CommandSender player, Command cmd, String label, String[] args) {\n}复制代码现在开始写第一个命令，resetbalance。\nMain.econ.withdrawPlayer(args[0], Main.econ.getBalance(args[0]));\nif (!(Bukkit.getPlayer(args[0]) == null)){\n           Main.econ.withdrawPlayer(args[0], Main.econ.getBalance(args[0]));\n           return true;\n} else {\n//Player Isnt Online\nreturn true;\n}}复制代码\n可交互的书原文\n创建一个书\n我们需要 ItemStack 的 BookMeta 来开始我们的第一步。只有一个为 Material.BOOK_AND_QUILL 或 Material.WRITTEN_BOOK 的物品才有 BookMeta。\nItemStack book = new ItemStack(Material.WRITTEN_BOOK);\nBookMeta bookMeta = (BookMeta) book.getItemMeta();复制代码\n获取每一页\nBookMeta 是一个 CraftBukkit 中的 CraftMetaBook 的 Bukkit 接口。这个教程写的时候，BookMeta 还没有一个方法获得一个 IChatBaseComponent 列表的方法，所以我们必须使用反射来获得。这是一个示例:\nList<IChatBaseComponent> pages = (List<IChatBaseComponent>) CraftMetaBook.class.getDeclaredField(\"pages\").get(bookMeta);复制代码这个字段的任何变化都会让书更新，所以我们编辑完成后必读赋值回去。\n\n创建一个可以点击和悬浮查看的页\n使用 BungeeCord 的 ChatComponentAPI(包括在 Spigot 服务器 jar 中)，你可以制造一个 IChatComponent 使用 BungeeCordAPI，就可以创建一个 IChatBaseComponent 来制作悬浮和点击事件了。\n当然你也可以创建自己的 jsonString，这可以让你使用书本特定的事件。\nBaseComponent text; //this is the base component we will be turning into a page\n//convert the base component into a json string\nString pageJson = ComponentSerializer.toString(text);\n//get an IChatBaseComponent object which represents this json string\nIChatBaseComponent page = IChatBaseComponent.ChatSerializer.a(pageJson);\n//add this page to the pages list\npages.add(page);复制代码\n完成创建 ItemStack\n当你添加了这个页之后，不要忘记将新的 BookMeta 添加回原来的 ItemStack! 你也可以设置书本的标题和作者。\nbookMeta.setTitle(\"Interactive Book\");\nbookMeta.setAuthor(\"gigosaurus\");\nbook.setItemMeta(bookMeta);复制代码\n一个样书\n//create the book\nItemStack book = new ItemStack(Material.WRITTEN_BOOK);\nBookMeta bookMeta = (BookMeta) book.getItemMeta();\nList<IChatBaseComponent> pages;\n//get the pages\ntry {\n    pages = (List<IChatBaseComponent>) CraftMetaBook.class.getDeclaredField(\"pages\").get(bookMeta);\n} catch (ReflectiveOperationException ex) {\n    ex.printStackTrace();\n    return;\n}\n//create a page\nTextComponent text = new TextComponent(\"Click me\");\ntext.setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, \"http://spigotmc.org\"));\ntext.setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder(\"Goto the spigot website!\").create()));\n//add the page to the list of pages\nIChatBaseComponent page = ChatSerializer.a(ComponentSerializer.toString(text));\npages.add(page);\n//set the title and author of this book\nbookMeta.setTitle(\"Interactive Book\");\nbookMeta.setAuthor(\"gigosaurus\");\n//update the ItemStack with this new meta\nbook.setItemMeta(bookMeta);复制代码不同版本的 NMS (无反射)\n原文\n我看见过很多人制作了一些固定版本的插件，用来发送 title，或者 actionbar 信息。很多人通过使用 NMS(net.minecraft.server) 实现这些功能，并且常常只有这样做才能实现这样的功能。因为 NMS 是版本特定的，所以我见过很多限定版本的插件，当新版本发行后，他们就不再支持原来的版本了。\n之前我在寻找让我的插件支持多版本的最好方法就是使用反射。\n当我在想 这是一个好事的时候(因为我的插件不支持老版本)，@DarkSeraphim 在我发布的一篇关于如何使用反射的帖子里告诉我说，服务器使用反射的情况更少，我们应该使用一个接口，用来检查版本合适时才加载我的插件。\n使用接口可以让我的 NMS 代码放在不同的类中，并且根据版本来使用特定的类，这完全避免了使用反射！\n尽管这个指南没有消除使用反射的需要，因为你可能遇到各种情况(有时你有必要使用它们)，比如发送一个 title 或者一条 actionbar 信息，这不是很棒吗?\n在这个示例插件里我们会发送一条 actionbar 公告到每个登录的玩家，这个插件将会在任何 1.8 的服务器工作。\n所以让我们开始:\n在你的插件里，你应该新建一个包用来放接口和 NMS 类:\n在这个包里，我们会创建一个叫 Actionbar 的接口，这个接口会含有 NMS 类用于发送实际的 actionbar 的虚方法，任何实现这个接口的类必须包含这个方法。\n所以让我们开始创建接口吧:\npackage me.clip.actionbarplugin.actionbar;\nimport org.bukkit.entity.Player;\npublic interface Actionbar {\n    public void sendActionbar(Player p, String message);\n}复制代码很简单是吧，只有一行代码，这是我们实现这个接口的类需要调用 NMS 的方法。\n如果你想给你的类添加更多功能，你可以任意添加新的方法，但是每个实现它的类必须包含列出的所有方法。\n现在我们有了自己的接口，让我们创建实际的用于发送 actionbar，使用 NMS 的类吧！\n1.8.1 的实现了 Actionbar 接口的类:\npackage me.clip.actionbarplugin.actionbar;\nimport net.minecraft.server.v1_8_R1.ChatSerializer;\nimport net.minecraft.server.v1_8_R1.IChatBaseComponent;\nimport net.minecraft.server.v1_8_R1.PacketPlayOutChat;\nimport org.bukkit.craftbukkit.v1_8_R1.entity.CraftPlayer;\nimport org.bukkit.entity.Player;\npublic class Actionbar_1_8_R1 implements Actionbar {\n    @Override\n    public void sendActionbar(Player p, String message) {\n        IChatBaseComponent icbc = ChatSerializer.a(\"{\"text\": \"\" + message + \"\"}\");\n        PacketPlayOutChat bar = new PacketPlayOutChat(icbc, (byte) 2);\n        ((CraftPlayer) p).getHandle().playerConnection.sendPacket(bar);\n    }\n}复制代码1.8.3 的实现了 Actionbar 接口的类:\npackage me.clip.actionbarplugin.actionbar;\nimport net.minecraft.server.v1_8_R2.IChatBaseComponent;\nimport net.minecraft.server.v1_8_R2.PacketPlayOutChat;\nimport net.minecraft.server.v1_8_R2.IChatBaseComponent.ChatSerializer;\nimport org.bukkit.craftbukkit.v1_8_R2.entity.CraftPlayer;\nimport org.bukkit.entity.Player;\npublic class Actionbar_1_8_R2 implements Actionbar {\n    @Override\n    public void sendActionbar(Player p, String message) {\n        IChatBaseComponent icbc = ChatSerializer.a(\"{\"text\": \"\" + message + \"\"}\");\n        PacketPlayOutChat bar = new PacketPlayOutChat(icbc, (byte) 2);\n        ((CraftPlayer) p).getHandle().playerConnection.sendPacket(bar);\n    }\n}复制代码现在我们有了所有的版本特定的类了，现在需要做的就是在主类里加载正确的类，获得一个 Actionbar 实例。\nActionbar 插件:\npackage me.clip.actionbarplugin;\nimport me.clip.actionbarplugin.actionbar.Actionbar;\nimport me.clip.actionbarplugin.actionbar.Actionbar_1_8_R1;\nimport me.clip.actionbarplugin.actionbar.Actionbar_1_8_R2;\nimport org.bukkit.Bukkit;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\npublic class ActionbarPlugin extends JavaPlugin implements Listener {\n    // our interface reference! Any class that implements Actionbar can be assigned to this reference!\n    // when we need to send an actionbar, all we need to do is call actionbar.sendActionbar(player, message);\n    // since the proper NMS class was assigned onEnable, we are now backwards compatible!\n    private Actionbar actionbar;\n    @Override\n    public void onEnable() {\n        if (setupActionbar()) {\n            Bukkit.getPluginManager().registerEvents(this, this);\n            getLogger().info(\"Actionbar setup was successful!\");\n            getLogger().info(\"The plugin setup process is complete!\");\n        } else {\n            getLogger().severe(\"Failed to setup Actionbar!\");\n            getLogger().severe(\"Your server version is not compatible with this plugin!\");\n            Bukkit.getPluginManager().disablePlugin(this);\n        }\n    }\n    // this method will setup our actionbar class and return true if the server is running a\n    // version compatible with our NMS classes.\n    // If the server is not compatible, it will return false!\n    private boolean setupActionbar() {\n        String version;\n        try {\n            version = Bukkit.getServer().getClass().getPackage().getName().replace(\".\",  \",\").split(\",\")[3];\n        } catch (ArrayIndexOutOfBoundsException whatVersionAreYouUsingException) {\n            return false;\n        }\n        getLogger().info(\"Your server is running version \" + version);\n        if (version.equals(\"v1_8_R1\")) {\n            //server is running 1.8-1.8.1 so we need to use the 1.8 R1 NMS class\n            actionbar = new Actionbar_1_8_R1();\n        } else if (version.equals(\"v1_8_R2\")) {\n            //server is running 1.8.3 so we need to use the 1.8 R2 NMS class\n            actionbar = new Actionbar_1_8_R2();\n        }\n        // This will return true if the server version was compatible with one of our NMS classes\n        // because if it is, our actionbar would not be null\n        return actionbar != null;\n    }\n    @EventHandler\n    public void onJoin(PlayerJoinEvent event) {\n        actionbar.sendActionbar(event.getPlayer(), \"Welcome to the server!\");\n    }\n}复制代码在我的教程插件里，我将所有的东西放在了主类。\n，如果你有一个更大的插件，并且使用了多个类(如你的监听器类)，你应该创建 Actionbar 的 getter，这样你在其他的类里也可以访问这个字段。\n创建一个 getter 是非常简单的，你看了这个就懂了:\npublic Actionbar getActionbar() {\n    return actionbar;\n}复制代码现在你的类就可以发送 actionbar 信息了！\n有很多种方式检查服务器版本，这完全由你决定，我使用了 Bukkit 包名，但是你也可以使用 Bukkit.getBukkitVersion() 然后决定使用哪一个 NMS 类。\n这样处理 NMS 代码是向后兼容的，这是个很蠢的证明。\n如果你的插件加载了与版本不符合的类，服务器就会抛出一个 ClassNotFoundException 异常。\n所以请保证只加载正确版本的类。\n就是这样了，我们现在有了一个向后兼容的 actionbar 插件，使用 NMS 而不是反射！当 Spigot 的新版本发行后，有了新的包名，我们要做的只是添加一个新的 NMS 类，然后更新，检查新版本的加载设定。\n\n感谢阅读。我不是最好的开发者，我也像你一样每天学习新的知识。\n我希望这个教程可以让一些人学会如何使用接口来用 NMS 在不同版本上做事而不用反射。\n\n创建自定义的合成原文\n在这个代码片段中，我们会向你展示如何创造使用自定义物品的自定义合成。我们将会制作一个以钻石剑为基础的绿宝石剑。\n\n你需要什么\n现在我们需要一个继承了 JavaPlugin 的类，含有 onEnable() 方法。\n\n变量\n现在我们开始，我们需要 3 个 onEnable() 内的变量。\n// Our custom variable which we will be changing around.\nItemStack item = new ItemStack(Material.DIAMOND_SWORD);\n// The meta of the diamond sword where we can change the name, and properties of the item.\nItemMeta meta = item.getItemMeta();\n// We will initialise the next variable after changing the properties of the sword复制代码这里我们更改了属性，这样这就不是一个普通的钻石剑了。\n// This sets the name of the item.\n// Instead of the § symbol, you can use ChatColor.<color>\nmeta.setDisplayName(\"§aEmerald Sword\");\n// Set the meta of the sword to the edited meta.\nitem.setItemMeta(meta);\n// Add the custom enchantment to make the emerald sword special\n// In this case, we're adding the permission that modifies the damage value on level 5\n// Level 5 is represented by the second parameter. You can change this to anything compatible with a sword\nitem.addEnchantment(Enchantment.DAMAGE_ALL, 5);复制代码\n创建新的合成\n这里就是最有趣的地方了，我们的变量在这里将会被使用。\n// Create our custom recipe variable\nShapedRecipe recipe = new ShapedRecipe(item);\n// Here we will set the places. E and S can represent anything, and the letters can be anything. Beware; this is case sensitive.\nrecipe.shape(\" E \", \" E \", \" S \");\n// Set what the letters represent.\n// E = Emerald, S = Stick\nrecipe.setIngredient('E', Material.EMERALD);\nrecipe.setIngredient('S', Material.STICK);\n// Finally, add the recipe to the bukkit recipes\nBukkit.addRecipe(recipe);复制代码\n完成\n你已经完成了创建新的合成，现在你应该看看合在一起的代码:\n   public void onEnable() {\n        // Our custom variable which we will be changing around.\n        ItemStack item = new ItemStack(Material.DIAMOND_SWORD);\n        // The meta of the diamond sword where we can change the name, and properties of the item.\n        ItemMeta meta = item.getItemMeta();\n        // We will initialise the next variable after changing the properties of the sword\n        // This sets the name of the item.\n        // Instead of the § symbol, you can use ChatColor.<color>\n        meta.setDisplayName(\"§aEmerald Sword\");\n        // Set the meta of the sword to the edited meta.\n        item.setItemMeta(meta);\n        // Add the custom enchantment to make the emerald sword special\n        // In this case, we're adding the permission that modifies the damage value on level 5\n        // Level 5 is represented by the second parameter. You can change this to anything compatible with a sword\n          item.addEnchantment(Enchantment.DAMAGE_ALL, 5);\n        // Create our custom recipe variable\n        ShapedRecipe recipe = new ShapedRecipe(item);\n        // Here we will set the places. E and S can represent anything, and the letters can be anything. Beware; this is case sensitive.\n        recipe.shape(\" E \", \" E \", \" S \");\n        // Set what the letters represent.\n        // E = Emerald, S = Stick\n        recipe.setIngredient('E', Material.EMERALD);\n        recipe.setIngredient('S', Material.STICK);\n        // Finally, add the recipe to the bukkit recipes\n        Bukkit.addRecipe(recipe);\n    }复制代码确保你的所有的导入都来自 org.bukkit.\n这里是正确的导入列表:\nimport org.bukkit.Material;\nimport org.bukkit.enchantments.Enchantment;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.ShapedRecipe;\nimport org.bukkit.inventory.meta.ItemMeta;复制代码来自 md-5 的源码就在 GitHub\nhttps://github.com/md-5/SmallPlugins/blob/master/EmeraldSword/src/main/java/net/md_5/EmeraldSword.java\n\n编辑、使用牌子原文\n这是一个用来教你如何编辑牌子，交互牌子的教程。我可不是最好的插件编写者，所以如果有什么缺漏或者错误请务必告诉我，然后我会添上。\n\nSignChangeEvent\n这个事件显然是当牌子更改时被触发，并且可以取消。关于事件的其他说明和 API 可以前往 Spigot Developer Hub 查看。现在，让我们先开始写一些代码，我会先创建一个简单的 EventHandler:\n@EventHandler\npublic void onSignChange(SignChangeEvent e) {\n    if (e.getPlayer().hasPermission(\"sign.color\")) {\n    }\n}复制代码上面的代码也包含了一个简单的权限检查，方便管理服务器。下一步，我们显然知道牌子有 4 行，所以我们可以这样更新我们的 handler:\n@EventHandler\npublic void onSignChange(SignChangeEvent e) {\n    if (e.getPlayer().hasPermission(\"sign.color\")) {\n        for (int i = 0; i < 4; i++) {\n            String line = e.getLine(i);\n            if (line != null && !line.equals(\"\")) {\n                e.setLine(i, ChatColor.translateAlternateColorCodes('&', line));\n            }\n        }\n    }\n}复制代码现在我们拆开来讲，我们有一个重复 4 遍的循环:\nfor (int i = 0; i < 4; i++) {复制代码接着，用代码获取每一行，要保证其不是 null 或者是一个空的字符串，因为玩家可能什么也没有写。\nString line = e.getLine(i);\nif (line != null && !line.equals(\"\")) {复制代码这个检查完成后，我们现在可以操作这个事件了，在这个例子里，我们将会吧 '&' 替换为真正的颜色符。\ne.setLine(i, ChatColor.translateAlternateColorCodes('&', line));复制代码这就是了，这是我们的 SignChangeEvent ，我们可以用它设置获取行数内容，但是不要忘了有个方法可以返回所有的行。\ngetLines()复制代码\n如何从一个方块得到牌子\n这就是代码，你可以运行:\nBlock b = p.getLocation().getBlock();复制代码你是知道这是一个牌子的，你只是想编辑它，但是你不能，因为电脑不知道这是一个牌子，所以我们需要告诉他怎么做，通过使用:\ngetType()复制代码返回一个 Material 枚举告诉你这是一个牌子。\nif (b.getType() == Material.WALL_SIGN || b.getType() == Material.SIGN_POST)复制代码当这是一个牌子，你就可以将 Block State 转换为牌子:\nSign sign = (Sign)b.getState();复制代码保证你导入了 Block 对象。\nimport org.bukkit.block.Sign;复制代码而不是\nimport org.bukkit.material.Sign;复制代码这是两个完全不同的东西，当你编辑某个方块你需要导入它，现在我们有了方块，我们可以做很多事了，比如:\nsign.getLine(int line); // Get any line (line ranges from 0 to 3); returns String\nsign.setLine(int line, String text); // Set any line (Same range for line); returns void\nsign.getLines(); // Get all the lines; returns String[]复制代码现在继续，我们可以使用 PlayerInteractEvent 来让点击木牌的玩家交互，只需要继续按照上面的代码来:\n@EventHandler\npublic void onSignClick(PlayerInteractEvent e) {\n    if (e.getAction() != Action.RIGHT_CLICK_BLOCK) {\n        return;\n    }\n    Player p = e.getPlayer();\n    if (p.hasPermission(\"sign.use\")) {\n        Block b = e.getClickedBlock();\n        if (b.getType() == Material.SIGN_POST || b.getType() == Material.WALL_SIGN) {\n            Sign sign = (Sign) b.getState();\n            if (ChatColor.stripColor(sign.getLine(0)).equalsIgnoreCase(\"[WARP]\")) {\n                String warp = sign.getLine(2);\n                Bukkit.dispatchCommand(p, \"warp \" + warp);\n            }\n        }\n    }\n}复制代码这个部分你唯一不需要详细了解的就是\nif (ChatColor.stripColor(sign.getLine(0)).equalsIgnoreCase(\"[WARP]\")) {\n    String warp = sign.getLine(2);\n    Bukkit.dispatchCommand(p, \"warp \" + warp);\n}复制代码现在，我们应该检查第一行是不是 [WARP]，如果是，我们就要将玩家传送到第三行的坐标去。(我们使用了 dispatchCommand，这会提醒玩家是否有权限传送)\n上面的这些包含了一些轻量的木牌传送，区域跳跃 甚至是有趣的小游戏。我希望这个教程可以教会不知道木牌的开发者们。请自由留下评论 我只是希望教会人们怎么在 Bukkit/Spigot 使用木牌。\n如果你觉得你能添加更多，或者修复我的一些小错误，请随意编辑！我会很高兴有这么多人帮助我完善这篇教程。\n\n不同版本的 Sound 枚举原文\n如果你想要在插件里给玩家播放声音，这是很简单的，你只需要\nplayer.playSound(player.getEyeLocation(), Sound.BLOCK_NOTE_PLING, 1, 1);复制代码所以这有什么问题吗？其实是因为在 1.9，Sound 枚举里的声音名称已经改变，变得更加像你的 /playesound 命令一样。你可以在这里找到\n1.9\n1.9 之前\n现在，所有为 1.7/1.8 制造的插件不会继续在 1.9 上运行了！如何让 1.9 的插件仍然有向后的兼容呢？好吧，你可以使用 if 来判断版本号。我们快来试试！\nif (Bukkit.getVersion().contains(\"1.9\")) {\n     player.playSound(player.getEyeLocation(), Sound.BLOCK_NOTE_PLING, 1, 1);\n} else {\n     player.playSound(player.getEyeLocation(), Sound.NOTE_PLING, 1, 1);\n}复制代码好吧，很令人悲伤，这也不会运行，为什么呢？因为 Sound.NOTE_PLING 没有在 1.9 出现，但你使用了 1.9 作为你的库！而且不要试图切换库的版本，要不然第一个就不会正常工作了！所以要怎样同时使用两个库呢？其实这很简单：\nif (Bukkit.getVersion().contains(\"1.9\")) {\n     player.playSound(player.getEyeLocation(), Sound.valueOf(\"BLOCK_NOTE_PLING\"), 1, 1);\n} else {\n     player.playSound(player.getEyeLocation(), Sound.valueOf(\"NOTE_PLING\"), 1, 1);\n}复制代码现在对了！你可以一排解决，牺牲一些可读性，像这样：\nplayer.playSound(player.getEyeLocation(), Sound.valueOf(Bukkit.getVersion().contains(\"1.9\") ? \"BLOCK_NOTE_PLING\" : \"NOTE_PLING\"), 1, 1);复制代码如果你正在制造一些像是 Util 的东西，你可以这样：\npublic static String getPre1_9Name(Sound sound) {\n     switch (sound) {\n          case BLOCK_NOTE_PLING: return \"NOTE_PLING\";\n          case ENTITY_ITEM_BREAK: return \"ITEM_BREAK\";\n     }\n}复制代码等等。\n这是一个简单的、能让你的插件兼容多个版本、能让玩家享受完美的音效的小技巧。\n\n禁止小僵尸原文\n这是一个简单的示例，展示了如何在一个生物即将出生时编辑它。\n在这个例子里，如果一个僵尸出生并且是一个小僵尸，你可以阻止生成或者将其更改为普通僵尸。\n在这个例子里，我们阻止生成。下面的例子我们将其更改为大僵尸，你可以学习在自己的实际情况下使用。\n//called when a creature spawns.\n@EventHandler\npublic void onCreatureSpawn(CreatureSpawnEvent event) {\n    //check if the creature spawned is a zombie.\n    if (event.getEntity().getType() == EntityType.ZOMBIE) {\n        //create a variable to store the zombie.\n        Zombie zombie = (Zombie) event.getEntity();\n        //check if the zombie is a baby.\n        if(zombie.isBaby()) {\n            // don't spawn it.\n            event.setCancelled(true);\n             // Or you could instead just restore the zombie's maturity with this line.\n            zombie.setBaby(false);\n        }\n    }\n}复制代码\n\n\n防止 Tab 重置你的配置文件原文\n目标\n作为一个插件开发者，如果你有一个 config.yml 在你的插件里，你会知道当用户告诉你他们的整个 config.yml 被重置了的痛苦、随着脸色一阵苍白，你知道这是因为用户输入了 Tab 而不是空格。\n所以我们应该怎么样呢？有了这个教程，你可以监测 yml 文件中的 TAB 防止文件重置。不再需要在线的 YAML 转换器了！你的插件将会很有效率的处理。\n\n开始之前\n非常建议你先对以下进行了解后再开始。\n对 java.util.Scanner 的基础了解对 Bukkit Configuration API 的基础了解\n\n建立你的类\n我们要用主类来进行 TAB 检测。\n/**\n* Our class name is going to be YamlTabParser. Replace with your main class\n* name!\n*\n*/\npublic class YamlTabParser extends JavaPlugin {}复制代码\n基础操作\n接下来我们定义两个变量。\npublic class YamlTabParser extends JavaPlugin {\n    /*\n     * These two member variables are pointers to the config.yml file we will be\n     * creating. They are fields because they have a very broad scope and must\n     * be handled appropriately during save and load operations\n     */\n    private File file;\n    private FileConfiguration config;\n}复制代码接着我们覆写 onEnable().\n    @Override\n    public void onEnable() {\n        // define member variables\n        // NOTE: You cannot use a constructor in the main class! This would\n        // crash your plugin!\n        file = new File(getDataFolder(), \"config.yml\");\n        config = new YamlConfiguration();\n        // reload and save files, we will be overriding the JavaPlugin\n        // implementations in a later step.\n        reloadConfig();\n        saveConfig();\n    }复制代码\n覆写 saveConfig() 和 getConfig()\n我们在 onEnable() 完成初始化后，我们必须覆写 saveConfig() 方法和 getConfig() 方法来匹配我们之前定义的成员变量。\n    /**\n     * Overrides by returning our defined FileConfiguration variable\n     */\n    @Override\n    public FileConfiguration getConfig() {\n        return config;\n    }\n    /**\n     * Overrides the default save operation by saving using our predefined File\n     * and FileConfiguration variables.\n     */\n    @Override\n    public void saveConfig() {\n        try {\n            config.save(file);\n        }\n        catch (IOException e) {\n            // print stacktrace if you prefer\n            getLogger().severe(\n                    \"Could not save config.yml due to: \" + e.getMessage());\n        }\n    }复制代码注意这里没什么多说的，我们只是在制作一个配置存储的方法。\n技巧: 使用 @Override 注释，这样如果你有方法拼写错误，编译器将会提示你。\n\n创建你的 Scanner\n现在如果你按照之前的步骤来的话，我们就要开始真正的重点：扫描文件中的 TAB。\n注意: 如果你之前没有使用过 Scanners，我建议你花些时间来阅读一下。这会让你理解下面几步。\n我们的方法返回 void，并且没有参数。因为我们的 FileConfiguration 和 File 变量是全局的，这是最方便的。\n    /**\n     * Opens a java.util.Scanner to scan the config file for any tabs.\n     */\n    private void scanConfig() {}复制代码声明 Scanner\n    private void scanConfig() {\n        // declare our scanner variable\n        Scanner scan = null;\n    }复制代码定义 Scanner\n    private void scanConfig() {\n        Scanner scan = null;\n        try {\n            scan = new Scanner(file);\n        }\n        catch (FileNotFoundException e) {\n            // this error should never happen if the file exists\n            e.printStackTrace();\n        }\n    }复制代码现在我们完成了一些基础工作，scanner 读取文件或是一个一个读字节都是很有效率的。当我们读取文件时，我们希望注意两个东西，文件的行数和该行的内容。\n注意我们实际上不需要行数，这取决于用户，如果我们一直跟踪行数，然后我们找到了一个 TAB，我们可以告诉用户哪一行是找到的 TAB！\n    private void scanConfig() {\n        Scanner scan = null;\n        try {\n            scan = new Scanner(file);\n            int row = 0;\n            String line = \"\";\n        }\n        catch (FileNotFoundException e) {\n            // this error should never happen if the file exists\n            e.printStackTrace();\n        }\n    }复制代码我们必须读取文件，一行一行的来，一个 while 循环是最方便的方法。当文件有下一行，我们会重新定义一遍临时变量。\n    private void scanConfig() {\n        Scanner scan = null;\n        try {\n            scan = new Scanner(file);\n            int row = 0;\n            String line = \"\";\n            // iterate through the file line by line\n            while (scan.hasNextLine()) {\n                line = scan.nextLine();\n                // add to the row\n                row++;\n            }\n        }\n        catch (FileNotFoundException e) {\n            // this error should never happen if the file exists\n            e.printStackTrace();\n        }\n    }复制代码现在我们在一行一行间迭代，我们检查是否包含 TAB，在 Java 里，TAB 将会转变为正则表达式。一些对正则表达式的基础了解是很有用的，但并不是必须的。TAB 的正则表达式是 '\\t'。每次在你的文件中有 TAB，他都将转换为 '\\t'。我们不在意 TAB 在哪里，但是确实出现了。我们可以用 String#indexOf() 来检查是否含有 TAB。\n    private void scanConfig() {\n        Scanner scan = null;\n        try {\n            scan = new Scanner(file);\n            int row = 0;\n            String line = \"\";\n            // iterate through the file line by line\n            while (scan.hasNextLine()) {\n                line = scan.nextLine();\n                // add to the row\n                row++;\n                // If a tab is found ... \\t = tab in regex\n                if (line.indexOf(\"\\t\") != -1) {\n                    /*\n                     * Tell the user where the tab is! We throw an\n                     * IllegalArgumentException here. The reason for this will\n                     * be explained further down the article.\n                     */\n                    String error = (\"Tab found in config-file on line # \" + row + \"!\");\n                    throw new IllegalArgumentException(error);\n                }\n            }\n        }\n        catch (FileNotFoundException e) {\n            // this error should never happen if the file exists\n            e.printStackTrace();\n        }\n    }\n}复制代码因为这个方法处理文件读取，所以我们必须在没有 TAB 后加载文件。我们也需要关闭 Scanner 来防止内存泄露。\n注意: 加载操作会抛出 InvalidConfigurationException 和 IOException，你必须正确处理。\n    /**\n     * Opens a java.util.Scanner to scan the config file for any tabs.\n     */\n    private void scanConfig() {\n        // declare our scanner variable\n        Scanner scan = null;\n        try {\n            scan = new Scanner(file);\n            int row = 0;\n            String line = \"\";\n            // iterate through the file line by line\n            while (scan.hasNextLine()) {\n                line = scan.nextLine();\n                // add to the row\n                row++;\n                // If a tab is found ... \\t = tab in regex\n                if (line.indexOf(\"\\t\") != -1) {\n                    /*\n                     * Tell the user where the tab is! We throw an\n                     * IllegalArgumentException here.\n                     */\n                    String error = (\"Tab found in config-file on line # \" + row + \"!\");\n                    throw new IllegalArgumentException(error);\n                }\n            }\n            /*\n             * load the file, if tabs were found then this will never execute\n             * because of IllegalArgumentException\n             */\n            config.load(file);\n        }\n        catch (FileNotFoundException e) {\n            // this error should never happen if the file exists\n            e.printStackTrace();\n        }\n        catch (IOException e) {\n            // failed loading error\n            e.printStackTrace();\n        }\n        catch (InvalidConfigurationException e) {\n            // snakeyaml error if the config setup is incorrect.\n            e.printStackTrace();\n        }\n        finally {\n            // Close the scanner to avoid memory leaks.\n            if (scan != null) {\n                scan.close();\n            }\n        }\n    }复制代码\n覆写重载方法\n我们还没完呢！我们需要在插件加载时和插件重载时都要读取配置。我们在插件加载时调用 scanConfig() 方法，在插件重载时调用 reloadConfig() 方法。\n    /**\n     * Override default implementation for reloading\n     */\n    @Override\n    public void reloadConfig() {\n        if (!file.exists()) {\n            // Create file if it doesn't exist. Change appropriately based on\n            // your setup\n            saveDefaultConfig();\n        }\n        scanConfig();\n    }复制代码\n总结\n如果你按照这些正确执行后，你现在有了一个 YAML TAB 检测器了！整个的类可以在 GitHub Gist 找到。\n提示: 如果你想要一个线程安全的操作，不要使用 Scanner。一个 BufferedReader 将会同步完成任务，但我不会在这里讲。Bukkit-API 是非常不线程安全的，所以没有必要将这个操作异步化。\n\n建立 MongoDB 数据库\n查看 https://www.runoob.com/mongodb/mongodb-linux-install.html\n其他关于如何在 Java 连接到 MongoDB 的方法请在目录寻找，前面有两篇\n\nSpigot 配置 (server.properties)原文\ngenerator-settings\n默认值: \"\"\n数据类型: String\n描述: 让主世界进一步定制生成引擎，例如: SuperFlat\n\nop-permission-level\n默认值: 4\n数据类型: Integer\n描述:设置你的管理员的默认权限的一种方式. 权限大小从低到高为1~4,1级的管理员能够无视主城保护，2级的管理员能够管理普通玩家并维护服务器秩序，他们能够执行诸如/clear, /difficulty, /effect, /gamemode, /gamerule, /give, 和 /tp 这样的命令. 请注意，他们还能够编辑命令方块. 3级的管理员能够管理普通的管理员——他们能够使用/ban, /deop, /kick, 和 /op 这样的命令. 4级的管理员相比于3级更多的权限是能够直接控制服务器——是的，他们能够使用/stop 和 /save-*. \n\nallow-nether\n默认值: true\n数据类型: Boolean\n描述: 是否生成地狱. false意味着地狱将不会生成\n\nlevel-name\n默认值: \"world\"\n数据类型: String\n描述: 选择主世界的名称以及其主目录. 对应的地狱或者末地会生成在该子目录下.\n\nenable-query\n默认值: false\n数据类型: Boolean\n描述: 选择是否能够远程查询你的服务器.\n\nallow-flight\n默认值: false\n数据类型: Boolean\n描述: 是否检查飞行. 这里指的不仅仅是非法飞行——所有非OP成员的飞行都会被拦截，无论是通过作弊端亦或是/fly\n\nannounce-player-achievements\n默认值: true\n数据类型: Boolean\n描述: 当玩家获得一个新成就时，是否在全屏发送通告. \n\nserver-port\n默认值: 25565\n数据类型: Integer\n描述: 选择启动的端口. 玩家输入 IP:端口 以连入服务器.\n\nlevel-type\n默认值: \"DEFAULT\"\n数据类型: String\n描述: 选择世界生成器，例如 AMPLIFIED, FLAT, LARGEBIOMES, CUSTOMIZED.\n\nenable-rcon\n默认值: false\n数据类型: Boolean\n描述: 控制服务器是否接受rcon (远程控制台)协议.\n\nforce-gamemode\n默认值: false\n数据类型: Boolean\n描述: 玩家在加入游戏时是否重置为默认模式.\n\nlevel-seed\n默认值:\n数据类型: String\n描述: 选择服务器的种子.\n\nserver-ip\n默认值:\n数据类型: IPv4 Address\n描述: 如果服务器同时有多个IP，控制服务器从哪个IP接收玩家. 通常留空. \n\nmax-build-height\n默认值: 256\n数据类型: Integer\n描述: 世界之顶，玩家能够建筑的最高高度，填写1~256的整数. \n\nspawn-npcs\n默认值: true\n数据类型: Boolean\n描述: 在村庄里是否生成村民.\n\nhardcore\n默认值: false\n数据类型: Boolean\n描述: 是否开启极限模式(死亡的玩家将被从服务器中禁止).\n\nsnooper-enabled\n默认值: true\n数据类型: Boolean\n描述: 选择是否自动将服务器信息发送给Mojang.\n\nonline-mode\n默认值: true\n数据类型: Boolean\n描述: 是否开启正版验证.\n\nresource-pack\n默认值:\n数据类型: URL\n描述: 服务端是否使用其他资源包. 如果不使用其他资源包，请留空;否则，请填写资源包下载链接.\n\npvp\n默认值: true\n数据类型: Boolean\n描述: 控制玩家是否能给他人造成伤害.\n\ndifficulty\n默认值: 1\n数据类型: Integer\n描述: 控制游戏难度，从0~3依次是:和平，简单，普通，困难.\n\nenable-command-block\n默认值: false\n数据类型: Boolean\n描述: 服务器中能否籍借命令方块来执行命令.\n\ngamemode\n默认值: 0\n数据类型: Integer\n描述: 服务器的默认模式，从0~2，依次是生存，创造，冒险.\n\nplayer-idle-timeout\n默认值: 0\n数据类型: Integer\n描述: 当此项为0，则不对挂机玩家做出任何处理;当此项非0，则会踢出该秒数未活动的玩家.（注意，以秒为单位）\n\nmax-players\n默认值: 20\n数据类型: Integer\n描述: 控制同一时刻最多能有多少玩家在线.\n\nspawn-monsters\n默认值: true\n数据类型: Boolean\n描述: 是否生成怪物.\n\ngenerate-structures\n默认值: true\n数据类型: Boolean\n描述: 在世界中是否生成各种结构体，例如沙漠神庙、村庄和地牢.\n\nview-distance (被Spigot覆盖)\n默认值: 10\n数据类型: Integer\n描述: 玩家能够看到多大范围内的生物，取值为(1-15).\n#与Spigot.yml比例关系为4:1,这儿4=那儿1\n\nspawn-protection\n默认值: 16\n数据类型: Integer\n描述: 以主城为中心，半径多少的方格将不会被非OP破坏.\n\nmotd\n默认值: A minecraft server\n数据类型: String\n描述: 控制显示在服务器列表中的MOTD信息.\n\nby @Smokey_Days \n\n使用 Redis (Jedis)原文\n什么是 Redis?\nRedis 是一个键值数据库，基于 HashMap（但也接受其他的数据类型），非常适用于计分板，统计，用户账户等。BuildAPrefix 是我使用 Redis 的一个产物。\n\n我怎样使用 Redis?\n很高兴你问了！我会使用 Apache Maven 来管理依赖，但你可以直接将 Jedis 添加到构建路径。GitHub 页面。请注意有些代码是来自我的项目。\n添加 Jedis 为一个依赖，很简单，不需要 repo。你还需要添加 Apache Commons Pools 来保证 Jedis 正常运行。\n<dependency>\n    <groupId>redis.clients</groupId>\n    <artifactId>jedis</artifactId>\n    <version>2.8.1</version>\n    <type>jar</type>\n    <scope>compile</scope>\n</dependency>\n<dependency>\n    <groupId>org.apache.commons</groupId>\n    <artifactId>commons-pool2</artifactId>\n    <version>2.4.2</version>\n</dependency>复制代码接着把 Jedis 打包到你的 jar 里，这很重要，否则运行时会报错。\n<build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>2.1</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <relocations>\n                                <relocation>\n                                    <pattern>redis.clients.jedis</pattern>\n                                    <shadedPattern>your.package.here.shaded.redis.clients.jedis</shadedPattern>\n                                    <pattern>org.apache.commons</pattern>\n                                    <shadedPattern>your.package.here.shaded.org.apache.commons</shadedPattern>\n                                </relocation>\n                            </relocations>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>复制代码现在在 onEnable() 方法初始化 JedisPool，这是一个线程安全的访问 Jedis 的方法。\nprivate JedisPool pool;\n@Override\npublic void onEnable() {\n    /*\n     * THANKS TO @Tux for the ClassLoader wizardry.\n     */\n    ClassLoader previous = Thread.currentThread().getContextClassLoader();\n    Thread.currentThread().setContextClassLoader(RedisDatabase.class.getClassLoader());\n    pool = new JedisPool(\"ip\", 123 /* Port */);\n    Thread.currentThread().setContextClassLoader(previous);\n}\n@Override\npublic void onDisable() {\n    pool.close();\n}复制代码最后，要用 Jedis 只需要（try-with-resource）\n// Try-with-resources will handle calling #close() for us\ntry (Jedis jedis = pool.getResource()) {\n   // If you want to use a password, use\n   jedis.auth(\"some-secure-password\");\n   jedis.set(\"key\", \"value\");\n   getLogger().info(jedis.get(\"key\"));\n}复制代码\n入门向量编程原文\n什么是向量？\n向量由长度和方向组成，总是用来描述从一个点到另一个的移动。很多人包括你可能已经听说过向量，或是见到一些用来表示向量的奇怪的箭头。现在让我们看看 Spigot 里的向量。\n\nSpigot 里的向量\nSpigot 里的向量可以在 org.bukkit.util 包里找到，可以用以下方法创建：\nVector v = new Vector();  //Creates a vector with length 0 and NO direction\nVector v = new Vector(x, y, z);  //Creates a vector with defined direction and length复制代码每个向量都用 3 个值来表示他的方向（X, Y, Z）。有一点你需要知道，你可以使用 length() 方法获得这个向量的长度（速度的大小），使用这些方法来获得/设置每个轴的值 .getX(), .getY(), .getZ(), and .setX(x), .setY(y), .setZ(z)。\n\nSpigot 的向量有什么用？\n无论是一个实体的移动，还是你正在看着的目标，计算的时候都需要向量。在这篇教程的结尾，你也可以这样做。\n让我们解释一下可能的计算：\n* 蓝色的箭头总是计算的结果\n\n向量加法\n\n这个计算很简单，你有两个向量相加，让我们编程实现：\nVector first = new Vector(1, 3, 2);\nVector second = new Vector(3, -1, 4);\n// Let's add them together!\nVector result = first.add(second); // Result is now a Vector of 4, 2, 6复制代码\n向量数乘\n\n第二个简单而必要的计算。只需要将向量长度相乘，当乘数是个负数，向量的方向与原来相反。\nVector v = new Vector(3, 4, 2);\nVector result1 = v.multiply(2);  // Vector of 6, 8, 4\nVector result2 = v.multiply(-1); // Vector of -3, -4, -2复制代码就像你看到的一样，向量的每一个值都被乘以乘数。\n\n普通化\n将向量的长度设置为 1。比如你有一个向量 (3, 3, 3)，接着它的长度是 √( (3^2)+(3^2)+(3^2) ) = √(27) = 5.19。\n普通化一个向量就是将其长度缩短至 1。所以普通化也就等于使用这个方法 .multiply(1/5.19) ，得到这个向量 (0.57, 0.57, 0.57)。（1/5.19=0.57）\nVector v = new Vector(3, 3, 3);\nVector result = v.normalize();  // Returns vector of length 1 and movement of 0.57, 0.57, 0.57复制代码\n向量积（叉乘）\n\n这个计算返回两个向量正交的向量。长度是浅蓝色的四边形。这个可以用来比较两个向量是否几乎相同（比如当指向玩家时）。\nVector first = new Vector(1, 2, 3);\nVector second = new Vector(-7, 8, 9);\nVector result = first.crossProduct(second); // Will return vector of -6, -30, 22复制代码\n\n中点\n这很简单！两个向量相加，除以二，就有了中点。\n\n你有一个黑色的和橙色的向量，将其相加得到了绿色的，除 2 或者乘 0.5 得到了中点向量。\nVector first = new Vector(1, 3, 4);\nVector second = new Vector(4, 3, 1);\nVector midpoint1 = first.midpoint(second); // Vector of 2.5, 3, 2.5\nVector midpoint2 = first.add(second).multiply(0.5); // Vector of 2.5, 3, 2.5复制代码现在你知道怎么使用向量了，是时候来点练习了！\n\n示例\n我们来检测玩家是否指向了一个坐标点。\npublic boolean doesPlayerTarget(Player p, Location target){\n        //p is your player\n        //target is the location the player might target\n        //Check if they are in the same world\n        if(!target.getWorld().equals(p.getWorld()))return false;\n        //Let's begin!\n        //Get the players head location\n        Location head = p.getLocation().add(0, p.getEyeHeight(), 0);\n        //Get the players looking direction as vector and\n        // shorten it to a length of 1 by using normalize()\n        Vector look = p.getLocation().getDirection().normalize();\n        //Get the direction of the target from the player by substracting his location with the target\n        //Again use normalize() of course, to shorten the value\n        Vector direction = head.subtract(target).toVector().normalize();\n        //Lets build our crossProduct. When the crossProduct's length is 0, the player\n        //is exactly targeting our target location\n        //why? because then the parallelogram shown above has an area of 0 :)\n        Vector cp = direction.crossProduct(look);\n        //Lets get the length from the vector\n        double length = cp.length();\n        //If the length is bigger than 0.1 the player is probably\n        //Not targeting our location. Choose this value appropriate\n        return (length < 0.1);\n    }复制代码\n服务器图标原文\n什么是服务器图标\n服务器图标是在用户将服务器添加到服务器列表后，显示在服务器列表中服务器旁边的一张小图片。\n服务器图标可能够被通过“Minecraft 服务器列表”网页来作为服务器的标志而下载。\n服务器图标能够帮助用户在服务器列表界面滚动时轻松地辨认出服务器。\n\n安装\n打开你选择好的图片制作器/编辑器，然后制作一张64x64像素大小的图片，你需要用PNG格式来储存。\n文件名需要是 server-icon.png ，目的是文件能够被服务器辨别。\n将 server-icon.png 放到与spigot或bungeecord核心.jar文件的同目录下；\n在你在服务器根目录放好文件之后你必须重启服务器才能让服务器图标被服务器所识别。\n\nby @1345979462 \n\n使用配置文件原文\n配置文件有什么用\n在拟开发的时候，你总会用很多的实例来存储数据，比如一个 HashMap 或者 ArrayList，但是当你的服务器重启或者关闭的时候，这些数据会全部丢失，因为这些对象全部存储在虚拟内存里，换句话说，它们消失就像创建它们一样容易，这就是我们使用配置文件的原因。\n文件是另一种存储数据的方法，但是他们不会在程序结束后消失，这是因为文件不是存储在虚拟内存的而是实际的存储盘。你可以用此存储玩家的经济、昵称和其他的你想在服务器重启后仍然存在的数据。\n让我们开始吧！\n\n使用单个配置文件\n创建配置文件：\nprivate void createConfig() {\n    try {\n        if (!getDataFolder().exists()) {\n            getDataFolder().mkdirs();\n        }\n        File file = new File(getDataFolder(), \"config.yml\");\n        if (!file.exists()) {\n            getLogger().info(\"Config.yml not found, creating!\");\n            saveDefaultConfig();\n        } else {\n            getLogger().info(\"Config.yml found, loading!\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}复制代码\n检查是否存在\nif (!getDataFolder().exists()) {\n    getDataFolder().mkdirs();\n}复制代码这段代码用来检查你的插件的文件夹是否存在，这是 Bukkit / Spigot 管理插件的方法，给每个插件分配单独的“数据文件夹”，这些文件夹用于存放每个插件单独的配置文件，存储重要的信息。使用 getDataFolder() 方法获得路径后，使用 if 检查这个文件夹是否存在，如果不存在就使用 mkdiirs() 方法（创建这个文件夹）。\n\n声明配置文件\nFile file = new File(getDataFolder(), \"config.yml\");\nif (!file.exists()) {\n    getLogger().info(\"config.yml not found, creating!\");\n    saveDefaultConfig();\n} else {\n    getLogger().info(\"config.yml found, loading!\");\n}复制代码这是你用来声明配置文件的代码。你需要先创建一个 File 对象，使用参数 'getDataFolder' 和 'config.yml'，就像之前提到的，getDamaFolder() 方法返回插件的数据文件夹，将其作为第一个参数，第二个参数告诉构造方法要在这个文件夹中创建一个叫 'config.yml' 的文件，但是这时候这个文件还没有被存储进入物理盘，下一个 if 检查这个配置文件是否存在，如果不存在就调用 saveDefaultConfig() 方法将插件 JAR 中的 'config.yml' 保存在插件文件夹里。\n这就是使用配置文件之前必要的所有工作了，但是请记住在 onEnable() 里执行这些代码，保证在其他发生之前加载完成配置文件。\n\n使用配置文件\n按照上面的代码之后，我们就可以使用 getConfig() 了。但是如果你要在主类外使用这个方法，你需要使用主类的实例。\n现在我们有了配置，就可以从中读写，一个简单的例子：\n// Reading from the config\nString name = plugin.getConfig().getString(\"player-name\");\n// Writing to the config\nplugin.getConfig().set(\"player-name\", name);复制代码\"player-name\" 是配置文件中的路径，如果你见过其他的 YAML 配置文件，你就会见到这种格式 \"路径: 值\"。访问一个路径就需要这个名字，但是有时有 \"子路径\"，标签在其他的标签之下就是这样的情况。\nplayer-name: Steve\nplayer:\n  time:\n    join: 6:00pm复制代码访问子路径你可以使用 '.' 来表示更低的路径级别，比如：\n// Reading from the config\nString time = plugin.getConfig().getString(\"player.time.join\");\n// Writing to the config\nplugin.getConfig().set(\"player.time.join\", time);复制代码插件会将 '.' 作为 \"啊！我应该检查子路径\" 的标记。\n注意我尽管使用了 String，但是你可以使用其他的类型。Getter 有这些： getInt(), getBoolean(), getList(), 而且还有更多，而 Setter，你只需要填一个 String 作为路径名，第二个 Object 参数为你想要存储的数据。\n很重要的一点，当你读写配置文件后，一定要保存。你可以：\nplugin.saveConfig();复制代码配置文件有各种技巧和工具，正确使用，你就可以将其作为你最有力的财富。\n\n使用多个配置文件\n创建文件\n第一步，你需要保证你的 File 和 FileConfiguration 对象对其他类可用，这样你才可以读写配置文件，怎样做呢？\n在你的主类，创建字段变量，这些变量没有包含在方法里，这样它们可以被外部访问。\npublic class Main extends JavaPlugin {\n    private File configf, specialf;\n    private FileConfiguration config, special;\n    @Override\n    public void onEnable(){\n        createFiles();\n    }\n    public FileConfiguration getSpecialConfig() {\n        return this.special;\n    }\n    private void createFiles() {\n        configf = new File(getDataFolder(), \"config.yml\");\n        specialf = new File(getDataFolder(), \"special.yml\");\n        if (!configf.exists()) {\n            configf.getParentFile().mkdirs();\n            saveResource(\"config.yml\", false);\n        }\n        if (!specialf.exists()) {\n            specialf.getParentFile().mkdirs();\n            saveResource(\"special.yml\", false);\n         }\n        config = new YamlConfiguration();\n        special = new YamlConfiguration();\n        try {\n            config.load(configf);\n            special.load(specialf);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}复制代码这干了什么呢？这是一个基本的主类的示例，还有就是它创建了两个配置文件，\"config.yml\" 和 \"special.yml\"。当插件启用时，调用 createFiles() 方法，这个方法检查每个文件是否存在，如果不存在就创建，这一部分在上面的使用单个配置文件部分有更详细的解释。\n那么 saveResource(String, boolean) 部分呢？你可以在你的 JAR 文件里储存其他的东西，比如 YML 文件，而不只是你的类。决定与你的 IDE，你可以在 src 文件夹创建一个新的文件夹（名字取决于编辑器），然后你可以在主类调用 saveResource(\"JAR 里文件的名字\", 是否替换已经出现的文件)。这会在插件的数据文件夹里存储这个文件。现在你已经创建了多个配置文件了！\n\n读写多个文件\n我们可以这样：\nplugin.getSpecialConfig().getString(\"路径\");复制代码基本上你可以使用 getConfig()，像使用一个配置一样，如果你想查看更多关于操作和访问配置的说明，阅读这篇文章。至于保存，你需要使用 FileConfiguration#save(File) (就像 saveConfig() 对 config.yml 的效果) 来将数据写入硬盘。\n\n分析崩溃原文\n世界相关问题\n栈溢出\n发生这个问题的错误报告通常以 “java.lang.StackOverflowError” 开头，在Minecraft默认的崩溃日志文件中看的很清楚。\n这样的字符会重复出现多次。java.lang.StackOverflowError\n        at java.lang.Class.getName0(Native Method)\n        at java.lang.Class.getName(Class.java:573)\n        at java.lang.Class.getSimpleName(Class.java:1161)\n        at net.minecraft.server.v1_6_R3.CrashReportDetail.<init>(SourceFile:184)\n        at net.minecraft.server.v1_6_R3.CrashReportSystemDetails.a(SourceFile:81)\n        at net.minecraft.server.v1_6_R3.CrashReportSystemDetails.a(SourceFile:85)\n        at net.minecraft.server.v1_6_R3.CrashReportSystemDetails.a(SourceFile:76)\n        at net.minecraft.server.v1_6_R3.CrashReport.h(CrashReport.java:36)\n        at net.minecraft.server.v1_6_R3.CrashReport.<init>(CrashReport.java:28)\n        at net.minecraft.server.v1_6_R3.CrashReport.a(CrashReport.java:212)\n        at net.minecraft.server.v1_6_R3.EntityTracker.addEntity(EntityTracker.java:107)\n        at net.minecraft.server.v1_6_R3.EntityTracker.track(EntityTracker.java:57)\n        at net.minecraft.server.v1_6_R3.WorldManager.a(WorldManager.java:18)\n        at net.minecraft.server.v1_6_R3.World.a(World.java:1025)\n        at net.minecraft.server.v1_6_R3.WorldServer.a(WorldServer.java:793)\n        at net.minecraft.server.v1_6_R3.World.addEntity(World.java:1018)\n        at net.minecraft.server.v1_6_R3.World.addEntity(World.java:945)\n        at net.minecraft.server.v1_6_R3.Entity.a(Entity.java:1291)\n        at net.minecraft.server.v1_6_R3.EntityMinecartAbstract.a(EntityMinecartAbstract.java:172)\n        at net.minecraft.server.v1_6_R3.EntityMinecartTNT.a(SourceFile:56)\n        at net.minecraft.server.v1_6_R3.EntityMinecartAbstract.damageEntity(EntityMinecartAbstract.java:153)\n        at net.minecraft.server.v1_6_R3.Explosion.a(Explosion.java:171)\n        at net.minecraft.server.v1_6_R3.World.createExplosion(World.java:1769)\n        at net.minecraft.server.v1_6_R3.WorldServer.createExplosion(WorldServer.java:846)\n        at net.minecraft.server.v1_6_R3.World.explode(World.java:1761)\n        at net.minecraft.server.v1_6_R3.EntityMinecartTNT.c(SourceFile:73)\n        at net.minecraft.server.v1_6_R3.EntityMinecartTNT.a(SourceFile:65)\n        at net.minecraft.server.v1_6_R3.EntityMinecartAbstract.damageEntity(EntityMinecartAbstract.java:153)\n        at net.minecraft.server.v1_6_R3.Explosion.a(Explosion.java:171)\n        at net.minecraft.server.v1_6_R3.World.createExplosion(World.java:1769)\n        at net.minecraft.server.v1_6_R3.WorldServer.createExplosion(WorldServer.java:846)\n        at net.minecraft.server.v1_6_R3.World.explode(World.java:1761)\n        at net.minecraft.server.v1_6_R3.EntityMinecartTNT.c(SourceFile:73)复制代码\n区块损坏\n错误报告信息以“java.io.UTFDataFormatException: malformed input around byte 111”\n”java.io.EOFException: Unexpected end of ZLIB input stream” 开头。复制代码在Minecraft崩溃日志中你很容易就能找到这样的字符，在这开头的报错信息之后请注意后面的服务器信息，以\nSection， BlockLight 或是 Blocks 这种标志表示。---- Minecraft Crash Report ----\n// Don't do that.\n\nTime: 14/10/13 17.58\nDescription: Loading NBT data\n\njava.io.UTFDataFormatException: malformed input around byte 111\n        at java.io.DataInputStream.readUTF(DataInputStream.java:656)\n        at java.io.DataInputStream.readUTF(DataInputStream.java:564)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:96)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTTagList.load(SourceFile:41)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTBase.a(SourceFile:89)\n        at net.minecraft.server.v1_6_R3.NBTCompressedStreamTools.a(SourceFile:75)\n        at net.minecraft.server.v1_6_R3.ChunkRegionLoader.loadChunk(ChunkRegionLoader.java:75)\n        at org.bukkit.craftbukkit.v1_6_R3.chunkio.ChunkIOProvider.callStage1(ChunkIOProvider.java:19)\n        at org.bukkit.craftbukkit.v1_6_R3.chunkio.ChunkIOProvider.callStage1(ChunkIOProvider.java:13)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.init(AsynchronousExecutor.java:150)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.initAsync(AsynchronousExecutor.java:95)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.run(AsynchronousExecutor.java:85)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:724)\n\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n---------------------------------------------------------------------------------------\n\n-- Head --\nStacktrace:\n        at java.io.DataInputStream.readUTF(DataInputStream.java:656)\n        at java.io.DataInputStream.readUTF(DataInputStream.java:564)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:96)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTTagList.load(SourceFile:41)\n\n-- NBT Tag --\nDetails:\n        Tag name: Sections\n        Tag type: 9\nStacktrace:\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTTagCompound.load(SourceFile:38)\n        at net.minecraft.server.v1_6_R3.NBTBase.b(SourceFile:101)\n        at net.minecraft.server.v1_6_R3.NBTBase.a(SourceFile:89)\n        at net.minecraft.server.v1_6_R3.NBTCompressedStreamTools.a(SourceFile:75)\n        at net.minecraft.server.v1_6_R3.ChunkRegionLoader.loadChunk(ChunkRegionLoader.java:75)\n        at org.bukkit.craftbukkit.v1_6_R3.chunkio.ChunkIOProvider.callStage1(ChunkIOProvider.java:19)\n        at org.bukkit.craftbukkit.v1_6_R3.chunkio.ChunkIOProvider.callStage1(ChunkIOProvider.java:13)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.init(AsynchronousExecutor.java:150)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.initAsync(AsynchronousExecutor.java:95)\n        at org.bukkit.craftbukkit.v1_6_R3.util.AsynchronousExecutor$Task.run(AsynchronousExecutor.java:85)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:724)\n\n-- System Details --\nDetails:\n        Minecraft Version: 1.6.4\n        Operating System: Linux (amd64) version 3.2.0-4-amd64\n        Java Version: 1.7.0_25, Oracle Corporation\n        Java VM Version: Java HotSpot(TM) 64-Bit Server VM (mixed mode), Oracle Corporation\n        Memory: 664694752 bytes (633 MB) / 1511219200 bytes (1441 MB) up to 5316411392 bytes (5070 MB)\n        JVM Flags: 4 total; -XX:ParallelGCThreads=6 -Xmx5G -Xms1G -Xincgc\n        AABB Pool Size: 0 (0 bytes; 0 MB) allocated, 0 (0 bytes; 0 MB) used\n...\n        IntCache: cache: 0, tcache: 0, allocated: 1, tallocated: 63\n        CraftBukkit Information: \n   Running: CraftBukkit version git-Spigot-1130 (MC: 1.6.4) (Implementing API version 1.6.4-R0.1-SNAPSHOT) false\n   Plugins: {...}\n   Warnings: DEFAULT\n   Threads: {...}\n   Recent tasks from 12811-12841{BanManager:me.confuserr.banmanager.Scheduler.muteAsync@12849,BanManager:me.confuserr.banmanager.Scheduler.bansAsync@12869,WorldEdit:com.sk89q.worldedit.bukkit.SessionTimer@12869,}\n        Profiler Position: N/A (disabled)\n        Vec3 Pool Size: ~~ERROR~~ NullPointerException: null\n        Player Count: 25 / 200; [....]\n        Is Modded: Definitely; Server brand changed to 'craftbukkit'\n        Type: Dedicated Server (map_server.txt)复制代码\n常见问题\n在Minecraft 1.7中当前有两个较为常见的漏洞。\n它们是\" java.lang.IllegalArgumentException: n must be positive \"复制代码和“java.lang.RuntimeException: Already decorating!!”复制代码现在这两个已知Bug目前还没有修复方法。\n---- Minecraft Crash Report ----\n// Daisy, daisy...\n\nTime: 7/5/13 1:36 PM\nDescription: Exception in server tick loop\n\njava.lang.RuntimeException: Already decorating!!\n        at net.minecraft.server.v1_6_R1.BiomeDecorator.a(SourceFile:21)\n        at net.minecraft.server.v1_6_R1.BiomeBase.a(SourceFile:217)\n        at net.minecraft.server.v1_6_R1.ChunkProviderGenerate.getChunkAt(SourceFile:454)\n        at org.bukkit.craftbukkit.v1_6_R1.generator.NormalChunkGenerator.getChunkAt(NormalChunkGenerator.java:49)\n        at net.minecraft.server.v1_6_R1.ChunkProviderServer.getChunkAt(ChunkProviderServer.java:227)\n        at net.minecraft.server.v1_6_R1.Chunk.a(Chunk.java:833)\n        at org.bukkit.craftbukkit.v1_6_R1.chunkio.ChunkIOProvider.callStage2(ChunkIOProvider.java:61)\n        at org.bukkit.craftbukkit.v1_6_R1.chunkio.ChunkIOProvider.callStage2(ChunkIOProvider.java:13)\n        at org.bukkit.craftbukkit.v1_6_R1.util.AsynchronousExecutor$Task.finish(AsynchronousExecutor.java:179)\n        at org.bukkit.craftbukkit.v1_6_R1.util.AsynchronousExecutor.finishActive(AsynchronousExecutor.java:287)\n        at org.bukkit.craftbukkit.v1_6_R1.chunkio.ChunkIOExecutor.tick(ChunkIOExecutor.java:30)\n        at net.minecraft.server.v1_6_R1.MinecraftServer.t(MinecraftServer.java:527)\n        at net.minecraft.server.v1_6_R1.DedicatedServer.t(DedicatedServer.java:235)\n        at net.minecraft.server.v1_6_R1.MinecraftServer.s(MinecraftServer.java:481)\n        at net.minecraft.server.v1_6_R1.MinecraftServer.run(MinecraftServer.java:413)\n        at net.minecraft.server.v1_6_R1.ThreadServerApplication.run(SourceFile:582)\n\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n---------------------------------------------------------------------------------------\n\n-- System Details --\nDetails:\n        Minecraft Version: 1.6.1\n        Operating System: Linux (amd64) version 3.5.0-23-generic\n        Java Version: 1.6.0_27, Sun Microsystems Inc.\n        Java VM Version: OpenJDK 64-Bit Server VM (mixed mode), Sun Microsystems Inc.\n        Memory: 13309690840 bytes (12693 MB) / 16320888832 bytes (15564 MB) up to 16320888832 bytes (15564 MB)\n        JVM Flags: 14 total; -Xmn8G -Xms16G -Xmx16G -Xss128K -XX:+AggressiveOpts -XX:MaxTenuringThreshold=31 -XX:ParallelGCThreads=8 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:TargetSurvivorRatio=90 -XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC\n        AABB Pool Size: 5182 (290192 bytes; 0 MB) allocated, 0 (0 bytes; 0 MB) used\n        Suspicious classes: ...\n        IntCache: cache: 0, tcache: 0, allocated: 1, tallocated: 71\n        CraftBukkit Information: \n   Running: CraftBukkit version git-Spigot-1005 (MC: 1.6.1) (Implementing API version 1.6.1-R0.1-SNAPSHOT) true\n   Plugins: {...}\n   Warnings: DEFAULT\n   Threads: {...}\n   Recent tasks from 399181-399211{ChestShop:com.Acrobot.ChestShop.DB.Queue@399229,Essentials:com.earth2me.essentials.spawn.EssentialsSpawnPlayerListener$1@399240,Essentials:com.earth2me.essentials.EssentialsPlayerListener$1@399240,}\n        Profiler Position: N/A (disabled)\n        Vec3 Pool Size: ~~ERROR~~ NullPointerException: null\n        Player Count: 8 / 50; [...]\n        Is Modded: Definitely; Server brand changed to 'craftbukkit'\n        Type: Dedicated Server (map_server.txt)复制代码[15:13:58] [Server thread/ERROR]: Encountered an unexpected exception\njava.lang.IllegalArgumentException: n must be positive\n        at java.util.Random.nextInt(Random.java:300) ~[?:1.7.0_25]\n        at net.minecraft.server.v1_7_R1.BiomeDecorator.a(BiomeDecorator.java:156) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.BiomeDecorator.a(BiomeDecorator.java:83) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.BiomeBase.a(SourceFile:362) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.ChunkProviderGenerate.getChunkAt(SourceFile:432) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.generator.NormalChunkGenerator.getChunkAt(NormalChunkGenerator.java:49) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.ChunkProviderServer.getChunkAt(ChunkProviderServer.java:228) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.Chunk.a(Chunk.java:876) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.chunkio.ChunkIOProvider.callStage2(ChunkIOProvider.java:61) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.chunkio.ChunkIOProvider.callStage2(ChunkIOProvider.java:13) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.util.AsynchronousExecutor$Task.finish(AsynchronousExecutor.java:179) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.util.AsynchronousExecutor.finishActive(AsynchronousExecutor.java:287) ~[spigot.jar:git-Spigot-1225]\n        at org.bukkit.craftbukkit.v1_7_R1.chunkio.ChunkIOExecutor.tick(ChunkIOExecutor.java:30) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.MinecraftServer.u(MinecraftServer.java:592) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.DedicatedServer.u(DedicatedServer.java:273) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.MinecraftServer.t(MinecraftServer.java:540) ~[spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.MinecraftServer.run(MinecraftServer.java:446) [spigot.jar:git-Spigot-1225]\n        at net.minecraft.server.v1_7_R1.ThreadServerApplication.run(SourceFile:617) [spigot.jar:git-Spigot-1225]\n[15:13:58] [Server thread/ERROR]: This crash report has been saved to: /home/nemesispvp/server/./crash-reports/crash-2014-01-01_15.13.58-server.txt复制代码\n\n会话锁损坏\n在服务器运行时 session.lock 文件或世界相关文件被损坏，删除或是强制更改后出现的报错。\n“java.lang.RuntimeException: Failed to check session lock, aborting”，\n “java.io.FileNotFoundException: .\\world\\session.lock (The requested operation cannot be performed on a file with a user-mapped section open)”复制代码这些都能够在server.log和Minecraft客户端的崩溃日志中找到。\n修复方法是关闭服务器后，删除你的世界目录下的 session.lock 文件，然后再开启服务器。---- Minecraft Crash Report ----\n// Ooh. Shiny.\n\nTime: 08/02/15 06:01\nDescription: Exception in server tick loop\n\njava.lang.RuntimeException: Failed to check session lock for world located at ./world, aborting. Stop the server and delete the session.lock in this world to prevent further issues.\n    at net.minecraft.server.v1_8_R1.WorldNBTStorage.h(WorldNBTStorage.java:57)\n    at net.minecraft.server.v1_8_R1.WorldNBTStorage.<init>(WorldNBTStorage.java:41)\n    at net.minecraft.server.v1_8_R1.ServerNBTManager.<init>(SourceFile:19)\n    at net.minecraft.server.v1_8_R1.MinecraftServer.a(MinecraftServer.java:249)\n    at net.minecraft.server.v1_8_R1.DedicatedServer.init(DedicatedServer.java:211)\n    at net.minecraft.server.v1_8_R1.MinecraftServer.run(MinecraftServer.java:494)\n    at java.lang.Thread.run(Thread.java:745)\n\n\nA detailed walkthrough of the error, its code path and all known details is as follows:\n---------------------------------------------------------------------------------------\n\n-- System Details --\nDetails:\n    Minecraft Version: 1.8\n    Operating System: Linux (amd64) version 3.10.23-xxxx-std-ipv6-64\n    Java Version: 1.7.0_75, Oracle Corporation\n    Java VM Version: OpenJDK 64-Bit Server VM (mixed mode), Oracle Corporation\n    Memory: 791254800 bytes (754 MB) / 1020919808 bytes (973 MB) up to 8520204288 bytes (8125 MB)\n    JVM Flags: 4 total; -Xincgc -Xmx8G -XX:PermSize=128m -XX:MaxPermSize=256M\n    IntCache: cache: 0, tcache: 0, allocated: 0, tallocated: 0\n    CraftBukkit Information:\n   Running: CraftBukkit version git-Spigot-29dbaa7-262c777 (MC: 1.8) (Implementing API version 1.8-R0.1-SNAPSHOT) false\n   Warnings: DEFAULT\n   Threads: {...}\n   Recent tasks from -31--1{}\n    Profiler Position: N/A (disabled)\n    Player Count: 0 / 100; []\n    Is Modded: Definitely; Server brand changed to 'Spigot'\n    Type: Dedicated Server (map_server.txt)复制代码\n\n读取插件出现错误\n一般崩溃原因\n每次你服务器崩溃时（不是JVM出现问题），Spigot都会储存追踪记录。\n90%的时间它都不会生成默认的Minecraft崩溃日志。\n大多数时间你都可以在 “Server thread” 这里找到使服务器崩溃的插件。\n大多数时间，这个问题的解决方法是更新插件，或是移除等待作者更新修复问题。\n在你找到了服务器主线程之后，仔细阅读这里的代码，这些是与错误无关的内容：\nJavaApacheSunNettySpigotNet.minecraft.serverBukkitGoogleYaml/SnakeYaml\n如果你找到一行字没有上面的内容的话，你就可能找到了制造问题的插件，最简单的解释方式就是用例子——\n这是服务器崩溃的主线程记录，尝试找出是什么让服务器崩溃：2013-10-29 16:34:53 [SEVERE]            java.io.WinNTFileSystem.getBooleanAttributes(Native Method)\n2013-10-29 16:34:53 [SEVERE]            java.io.File.exists(Unknown Source)\n2013-10-29 16:34:53 [SEVERE]            com.onarandombox.multiverseinventories.util.data.FlatFilePlayerData.getGlobalFile(FlatFilePlayerData.java:146)\n2013-10-29 16:34:53 [SEVERE]            com.onarandombox.multiverseinventories.util.data.FlatFilePlayerData.getGlobalProfile(FlatFilePlayerData.java:342)\n2013-10-29 16:34:53 [SEVERE]            com.onarandombox.multiverseinventories.util.data.FlatFilePlayerData.updateWorld(FlatFilePlayerData.java:371)\n2013-10-29 16:34:53 [SEVERE]            com.onarandombox.multiverseinventories.InventoriesListener.playerQuit(InventoriesListener.java:129)\n2013-10-29 16:34:53 [SEVERE]            sun.reflect.GeneratedMethodAccessor213.invoke(Unknown Source)\n2013-10-29 16:34:53 [SEVERE]            sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)\n2013-10-29 16:34:53 [SEVERE]            java.lang.reflect.Method.invoke(Unknown Source)\n2013-10-29 16:34:53 [SEVERE]            org.bukkit.plugin.java.JavaPluginLoader$1.execute(JavaPluginLoader.java:425)\n2013-10-29 16:34:53 [SEVERE]            org.bukkit.plugin.RegisteredListener.callEvent(RegisteredListener.java:62)\n2013-10-29 16:34:53 [SEVERE]            org.bukkit.plugin.TimedRegisteredListener.callEvent(TimedRegisteredListener.java:26)\n2013-10-29 16:34:53 [SEVERE]            org.bukkit.plugin.SimplePluginManager.fireEvent(SimplePluginManager.java:479)\n2013-10-29 16:34:53 [SEVERE]            org.bukkit.plugin.SimplePluginManager.callEvent(SimplePluginManager.java:464)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.PlayerList.disconnect(PlayerList.java:254)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.PlayerConnection.a(PlayerConnection.java:692)\n2013-10-29 16:34:53 [SEVERE]            org.spigotmc.netty.NettyNetworkManager.b(NettyNetworkManager.java:191)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.PlayerConnection.d(PlayerConnection.java:110)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.ServerConnection.b(SourceFile:35)\n2013-10-29 16:34:53 [SEVERE]            org.spigotmc.MultiplexingServerConnection.b(MultiplexingServerConnection.java:72)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.MinecraftServer.r(MinecraftServer.java:582)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.DedicatedServer.r(DedicatedServer.java:226)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.MinecraftServer.q(MinecraftServer.java:471)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.MinecraftServer.run(MinecraftServer.java:403)\n2013-10-29 16:34:53 [SEVERE]            net.minecraft.server.v1_5_R2.ThreadServerApplication.run(SourceFile:573)复制代码答案：\nMultiverse Inventories - 因为某些行中有 containing com.onarandombox.multiverseinventories 。\n再次审查这个错误，你会发现这是因为 Multiverse Inventories 插件在玩家离开游戏后尝试更新玩家的相关设置。\n如果你看到了像这样的错误信息的话：\n[WARNING] [Server] The main thread failed to respond after 10 seconds\n[WARNING] [Server] Probable Plugin causes: 'iConomy, Vault and ChestShop'复制代码这是明确的告诉你 iConomy, Vault 或是 ChestShop 是报错的原因。\n当然目前不是所有的崩溃都是插件引起，有些时候是因为你或玩家的不当操作。\n例如，这个崩溃日志的原因就是大型WorldEdit操作所造成的（使用//set命令，详见第十行），它让你的服务器达到了连接超时上限。2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.World.c(World.java:2368)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.Chunk.d(Chunk.java:235)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.Chunk.h(Chunk.java:321)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.Chunk.a(Chunk.java:405)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.World.setTypeIdAndData(World.java:351)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.bukkit.DefaultNmsBlock.setSafely(DefaultNmsBlock.java:256)\n2013-10-13 16:31:21 [SEVERE]sun.reflect.GeneratedMethodAccessor149.invoke(Unknown Source)\n2013-10-13 16:31:21 [SEVERE]sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n2013-10-13 16:31:21 [SEVERE]java.lang.reflect.Method.invoke(Method.java:606)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.bukkit.BukkitWorld.setBlock(BukkitWorld.java:1369)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.EditSession.rawSetBlock(EditSession.java:239)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.EditSession.flushQueue(EditSession.java:705)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.WorldEdit.handleCommand(WorldEdit.java:1436)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.worldedit.bukkit.WorldEditPlugin.onCommand(WorldEditPlugin.java:242)\n2013-10-13 16:31:21 [SEVERE]com.sk89q.bukkit.util.DynamicPluginCommand.execute(DynamicPluginCommand.java:52)\n2013-10-13 16:31:21 [SEVERE]org.bukkit.command.SimpleCommandMap.dispatch(SimpleCommandMap.java:192)\n2013-10-13 16:31:21 [SEVERE]org.bukkit.craftbukkit.v1_6_R3.CraftServer.dispatchCommand(CraftServer.java:527)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.PlayerConnection.handleCommand(PlayerConnection.java:977)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.PlayerConnection.chat(PlayerConnection.java:888)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.PlayerConnection.a(PlayerConnection.java:835)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.Packet3Chat.handle(SourceFile:49)\n2013-10-13 16:31:21 [SEVERE]org.spigotmc.netty.NettyNetworkManager.b(NettyNetworkManager.java:230)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.PlayerConnection.e(PlayerConnection.java:117)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.ServerConnection.b(SourceFile:37)\n2013-10-13 16:31:21 [SEVERE]org.spigotmc.netty.NettyServerConnection.b(NettyServerConnection.java:132)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.MinecraftServer.t(MinecraftServer.java:594)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.DedicatedServer.t(DedicatedServer.java:240)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.MinecraftServer.s(MinecraftServer.java:483)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:415)\n2013-10-13 16:31:21 [SEVERE]net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)复制代码\n如果你看到了类似这样的报错信息的话[SEVERE] Could not pass event X to PluginY\norg.bukkit.event.EventException复制代码PluginY 就是报错的原因，如果插件目前还没有修复这个问题的版本的话，请联系插件的开发者。\nMetrics和版本检测也可能会让你的服务器崩溃。\n就像在这个崩溃日志中所显示的—— 一些插件会尝试连接外服，在18和19行我们可以看到崩溃是 ModReq 造成的，最有可能的原因就是连接超时。\n要想修复这个的话，请检查插件的配置文件，关闭自动更新系统。2013-10-10 05:06:54 [SEVERE]            java.net.PlainSocketImpl.socketConnect(Native Method)\n2013-10-10 05:06:54 [SEVERE]            java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)\n2013-10-10 05:06:54 [SEVERE]            java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)\n2013-10-10 05:06:54 [SEVERE]            java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)\n2013-10-10 05:06:54 [SEVERE]            java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)\n2013-10-10 05:06:54 [SEVERE]            java.net.Socket.connect(Socket.java:579)\n2013-10-10 05:06:54 [SEVERE]            java.net.Socket.connect(Socket.java:528)\n2013-10-10 05:06:54 [SEVERE]            sun.net.NetworkClient.doConnect(NetworkClient.java:180)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.http.HttpClient.openServer[/url](HttpClient.java:378)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.http.HttpClient.openServer[/url](HttpClient.java:473)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.http.HttpClient.[/url]<init>(HttpClient.java:203)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.http.HttpClient.New[/url](HttpClient.java:290)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.http.HttpClient.New[/url](HttpClient.java:306)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.getNewHttpClient[/url](HttpURLConnection.java:995)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.plainConnect[/url](HttpURLConnection.java:931)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.connect[/url](HttpURLConnection.java:849)\n2013-10-10 05:06:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.getInputStream[/url](HttpURLConnection.java:1299)\n2013-10-10 05:06:54 [SEVERE]            modreq.VersionChecker.getVersion(VersionChecker.java:43)\n2013-10-10 05:06:54 [SEVERE]            modreq.VersionChecker.run(VersionChecker.java:78)\n2013-10-10 05:06:54 [SEVERE]            org.bukkit.craftbukkit.v1_6_R3.scheduler.CraftTask.run(CraftTask.java:58)\n2013-10-10 05:06:54 [SEVERE]            org.bukkit.craftbukkit.v1_6_R3.scheduler.CraftScheduler.mainThreadHeartbeat(CraftScheduler.java:345)\n2013-10-10 05:06:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.t(MinecraftServer.java:520)\n2013-10-10 05:06:54 [SEVERE]            net.minecraft.server.v1_6_R3.DedicatedServer.t(DedicatedServer.java:240)\n2013-10-10 05:06:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.s(MinecraftServer.java:483)\n2013-10-10 05:06:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:415)\n2013-10-10 05:06:54 [SEVERE]            net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)复制代码有关Metrics崩溃的话，前往spigot安装目录/Plugins/PluginMetrics/ 然后将统计在配置中关闭。\n下面就是metrics崩溃的例子。2013-10-01 03:00:54 [SEVERE]            java.net.PlainSocketImpl.socketConnect(Native Method)\n2013-10-01 03:00:54 [SEVERE]            java.net.AbstractPlainSocketImpl.doConnect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            java.net.AbstractPlainSocketImpl.connectToAddress(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            java.net.AbstractPlainSocketImpl.connect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            java.net.SocksSocketImpl.connect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            java.net.Socket.connect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            java.net.Socket.connect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.NetworkClient.doConnect(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.http.HttpClient.openServer[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.http.HttpClient.openServer[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.http.HttpClient.[/url]<init>(Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.http.HttpClient.New[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.http.HttpClient.New[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.getNewHttpClient[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.plainConnect[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.connect[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            sun.net.[url]www.protocol.http.HttpURLConnection.getOutputStream[/url](Unknown Source)\n2013-10-01 03:00:54 [SEVERE]            me.sinnoh.MasterPromote.Metrics.Metrics.postPlugin(Metrics.java:412)\n2013-10-01 03:00:54 [SEVERE]            me.sinnoh.MasterPromote.Metrics.Metrics.access$5(Metrics.java:354)\n2013-10-01 03:00:54 [SEVERE]            me.sinnoh.MasterPromote.Metrics.Metrics$1.run(Metrics.java:255)\n2013-10-01 03:00:54 [SEVERE]            org.bukkit.craftbukkit.v1_6_R3.scheduler.CraftTask.run(CraftTask.java:67)\n2013-10-01 03:00:54 [SEVERE]            org.bukkit.craftbukkit.v1_6_R3.scheduler.CraftScheduler.mainThreadHeartbeat(CraftScheduler.java:345)\n2013-10-01 03:00:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.t(MinecraftServer.java:520)\n2013-10-01 03:00:54 [SEVERE]            net.minecraft.server.v1_6_R3.DedicatedServer.t(DedicatedServer.java:240)\n2013-10-01 03:00:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.s(MinecraftServer.java:483)\n2013-10-01 03:00:54 [SEVERE]            net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:415)\n2013-10-01 03:00:54 [SEVERE]            net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)复制代码\n\nSpigot/Bukkit 相关问题\n文件权限错误\n因为文件权限问题，Spigot 可能不能生成一些核心的文件，例如日志文件，配置文件和 metrics 文件夹。\n在linux上这个问题的解决方法很简单，前往你的jar所在路径然后把jar的文件权限设置为700，其他的文件设置为500就好了。\n请确保文件的拥有者权限正确。\n这个问题的典型报错：2013-10-05 17:35:57 [SEVERE] Could not start metrics service\njava.io.IOException: Unable to create parent directories of plugins/PluginMetrics/config.yml\n        at com.google.common.io.Files.createParentDirs(Files.java:463)\n        at org.bukkit.configuration.file.FileConfiguration.save(FileConfiguration.java:52)\n        at org.spigotmc.Metrics.<init>(Metrics.java:137)\n        at org.spigotmc.SpigotConfig.registerCommands(SpigotConfig.java:71)\n        at net.minecraft.server.v1_6_R3.DedicatedServer.init(DedicatedServer.java:96)\n        at net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:399)\n        at net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)\njava.lang.NullPointerException\n        at org.bukkit.plugin.SimplePluginManager.loadPlugins(SimplePluginManager.java:119)\n        at org.bukkit.craftbukkit.v1_6_R3.CraftServer.loadPlugins(CraftServer.java:243)\n        at net.minecraft.server.v1_6_R3.DedicatedServer.init(DedicatedServer.java:118)\n        at net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:399)\n        at net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)复制代码\n\n内存空间相关\n在1.7的更新之后，Mojang为Minecraft增加了更多的资源文件，这导致了jar文件中类的数量显著增加。\n结果就是，运行服务器所需要的PermGen空间就变多了。\n你可以在下面的 设置PermGen大小 小节查看怎么修复这个问题。\n\n其他问题\n作弊修改的实体或物品\n因为创造模式拥有无限的权利，使用作弊端的玩家能生成使你的服务器崩溃的物品。\n最容易看到的就是 “java.lang.IllegalArgumentException: n must be positive”，这是因为实体或玩家的物品或装备的附魔等级是个负数。\n每次玩家加入游戏或是进入这片区域的时候，服务器就会崩溃。\n尝试将玩家或实体的物品栏清空是解决这个崩溃的方法。java.lang.IllegalArgumentException: n must be positive\n        at java.util.Random.nextInt(Unknown Source)\n        at net.minecraft.server.v1_6_R3.EnchantmentManager.a(SourceFile:144)\n        at net.minecraft.server.v1_6_R3.EntityLiving.c(EntityLiving.java:920)\n        at net.minecraft.server.v1_6_R3.EntityHuman.d(EntityHuman.java:782)\n        at net.minecraft.server.v1_6_R3.EntityLiving.damageEntity(EntityLiving.java:665)\n        at net.minecraft.server.v1_6_R3.EntityHuman.damageEntity(EntityHuman.java:719)\n        at net.minecraft.server.v1_6_R3.EntityPlayer.damageEntity(EntityPlayer.java:399)\n        at net.minecraft.server.v1_6_R3.EntityEnderPearl.a(EntityEnderPearl.java:52)\n        at net.minecraft.server.v1_6_R3.EntityProjectile.l_(EntityProjectile.java:156)\n        at net.minecraft.server.v1_6_R3.World.entityJoinedWorld(World.java:1492)\n        at net.minecraft.server.v1_6_R3.World.playerJoinedWorld(World.java:1467)\n        at net.minecraft.server.v1_6_R3.World.tickEntities(World.java:1336)\n        at net.minecraft.server.v1_6_R3.WorldServer.tickEntities(WorldServer.java:517)\n        at net.minecraft.server.v1_6_R3.MinecraftServer.t(MinecraftServer.java:573)\n        at net.minecraft.server.v1_6_R3.DedicatedServer.t(DedicatedServer.java:240)\n        at net.minecraft.server.v1_6_R3.MinecraftServer.s(MinecraftServer.java:483)\n        at net.minecraft.server.v1_6_R3.MinecraftServer.run(MinecraftServer.java:415)\n        at net.minecraft.server.v1_6_R3.ThreadServerApplication.run(SourceFile:583)复制代码\n玩家也能够生成无限长名字的生物，这会让生物附近玩家的客户端崩溃，原因是包过长。\n解决方法只有移除这个生物。\n\nMultiCraft 会缩减日志文件\nMulticraft 其中一个正在开发的特性就是它会在崩溃时缩短你的日志文件。\n如果你看到\n[Multicraft] Skipped x lines due to rate limit (y/s)复制代码这说明你可能无法成功地分析错误报告了。将限制的值设置为一个尤其大的数能够阻止这个特性缩减你的日志文件——\n如果你没有权限的话尝试联系你的服务器提供商。\n\nby @1345979462 \n\n更改PermGen大小原文\n重要：Java 8对 PermGen 的支持被移除了。\n背景\nMojang在1.7的更新中为Minecraft服务器增加了一些资源文件，这导致了核心文件中类的增加，以及需要使用更多的PermGen空间。\n为了让你的服务器运行状态达到最佳并预防崩溃，我们推荐你在JVM中增加PermGen的配置来预防这些问题。\n因为动态配置 metaspace 这一新特性的发明，在Java 8中对PermGen的支持被移除了。\n结果是你就不需要再注意这一项了，也不要陷入任何相关问题之中，除非你耗尽了堆内存。\n\n方法\n首先，用你喜欢的文本编辑器打开你的运行命令行或运行文件。\n运行命令看起来应该像这样：\n<path to java executable // java> -Xms1G -Xmx2G -<extra flags> -jar spigot.jar nogui复制代码要想改变你的PermGen设置，你需要在这个命令中加入 -XX:MaxPermSize=128M 参数。\n你需要把它放在java执行命令后，-jar参数之前。举个例子：\n<path to java executable // java> -Xms1G -Xmx2G -XX:MaxPermSize=128M -<extra flags> -jar spigot.jar nogui复制代码在你关闭服务器并使用这个新的命令重启服务器之后，你就成功配置了更多的PermGen空间，最终你就能运行更多插件了。\n\n其它配置设置\n如果你使用 McMyAdmin 的话，将 -XX:MaxPermSize=128M 放在 McMyAdmin.conf 文件里的 Java.CustomOpts 设置项中如果你使用 mark2 的话，将 java.cli.XX.MaxPermSize=128M 放在 mark2.properties 中如果你使用 Multicraft 的话，请去阅读适合Spigot的配置文档如果你使用 Rtoolkit 的话，打开工具包文件夹下的 \"wrapper.properties\" 文件。然后在 \"extra-runtime-arguments\" 设置项后加入 \",-XX:MaxPermSize=128M\"，重启服务器来应用设置。\n\nby @1345979462 \n\n减少服务器卡顿原文\n大家好 ！我要制作本页面的原因是我找不到其它减少延迟相关的Wiki页面。\n现在，这将会是最棒的基础教程。但我会将它做的最好的。欢迎大家来改善它！\n这个教程需要参考你服务器根目录下的 spigot.yml 文件。\n如果你使用Windows系统的话推荐你使用 Notepad++ 应用打开文件。\n    anti-xray:\n      enabled: true复制代码现在，根据你服务器的模式你可以将这一样启用或关闭。\n事实是，玩家很喜欢作弊。如果玩家发现这个服务器无法作弊的话，他们可能会去下个服务器的。\n这个选项的启用与否可以完全取决于你，但我推荐你设置为：    anti-xray:\n      enabled: false复制代码    merge-radius:\n      item: 2.5\n      exp: 3.0复制代码这些选项指定物品合并所需要的距离，你可以将其设置为：\n    merge-radius:\n      item: 4\n      exp: 6复制代码更多内容很快就到！请关注本页面！\nby @1345979462 \n\n分离崩溃原文\n如果你在服务器启动时出现问题的话，这是能够帮助你排查问题并找到原因的步骤。\n\n1. 获取最新的Spigot构建\n通常这都能解决问题。使用不同版本的构建，试试早些或晚些的构建能不能解决问题。没用？请看第二步。\n\n2. 移除世界运行\n在读取插件之前，一些错误的世界也可能会让你的服务器崩溃。尝试不装载世界开启服务器来查看问题能否解决。\n你可以将你的世界移出你的服务器目录。\n如果这有用的话，说明你服务器的世界之一出错了。\n将世界一个一个放回服务器来查找出现问题的世界。\n找到出现问题的世界以后，如果你可以删除的话就请删除，如果不能请运行区块修复工具。\n没有解决？看第三步。\n\n3. 移除插件运行\n关闭服务器，尝试删除或移走你的插件目录。如果问题解决的话说明是崩溃是插件引起，然后请去3a。\n\n3a. 更新所有插件\n看起来这样做工作量会很大，但是让你所有的插件都保持最新确实是个很好的习惯。\n问题仍存在？看3b。\n\n3b. 排查错误插件\n现在你已经知道是插件造成的问题，所以就是你梳理插件目录找到问题插件的时候了。请仅仅安装你一半的插件（把另一半放到别的地方），然后开启服务器。\n如果问题已经解决，那么说明问题插件在你拿出来的那一半中。\n如果问题仍然存在，那么说明问题插件还在你留下来的那一半中。\n请重复这种操作直到你找到单个问题插件。\n请确定就是它造成的问题。\n\n如果这些都没有用的话，请将你的崩溃日志发送到Spigot论坛的Bug板块中。\n请确保使用 pastebin.com 将你所有的控制台错误发送，并且请给出足够多的信息。\nby @1345979462 \n\n使用 WorldEdit API原文\n如何使用 WorldEdit API\n将以下代码放入 pom.xml 的 repositories里\n<repository>\n<id>sk89q-snapshots</id>\n<url>http://maven.sk89q.com/artifactory/repo</url>\n<releases>\n<enabled>true</enabled>\n</releases>\n<snapshots>\n<enabled>true</enabled>\n</snapshots>\n</repository>复制代码接着把这部分代码放入 dependencies 里\n<dependency>\n<groupId>com.sk89q.worldedit</groupId>\n<artifactId>worldedit-bukkit</artifactId>\n<version>6.1.1-SNAPSHOT</version>\n</dependency>复制代码\n等一小会儿，然后你的 Maven Dependencies 里多了一大堆东西，点击 worldedit-bukkit-6.1.1-SNAPSHOT.jar 按下 Command-I，前往 Javadoc Location 部分，粘贴 http://docs.sk89q.com/worldedit/apidocs/，点击 Validate，然后点击 OK (或者按下 return) 然后 WorldEdit 应该设置完成了。\n\nWorldEdit 的包名应该是 com.sk89q.worldedit\n\n配置管理器原文\n大家好，很多人都还在创建默认的 config.yml 文件，但是我个人不是很喜欢。。。只有一个文件，所以这就是我制作这篇 SettingsManager 教程的原因：\n\n什么是 SettingsManager:\nSettingsManager 允许你创建自己的文件，自己的文件夹，比如 \"/plugins/PluginName/CustomFolder/CustomFile.yml\"。\n\n如何制作 SettingsManager:\n我将展示我使用的 SettingManager：\npackage YourPackage;\nimport java.io.File;\nimport java.io.IOException;\nimport org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.configuration.file.YamlConfiguration;\npublic class YourClass {\n    static FileConfiguration YourFile;\n    static File pdfile;\n    public static void setup() {\n        pdfile = new File(\"plugins/YourPlugin/\", \"YourFile.yml\");\n        if (!pdfile.exists()) {\n            try {\n                pdfile.createNewFile();\n            } catch (IOException e) {\n            }\n        }\n        YourFile = YamlConfiguration.loadConfiguration(pdfile);\n    }\n    public static FileConfiguration get() {\n        return YourFile;\n    }\n    public static void save() {\n        try {\n            YourFile.save(pdfile);\n        } catch (IOException e) {\n            Bukkit.getServer().getLogger().severe(ChatColor.RED + \"Could not save yourfile.yml!\");\n        }\n    }\n    public static void reload() {\n        YourFile = YamlConfiguration.loadConfiguration(pdfile);\n    }\n}复制代码如果你想创建/重载/保存/获取一个文件，你需要在 onEnable() 里这样做：\nYourClass.setup();\nYourClass.get().addDefault(\"Default\", \"Default\");\nYourClass.get().options().copyDefaults(true);\nYourClass.save();复制代码这就是创建你自己的设置管理器的方法，不难吧？\n感谢阅读，祝你和你的自定义配置好运！\n\nSpigot 1.11 插件列表\n\n原文\n\nSpigot 1.12 插件列表\n\n原文\n\nSpigot 1.12 插件列表\n\n原文\n\nSpigot 变更日志原文\nCraftBukkitBukkitSpigot\nSpigotCraftBukkitBukkit\nSpigot 命令 & 权限原文\n/restart \n权限节点: bukkit.command.restart\n这个命令会尝试让服务器重启，你必须在 spigot.yml 里正确填写 \"restart-script\"\n默认: 管理员\n\n/tps \n权限节点: bukkit.command.tps\n这个命令将会显示TPS(每秒 tick 数)的最近的 1分钟、5分钟、15分钟的平均值\n默认: 管理员\n\n/timings on (在 builds #1261-#1537 间被停用)\n权限节点: bukkit.command.timings\nThis command will turn on server benchmark timings, without requiring a restart.\n默认: 管理员\n\n/timings off (在 builds #1319-#1537 间被停用)\n权限节点: bukkit.command.timings\n这个命令会关闭服务器跑分 timings，不需要重启\n默认: 管理员\n\n/timings merged \n权限节点: bukkit.command.timings\n这个命令将会把 timings 写入磁盘，名为 timnigsX.txt 的文本文件将存储在 /timings 目录下。\n默认: 管理员\n\n/timings separate \n权限节点: bukkit.command.timings\n这个命令将会为活跃的插件产生 timings 报告，但是会分为多个单独的文件。\n默认: 管理员\n\n/timings paste \n权限节点: bukkit.command.timings\n不像是写入文件，这将把结果粘贴进 Ubuntu Paste，可以在 Aikar's Timings Viewer 查看。\n默认: 管理员\n\n/timings reset \n权限节点: bukkit.command.timings\n这个命令将会重置之前的 timings 结果。\n默认: 管理员\n\nSpigot Maven原文\nMaven Repository\nSpigot 有 maven repository\nhttps://hub.spigotmc.org/nexus/# ... shots~browsestorage\n\npom.xml\n这是一份从Spigot仓库获得API的示例 pom.xml。\n你应该只用其中的一个\n如果你需要使用SpigotAPI，那么你只需要填写 SpigotAPI\n将以下代码放入 pom.xml\n<repositories>\n    <repository>\n        <id>spigot-repo</id>\n        <url>[url]https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>[/url]\n    </repository>\n</repositories>\n<dependencies>\n    <!--Spigot API-->\n    <dependency>\n        <groupId>org.spigotmc</groupId>\n        <artifactId>spigot-api</artifactId>\n        <version>1.12-R0.1-SNAPSHOT</version>\n        <scope>provided</scope>\n    </dependency>\n    <!--Bukkit API-->\n    <dependency>\n        <groupId>org.bukkit</groupId>\n        <artifactId>bukkit</artifactId>\n        <version>1.12-R0.1-SNAPSHOT</version>\n        <scope>provided</scope>\n    </dependency>\n</dependencies>复制代码如果你使用 NMS，你需要将 CraftBukkit 也加入 dependency\n<dependency>\n    <groupId>org.bukkit</groupId>\n    <artifactId>craftbukkit</artifactId>\n    <version>1.12-R0.1-SNAPSHOT</version>\n    <scope>provided</scope>\n</dependency>复制代码你需要运行 BuildTools 来确保将其加入你的依赖项\n如果你需要 Spigot 版本包含的 NMS，你需要这个\n<dependency> <!-- Spigot (this includes Spigot API, Bukkit API, Craftbukkit and NMS) -->\n    <groupId>org.spigotmc</groupId>\n    <artifactId>spigot</artifactId>\n    <version>1.12-R0.1-SNAPSHOT</version>\n    <scope>provided</scope>\n</dependency>复制代码你需要使用 BuildTools\n\n[groupid=1330]PluginsCDTribe[/groupid]",
    "replies": [
        {
            "author": "xuan3er3",
            "timestamp": 1501165860,
            "txt_content": "抢沙发，前排支持。\n对我这种二手开发来说很有帮助的"
        },
        {
            "author": "zxczly",
            "timestamp": 1504695660,
            "txt_content": "不错哦 但是有没有中文wiki呢？"
        },
        {
            "author": "西瓜太郎",
            "timestamp": 1522370760,
            "txt_content": "翻译很棒呀\nSpigot插件开发块什么时候能翻译呢"
        },
        {
            "author": "awd410842",
            "timestamp": 1523139600,
            "txt_content": "感谢教程，有空我会多学习一下的"
        },
        {
            "author": "Qin_An",
            "timestamp": 1565368200,
            "txt_content": "支持作者！"
        },
        {
            "author": "AuroraCruiser",
            "timestamp": 1590746520,
            "txt_content": "翻译的挺好"
        },
        {
            "author": "dousha0v0",
            "timestamp": 1595201040,
            "txt_content": "大佬，你鸽了。。。三年了！2333"
        }
    ]
}