{
    "title": "[已解决]Spigot插件开发求助",
    "author": "Delamer",
    "replyCount": 4,
    "timestamp": 1587889800,
    "txt_content": " 本帖最后由 Delamer 于 2020-4-27 14:14 编辑 \n\n\n\n版本：Spigot-1.15.2\n有多个问题向大佬求助，在下一一列出。\n\n1、如何对玩家进行计分板操作？\n\n        假设我需要记录玩家的破坏圆石数或击杀僵尸数，并在该数字达到10时将其清零，该如何去编写代码呢？\n\n        虽然有在其他教程看到过一些相关操作，但是我想要知道更多相关操作的细节。\n        ScoreboardManager manager = Bukkit.getScoreboardManager();\n        Scoreboard scoreboard = manager.getNewScoreboard();\n        Objective objective = scoreboard.registerNewObjective(\"name\", \"dummy\", \"displayName\");\n        现在关于spigot对计分板的操作我只知道这几条而已，至于新建出的这个计分板如何实装到服务器中，如何获取玩家的现有分数，以及如何对现有分数进行操作等等，目前一概不知，还望大佬指点或给个传送门。。。\n\n\n2、如果我想对玩家存储文本信息，该怎么去做？\n\n        紧接着上面的情景，假设我想在玩家击杀僵尸数达到10时，为玩家赋予称号，该存储在什么位置，又如何取出？\n\n        除了想要实现称号功能以外，其实还想要做多个称号由玩家自行切换的效果，但是在这第一步就卡住了无从思考第二步\n        游戏自带的tag似乎只能存储标识符的样子，无法存储汉字信息，于是想要知道Player对象有没有什么空间可以写入或读取字符串数据，如果没有，那就只能写到外部文件用IO来实现称号系统了，不过IO操作字符串的话，嗯，过于折腾。\n\n\n3、如何让玩家死亡时只掉落一部分物品？\n\n        在玩家死亡事件(PlayerDeathEvent)中，有getDrops()和getDroppedExp()这两个获取掉落物列表和掉落经验值的方法，然而掉落的经验值可以通过setDroppedExp()来调整，可掉落物似乎并没有。\n        有没有办法在这个阶段给玩家保留一定的道具，比如装备栏与快捷栏的物品呢？另外，如果我想让玩家在死亡后无法主动复活，而是经过一定时长后自动复活，能不能实现？如何去实现？\n\n\n最近脑子抽风，问题有点多，拆开连续发贴又不合适，就这样给它堆一起了。等待大佬ing。\n\n",
    "replies": [
        {
            "author": "鬼畜畜",
            "timestamp": 1587897780,
            "txt_content": "问题2可以用持久化数据存储API（>1.14) https://www.mcbbs.net/thread-918325-1-1.html"
        },
        {
            "author": "天辉胡萝卜",
            "timestamp": 1587928320,
            "txt_content": "问题2\n即使折腾，仍推荐使用sql之类的，毕竟某些服务器有跨服的需要。。。\n\n问题3\nspigot貌似并不能直接setdrop，所以只能在死亡瞬间getinventory，然后随机选择一些slot设置为空，之后dropItemNaturally，手动生成掉落物"
        },
        {
            "author": "Delamer",
            "timestamp": 1587965100,
            "txt_content": "疾风暗影 发表于 2020-4-27 03:12\n问题2\n即使折腾，仍推荐使用sql之类的，毕竟某些服务器有跨服的需要。。。\n嗯。。咱暂时没有考虑跨服那边，倒不如说我甚至想给每个世界都做一套不同的设计。不过那个是之后的事了。现在在弄明白楼上大佬贴的持久化数据存储之前暂时通过tag加识别转写的方式勉强实现了，后面再决定要不要走sql吧。。\n关于掉落物那点。由于玩家死亡和重生是两种不同事件所以没法共用参数的样子，大佬给出的这个虽然能设置随机掉落，却不能回收被设为空的物品槽。我该怎样把这些物品数据再传递到重生事件中呢。。"
        },
        {
            "author": "Ir.Nep",
            "timestamp": 1587967800,
            "txt_content": "1、操作计分板      计分板操作计分板基本操作可以参考MaySpeed教程如果有对每个玩家显示特定内容的需求可以对服内每个玩家使用getNewScoreboard()创建专属计分板，并使用player.setScoreboard(刚创建的计分板)，这样每个玩家所看到的计分板内容就不一样了\n假设我需要记录玩家的破坏圆石数或击杀僵尸数，并在该数字达到10时将其清零\n      以破坏圆石数量为例子，以每个玩家独立计分板、计分板侧边栏Objective名字为name、记录破坏圆石数条目(Entry)名为\"已破坏圆石数量\"为前提。\n流程：监听BlockBreakEvent，判断破坏方块是否为圆石，是则取出事件玩家的计分板，从该计分板中获取名为name的Objective，从该Objective中取出条目名为\"已破坏圆石数量\"的分数（此处分数是Score对象，而不是数字），给他加一，判断分数是否≥10，是则清零\n代码：\n        public void onEnable(){\n                // 同样监听PlayerJoinEvent\n                // 以确保对玩家使用getScoreboard非空\n                for(Player p : Bukkit.getOnlinePlayers()) {\n                        // 为每个玩家创建新的计分板\n                        Scoreboard sb = Bukkit.getScoreboardManager().getNewScoreboard();\n                        // 为这个新的计分板创建Objective\n                        Objective objective = sb.registerNewObjective(\"name\", \"dummy\", \"侧边栏标题\");\n                        // 让Objective显示在右侧\n                        objective.setDisplaySlot(DisplaySlot.SIDEBAR);\n                        // 初始化(非必须)\n                        // spigot已经处理过了，objective.getScore(String)所得分数不会是null\n                        // 若条目原先不存在于Objective\n                        // 使用getScore()所得分数将为0\n                        objective.getScore(\"已破坏圆石数量\").setScore(0);\n                        // 向玩家展示计分板\n                        p.setScoreboard(sb);\n                        info(sb);\n                }\n                getServer().getPluginManager().registerEvents(this, this);\n        }\n        \n        @EventHandler\n        public void onBlockBreak(BlockBreakEvent e) {\n                // 判断破坏方块是否为圆石\n                if(e.getBlock().getType().equals(Material.COBBLESTONE)) {\n                        // 获取玩家独有计分板\n                        Scoreboard sb = e.getPlayer().getScoreboard();\n                        // 获取名为name的Objective\n                        Objective objective = sb.getObjective(\"name\");\n                        // 获取名为\"已破坏圆石数量\"的分数\n                        Score score_stone = objective.getScore(\"已破坏圆石数量\");\n                        // 设置分数为原有分数+1\n                        score_stone.setScore(score_stone.getScore() + 1);\n                        // 分数是否达到了10\n                        if(score_stone.getScore() >= 10) {\n                                // 清零\n                                score_stone.setScore(0);\n                                // Do sth\n                        }\n                }\n        }复制代码\n2、存储文本信息\n      可使用2L所说的方法，可使用数据库，可使用yml（不推荐，对文本的限制多）\n\n3、处理死亡掉落物品\n      可以关闭原生掉落，自己新建掉落体系\n也可以对getDrops()进行操作，把不应该掉落的物品移出getDrops()，并存起来，1tick后重新给予玩家\n        @EventHandler\n        public void onPlayerDeath(PlayerDeathEvent e) {\n                List<ItemStack> toSave = new ArrayList();\n                for(ItemStack item : e.getDrops()) {\n                        if(保存条件) {\n                                toSave.add(item);\n                        }\n                }\n                for(ItemStack item : toSave) {\n                        e.getDrops().remove(item);\n                }\n                new BukkitRunnable() {\n                        public void run() {\n                                for(ItemStack item : toSave) {\n                                        e.getEntity().getInventory().addItem(item);\n                                }\n                        }\n                }.runTaskLater(this, 1);\n        }复制代码4、控制玩家的复活      要控制玩家的复活，一种是直接在玩家死亡事件中调用player.spigot().respawn()，然后设置玩家的游戏模式，这种方法无需调用NMS，但如果要限制玩家的行动会比较麻烦。\n      另一种是让玩家无法点击死亡界面的重生。由于死亡界面是由客户端控制的，因此我们需要使用到NMS发包，并用一点trick：玩家死亡后，重生按钮有1秒时长是无法按下的，在这期间，向玩家发送复活包+死亡包，此时玩家的重生按钮将一直是灰的。\n代码示例(使用spigot-1.14.4):\n        // 多少tick后使玩家重生\n        private static final int RESPAWN_AFTER = 100;\n        // 多少tick重新发一次包\n        private static final int PACKET_SEND_PERIOD = 10;\n        \n        @EventHandler\n        public void onPlayerDeath(PlayerDeathEvent e) {\n                new BukkitRunnable() {\n                        int i = 0;\n                        public void run() {\n                                if(i++ > RESPAWN_AFTER / PACKET_SEND_PERIOD) {\n                                        e.getEntity().spigot().respawn();\n                                        this.cancel();\n                                }else {\n                                        sendRespawnPacket(e.getEntity());\n                                        sendDeadPacket(e.getEntity());\n                                }\n                        }\n                }.runTaskTimer(this, PACKET_SEND_PERIOD, PACKET_SEND_PERIOD);\n        }\n\n        private void sendPacket(Player p, Packet packet){\n                ((CraftPlayer) p).getHandle().playerConnection.sendPacket(packet);\n        }\n        \n        private EntityPlayer getHandle(Player player) {\n                return ((CraftPlayer)player).getHandle();\n        }\n        \n        public void sendDeadPacket(Player p) {\n                sendPacket(p, new PacketPlayOutCombatEvent(getHandle(p).getCombatTracker(), EnumCombatEventType.ENTITY_DIED));\n        }\n        \n        public void sendRespawnPacket(Player p) {\n                sendPacket(p, new PacketPlayOutRespawn(getHandle(p).dimension, getHandle(p).getWorld().getWorldData().getType(), EnumGamemode.SURVIVAL));\n        }复制代码\n\n\n\n"
        }
    ]
}