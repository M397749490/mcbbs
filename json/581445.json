{
    "title": "背包界面GUI 区分小技巧",
    "author": "494308843",
    "replyCount": 8,
    "timestamp": 1462434780,
    "txt_content": "\n说是GUI也就是直接调用了背包设置物品\n然后监听事件判断是不是点击了插件自身设置的那个背包  然后判断点击了哪个物品触发什么事件\n\n但是区分背包,有很大可能会混淆\n比如2个插件设置了相同的标题  比如不小心和菜单设置一样了\n\n我有一个不错的想法\n\n标题是可以显示颜色代码的\n\n\n可以用颜色代码隐藏一串数字作为ID\n方便区分\n就算看着界面是一样的  实际内容是不一样的\n\n提取隐藏的ID\n只用ID的话  计算怎么自定义标题   也只需要判断一下隐藏的ID\n\n物品也是一样\n\n好多插件都是这样解决的\n比如RPG物品Σ( ° △ °|||)︴  可以用来给物品区分 或者在lore隐藏一串数字  （比如时间戳）作为物品的创建时间  让物品具有唯一性等\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "107874017",
            "timestamp": 1462634820,
            "txt_content": "那么 怎么确定已生成的两个颜色代码是相同的？\n这和抽屉原理一样 在有限的位数内无限的数量一定有相互相同的"
        },
        {
            "author": "TimmyOVO",
            "timestamp": 1462668720,
            "txt_content": "隐藏数字好说呀\nRandom是伪随机数\n用的是当前时间戳当的种子\n然后就可以Random一个int\n同时把它放进hashmap里面储存\n我觉得这方法可行→_→"
        },
        {
            "author": "494308843",
            "timestamp": 1462687260,
            "txt_content": "107874017 发表于 2016-5-7 23:27\n那么 怎么确定已生成的两个颜色代码是相同的？\n这和抽屉原理一样 在有限的位数内无限的数量一定有相互相同 ...\n一般不会冲突的   在一台服务器有多少插件会用这种方式  有多少ID会相同？\n按楼下的随机数  就更难冲突了"
        },
        {
            "author": "107874017",
            "timestamp": 1462695240,
            "txt_content": "不不不 \n我的意思是\n这种方法使用的前提是用户可以无限制的创造同一名字的物品\n这个方法显然是有限位数 在考虑极端情况下\n这不克星"
        },
        {
            "author": "云闪",
            "timestamp": 1462698420,
            "txt_content": "107874017 发表于 2016-5-8 16:14\n不不不 \n我的意思是\n这种方法使用的前提是用户可以无限制的创造同一名字的物品\n用long\nlong的最大值19位\n用前2位标记物品类型(这个你可以选择不要)\n第3到8位标记日期(如160508)\n剩下的10位就是当天ID生成的序号(使用原子操作方式实现不重复)\n最后一位保留以避免超出long最大值\n\n写到名字就把每个数字前加颜色代码§\n读就是读物品名前36位(16 * 2)，然后去掉§，如果结果是纯数字就判断是否符合id结构然后确认id，如果非纯数字就说明该物品名中没有合法id\n\n这个方法，可以支持每天服务器生成10亿个物品ID，并且持续到2099年(我并不认为哪个服务器一天会生成10亿个rpg物品，或者能开到2099年)\n\n而且这样的ID很容易判断物品类型，物品创建日期"
        },
        {
            "author": "初音Py2001",
            "timestamp": 1463062920,
            "txt_content": " 本帖最后由 初音Py2001 于 2016-5-12 22:26 编辑 \n\n几乎没这个必要,\n\n我们要思考的是,\n怎么保证监听到的是我们的需要箱子\n方法一: 针对玩家\n例如,玩家一要打开菜单,\n那么我们就建立一个对象,\n从玩家一打开箱子,点击物品,关闭箱子,全程跟踪\n每个对象服务一个玩家\n这样就能保证我们监听到的一定是我们的箱子事件\n\n方法二: 针对按钮(物品)\n我们要建立独一无二的物品用于按钮\n这样不管玩家打开的是什么箱子,\n只要点击的物品是对应的按钮\n我们就响应按钮对应的事件\n\n另外的提示\n通过面向对象的思维思考\n你要使玩家打开一个箱子\n里面装的都是你自己生成的物品(设置用按钮)\n于是这就专门用于监听玩家选择的对象\n它有这么几个属性:\n 按钮集合,也就是箱子里面所有的物品集合\n 玩家对象,也就是谁打开的箱子菜单\n还有这么些方法:\n 监听玩家点击箱子事件方法\n 监听玩家拖拽箱子事件方法\n 监听玩家关闭箱子事件方法\n 这个对象的回调方法"
        },
        {
            "author": "魔族宝",
            "timestamp": 1472034600,
            "txt_content": "其实有一个更好的办法。\n\n如果想创建一个Inventory，那么需要用到这个方法。\nInventory org.bukkit.Bukkit.createInventory(InventoryHolder owner, int size, String title) 复制代码\n\n这个方法的第一个参数是InventoryHolder，也就是背包持有者。\n一般情况下，这个Holder应该是一个玩家。\n\n我们为什么不在Holder上下手呢？\n所以，正确的做法应该是创建一个类，去实现InventoryHolder这个接口。\npublic class Viewer implements InventoryHolder{\n\n        private SimpleUI ui;\n        \n        public Viewer(SimpleUI simpleUI){\n                this.ui = simpleUI;\n        }\n        \n        public Inventory getInventory() {\n                // TODO Auto-generated method stub\n                return this.ui.getInventory(false);\n        }\n        \n        public SimpleUI getUI(){\n                return ui;\n        }\n        \n        public void setUI(SimpleUI ui){\n                this.ui = ui;\n        }\n        \n}复制代码\n\n在Holder中标记这个背包，也就是我们的GUI的标记。如我上方的代码，摘录SimpleUI的相关部分。\n\npublic static boolean isChestUI(Inventory inventory) {\n                // TODO Auto-generated method stub\n                return inventory.getHolder() instanceof Viewer;\n        }\n\n        public static SimpleUI fromInventory(Inventory inventory) {\n                // TODO Auto-generated method stub\n                if(!isChestUI(inventory)) return null;\n                Viewer viewer = (Viewer) inventory.getHolder();\n                return (SimpleUI) viewer.getUI();\n        }复制代码\n而这些代码则是如何判断一个Inventory是否是一个GUI，和获取GUI的实例。\n\n\nSimpleUI将会在未来两个月内开源发布，只为了各位插件开发员更简易的开发GUI插件。"
        },
        {
            "author": "云闪",
            "timestamp": 1472607840,
            "txt_content": "魔族宝 发表于 2016-8-24 18:30\n其实有一个更好的办法。\n\n如果想创建一个Inventory，那么需要用到这个方法。\n没错\nInventoryHandler正解"
        }
    ]
}