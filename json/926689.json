{
    "title": "[bukkit讨论] 浅析：BukkitScheduler",
    "author": "1609089074",
    "replyCount": 5,
    "timestamp": 1573926840,
    "txt_content": " 本帖最后由 1609089074 于 2019-11-17 15:50 编辑 \n\n最近了解到有种叫“线程池”的东西，愁着不知道怎么实际运用，于是艹了一下 obc 的 BukkitScheduler 学习一下，\n因为我也比较菜，希望能跟大家交流学习，以下是我个人的理解，如有不对劲的地方非常欢迎指正\n一开始我是从 BukkitRunnable 的 runTaskTimerAsynchronously 方法入手，追踪到了 CraftScheduler 的同名方法：\n（其实 [ruby=提交同步任务]runTaskTimer[/ruby] 和 [ruby=提交异步任务]runTaskTimerAsynchronously[/ruby] 的差别在于方法内 new 的 task 是 CraftTask 还是 CraftAsyncTask ）\n        public BukkitTask runTaskTimerAsynchronously(Plugin plugin, Runnable runnable, long delay, long period) {\n                validate(plugin, runnable);\n                if (delay < 0L) {\n                        delay = 0L;\n                }\n                if (period == 0L) {\n                        period = 1L;\n                } else if (period < -1L) {\n                        period = -1L;\n                }\n                return handle(new CraftAsyncTask(runners, plugin, runnable, nextId(), period), delay);\n        }复制代码\n当从这里（CraftScheduler实例内）提交 BukkitRunnable 任务，此方法将 delay 和 period 规范好后，\n生成 task 实例并交给私有方法 handle 处理：\n        private CraftTask handle(CraftTask task, long delay) {\n                task.setNextRun(this.currentTick + delay);\n                addTask(task);\n                return task;\n        }复制代码\n在方法 handle 内，先[ruby=CraftTask#setNextRun(long)]将 task 定时运行[/ruby]，该定时运行的tick时刻为[ruby=CraftScheduler#currentTick]当前tick[/ruby] + [ruby=方法参数delay]延时tick[/ruby]（此处的 [ruby=CraftScheduler#currentTick]当前tick字段[/ruby] 由方法 mainThreadHeartbeat 进行更新，方法内容先不做展开，下面会再详细讲），\n定时设置好后再[ruby=CraftScheduler#addTask(CraftTask)]将 task 加入\"提交队列”[/ruby]，\n        private void addTask(CraftTask task) {\n                AtomicReference<CraftTask> tail = this.tail; // 原子性实例AtomicReference，保证变量在多线程中的准确性（个人理解）\n                CraftTask tailTask = (CraftTask) tail.get();\n                /* http://jszx-jxpt.cuit.edu.cn/JavaAPI/java/util/concurrent/atomic/AtomicReference.html#compareAndSet(V,%20V)\n                 * public final boolean compareAndSet(V expect, V update) - java.util.concurrent.atomic.AtomicReference\n                 * 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。\n                 * 参数：expect - 预期值; update - 新值;\n                 * 返回：如果成功，则返回 true。返回 false 指示实际值与预期值不相等。\n                 */\n                while (!tail.compareAndSet(tailTask, task)) { // 不断尝试以原子性设置队尾 task 变量\n                        tailTask = (CraftTask) tail.get();\n                }\n                tailTask.setNext(task);\n        }复制代码\n对于所谓“提交队列”，这里得提到在 CraftTask 内的实例字段 [ruby=CraftTask#next]volatile @Nullable CraftTask next[/ruby] ，其代指紧跟在该 task 后的 task，可以理解为其以这样的方式代替了一个 ArrayList。所以所谓“加入提交队列”实际上只是将“提交队尾”的 task 实例的字段 next 引用为新的 task ，这其中并没有涉及到任何集合。\n到这里，提交任务的流程就走完了。\n\n\n接下来讲一下调度器的主体运行方法 mainThreadHeartbeat ，\n    public void mainThreadHeartbeat(final int currentTick) {\n        this.currentTick = currentTick; // 更新 tick\n        final List<CraftTask> temp = this.temp; // 任务缓存列表，空列表\n        this.parsePending(); // 解析提交的 task\n        while (this.isReady(currentTick)) {\n            final CraftTask task = this.pending.remove();\n            if (task.getPeriod() < -1L) {\n                if (task.isSync()) {\n                    this.runners.remove(task.getTaskId(), task);\n                }\n                this.parsePending();\n            }\n            else {\n                if (task.isSync()) {\n                    try {\n                        task.timings.startTiming(); // org.pigotmc.CustomTimingsHandler.startTiming(); 没搞懂啥用处\n                        task.run();\n                        task.timings.stopTiming(); // org.pigotmc.CustomTimingsHandler.stopTiming(); 没搞懂啥用处\n                    }\n                    catch (Throwable throwable) {\n                        task.getOwner().getLogger().log(Level.WARNING, String.format(\"Task #%s for %s generated an exception\", task.getTaskId(), task.getOwner().getDescription().getFullName()), throwable);\n                    }\n                    this.parsePending();\n                }\n                else {\n                    this.debugTail = this.debugTail.setNext(new CraftAsyncDebugger(currentTick + CraftScheduler.RECENT_TICKS, task.getOwner(), task.getTaskClass())); // CraftAsyncDebugger 没搞懂这个具体怎么用\n                    this.executor.execute(task);\n                }\n                final long period = task.getPeriod();\n                if (period > 0L) {\n                    task.setNextRun(currentTick + period);\n                    temp.add(task);\n                }\n                else {\n                    if (!task.isSync()) {\n                        continue;\n                    }\n                    this.runners.remove(task.getTaskId());\n                }\n            }\n        }\n        this.pending.addAll((Collection<?>)temp);\n        temp.clear();\n        this.debugHead = this.debugHead.getNextHead(currentTick);\n    }复制代码\n该方法由服务器主线程每tick进行调用（位于nms包MinecraftServer类内的方法，每个服务端版本的混淆名可能都不一样），传入的方法参数 currentTick 即为当前服务器已运行的第几 tick 数。在方法内，先将 [ruby=CraftScheduler#currentTask]this.currentTask[/ruby] 更新，载入缓存列表（一般情况下为空列表），然后开始解析提交的 task ，此处调用了私有方法 parsePending，\n        private void parsePending() {\n                CraftTask head = this.head;\n                CraftTask task = head.getNext();\n                CraftTask lastTask = head;\n                for (; task != null; task = (lastTask = task).getNext()) {\n                        if (task.getTaskId() == -1) {\n                                task.run();\n                        } else if (task.getPeriod() >= -1L) {\n                                pending.add(task);\n                                runners.put(Integer.valueOf(task.getTaskId()), task);\n                        }\n                }\n                for (task = head; task != lastTask; task = head) {\n                        head = task.getNext();\n                        task.setNext(null);\n                }\n                this.head = lastTask;\n        }复制代码\n在方法 parsePending 内，先获取[ruby=CraftScheduler#head]“提交队首”的 task[/ruby] 为局部字段 head（该 head 最开始是调度器实例化时就生成的无实际run()内容的 CraftTask 实例，也是最初的[ruby=CraftScheduler#tail]“队尾”变量[/ruby]），接下来通过 [ruby=CraftTask#next]head.getNext()[/ruby] 遍历提交任务（如果[ruby=getNext()==null]没有新的任务了[/ruby]就啥也不做），如果任务的[ruby=task.getPeriod()>=-1]周期参数有效[/ruby]，任务加入[ruby=CraftScheduler#pending]挂起队列[/ruby]，并放入[ruby=CraftScheduler#runners]任务表（ConcurrentHashMap<Integer, CraftTask>）中，然后清空“提交队列”（将原本是“提交队列”中的 task 的 next 字段设为 null），最后将原本位于“提交队尾”的 task 设为“提交队首”。\n\n解析好“提交队列”后（分配好挂起队列和任务表后），mainThreadHeartbeat 将开始从队首迭代挂起队列的任务，而循环迭代的条件是 [ruby=CraftScheduler#isReady(long)]isReady(long currentTick)[/ruby] ，其内容就是判断：挂起队列不为空并且在队首的 task 的[ruby=CraftTask#getNextRun()]定时运行的时刻点[/ruby]到了。\n        private boolean isReady(int currentTick) {\n                return (!this.pending.isEmpty()) && (((CraftTask) this.pending.peek()).getNextRun() <= this.currentTick);\n        }复制代码\n如果队首 task 运行时刻到了，mainThreadHeartbeat 将其取出（同时从队列中将其移除，意即 get 并 remove），    若任务周期无效（period值小于 -1）\n        如果是同步任务 -> 从[ruby=CraftScheduler#runners]任务表[/ruby]移除此任务\n        调用 parsePending 重新解析“提交队列” // 这里没搞懂再次调用的原因\n    否则正常进行\n        如果是同步任务：\n            try块\n                task.timings.startTiming(); // org.pigotmc.CustomTimingsHandler.startTiming(); 没搞懂啥用处\n                直接执行 task.run();\n                task.timings.stopTiming(); // org.pigotmc.CustomTimingsHandler.stopTiming(); 没搞懂啥用处\n            catch到异常\n                打印至log\n            调用 parsePending 重新解析“提交队列” // 这里也是没搞懂再次调用的原因\n        否则异步执行：\n            设置[ruby=CraftAsyncDebugger]异步debug类[/ruby]的 next // 不清楚这玩意具体啥用\n            [ruby=CraftScheduler#executor]使用线程池[/ruby]直接 execute(task)\n                        /* 此线程池字段在调度器初始化时赋值：\n                         * private final Executor executor = Executors .newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"Craft Scheduler Thread - %1$d\").build());\n                        */\n        执行任务完成后准备根据周期进行定时下次执行\n        如果任务有周期计划（period值大于 0）\n            [ruby=CraftTask#setNextRun(long)]定时任务下次执行时刻[/ruby]，时刻值为 currentTick + period\n            将任务加入缓存列表\n        否则如果是同步任务 -> 从[ruby=CraftScheduler#runners]任务表[/ruby]移除此任务\n任务迭代完后，将缓存列表的所有任务放回挂起队列\n清空缓存列表\n最后调用 this.debugHead = debugHead.getNextHead(currentTick); // 但还是不清楚这玩意具体啥用\n\n到这里，执行任务的流程就走完了。\n\n总结：给自己做的笔记...   \n1.  CraftTask自身有单链表结构（感谢三楼大佬提示这个专业名词），装载刚提交上来还没有挂起的任务。\n2.  在[ruby=mainThreadHeartbeat]调度器核心方法中[/ruby]运行同步方法是直接调用任务 task.run() ，而运行异步任务也仅是在任务要运行时才调用调度器中唯一的[ruby=Executer]线程池[/ruby]进行 execute(task)；\n2.a.  调度器中处理任务队列（同异步的任务都在一个队列中）的[ruby=mainThreadHeartbeat]核心方法[/ruby]由服务器主线程调用，因此，无论任务是同步还是异步都由主线程先过手，所以一旦主线程堵塞（或主线程处理出现缓慢）也会影响到异步任务不能及时处理。换个说法来讲，异步线程池的工作仅仅是调用任务 task.run() 而已，这个工作是由主线程叫它做的，它并不会自己去队列里取任务出来处理，所以如果主线程迟缓，还没处理的异步任务一样会被搁置在队列中。\n2.b.  实质上，只有 主线程 和 异步线程池 这两个线程在跑任务，而且后者也有可能因为前者出现堵塞、迟缓而导致闲置。这两个线程加起来的吞吐量算是不高的，如果提交的任务量太多很可能会影响运行（用专业名词来讲或许是叫做 tps 过低吧？）。在不涉及bukkit操作的时候根据情况自己再适当开线程池或许能更好的提供吞吐量。\n\n（或许我未写完（记性不太好），待补... ）\n\n\n以下是从 v1_11_R1 反艹出来的 CraftScheduler 代码，仅供学习参考：\npackage org.bukkit.craftbukkit.v1_11_R1.scheduler;\n\nimport java.util.concurrent.atomic.*;\nimport com.google.common.util.concurrent.*;\nimport java.util.concurrent.*;\nimport org.apache.commons.lang.*;\nimport java.util.*;\nimport java.util.logging.*;\nimport org.bukkit.plugin.*;\nimport org.bukkit.scheduler.*;\n\npublic class CraftScheduler implements BukkitScheduler\n{\n    private final AtomicInteger ids;\n    private volatile CraftTask head;\n    private final AtomicReference<CraftTask> tail;\n    private final PriorityQueue<CraftTask> pending;\n    private final List<CraftTask> temp;\n    private final ConcurrentHashMap<Integer, CraftTask> runners;\n    private volatile int currentTick;\n    private final Executor executor;\n    private CraftAsyncDebugger debugHead;\n    private CraftAsyncDebugger debugTail;\n    private static final int RECENT_TICKS;\n    \n    static {\n        RECENT_TICKS = 30;\n    }\n    \n    public CraftScheduler() {\n        this.ids = new AtomicInteger(1);\n        this.head = new CraftTask();\n        this.tail = new AtomicReference<CraftTask>(this.head);\n        this.pending = new PriorityQueue<CraftTask>(10, new Comparator<CraftTask>() {\n            @Override\n            public int compare(final CraftTask o1, final CraftTask o2) {\n                final int value = (int)(o1.getNextRun() - o2.getNextRun());\n                return (value != 0) ? value : (o1.getTaskId() - o2.getTaskId());\n            }\n        });\n        this.temp = new ArrayList<CraftTask>();\n        this.runners = new ConcurrentHashMap<Integer, CraftTask>();\n        this.currentTick = -1;\n        this.executor = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat(\"Craft Scheduler Thread - %1$d\").build());\n        this.debugHead = new CraftAsyncDebugger(-1, (Plugin)null, (Class)null) {\n            @Override\n            StringBuilder debugTo(final StringBuilder string) {\n                return string;\n            }\n        };\n        this.debugTail = this.debugHead;\n    }\n    \n    @Override\n    public int scheduleSyncDelayedTask(final Plugin plugin, final Runnable task) {\n        return this.scheduleSyncDelayedTask(plugin, task, 0L);\n    }\n    \n    @Override\n    public BukkitTask runTask(final Plugin plugin, final Runnable runnable) {\n        return this.runTaskLater(plugin, runnable, 0L);\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleAsyncDelayedTask(final Plugin plugin, final Runnable task) {\n        return this.scheduleAsyncDelayedTask(plugin, task, 0L);\n    }\n    \n    @Override\n    public BukkitTask runTaskAsynchronously(final Plugin plugin, final Runnable runnable) {\n        return this.runTaskLaterAsynchronously(plugin, runnable, 0L);\n    }\n    \n    @Override\n    public int scheduleSyncDelayedTask(final Plugin plugin, final Runnable task, final long delay) {\n        return this.scheduleSyncRepeatingTask(plugin, task, delay, -1L);\n    }\n    \n    @Override\n    public BukkitTask runTaskLater(final Plugin plugin, final Runnable runnable, final long delay) {\n        return this.runTaskTimer(plugin, runnable, delay, -1L);\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleAsyncDelayedTask(final Plugin plugin, final Runnable task, final long delay) {\n        return this.scheduleAsyncRepeatingTask(plugin, task, delay, -1L);\n    }\n    \n    @Override\n    public BukkitTask runTaskLaterAsynchronously(final Plugin plugin, final Runnable runnable, final long delay) {\n        return this.runTaskTimerAsynchronously(plugin, runnable, delay, -1L);\n    }\n    \n    @Override\n    public int scheduleSyncRepeatingTask(final Plugin plugin, final Runnable runnable, final long delay, final long period) {\n        return this.runTaskTimer(plugin, runnable, delay, period).getTaskId();\n    }\n    \n    @Override\n    public BukkitTask runTaskTimer(final Plugin plugin, final Runnable runnable, long delay, long period) {\n        validate(plugin, runnable);\n        if (delay < 0L) {\n            delay = 0L;\n        }\n        if (period == 0L) {\n            period = 1L;\n        }\n        else if (period < -1L) {\n            period = -1L;\n        }\n        return this.handle(new CraftTask(plugin, runnable, this.nextId(), period), delay);\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleAsyncRepeatingTask(final Plugin plugin, final Runnable runnable, final long delay, final long period) {\n        return this.runTaskTimerAsynchronously(plugin, runnable, delay, period).getTaskId();\n    }\n    \n    @Override\n    public BukkitTask runTaskTimerAsynchronously(final Plugin plugin, final Runnable runnable, long delay, long period) {\n        validate(plugin, runnable);\n        if (delay < 0L) {\n            delay = 0L;\n        }\n        if (period == 0L) {\n            period = 1L;\n        }\n        else if (period < -1L) {\n            period = -1L;\n        }\n        return this.handle(new CraftAsyncTask(this.runners, plugin, runnable, this.nextId(), period), delay);\n    }\n    \n    @Override\n    public <T> Future<T> callSyncMethod(final Plugin plugin, final Callable<T> task) {\n        validate(plugin, task);\n        final CraftFuture<T> future = new CraftFuture<T>(task, plugin, this.nextId());\n        this.handle(future, 0L);\n        return future;\n    }\n    \n    @Override\n    public void cancelTask(final int taskId) {\n        if (taskId <= 0) {\n            return;\n        }\n        CraftTask task = this.runners.get(taskId);\n        if (task != null) {\n            task.cancel0();\n        }\n        task = new CraftTask(new Runnable() {\n            @Override\n            public void run() {\n                if (!this.check(CraftScheduler.this.temp)) {\n                    this.check(CraftScheduler.this.pending);\n                }\n            }\n            \n            private boolean check(final Iterable<CraftTask> collection) {\n                final Iterator<CraftTask> tasks = collection.iterator();\n                while (tasks.hasNext()) {\n                    final CraftTask task = tasks.next();\n                    if (task.getTaskId() == taskId) {\n                        task.cancel0();\n                        tasks.remove();\n                        if (task.isSync()) {\n                            CraftScheduler.this.runners.remove(taskId);\n                        }\n                        return true;\n                    }\n                }\n                return false;\n            }\n        });\n        this.handle(task, 0L);\n        for (CraftTask taskPending = this.head.getNext(); taskPending != null; taskPending = taskPending.getNext()) {\n            if (taskPending == task) {\n                return;\n            }\n            if (taskPending.getTaskId() == taskId) {\n                taskPending.cancel0();\n            }\n        }\n    }\n    \n    @Override\n    public void cancelTasks(final Plugin plugin) {\n        Validate.notNull(plugin, \"Cannot cancel tasks of null plugin\");\n        final CraftTask task = new CraftTask(new Runnable() {\n            @Override\n            public void run() {\n                this.check(CraftScheduler.this.pending);\n                this.check(CraftScheduler.this.temp);\n            }\n            \n            void check(final Iterable<CraftTask> collection) {\n                final Iterator<CraftTask> tasks = collection.iterator();\n                while (tasks.hasNext()) {\n                    final CraftTask task = tasks.next();\n                    if (task.getOwner().equals(plugin)) {\n                        task.cancel0();\n                        tasks.remove();\n                        if (!task.isSync()) {\n                            continue;\n                        }\n                        CraftScheduler.this.runners.remove(task.getTaskId());\n                    }\n                }\n            }\n        });\n        this.handle(task, 0L);\n        for (CraftTask taskPending = this.head.getNext(); taskPending != null; taskPending = taskPending.getNext()) {\n            if (taskPending == task) {\n                return;\n            }\n            if (taskPending.getTaskId() != -1 && taskPending.getOwner().equals(plugin)) {\n                taskPending.cancel0();\n            }\n        }\n        for (final CraftTask runner : this.runners.values()) {\n            if (runner.getOwner().equals(plugin)) {\n                runner.cancel0();\n            }\n        }\n    }\n    \n    @Override\n    public void cancelAllTasks() {\n        final CraftTask task = new CraftTask(new Runnable() {\n            @Override\n            public void run() {\n                final Iterator<CraftTask> it = CraftScheduler.this.runners.values().iterator();\n                while (it.hasNext()) {\n                    final CraftTask task = it.next();\n                    task.cancel0();\n                    if (task.isSync()) {\n                        it.remove();\n                    }\n                }\n                CraftScheduler.this.pending.clear();\n                CraftScheduler.this.temp.clear();\n            }\n        });\n        this.handle(task, 0L);\n        for (CraftTask taskPending = this.head.getNext(); taskPending != null && taskPending != task; taskPending = taskPending.getNext()) {\n            taskPending.cancel0();\n        }\n        for (final CraftTask runner : this.runners.values()) {\n            runner.cancel0();\n        }\n    }\n    \n    @Override\n    public boolean isCurrentlyRunning(final int taskId) {\n        final CraftTask task = this.runners.get(taskId);\n        if (task == null || task.isSync()) {\n            return false;\n        }\n        final CraftAsyncTask asyncTask = (CraftAsyncTask)task;\n        synchronized (asyncTask.getWorkers()) {\n            // monitorexit(asyncTask.getWorkers())\n            return asyncTask.getWorkers().isEmpty();\n        }\n    }\n    \n    @Override\n    public boolean isQueued(final int taskId) {\n        if (taskId <= 0) {\n            return false;\n        }\n        for (CraftTask task = this.head.getNext(); task != null; task = task.getNext()) {\n            if (task.getTaskId() == taskId) {\n                return task.getPeriod() >= -1L;\n            }\n        }\n        CraftTask task = this.runners.get(taskId);\n        return task != null && task.getPeriod() >= -1L;\n    }\n    \n    @Override\n    public List<BukkitWorker> getActiveWorkers() {\n        final ArrayList<BukkitWorker> workers = new ArrayList<BukkitWorker>();\n        for (final CraftTask taskObj : this.runners.values()) {\n            if (taskObj.isSync()) {\n                continue;\n            }\n            final CraftAsyncTask task = (CraftAsyncTask)taskObj;\n            synchronized (task.getWorkers()) {\n                workers.addAll(task.getWorkers());\n            }\n            // monitorexit(task.getWorkers())\n        }\n        return workers;\n    }\n    \n    @Override\n    public List<BukkitTask> getPendingTasks() {\n        final ArrayList<CraftTask> truePending = new ArrayList<CraftTask>();\n        for (CraftTask task = this.head.getNext(); task != null; task = task.getNext()) {\n            if (task.getTaskId() != -1) {\n                truePending.add(task);\n            }\n        }\n        final ArrayList<BukkitTask> pending = new ArrayList<BukkitTask>();\n        for (final CraftTask task2 : this.runners.values()) {\n            if (task2.getPeriod() >= -1L) {\n                pending.add(task2);\n            }\n        }\n        for (final CraftTask task2 : truePending) {\n            if (task2.getPeriod() >= -1L && !pending.contains(task2)) {\n                pending.add(task2);\n            }\n        }\n        return pending;\n    }\n    \n    public void mainThreadHeartbeat(final int currentTick) {\n        this.currentTick = currentTick;\n        final List<CraftTask> temp = this.temp;\n        this.parsePending();\n        while (this.isReady(currentTick)) {\n            final CraftTask task = this.pending.remove();\n            if (task.getPeriod() < -1L) {\n                if (task.isSync()) {\n                    this.runners.remove(task.getTaskId(), task);\n                }\n                this.parsePending();\n            }\n            else {\n                if (task.isSync()) {\n                    try {\n                        task.timings.startTiming();\n                        task.run();\n                        task.timings.stopTiming();\n                    }\n                    catch (Throwable throwable) {\n                        task.getOwner().getLogger().log(Level.WARNING, String.format(\"Task #%s for %s generated an exception\", task.getTaskId(), task.getOwner().getDescription().getFullName()), throwable);\n                    }\n                    this.parsePending();\n                }\n                else {\n                    this.debugTail = this.debugTail.setNext(new CraftAsyncDebugger(currentTick + CraftScheduler.RECENT_TICKS, task.getOwner(), task.getTaskClass()));\n                    this.executor.execute(task);\n                }\n                final long period = task.getPeriod();\n                if (period > 0L) {\n                    task.setNextRun(currentTick + period);\n                    temp.add(task);\n                }\n                else {\n                    if (!task.isSync()) {\n                        continue;\n                    }\n                    this.runners.remove(task.getTaskId());\n                }\n            }\n        }\n        this.pending.addAll((Collection<?>)temp);\n        temp.clear();\n        this.debugHead = this.debugHead.getNextHead(currentTick);\n    }\n    \n    private void addTask(final CraftTask task) {\n        AtomicReference<CraftTask> tail;\n        CraftTask tailTask;\n        for (tail = this.tail, tailTask = tail.get(); !tail.compareAndSet(tailTask, task); tailTask = tail.get()) {}\n        tailTask.setNext(task);\n    }\n    \n    private CraftTask handle(final CraftTask task, final long delay) {\n        task.setNextRun(this.currentTick + delay);\n        this.addTask(task);\n        return task;\n    }\n    \n    private static void validate(final Plugin plugin, final Object task) {\n        Validate.notNull(plugin, \"Plugin cannot be null\");\n        Validate.notNull(task, \"Task cannot be null\");\n        if (!plugin.isEnabled()) {\n            throw new IllegalPluginAccessException(\"Plugin attempted to register task while disabled\");\n        }\n    }\n    \n    private int nextId() {\n        return this.ids.incrementAndGet();\n    }\n    \n    private void parsePending() {\n        CraftTask head = this.head;\n        CraftTask task = head.getNext();\n        CraftTask lastTask = head;\n        while (task != null) {\n            if (task.getTaskId() == -1) {\n                task.run();\n            }\n            else if (task.getPeriod() >= -1L) {\n                this.pending.add(task);\n                this.runners.put(task.getTaskId(), task);\n            }\n            task = (lastTask = task).getNext();\n        }\n        for (task = head; task != lastTask; task = head) {\n            head = task.getNext();\n            task.setNext(null);\n        }\n        this.head = lastTask;\n    }\n    \n    private boolean isReady(final int currentTick) {\n        return !this.pending.isEmpty() && this.pending.peek().getNextRun() <= currentTick;\n    }\n    \n    @Override\n    public String toString() {\n        final int debugTick = this.currentTick;\n        final StringBuilder string = new StringBuilder(\"Recent tasks from \").append(debugTick - CraftScheduler.RECENT_TICKS).append('-').append(debugTick).append('{');\n        this.debugHead.debugTo(string);\n        return string.append('}').toString();\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleSyncDelayedTask(final Plugin plugin, final BukkitRunnable task, final long delay) {\n        return this.scheduleSyncDelayedTask(plugin, (Runnable)task, delay);\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleSyncDelayedTask(final Plugin plugin, final BukkitRunnable task) {\n        return this.scheduleSyncDelayedTask(plugin, (Runnable)task);\n    }\n    \n    @Deprecated\n    @Override\n    public int scheduleSyncRepeatingTask(final Plugin plugin, final BukkitRunnable task, final long delay, final long period) {\n        return this.scheduleSyncRepeatingTask(plugin, (Runnable)task, delay, period);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTask(final Plugin plugin, final BukkitRunnable task) throws IllegalArgumentException {\n        return this.runTask(plugin, (Runnable)task);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTaskAsynchronously(final Plugin plugin, final BukkitRunnable task) throws IllegalArgumentException {\n        return this.runTaskAsynchronously(plugin, (Runnable)task);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTaskLater(final Plugin plugin, final BukkitRunnable task, final long delay) throws IllegalArgumentException {\n        return this.runTaskLater(plugin, (Runnable)task, delay);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTaskLaterAsynchronously(final Plugin plugin, final BukkitRunnable task, final long delay) throws IllegalArgumentException {\n        return this.runTaskLaterAsynchronously(plugin, (Runnable)task, delay);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTaskTimer(final Plugin plugin, final BukkitRunnable task, final long delay, final long period) throws IllegalArgumentException {\n        return this.runTaskTimer(plugin, (Runnable)task, delay, period);\n    }\n    \n    @Deprecated\n    @Override\n    public BukkitTask runTaskTimerAsynchronously(final Plugin plugin, final BukkitRunnable task, final long delay, final long period) throws IllegalArgumentException {\n        return this.runTaskTimerAsynchronously(plugin, (Runnable)task, delay, period);\n    }\n}\n复制代码\n以下是从 v1_11_R1 反艹出来的 CraftTask 与 CraftAsyncTask 代码，仅供学习参考：\npackage org.bukkit.craftbukkit.v1_11_R1.scheduler;\n\nimport org.bukkit.scheduler.*;\nimport org.bukkit.plugin.*;\nimport org.spigotmc.*;\nimport org.bukkit.craftbukkit.v1_11_R1.*;\nimport org.bukkit.*;\n\npublic class CraftTask implements BukkitTask, Runnable\n{\n    private volatile CraftTask next;\n    private volatile long period;\n    private long nextRun;\n    private final Runnable task;\n    private final Plugin plugin;\n    private final int id;\n    final CustomTimingsHandler timings;\n    public String timingName;\n    \n    CraftTask() {\n        this(null, null, -1, -1L);\n    }\n    \n    CraftTask(final Runnable task) {\n        this(null, task, -1, -1L);\n    }\n    \n    CraftTask(final String timingName) {\n        this(timingName, null, null, -1, -1L);\n    }\n    \n    CraftTask(final String timingName, final Runnable task) {\n        this(timingName, null, task, -1, -1L);\n    }\n    \n    CraftTask(final String timingName, final Plugin plugin, final Runnable task, final int id, final long period) {\n        this.next = null;\n        this.timingName = null;\n        this.plugin = plugin;\n        this.task = task;\n        this.id = id;\n        this.period = period;\n        this.timingName = ((timingName == null && task == null) ? \"Unknown\" : timingName);\n        this.timings = (this.isSync() ? SpigotTimings.getPluginTaskTimings(this, period) : null);\n    }\n    \n    CraftTask(final Plugin plugin, final Runnable task, final int id, final long period) {\n        this(null, plugin, task, id, period);\n    }\n    \n    @Override\n    public final int getTaskId() {\n        return this.id;\n    }\n    \n    @Override\n    public final Plugin getOwner() {\n        return this.plugin;\n    }\n    \n    @Override\n    public boolean isSync() {\n        return true;\n    }\n    \n    @Override\n    public void run() {\n        this.task.run();\n    }\n    \n    long getPeriod() {\n        return this.period;\n    }\n    \n    void setPeriod(final long period) {\n        this.period = period;\n    }\n    \n    long getNextRun() {\n        return this.nextRun;\n    }\n    \n    void setNextRun(final long nextRun) {\n        this.nextRun = nextRun;\n    }\n    \n    CraftTask getNext() {\n        return this.next;\n    }\n    \n    void setNext(final CraftTask next) {\n        this.next = next;\n    }\n    \n    Class<? extends Runnable> getTaskClass() {\n        return this.task.getClass();\n    }\n    \n    @Override\n    public void cancel() {\n        Bukkit.getScheduler().cancelTask(this.id);\n    }\n    \n    boolean cancel0() {\n        this.setPeriod(-2L);\n        return true;\n    }\n    \n    public String getTaskName() {\n        if (this.timingName != null) {\n            return this.timingName;\n        }\n        return this.task.getClass().getName();\n    }\n}\n复制代码package org.bukkit.craftbukkit.v1_11_R1.scheduler;\n\nimport org.bukkit.scheduler.*;\nimport org.bukkit.plugin.*;\nimport java.util.logging.*;\nimport java.util.*;\n\nclass CraftAsyncTask extends CraftTask\n{\n    private final LinkedList<BukkitWorker> workers;\n    private final Map<Integer, CraftTask> runners;\n    \n    CraftAsyncTask(final Map<Integer, CraftTask> runners, final Plugin plugin, final Runnable task, final int id, final long delay) {\n        super(plugin, task, id, delay);\n        this.workers = new LinkedList<BukkitWorker>();\n        this.runners = runners;\n    }\n    \n    @Override\n    public boolean isSync() {\n        return false;\n    }\n    \n    @Override\n    public void run() {\n        final Thread thread = Thread.currentThread();\n        synchronized (this.workers) {\n            if (this.getPeriod() == -2L) {\n                // monitorexit(this.workers)\n                return;\n            }\n            this.workers.add(new BukkitWorker() {\n                @Override\n                public Thread getThread() {\n                    return thread;\n                }\n                \n                @Override\n                public int getTaskId() {\n                    return CraftAsyncTask.this.getTaskId();\n                }\n                \n                @Override\n                public Plugin getOwner() {\n                    return CraftAsyncTask.this.getOwner();\n                }\n            });\n        }\n        // monitorexit(this.workers)\n        Throwable thrown = null;\n        try {\n            super.run();\n        }\n        catch (Throwable t) {\n            thrown = t;\n            this.getOwner().getLogger().log(Level.WARNING, String.format(\"Plugin %s generated an exception while executing task %s\", this.getOwner().getDescription().getFullName(), this.getTaskId()), thrown);\n            synchronized (this.workers) {\n                try {\n                    final Iterator<BukkitWorker> workers = this.workers.iterator();\n                    boolean removed = false;\n                    while (workers.hasNext()) {\n                        if (workers.next().getThread() == thread) {\n                            workers.remove();\n                            removed = true;\n                            break;\n                        }\n                    }\n                    if (!removed) {\n                        throw new IllegalStateException(String.format(\"Unable to remove worker %s on task %s for %s\", thread.getName(), this.getTaskId(), this.getOwner().getDescription().getFullName()), thrown);\n                    }\n                }\n                finally {\n                    if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                        this.runners.remove(this.getTaskId());\n                    }\n                }\n                if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                    this.runners.remove(this.getTaskId());\n                }\n            }\n            // monitorexit(this.workers)\n        }\n        finally {\n            synchronized (this.workers) {\n                try {\n                    final Iterator<BukkitWorker> workers = this.workers.iterator();\n                    boolean removed = false;\n                    while (workers.hasNext()) {\n                        if (workers.next().getThread() == thread) {\n                            workers.remove();\n                            removed = true;\n                            break;\n                        }\n                    }\n                    if (!removed) {\n                        throw new IllegalStateException(String.format(\"Unable to remove worker %s on task %s for %s\", thread.getName(), this.getTaskId(), this.getOwner().getDescription().getFullName()), thrown);\n                    }\n                }\n                finally {\n                    if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                        this.runners.remove(this.getTaskId());\n                    }\n                }\n                if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                    this.runners.remove(this.getTaskId());\n                }\n            }\n            // monitorexit(this.workers)\n        }\n        synchronized (this.workers) {\n            try {\n                final Iterator<BukkitWorker> workers = this.workers.iterator();\n                boolean removed = false;\n                while (workers.hasNext()) {\n                    if (workers.next().getThread() == thread) {\n                        workers.remove();\n                        removed = true;\n                        break;\n                    }\n                }\n                if (!removed) {\n                    throw new IllegalStateException(String.format(\"Unable to remove worker %s on task %s for %s\", thread.getName(), this.getTaskId(), this.getOwner().getDescription().getFullName()), thrown);\n                }\n            }\n            finally {\n                if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                    this.runners.remove(this.getTaskId());\n                }\n            }\n            if (this.getPeriod() < 0L && this.workers.isEmpty()) {\n                this.runners.remove(this.getTaskId());\n            }\n        }\n        // monitorexit(this.workers)\n    }\n    \n    LinkedList<BukkitWorker> getWorkers() {\n        return this.workers;\n    }\n    \n    @Override\n    boolean cancel0() {\n        synchronized (this.workers) {\n            this.setPeriod(-2L);\n            if (this.workers.isEmpty()) {\n                this.runners.remove(this.getTaskId());\n            }\n        }\n        // monitorexit(this.workers)\n        return true;\n    }\n}\n复制代码\n其实spigot官网上有开源..（感谢二楼大佬的提示）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "GiNYAi",
            "timestamp": 1573934700,
            "txt_content": "https://hub.spigotmc.org/stash/projects/SPIGOT/repos/craftbukkit/"
        },
        {
            "author": "a1294790523",
            "timestamp": 1573956780,
            "txt_content": "在？链表结构了解一下？"
        },
        {
            "author": "1609089074",
            "timestamp": 1573959660,
            "txt_content": "a1294790523 发表于 2019-11-17 10:13\n在？链表结构了解一下？\n嗷谢谢dalao！涨知识了，原来这种叫做链表啊结果啊，\n当时反艹后看了半天才搞清楚这种结构关系，当时就在想，如果是直接有个List应该会更明了吧...\n\n用这样的结构，比起直接用ArrayList，有哪些优势呢？"
        },
        {
            "author": "1609089074",
            "timestamp": 1573959960,
            "txt_content": "GiNYAi 发表于 2019-11-17 04:05\nhttps://hub.spigotmc.org/stash/projects/SPIGOT/repos/craftbukkit/\n哎呀没想到，原来有开源的呀！\n谢谢dalao提示！"
        },
        {
            "author": "a1294790523",
            "timestamp": 1573960260,
            "txt_content": "1609089074 发表于 2019-11-17 11:01\n嗷谢谢dalao！涨知识了，原来这种叫做链表啊结果啊，\n当时反艹后看了半天才搞清楚这种结构关系，当时就在 ...\n很抱歉数据结构忘光了233 你去搜索一下应该就知道了\n没记错的话插入和删除会更快，对于任务这种场景是最重要的了\n"
        }
    ]
}