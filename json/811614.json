{
    "title": "[PCD] 如何写一个世界生成器",
    "author": "海螺螺",
    "replyCount": 15,
    "timestamp": 1533348540,
    "txt_content": " 本帖最后由 754503921 于 2019-2-18 22:56 编辑 \n如何写一个世界生成器\n目录见上，可以点！可以点！\n\n这篇教程中的所有代码，如果未特别说明，均以 MIT-DNBM 开源\n简单来说就是：随便用，不用问我，用坏了也不关我事\n所有涉及的代码基本都能在这里找到 https://github.com/PluginsCDTribe/WorldGenTutor\n\n[afd]izzel[/afd]\n\n实现 Bukkit 的世界生成器\n\nBukkit 上的 World Generator假设你对 Bukkit 插件已经有了一些了解，主类大概看起来是这样的：\n package com.ilummc.tutor;\nimport org.bukkit.generator.ChunkGenerator;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class WorldGenTutor extends JavaPlugin {\n\n    @Override\n    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {\n        return null;\n    }\n\n}覆盖 getDefaultWorldGenerator 方法，然后编辑 bukkit.yml ：\nworlds:\n  world:\n    generator: 插件名当然，你也可以为这个世界指定同一个插件的不同生成器（当然你的插件需要根据 id 判断并实现对应功能），将 generator 后编辑为 插件名:id 即可，这里的 id 将会作为上文的方法的第二个 String 参数。\n最后，如果你想要控制主世界的生成，你需要在 plugin.yml 中加上 load: startup\n届时，Bukkit 已经认可你的插件是可以提供世界生成器了，但是目前而言，这个方法仍然返回 null，我们需要给他加上对应的功能。\n\n实现一个 ChunkGenerator\n创建一个新的类，看起来是这样的\n package com.ilummc.tutor;\nimport org.bukkit.generator.ChunkGenerator;\n\npublic class FlatGenerator extends ChunkGenerator {\n\n}\n超平坦应该是这样的：\n\n\n最下两层为基岩，第三层为草方块，其他什么也不要：\npublic class FlatGenerator extends ChunkGenerator {\n\n    @Override\n    public ChunkData generateChunkData(World world, Random random, int x, int z, BiomeGrid biome) {\n        // 创建区块数据\n        ChunkData chunkData = createChunkData(world);\n        // 一个区块的大小为 16*16，高度为 0-255\n        // 将这个区块的 (0,0,0) 到 (16,2,16) ，即最低两层填充为基岩\n        chunkData.setRegion(0, 0, 0, 16, 2, 16, Material.BEDROCK);\n        // 将第三层填充为草方块\n        chunkData.setRegion(0, 2, 0, 16, 3, 16, Material.GRASS_BLOCK);\n        // 将整个区块的生物群系设置为平原（PLAINS）\n        for (int i = 0; i < 16; i++) {\n            for (int j = 0; j < 16; j++) {\n                biome.setBiome(i, j, Biome.PLAINS);\n            }\n        }\n        return chunkData;\n    }\n\n}\nChunkData 类用于存储世界的方块信息，BiomeGrid 用于存储生物群系信息。\n\n这一章就在这里结束了，至此，如果认真阅读了源码，你应该已经了解了如何创建一个 Bukkit 上的地图生成器了。\n\n\n\n加工现有的 World Generator\nBukkit\n在 Bukkit 中，有一个 org.bukkit.WorldCreator 类，可以用于创建新的世界；而这个类中，有一个名为 generator() 的方法可以提供自定义的地形生成器（这也是下一节将会讲到的东西），如果不提供 generator 的话，Bukkit 将会使用内部的生成器。\n\nMinecraft 原版的世界生成分为两个阶段，Generation 和 Population。我们将会对 Population 阶段进行修改：\n世界加载时会触发 WorldInitEvent，这时世界已经加载好了所需的相关设置，即将进行区块生成。我们需要为这个世界添加自定义的 BlockPopulator：\npublic class ExtendVanillaGenerator implements Listener {\n\n    @EventHandler\n    public void onInit(WorldInitEvent event) {\n        if (\"world\".equals(event.getWorld().getName())) {\n            event.getWorld().getPopulators().add(new PumpkinPopulator());\n        }\n    }\n\n    private static class PumpkinPopulator extends BlockPopulator {\n\n        @Override\n        public void populate(World world, Random random, Chunk chunk) {\n            // 随机生成一些南瓜的数量\n            int amount = random.nextInt(8);\n            for (int i = 0; i < amount; i++) {\n                // 随机位置\n                int x = random.nextInt(16);\n                int z = random.nextInt(16);\n                for (int y = 255; y >= 0; y--) {\n                    if (chunk.getBlock(x, y, z).getType() != Material.AIR) {\n                        // 只让南瓜生成在草方块上\n                        if (chunk.getBlock(x, y, z).getType() == Material.GRASS_BLOCK\n&& chunk.getBlock(x, y + 1, z).getType() == Material.AIR)\n                            chunk.getBlock(x, y + 1, z).setType(Material.PUMPKIN);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n}\n我们想让世界在任何地方都随机生成一些南瓜，那么启动游戏看看效果：\n\n南瓜的确变多了。\n\nMinecraft 原版的所有世界生成的类都在 nms 包内以 WorldGen 开头，可以自行反编译查看他们的实现\n\n\n\n\nMojang 的生成器和别人的生成器目前，网络上能找到的各种世界生成器的教程/资源，按照以下的方式生成一个地图：\n使用噪波函数生成一串随机但是连续的数字使用这些数字的大小表示地形的高度/湿度/其他属性使用这些属性决定生物群系\n\n什么是噪波函数呢？\n噪波函数（这是我的叫法，这篇教程也会这么叫），别人把他叫做噪声函数，基本上是一个种子随机发生器。它需要一个数作为参数，然后根据这个参数返回一个随机数。如果两次都传同一个参数进来，它就会产生两次相同的数。这个性质决定了 Minecraft 使用相同的种子总是生成相同的地形，\n如果每个相近的参数生成的随机数相差太大，那么 Minecraft 的地形将是无比混乱的。噪波函数在传入连续的数字时，返回的随机数的差值是不大的，整体数值呈现随机但连续起伏。\n关于噪波函数，你可以去这里看看。如果你能够硬肛全洋文文档，你也可以去这里看看，这一篇详细的讲解了各种噪波的区别，\n\n那么 Mojang 的生成器是如何运作的呢？\n根据土球的答案，我们可以了解到 Minecraft 的地形生成与上文不同，是先生成生物群系，再通过群系来决定地形（如高度）。生成的地形分为两个大阶段，Generation 时期生成主要的地形，Population 时期生成点缀，比如树。\n土球回答的下面也有一个答案，那个答案比较详细的讲述了 Minecraft 的地形生成过程。\n\n我们的生成器我们采用地形决定群系的方式。首先是生成地形。常用的噪波函数有 Perlin Noise 和 Simplex，我们采用 Simplex。\npublic class NormalGenerator extends ChunkGenerator {\n\n    private SimplexOctaveGenerator noise;\n\n    @Override\n    public ChunkData generateChunkData(World world, Random random, int chunkX, int chunkZ, BiomeGrid biome) {\n        ChunkData chunkData = createChunkData(world);\n        // 我们需要的噪声生成器\n        if (noise == null) {\n            noise = new SimplexOctaveGenerator(world.getSeed(), 1);\n            // 我们需要更平缓的地形，所以需要设置 scale\n            // 该值越大，地形变化更大\n            // 微调即可\n            noise.setScale(0.005D);\n        }\n        for (int x = 0; x < 16; x++) {\n            for (int z = 0; z < 16; z++) {\n                // 方块的真实坐标\n                int realX = chunkX * 16 + x;\n                int realZ = chunkZ * 16 + z;\n                // noise 方法返回 -1 到 1 之间的随机数\n                double noiseValue = noise.noise(realX, realZ, 0.5D, 0.5D);\n                // 将 noise 值放大，作为该点的高度\n                int height = (int) (noiseValue * 40D + 100D);\n                // 底层基岩\n                chunkData.setBlock(x, 0, z, Material.BEDROCK);\n                // 中间石头\n                for (int y = 0; y < height - 1; y++) {\n                    chunkData.setBlock(x, y, z, Material.STONE);\n                }\n                // 表面覆盖泥土和草方块\n                chunkData.setBlock(x, height - 1, z, Material.DIRT);\n                chunkData.setBlock(x, height, z, Material.GRASS_BLOCK);\n            }\n        }\n        return chunkData;\n    }\n}\n\n有点单调，除了默认生成的生物以外没有任何东西，并且地形看起来也很单调。\n\n\n加点东西如果只是小小地点缀一下地图，BlockPopulator 是再适合不过的选择了。\n重写 getDefaultPopulators 方法，返回我们自定义的：树！\n@Override\npublic List<BlockPopulator> getDefaultPopulators(World world) {\n    return ImmutableList.of(new TreePopulator());\n}\n\nprivate static class TreePopulator extends BlockPopulator {\n\n    @Override\n    public void populate(World world, Random random, Chunk chunk) {\n        // 假设只有 1/4 的区块生成树\n        if (random.nextInt(4) < 1) {\n            // 假设每个区块生成 1-3 颗树\n            int amount = random.nextInt(3) + 1;\n            for (int i = 0; i < amount; i++) {\n                // 随机生成树的坐标\n                int x = random.nextInt(16);\n                int z = random.nextInt(16);\n                int y = 255;\n                // 找到最高的方块来生成树\n                while (chunk.getBlock(x, y, z).getType() == Material.AIR) y--;\n                // 生成树\n                world.generateTree(chunk.getBlock(x, y, z).getLocation(),\n                        // 搞点有趣的，我们随机选择不同的树生成\n                        TreeType.values()[random.nextInt(TreeType.values().length)]);\n            }\n        }\n    }\n\n}效果拔群。在下面这个实例里，我把 scale 从 0.005 调成了 0.0025，地图变得非常平缓。\n（最终还是没有蘑菇树，果然还是不行呢）\n\n地面上不是那么单调了，但是 Minecraft 的特色可不止地面上。现在，我们往这个世界加一点矿物：\n@Override\npublic List<BlockPopulator> getDefaultPopulators(World world) {\n    return ImmutableList.of(new TreePopulator(), new DiamondPopulator());\n}\n\nprivate static class DiamondPopulator extends BlockPopulator {\n\n    @Override\n    public void populate(World world, Random random, Chunk chunk) {\n        // 假设每个区块只有一个钻石矿\n        // 钻石矿脉随机生成在高度 16 以下\n        int x = random.nextInt(16);\n        // 不要生成在基岩上\n        int y = random.nextInt(15) + 1;\n        int z = random.nextInt(16);\n        // 继续生成的几率\n        while (random.nextDouble() < 0.8D) {\n            // 只替换岩石\n            if (chunk.getBlock(x, y, z).getType() == Material.STONE) {\n                chunk.getBlock(x, y, z).setType(Material.DIAMOND_ORE);\n            }\n            // 向某个方向随机继续生成\n            switch (random.nextInt(6)) {\n                case 0: x++; break;\n                case 1: y++; break;\n                case 2: z++; break;\n                case 3: x--; break;\n                // 不要生成到基岩下面去了\n                case 4: y = Math.max(y-1, 0); break;\n                default: z--; break;\n            }\n        }\n    }\n\n}经过暴力开采后找到了我们的钻石矿。\n\n你可以仿照这个方法生成其他矿物。\n\n\n\n玩转 NoiseGenerator / OctaveGenerator\n读了上面几章以后，你一定对代码中出现的 PerlinNoiseGenerator / SimplexOctaveGenerator 感到疑惑了。这一章将会教会你 噪波函数 的各种概念，以及如何使用。\n如果你能够访问 archive.org 并且可以阅读英文，那么你可以看看这一篇文章。\n\n噪波函数？各位相比用过随机数生成器，即 Java 的 Random 类，虽然这个类很好的满足了我们对于不可预测性的需求，但是它的输出过于随机；在这种情况下，Ken Perlin 发明了 Perlin 噪波函数。Perlin 函数看起来是这样的：\n\n如果传入更连续的参数，最终的结果会是这样的：\n\n噪波函数的形状被我们用于生成地形。\n\n函数的一些特性这是一个普通的正弦波\n\namplitude：振幅，为波的高度\nwavelength：波长，为每个峰之间的距离\nfrequency：频率，为 1/波长\n\n这是一个噪波函数\n\n每个红点代表函数的随机值\n振幅为函数可能取得的最大值和最小值的差值\n波长为每个红点之间的距离\n频率仍然为 1/波长\n\n现在，脑补一个随机的噪波，脑补一下增加/减少它的频率，增加/减少它的振幅\n当振幅减少时，函数将会变「矮」，当频率增加时，函数起伏更加剧烈。\n如果我们把低频高幅的函数和高频低幅的函数混合起来：\n\n就会得到和原有单调的噪波函数完全不同的、更为复杂的函数图像：\n\n数学表达式？我们将 噪波函数 定义为 noise(x) ，返回值为 0-1 的小数。\n那么上文的混合函数写出来可能就是这样的\nf(x) = 1*noise(x) + 0.5*noise(2x) + 0.25*noise(4x) + 0.125*noise(8x) + 0.0625*noise(16x) ......\n在数学表达式中，我们可以简单的把 2x 4x 8x 里的数字称为频率，将 0.5 0.25 0.125 称为振幅\n到这里，有心的读者可能会注意到了，这个 f(x) 最后的值不是可以大于 1 了，还能叫噪波函数吗？\n别担心，记住这个问题，继续往下看。\n\n代码？上文的混合函数可以写成这样：\n/**\n * 假设此函数返回 0-1 之间的随机数，并且满足噪波函数的相关定义\n *\n * @param x 参数\n * @return 0-1 的随机数\n */\nstatic double noise(double x) {\n    return 0;\n}\n\n/**\n * 噪波函数\n *\n * @param x    参数\n * @param freq 频率\n * @param amp  振幅\n * @return 函数值\n */\nstatic double f(double x, double freq, double amp) {\n    return amp * noise(x * freq);\n}\n\nstatic double f(double x) {\n    return f(x, 1, 1) + f(x, 2, 0.5) + f(x, 4, 0.25) + f(x, 8, 0.125);\n}这项技术被称为分形：\n维基百科：\n分形噪声是上述 Perlin 1985年的文章中提出的将符合上文所述三条件的噪声通过计算分形和构造更复杂效果的算法。\n在一维的情况下，设噪声函数为noise(x)，则通过 noise(2x), noise(4x) 等就可以构造更高频率的噪声。\n\n你可能也注意到了，分形函数中，我们可以将分形次数提取出来，作为单独的一个参数，这个参数我们称之为 octave。那么上文代码里最后一个方法可以写成这样：static double f(double x, double freq, double amp, int octaves, boolean normalized) {\n    double result = 0.0D;\n    double a = 1.0D;\n    double f = 1.0D;\n    double max = 0.0D;\n\n    for (int i = 0; i < octaves; ++i) {\n        result += f(x, f, a);\n        max += amp;\n        f *= freq;\n        a *= amp;\n    }\n\n    if (normalized) {\n        result /= max;\n    }\n\n    return result;\n}\n前文代码中最后一个 f() 方法就与目前我们的 f(x, 2, 0.5, 4, false) 的作用相同了，仔细想想，是不是这样？\n这 normalized 参数是干啥的？上文中我（也可能是读者你）提出了一个问题，这个参数即是解决这个问题的。仔细想想，是不是这样。\n\nNoiseGenerator 与 OctaveGenerator到了这里，我们只剩一个问题了：最开始的代码里的 noise 方法，如何实现呢？\norg.bukkit.util.noise 包内有 4 个类，用于提供生成噪波函数的方法。static double bukkitNoise(double x, double freq, double amp, int octaves, boolean normalized) {\n    SimplexNoiseGenerator generator = new SimplexNoiseGenerator(new Random());\n    return generator.noise(x, octaves, freq, amp, normalized);\n}\n\nstatic double bukkitOctave(double x, double freq, double amp, int octaves, boolean normalized) {\n    SimplexOctaveGenerator generator = new SimplexOctaveGenerator(new Random(), octaves);\n    return generator.noise(x, freq, amp, normalized);\n}\n如果你认真的看了上面的所有文章，并且认真的思考过后，你应该已经掌握了这几个类的用处了。\n几点需要注意的地方：\nBukkit 的噪波函数类返回 -1 到 1 的值，与上文的 0 到 1 不同，自行处理即可Bukkit 的噪波函数类默认频率很大，所以需要使用小频率（OctaveGenerator 的 setScale(0.005)）对于给定的相同种子，调用同一个点的函数总返回相同值\n\n最后一个问题：为什么会有 PerlinXxxxGenerator 和 SimplexXxxxGenerator 两种呢？\nPerlin 是初代噪波函数，Simplex 基于 Perlin 优化，得到的图像更好看，在高维度的速度也更快。\n\n\n\n噪波函数使用小技巧\n1. Math.pow这个函数的图像是这样的：\n\n你可以用这个函数让山峰更加陡峭，让山谷更加平坦n1 = new PerlinNoiseGenerator(random);\ndouble e = n1.noise(x * 0.01F, z * 0.01F, 6, 2.0F, 0.5F);\ne = Math.pow(e, 2.5);\nelevation[x][z] = (int) (64 + e * 64F);\n\n\n\n2. Math.abs你可以用此创建锋利的山脊 function ridgenoise(x, z) {  return 2 * (0.5 - abs(0.5 - noise(x, z))); }\ne0 =  1 * ridgenoise(1 * x, 1 * z);\ne1 =  0.5 * ridgenoise(2 * x, 2 * z) * e0;\ne2 = 0.25 * ridgenoise(4 * x, 4 * z) * (e0+e1);\ne = e0 + e1 + e2;\nelevation[x][z] = Math.pow(e, 2.5);\n\n\n[groupid=1330]PluginsCDTribe[/groupid]",
    "replies": [
        {
            "author": "zghh008",
            "timestamp": 1533350460,
            "txt_content": "里是真的流啤"
        },
        {
            "author": "寂",
            "timestamp": 1533603060,
            "txt_content": "前排支持海螺大佬的教程。\n说实话，国内似乎在这之前还没有世界生成器这种高级教程，感谢楼主开了这个先例。\n促进了开发界的发展与整体水平的提高。\n"
        },
        {
            "author": "July_Summer",
            "timestamp": 1533605880,
            "txt_content": "感谢感谢 \n之前弄个生成虚空的生成器 弄了一天 最后发现只要一个方法就好"
        },
        {
            "author": "Kyokuki",
            "timestamp": 1533748500,
            "txt_content": "非常棒的教程！学会了"
        },
        {
            "author": "1204942617",
            "timestamp": 1533777600,
            "txt_content": "一脸懵逼，感觉灰常lan-= ="
        },
        {
            "author": "龙腾猫跃",
            "timestamp": 1533779400,
            "txt_content": "暴力开采：物品栏的TNT"
        },
        {
            "author": "tdiant",
            "timestamp": 1533785520,
            "txt_content": "我觉得海星，支持海螺dalao，应该是为数不多的世界生成器文献了吧"
        },
        {
            "author": "yanshuchen",
            "timestamp": 1534158000,
            "txt_content": "这是真的流啤\n\n惊呆了"
        },
        {
            "author": "330377782",
            "timestamp": 1534691040,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "18956446679",
            "timestamp": 1534924500,
            "txt_content": "看的我脑壳痛"
        },
        {
            "author": "gu_xing_lei",
            "timestamp": 1535252760,
            "txt_content": "女装大佬 ** 举报举报 【滑稽】"
        },
        {
            "author": "langyo_v3",
            "timestamp": 1535731440,
            "txt_content": "这些天怎么蹦出来这么多大佬"
        },
        {
            "author": "490779629",
            "timestamp": 1536157800,
            "txt_content": "好流弊啊,支持dalao"
        },
        {
            "author": "BF_BingFeng",
            "timestamp": 1582954020,
            "txt_content": "谢谢指导，我去试试"
        },
        {
            "author": "kongbaiyo",
            "timestamp": 1583505120,
            "txt_content": " 本帖最后由 kongbaiyo 于 2020-4-23 23:02 编辑 \n\n学会了 这就用命令实现一下 数据包原版新维度指日可待\n做好了 是这个帖子->https://www.mcbbs.net/thread-995688-1-1.html\n"
        }
    ]
}