{
    "title": "Minecraft 启动器核心改造记 （一）",
    "author": "Exzh_PMGI",
    "replyCount": 7,
    "timestamp": 1548991680,
    "txt_content": " 本帖最后由 Exzh_PMGI 于 2019-2-1 11:28 编辑 \n\n\n\n鉴于此类文章的特殊性，我暂且将它放到茶馆上发布，此后这个系列将会搬运到我的个人博客上。\nBlog : 我的开发者博客  有任何建议或想法的请联系我 Email : realexzh@gmail.com\n\n \nMinecraft 启动器核心改造记 （一）\n最近我的 Minecode Studio 项目需要启动器来支持代码的调试和运行，本想着能够在 mcbbs 上找到用 C++ 写成的启动器动态库，可找了一圈就只找到了一个 C++ 静态库：QGettingStarted，于是乎 git clone 大法把它克隆到本地。\n\n\n库结构如上图所示\n翻阅它的 README.md 得知它的启动方法如下：\n QString launchCommand;\n        QGSLauncher launcher;\n        QGSGameDirectory gameDirectory(QDir(\"./minecraft\"));\n        QGSLaunchOptionsBuilder launchOptionsBuilder;\n\n        launchOptionsBuilder.setJavaPath(\"C:/Program Files/Java/jre1.8.0_162/bin/javaw.exe\");\n        launchOptionsBuilder.setMaxMemory(1024);\n        launchOptionsBuilder.setMinMemory(128);\n\n        QGSAuthInfo authInfo;\n        QEventLoop eventLoop;\n        //正版登录替换为QGSYggdrasilAccountFactory\n        QGSIAccount * account(QGSOfflineAccountFactory().createAccount());\n        QObject::connect(account, &QGSIAccount::finished, &eventLoop, &QEventLoop::quit);\n        QObject::connect(account, &QGSIAccount::finished, [&authInfo](QGSAuthInfo _authInfo)\n        {\n                authInfo = _authInfo;\n        });\n        /*正版登录的错误检查\n        QObject::connect(account, &QGSIAccount::error, [](QGSNetworkError networkError)\n        {\n                qDebug() << \"QGSNetworkError:\" << networkError.getCode() << networkError.getErrorString();\n        });\n        */\n        account->authenticate(\"player\");\n        //account->authenticate(\"123@xxx.com\",\"123456\"); 正版登录\n        eventLoop.exec();\n\n        launchOptionsBuilder.setAuthInfo(authInfo);\n        launchOptionsBuilder.setJVMArguments(\"-XX:+UseG1GC -XX:-UseAdaptiveSizePolicy -XX:-OmitStackTraceInFastThrow\");\n\n        launcher.generateLaunchCommand(gameDirectory.getVersion(\"1.11.2\"), gameDirectory, launchOptionsBuilder.getLaunchOptions(), launchCommand);复制代码我的天，光是启动就要这么多的对象，还不支持自动识别 Java 路径... 显然这样的代码我是不能接受的，好，开始动手改造！\n由于我对启动器的参数浑然不知，所以先来从它的启动参数生成类下手。\n从 main.cpp 中可以看出，启动步骤先是在栈上创建了一个 QGSLauncher 对象，那么我们去看看 QGSLauncher 是如何实现的。\nclass QGSLauncher : public QObject\n{\n        Q_OBJECT\npublic:\n        QGSLauncher(QObject * parent = nullptr);\n        QGSLauncher(const QGSLauncher & right) = delete;\n        QGSLauncher(QGSLauncher && right) = delete;\n        QGSLauncher & operator=(const QGSLauncher & right) = delete;\n        QGSLauncher & operator=(QGSLauncher && right) = delete;\n        virtual ~QGSLauncher();\n        virtual QGSLauncherError::ErrorFlags generateLaunchCommand(const QGSGameVersion & version, QGSGameDirectory & gameDirectory, const QGSLaunchOptions * launchOptions, QString & command);\n}复制代码从头文件得知 QGSLauncher 是直接继承自 Qt 基类 QObject 的，且它明确指出了不允许同一时间内存在两个完全相同的 QGSLauncher 对象。C++11 标准允许将赋值操作符、构造函数、析构函数删除，这使得编译器不能够为我们生成默认的复制构造函数、构造函数和析构函数。可以看到生成启动参数的虚函数返回类型为错误类型，但由于 Minecode Studio 需要输出完整的启动信息，因此，ErrorFlags 是库中多余的类型，改成 void。Qt Framework 为开发者们提供了极为便捷的 signal/slots 机制，即 信号/槽 机制，相比回调函数，信号/槽 在可读性上更具优势（虽然在编译期间，它还是会被转换为回调函数）。既然如此，那就让它生成完启动参数以后发出一个信号，再将这个信号与我的启动器的主类 mclLauncher 相连。接着，我们可以看到 generateLaunchCommand 这个函数传入了4个参数，前三个被定义为 const ，最后一个却没有加 const 修饰符。\n Tips : 根据 Effective C++ (第三版) [ISBN 978-7-121-12332-0] 的条款 03 \"Use const whenever possible.\" 所建议的：const 是个奇妙且非比寻常的东西:在函数参数和返回类型身上 ... 林林总总不一而足。 const 是个威力强大的助手。尽可能使用它。\n这是为何原因？我们先将这个疑惑放到一边，来看它的 .cpp 源文件：\nQGSLauncherError::ErrorFlags QGSLauncher::generateLaunchCommand(const QGSGameVersion & version, QGSGameDirectory & gameDirectory, const QGSLaunchOptions * launchOptions, QString & command)\n{\n        QGSGeneralLauncherStrategy launcherStrategy;\n\n        return launcherStrategy.generateLaunchCommand(version, gameDirectory, launchOptions, command);\n}复制代码函数的实现体内又出现了一个没有见到过的类 QGSGeneralLauncherStrategy ，继续跳到 QGSGeneralLauncherStrategy 的定义和实现：\nclass QGSGeneralLauncherStrategy : public QGSILauncherStrategy\n{\npublic:\n        QGSGeneralLauncherStrategy();\n        QGSGeneralLauncherStrategy(const QGSGeneralLauncherStrategy & right) = delete;\n        QGSGeneralLauncherStrategy(QGSGeneralLauncherStrategy && right) = delete;\n        QGSGeneralLauncherStrategy & operator=(const QGSGeneralLauncherStrategy & right) = delete;\n        QGSGeneralLauncherStrategy & operator=(QGSGeneralLauncherStrategy && right) = delete;\n        virtual ~QGSGeneralLauncherStrategy();\n\n        virtual QGSLauncherError::ErrorFlags generateLaunchCommand(const QGSGameVersion & version,\n                QGSGameDirectory & gameDirectory,\n                const QGSLaunchOptions * launchOptions,\n                QString & command) override;\n\n};复制代码QGSGeneralLauncherStrategy 是继承自 QGSILauncherStrategy 基类的派生类，这显然会为后续的开发带来便捷：方便定义和插件化系统，但这也带来一个问题：虽然这有着很大的优势，但继承自 QGSILauncherStrategy 这个基类的派生类只有 QGSGeneralLauncherStrategy 这么一个，为了展现 C++ 继承特性而去写基类虽说不会带来内存上的消耗但是却对代码可读性带来很大影响。（试想你为了查找一个函数翻阅了无数个基类的定义文件才知道它的真正实现在哪，这必然会对开发效率带来影响）Mark 一下，加入到改造计划的 ToDo 列表里。\n基类定义的虚函数如下：\n virtual QGSLauncherError::ErrorFlags generateLaunchCommand(const QGSGameVersion & version,\n                QGSGameDirectory & gameDirectory,\n                const QGSLaunchOptions * launchOptions,\n                QString & command) override;复制代码很明确得可以看出 QGSGeneralLauncherStrategy::generateLaunchCommand 这个函数是实现了 QGSILauncherStrategy 中定义的生成启动参数函数的。\nQGSLauncherError::ErrorFlags QGSGeneralLauncherStrategy::generateLaunchCommand(const QGSGameVersion & version,\n        QGSGameDirectory & gameDirectory,\n        const QGSLaunchOptions * launchOptions,\n        QString & command)\n{\n        QGSLauncherError::ErrorFlags ret(QGSLauncherError::Ok);\n        if (!launchOptions)\n        {\n                return ret |= QGSLauncherError::ErrorNullPointer;\n        }\n\n        QStringList launchCommandList;//launchCommand\n        auto rootVersionId(version.getId());\n        QGSGameVersion rootVersion;\n        //获取根版本\n        try\n        {\n                while (!gameDirectory.getVersion(rootVersionId).getInheritsFrom().isEmpty())\n                {\n                        rootVersionId = gameDirectory.getVersion(rootVersionId).getInheritsFrom();\n                }\n                rootVersion = gameDirectory.getVersion(rootVersionId);\n        }\n        catch (const QGSExceptionVersionNotFound & exception)\n        {\n                return ret |= QGSLauncherError::ErrorJarFileNotFound;\n        }\n\n        //根版本Jar文件\n        QSharedPointer<QFile> rootVersionJarFile(gameDirectory.generateGameVersionJarFile(rootVersionId));\n        if (!rootVersionJarFile->exists())\n        {\n                return ret |= QGSLauncherError::ErrorJarFileNotFound;\n        }\n        //前置指令\n        const auto && wrapper(launchOptions->getWrapper());\n        if (!wrapper.isEmpty())\n        {\n                launchCommandList.append(wrapper);\n        }\n        //Java路径\n        const auto && JavaPath(launchOptions->getJavaPath());\n        if (JavaPath.isEmpty())\n        {\n                ret |= QGSLauncherError::WarningJavaPathNotIncluded;\n        }\n        launchCommandList.append(QString(\"\"%1\"\").arg(JavaPath));\n        //JVM虚拟机参数\n        if (launchOptions->getGeneratedJVMArguments())\n        {\n                //自定义JVM虚拟机参数\n                const auto && JVMArguments(launchOptions->getJVMArguments());\n                if (!JVMArguments.isEmpty())\n                {\n                        launchCommandList.append(JVMArguments);\n                }\n                \n                launchCommandList.append(QString(\"\"-Dminecraft.client.jar=%1\"\").\n                        arg(rootVersionJarFile->fileName()));\n                //最大内存（MB）\n                launchCommandList.append(QString(\"-Xmx%1m\").arg(launchOptions->getMaxMemory()));\n                //最小内存（MB）\n                launchCommandList.append(QString(\"-Xmn%1m\").arg(launchOptions->getMinMemory()));\n                //内存永久保存区域（MB）\n                if (launchOptions->getMetaspaceSize() > 0)\n                {\n                        launchCommandList.append(QString(\"-XX:PermSize=%1m\").arg(launchOptions->getMetaspaceSize()));\n                }\n                //-Dfml.ignoreInvalidMinecraftCertificates=true -Dfml.ignorePatchDiscrepancies=true\n                launchCommandList.append(\"-Dfml.ignoreInvalidMinecraftCertificates=true\");\n                launchCommandList.append(\"-Dfml.ignorePatchDiscrepancies=true\");\n                //logging\n                auto && loggingPath(launchOptions->getLoggingPath());\n                if (!loggingPath.isEmpty())\n                {\n                        auto && argument(rootVersion.getLogging().value(\"client\").getArgument());\n                        if (!argument.isEmpty())\n                        {\n                                launchCommandList.append(argument.replace(\"${path}\", \"\"\" + loggingPath + \"\"\"));\n                        }\n                }\n        }\n        //新版json包含\"arguments\"属性\n        auto && arguments(rootVersion.getArguments());\n        auto && JVMList(arguments.getJVM());\n        if (!JVMList.isEmpty())\n        {\n                for (auto & i : JVMList)\n                {\n                        if (isRulesAllowing(i.getRules()))\n                        {\n                                auto && valueList(i.getValue());\n                                for (auto & j : valueList)\n                                {\n                                        //防止value中等号后的值带有空格所导致的问题\n                                        int equalSignLocation = j.indexOf(\"=\");\n                                        if (equalSignLocation != -1)\n                                        {\n                                                if (j.right(equalSignLocation).contains(\" \"))\n                                                {\n                                                        j = j.left(equalSignLocation + 1) + \"\"\" + j.mid(equalSignLocation + 1) + \"\"\";\n                                                }\n                                        }\n                                        launchCommandList.append(j);\n                                }\n                        }\n                }\n        }\n        else\n        {\n                launchCommandList.append(\"-Djava.library.path=${natives_directory}\");\n                launchCommandList.append(\"-Dminecraft.launcher.brand=${launcher_name}\");\n                launchCommandList.append(\"-Dminecraft.launcher.version=${launcher_version}\");\n                launchCommandList.append(\"-cp\");\n                launchCommandList.append(\"${classpath}\");\n        }\n        auto && customMinecraftArguments(launchOptions->getCustomMinecraftArguments());\n        //natives目录\n        auto nativesDirectory(gameDirectory.generateNativesDirectory(version.getId()));\n        nativesDirectory.mkpath(nativesDirectory.absolutePath());\n        //launcherName\n        const QString launcherName(customMinecraftArguments.contains(\"${launcher_name}\") ? customMinecraftArguments.value(\"${launcher_name}\") : \"\"QGettingStarted\"\");\n        //launcherVersion\n        const QString launcherVersion(customMinecraftArguments.contains(\"${launcher_version}\") ? customMinecraftArguments.value(\"${launcher_version}\") : \"\"Pre 1.0.0\"\");\n        //libraries\n        auto inheritsVersionId(version.getId());\n        QStringList libraryPathList;\n        do\n        {\n                auto & version(gameDirectory.getVersion(inheritsVersionId));\n                auto && libraryList(version.getLibraries());\n\n                //for (auto & i : libraryList)\n                for (int i = 0; i < libraryList.size(); ++i)\n                {\n                        if (!isRulesAllowing(libraryList[i].getRules()))\n                        {\n                                continue;\n                        }\n\n                        QSharedPointer<QFile> fileLibrary(gameDirectory.generateLibraryFile(libraryList[i]));\n                        auto libraryPath(fileLibrary->fileName());\n                        if (libraryList[i].getNative())\n                        {\n                                //解压natives\n                                auto extractList(QGSFileTools::extractDirectory(libraryPath, nativesDirectory.absolutePath()));\n                                if (extractList.isEmpty())\n                                {\n                                        //throw QGSExceptionCompress(libraryPath, nativesDirectory.absolutePath());\n                                        ret |= QGSLauncherError::WarningNativesCompressError;\n                                }\n\n                                auto && excludeList(libraryList[i].getExtract().getExclude());\n                                for (auto & exclude : excludeList)\n                                {\n                                        if (!QGSFileTools::removeDirectory(nativesDirectory.absolutePath() + SEPARATOR + exclude))\n                                        {\n                                                ret |= QGSLauncherError::WarningNativesCompressError;\n                                        }\n                                }\n\n                                continue;\n                        }\n\n                        libraryPathList.append(libraryPath);\n                }\n\n                QSharedPointer<QFile> fileInheritsVersionJar(gameDirectory.generateGameVersionJarFile(inheritsVersionId));\n                libraryPathList.append(fileInheritsVersionJar->fileName());//版本\".jar\"文件\n        } while (!(inheritsVersionId = gameDirectory.getVersion(inheritsVersionId).getInheritsFrom()).isEmpty());\n        //mainClass\n        launchCommandList.append(version.getMainClass());\n        /*minecraftArguments*/\n        auto && game(arguments.getGame());\n        QString minecraftArguments;\n        if (!game.isEmpty())\n        {\n                QStringList argumentList;\n                for (auto & i : game)\n                {\n                        if (i.getRules().getRules().isEmpty())\n                        {\n                                argumentList.append(i.getValue());\n                        }\n                }\n                minecraftArguments = argumentList.join(\" \");\n        }\n        else\n        {\n                minecraftArguments = version.getMinecraftArguments();\n        }\n        auto && authInfo(launchOptions->getAuthInfo());\n\n        QDir assetsDirectory;\n        if (!gameDirectory.generateAssetsDirectory(rootVersionId, rootVersion.getAssetIndex(), assetsDirectory))\n        {\n                ret |= QGSLauncherError::WarningAssetDirectoryGenerationFailure;\n        }\n        auto && assetsDirAbsolutePath(assetsDirectory.absolutePath());\n\n        auto && authPlayerName(authInfo.getSelectedProfile().getName());\n        if (authPlayerName.isEmpty())\n        {\n                return ret |= QGSLauncherError::ErrorPlayerNameNotIncluded;\n        }\n\n        auto && authUuid(authInfo.getSelectedProfile().getId());\n        if (authUuid.isEmpty())\n        {\n                return ret |= QGSLauncherError::ErrorAuthUuidNotIncluded;\n        }\n\n        auto && authAccessToken(authInfo.getAccessToken());\n        if (authAccessToken.isEmpty())\n        {\n                return ret |= QGSLauncherError::ErrorAuthAccessTokenNotIncluded;\n        }\n\n        auto && userType(authInfo.getUserType());\n        if (userType.isEmpty())\n        {\n                return ret |= QGSLauncherError::ErrorUserTypeNotIncluded;\n        }\n\n        minecraftArguments.replace(\"${auth_player_name}\", customMinecraftArguments.contains(\"${auth_player_name}\") ? customMinecraftArguments.value(\"${auth_player_name}\") : authPlayerName)\n                .replace(\"${version_name}\", customMinecraftArguments.contains(\"${version_name}\") ? customMinecraftArguments.value(\"${version_name}\") : version.getId())\n                .replace(\"${game_directory}\", customMinecraftArguments.contains(\"${game_directory}\") ? customMinecraftArguments.value(\"${game_directory}\") : QString(\"\"%1\"\").arg(gameDirectory.getBaseDir().absolutePath()))\n                .replace(\"${assets_root}\", customMinecraftArguments.contains(\"${assets_root}\") ? customMinecraftArguments.value(\"${assets_root}\") : QString(\"\"%1\"\").arg(assetsDirAbsolutePath))\n                .replace(\"${assets_index_name}\", customMinecraftArguments.contains(\"${assets_index_name}\") ? customMinecraftArguments.value(\"${assets_index_name}\") : rootVersion.getAssets())\n                .replace(\"${auth_uuid}\", customMinecraftArguments.contains(\"${auth_uuid}\") ? customMinecraftArguments.value(\"${auth_uuid}\") : authUuid)\n                .replace(\"${auth_access_token}\", customMinecraftArguments.contains(\"${auth_access_token}\") ? customMinecraftArguments.value(\"${auth_access_token}\") : authAccessToken)\n                .replace(\"${user_type}\", customMinecraftArguments.contains(\"${user_type}\") ? customMinecraftArguments.value(\"${user_type}\") : userType)\n                .replace(\"${version_type}\", customMinecraftArguments.contains(\"${version_type}\") ? customMinecraftArguments.value(\"${version_type}\") : \"\"QGettingStarted\"\")\n                .replace(\"${user_properties}\", customMinecraftArguments.contains(\"${user_properties}\") ? customMinecraftArguments.value(\"${user_properties}\") : authInfo.getTwitchAccessToken())\n                .replace(\"${auth_session}\", customMinecraftArguments.contains(\"${auth_session}\") ? customMinecraftArguments.value(\"${auth_session}\") : authAccessToken)\n                .replace(\"${game_assets}\", customMinecraftArguments.contains(\"${game_assets}\") ? customMinecraftArguments.value(\"${game_assets}\") : QString(\"\"%1\"\").arg(assetsDirAbsolutePath))\n                .replace(\"${profile_name}\", customMinecraftArguments.contains(\"${profile_name}\") ? customMinecraftArguments.value(\"${profile_name}\") : \"QGettingStarted\");\n        launchCommandList.append(minecraftArguments);\n        //窗口大小\n        auto && windowSize(launchOptions->getWindowSize());\n        if (!windowSize.isEmpty())\n        {\n                launchCommandList.append(QString(\"--height %1\").arg(windowSize.height()));\n                launchCommandList.append(QString(\"--width %1\").arg(windowSize.width()));\n        }\n        //直连服务器\n        auto && serverInfo(launchOptions->getServerInfo());\n        if (!serverInfo.getAddress().isEmpty() && !serverInfo.getPort().isEmpty())\n        {\n                launchCommandList.append(QString(\"--server %1\").arg(serverInfo.getAddress()));\n                launchCommandList.append(QString(\"--port %1\").arg(serverInfo.getPort()));\n        }\n        //代理\n        auto && proxy(launchOptions->getProxy());\n        if (proxy != QNetworkProxy::NoProxy && !proxy.hostName().isEmpty())\n        {\n                launchCommandList.append(QString(\"--proxyHost %1\").arg(proxy.hostName()));\n                launchCommandList.append(QString(\"--proxyPort %1\").arg(proxy.port()));\n                if (!proxy.user().isEmpty() && !proxy.password().isEmpty())\n                {\n                        launchCommandList.append(QString(\"--proxyUser %1\").arg(proxy.user()));\n                        launchCommandList.append(QString(\"--proxyPass %1\").arg(proxy.password()));\n                }\n        }\n        //游戏额**数\n        auto gameArguments(launchOptions->getGameArguments());\n        if (!gameArguments.isEmpty())\n        {\n                launchCommandList.append(gameArguments);\n        }\n\n        command = launchCommandList.join(\" \")\n                .replace(\"${natives_directory}\", \"\"\" + nativesDirectory.absolutePath() + \"\"\")\n                .replace(\"${launcher_name}\", launcherName)\n                .replace(\"${launcher_version}\", launcherVersion)\n                .replace(\"${classpath}\", QString(\"\"%1\"\").arg(libraryPathList.join(\";\")));\n        return ret;\n}复制代码从上面的实现代码中我们就可以得到先前所遗留下来的疑问：为什么 command 这个形参前没有加 const 修饰符 —— 因为函数的内部实现在生成参数的时候将参数输出到了 QString command 对象上。\n\n由此我们可以得到启动参数的普遍规律：\n<JVM 虚拟机路径> -Dminecraft.client.jar= <版本的 jar 文件> -Xmx<最大内存><数据单位> -Xmn<最小内存><数据单位> -XX:PermSize=<最大内存><数据单位> -Dfml.ignoreInvalidMinecraftCertificates=true -Dfml.ignorePatchDiscrepancies=true -Djava.library.path=<库路径> -Dminecraft.launcher.brand=<启动器名称> -Dminecraft.launcher.version=<启动器版本> -cp <依赖库路径> --height <游戏初始窗口高度> --width <游戏初始窗口高度> --server <直连服务器 IP> --port <直连服务器端口> ...\n\n当然可选的参数还有很多，但对启动器的开发来说，已经足够了。\n关于参数的模板格式可以参照 http://www.mcbbs.net/thread-704424-1-1.html 来看。\n今天的改造记先写到这里，下一章我会来讲述如何实现更高阶的启动器功能（库文件格式、Json 文件格式、版本大小判断 [不用 json] 等等）\n欢迎大家继续关注我的 Minecraft 启动器核心改造记 连载系列。\n\n打开有惊喜↓\n也请有钱的观众老爷们能赞赏我，开发不易，赏个饭钱吧 \n\n   \n",
    "replies": [
        {
            "author": "Abraham511",
            "timestamp": 1548992760,
            "txt_content": "看不懂的肯定不止我一个~~"
        },
        {
            "author": "逆天皮皮虾",
            "timestamp": 1548994620,
            "txt_content": "楼主太复杂了，我看的迷迷糊糊的"
        },
        {
            "author": "RedCarl",
            "timestamp": 1548998580,
            "txt_content": "你这个太复杂了，根本看不懂"
        },
        {
            "author": "虎水小骥",
            "timestamp": 1548999180,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "二哈大魔王",
            "timestamp": 1549000140,
            "txt_content": "虽然看不懂 但是好像很厉害的样子 。。"
        },
        {
            "author": "星卡比",
            "timestamp": 1549003920,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "@TGL",
            "timestamp": 1549177680,
            "txt_content": "举个用bat启动客户端的例子，否则不好理解"
        }
    ]
}