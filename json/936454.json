{
    "title": "【教程】SEUS PTGI 添加/修改光源与mod兼容",
    "author": "GeForceLegend",
    "replyCount": 29,
    "timestamp": 1577628420,
    "txt_content": " 本帖最后由 GeForceLegend 于 2020-12-28 00:34 编辑 \n\n\n\n====前言====\n\n作为Minecraft Java Edition最出名的基于路径追踪的光追光影，SEUS PTGI推出已经有很长一段时间了（虽然一直是测试版）。但是直到现在，SEUS PTGI的光源系统仍然不是很完善，许多本来应该发光的方块没有发光，同时由于方块对环境光照的遮挡体积是在光影内写死的而不是基于游戏内方块模型的，PTGI对大部分mod的兼容性也不是很好。本教程主要针对SEUS PTGI添加/修改光源与mod兼容提供一些方案。\n\n本教程不提供SEUS PTGI副本，建议各位去Sonic Ether的Patreon页面通过订阅获取。\n\n本教程与SEUS PTGI E12兼容。修改SEUS PTGI HRR Test时，deferred.fsh的内容变为deferred2.fsh；deferred10.fsh的内容变为deferred12.fsh。\n\n由于后期更新教程时使用了E12和HRR Test示范，因此部分变量名称可能不同，但无关紧要，自行更改变量名称即可。\n\n\n\n\n\n\nfile_1577628512000.jpg (95.35 KB, 下载次数: 5)\n\n下载附件\n\n2019-12-29 22:08 上传\n\n\n\n\n\n\n\n\n\n\n\n\nmod兼容与添加光源\n\n\n====主要修改文件====\n\n修改SEUS PTGI的光源系统主要需要修改以下文件：\nblock.properties，gbuffer_terrian.vsh，shadow.fsh，shadow.vsh\n以及极少数情况下需要修改deferred.fsh（在PTGI HRR Test中是deferred2）\n注：实体（例如末影箱、潮涌核心等）目前本教程的方案无法实现发光\n\nblock.properties\n（方块名称、方块状态与光影内部处理用的数字ID的映射表）\n（也是mod兼容的修改部分）\n\n\nblock.properties存储了各个版本内方块的数字ID（用于光影内部）与方块的英文ID、方块状态之间的联系。在1.13与1.14的数据中，扁平化后被删除的方块通过“#”注释掉。由于直到截稿的最新版本（SEUS PTGI E12 HRR Test）时，光影自带的block.properties只做了1.14版本的更新，1.13以及扁平化之前的版本的方块ID仍然停留在数个版本以前的状态。建议各位修改时以1.14版本的方块状态做参考。\n\n\n\n\n\nTIM截图20191229201659.png (185.35 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 20:17 上传\n\n\n\n\n\n\n同时，由于所有的方块遮光体积都是在光影内写死的，部分方块在方块状态不同时碰撞箱会发生变化，所以Sonic Ether注释掉了原方块ID，在下方新建一个方块ID，将类型相同的方块进行了合并。例如各种楼梯的不同方块状态：\n\n\n\n\n\nTIM截图20191229201939.png (204.99 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 20:20 上传\n\n\n\n\n\n\n如果需要添加光源，首先需要找到光源的ID，如果某些光源在扁平化后合并到了其他方块ID，则需要手动解除注释并修改方块ID和方块状态。例如红石矿石在官方的block.properties里面是这两行：\nblock.73=redstone_ore\n# block.74=lit_redstone_ore\n复制代码\n如果我们想要添加发光的红石矿石作为光源的话，就需要进行修改。我个人的修改如下：\nblock.73=redstone_ore:lit=false\nblock.74=redstone_ore:lit=true\n复制代码\n然后这个74就是我们要添加的方块光源的ID，在之后的文件中会添加到某些地方。\n\n而如果是需要做mod的兼容的话，则需要找到与mod里的方块的相似的原版方块的ID。例如暮色森林（twilightforest）中的黑木楼梯与原版的各种楼梯相似。原版楼梯的对应的ID组已在上面发过。这时候想要添加对黑木楼梯的支持，就需要在每个楼梯的方块ID后面按照原版楼梯的各种方块状态在后面新增对应的方块状态，同时还需要在前面加上mod的命名空间，例如添加朝北、偏下方、直型的黑木楼梯的支持，则需要在block.259那行后面添加如下内容：\ntwilightforest:dark_stairs_:shape=straight:half=bottom:facing=north复制代码\n同时别忘了填到正确的版本内。block.properties区分了三个版本的方块ID：1.14以上（第一行的 #if MC_VERSION >= 11400 开始）、1.13以上（#elif MC_VERSION >= 11300 开始）以及1.13以下（#else 开始）\n\n注：如果某一行太长觉得不方便的话，可以使用反斜杠“\\”，下一行的内容会接着上一行反斜杠前的内容\n\n\ngbuffers_terrian.vsh\n（贴图发光类型，只影响贴图亮起来的视觉效果，不影响实际的环境光光线追踪）\n（也用于分别处理不同类型的半透明贴图）\n\n\n从这个文件开始，搜索50可以快速找到我们需要修改的部分，因为50是火把在block.properties里的数字ID。当然，有时候也会搜到一些其他的东西，不过直接点击下一个就可以。由于Sonic Ether的混淆，许多文件中有重复的无用函数。\n修改目标在SEUS PTGI E11的原版文件内是540行左右开始，该文件的主函数处。在这里不同的方块ID被定义了不同的materialIDs，而materialIDs决定了贴图在光影内的渲染，包括发光和半透明贴图的渲染类型（水/染色玻璃/粘液块等）。\n\n\n\n\n\nTIM截图20191229204137.png (219.41 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-29 20:41 上传\n\n\n\n\n\n\n而对光源贴图的materialIDs定义从图中557行开始。与光源相关的materialIDs包括了MAT_ID_TORCH，MAT_ID_LAVA，MAT_ID_GLOWSTONE，MAT_ID_FIRE与MAT_ID_LIT_FURNACE。\n*MAT_ID_TORCH：贴图中较明亮的像素发光，而且像素越亮发光程度也越高。定义式如下：\n（定义式中v.albedo.xyz对应材质内每个像素的RGB三色，0-1对应RGB的值0-255）\nr.xyz+=v.albedo.xyz*pow(length(v.albedo.xyz),2.)*.5*GI_LIGHT_TORCH_INTENSITY;复制代码\n*MAT_ID_LAVA/GLOWSTONE/FIRE：整个贴图都会发出明亮的光。MAT_ID_LAVA的光较暗，GLOWTSONE略明亮一些，而FIRE极为明亮。各个的定义式：\n//MAT_ID_GLOWSTONE\nr.xyz+=v.albedo.xyz*GI_LIGHT_BLOCK_INTENSITY;\n//MAT_ID_LAVA\nr.xyz+=v.albedo.xyz*.75*GI_LIGHT_BLOCK_INTENSITY;\n//MAT_ID_FIRE\nr.xyz+=v.albedo.xyz*3.*GI_LIGHT_TORCH_INTENSITY;\n复制代码\n*MAT_ID_FURNACE：使贴图中偏红、偏黄的区域发光，偏蓝、偏绿等以及灰色、白色等的区域不会发光。定义式：\nfloat R=saturate(v.albedo.x-(v.albedo.y+v.albedo.z)*.5-.2);\nr+=v.albedo.xyz*R*2.*GI_LIGHT_TORCH_INTENSITY*vec3(2.,.35,.025);\n复制代码\n如果想给数字ID为74的方块（在block.properties区域添加的红石矿石）添加只让红色的矿物发光的效果，MAT_ID_FURNACE符合条件，在图中第577行中添加一个mc_Entity.x==74即可（由于使用的文件是已经被我修改过的，因此图中就已经存在了）（记得按照格式打上双竖杠）。给其他数字ID对应的方块添加其他的贴图发光类型同理。\n\n注：对于性质类似的方块（例如1.16新增的菌光体与萤石类似），可以直接在 block.properties 内共用方块ID来减少所需的判断数，以节省性能。\n\n\nshadow.fsh\n两个shadow文件影响的是实际的路径追踪环境光遮蔽的效果\n（可选，光源的颜色与亮度自定义）\n（熔炉类光源的颜色与亮度无法在此自定义，需要去deferred.fsh/deferred2.fsh(PTGI HRR Test版本)修改）\n\n\n本文件的修改目的地在代码的最下方，也就是图中被高亮显示的区域。在修改前，这块区域仅存在如下代码：\nif(abs(mcEntity-50.)<.1)\n    v.xyz=GetColorTorchlight()*.1*GI_LIGHT_TORCH_INTENSITY;\nif(abs(mcEntity-76.)<.1)\n    v.xyz=vec3(1.,.02,.01)*.05*GI_LIGHT_TORCH_INTENSITY;\nif(abs(mcEntity-51.)<.1)\n    v.xyz=vec3(2.,.35,.025);\n复制代码\n\n\n\n\nTIM截图20191229205255.png (213.18 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 20:54 上传\n\n\n\n\n\n\n添加的标准格式为\nif(abs(mcEntity-方块的数字ID.)<.1)\n    v.xyz=光源颜色*倍数（用于修改光源亮度）*GI_LIGHT_BLOCK_INTENSITY/GI_LIGHT_TORCH_INTENSITY（可选，可使该光源的亮度可在光影选项内一同修改）\n复制代码\n*光源颜色的标准格式是vec3(红,绿,蓝)也就是RGB，数值0-1对应着RGB8的0-255（但是可以填入大于1的数），\n*光源颜色有时候会用GetColorTorchLight()，测试后似乎就是火把的偏黄光，由光影设置内的Torchlight Color Temp决定；\n*GI_LIGHT_TORCH_INTENSITY/GI_LIGHT_TORCH_INTENSITY可以在游戏时在选项>视频设置>光影>光影设置>Lighting & Shadow Options内修改，在设置内名称为Block Light Intensity与Torch Light Intensity，默认为1，用于游戏内调节亮度\n*实际v.xyz的最终结果为vec3(R,G,B)，而这三个数字在实际渲染时貌似有一最小单位，每个颜色的光线的亮度只会以这最小单位增强/减弱，并不是随数字改变连续增强/减弱\n\n如：给数字ID为74的方块光源定义为稍微暗一点的红色：\nif(abs(mcEntity-74.)<.1)\n    v.xyz=vec3(1.,.02,.01)*.15*GI_LIGHT_BLOCK_INTENSITY;\n复制代码\n\n\nshadow.vsh\n（定义光源的存在以及种类）\n\n\n本文件中可能需要修改一个之前两个文件都有但是忽略掉的地方：\n（SEUS PTGI E11原版文件第178行）\nif(f.x==50.||f.x==76.)\n    {\n        i=0.;\n            if(m.y<.5)\n                i=1.;\n    }\n复制代码\nSEUS PTGI的方块类光源在使用了部分自定义模型的情况下，即使在其他地方都做了对应修改，在游戏内也只有贴图发光并没有实际影响到路径追踪的环境光，这种情况下在此处进行修改，添加不发光的光源对应的数字ID在绝大多数情况下可以解决问题。末影箱、潮涌核心等实体无论如何修改也无法发光。\n\n\n\n\n\nTIM截图20191229212017.png (184.36 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 21:20 上传\n\n\n\n\n\n\n然后进入本文件的主要修改部分，从SEUS PTGI E11原版文件的第564行开始\n\n\n\n\n\nTIM截图20191229212130.png (197.6 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 21:21 上传\n\n\n\n\n\n\n在这块区域的代码中，不同的数字ID对应的方块被赋予了不同的vMaterialIDs，而vMaterialIDs决定了方块在环境光追踪时的表现，例如50（火把、灯笼、营火等）等一系列数字ID的vMaterialIDs是241，而10（岩浆）等的vMaterialIDs是31。\nvMaterialIDs为31的为方块类光源，正如其名称，光源就是一个完整的方块，与其相邻的方块的表面会被光源本身遮挡而变黑，因此不建议非完整方块使用方块类光源；\nvMaterialIDs为241的为火把类光源，其实际光源是一个无遮光体积的完整方块，绝大部分非完整方块光源首选；\nvMaterialIDs为32~35的为熔炉类光源，其实际光源只有一个面，四个vMaterialIDs对应四个不同的朝向。\n\n添加例：\n给数字ID为74的方块添加一个方块类光源，在570行添加mc_Entity.x==74即可（记得按照格式打上双竖杠）\n\n注：对于性质类似的方块（例如1.16新增的菌光体与萤石类似），可以直接在 block.properties 内共用方块ID来减少所需的判断数，以节省性能。\n\n\ndeferred.fsh\n（在PTGI HRR Test中是deferred2）\n(定义熔炉类光源的颜色与亮度)\n\n\n\n本文件的修改点可以通过搜索35快速查找。\n\n\n\n\n\nTIM截图20191229213918.png (184.61 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 21:39 上传\n\n\n\n\n\n\n图中第798行以及未截图的内容大致相同的另一行：\nR+=.04*S*I*vec3(2.,.35,.025)*GI_LIGHT_BLOCK_INTENSITY;复制代码\n决定了熔炉类光源的颜色与亮度。\n由于此处光源颜色取决于W（混淆前应为vMaterialIDs）而不是数字ID，因此熔炉类光源的颜色只能一致。各位可以尝试其他办法来突破这一限制。\n\n\n====示范案例====\n\n添加光源：点亮的红石矿石\n\n\nblock.properties修改（定义点亮的红石矿石数字ID为74）：\n第75行：\nblock.73=redstone_ore >> block.73=redstone_ore:lit=false\n第76行：\n# block.74=lit_redstone_ore >> block.74=redstone_ore:lit=true\n\ngbuffers_terrian.vsh修改（定义ID为74的方块的贴图发光类型为熔炉型）：\n第577行：\nif(mc_Entity.x==188||mc_Entity.x==189||mc_Entity.x==190||mc_Entity.x==191)\n >> \nif(mc_Entity.x==74||mc_Entity.x==188||mc_Entity.x==189||mc_Entity.x==190||mc_Entity.x==191)\n\nshadow.fsh修改（定义颜色为红色，亮度较暗）：\n第613行与614行之间添加如下代码：\nif(abs(mcEntity-74.)<.1)\n    v.xyz=vec3(1.,.02,.01)*.15*GI_LIGHT_BLOCK_INTENSITY;\n\nshadow.vsh修改（定义光源类型：方块类）：\n第570行：\nif(mc_Entity.x==89||mc_Entity.x==124||mc_Entity.x==10||mc_Entity.x==11||mc_Entity.x==169||mc_Entity.x==91)\n >> \nif(mc_Entity.x==74||mc_Entity.x==89||mc_Entity.x==124||mc_Entity.x==10||mc_Entity.x==11||mc_Entity.x==169||mc_Entity.x==91)\n\n\n\n\n\n\nfile_1577628933000.jpg (51.17 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 22:15 上传\n\n\n\n\n\n\n添加光源：末地烛\n\n\nblock.properties无修改，数字ID为198；\n\ngbuffers_terrian.vsh修改（定义贴图发光类型为火把型）：\n第557行：if(mc_Entity.x==50) >> if(mc_Entity.x==50||mc_Entity.x==198)\n\nshadow.fsh修改（定义光源为较明亮的白色）：\n在第615、616行间添加如下代码：\nif(abs(mcEntity-198.)<.1)\n    v.xyz=vec3(1.,1.,1.)*.1*GI_LIGHT_BLOCK_INTENSITY;\nshadow.vsh修改（定义光源类型为火把型）：\n第178行：if(f.x==50.||f.x==76.) >> if(f.x==50.||f.x==76.||f.x==198.)（否则实测不发光）\n第564行：if(mc_Entity.x==50) >> if(mc_Entity.x==50||mc_Entity.x==198)\n\n\n\n\n\n\nfile_1577628859000.jpg (60.26 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-29 22:14 上传\n\n\n\n\n\n\n\n\n\n\n\n\n自定义贴图发光类型\n本章节开始建议有C，C++等编程语言基础的玩家阅读。\n\n====主要修改文件====\n\nlib/Materials.inc，deferred10.fsh（在PTGI HRR Test中为deferred12）\n\nlib/Materials.inc\n（定义各个MAT_ID对应的数字，以及获取该材料的materialIDs）\n\n\n在lib/Materials.inc的顶部，定义了各个MAT_ID对应的数字。如果需要添加自定义的MAT_ID，首先需要在顶部定义新的MAT_ID，例如：\n#define MAT_ID_BEACON 35复制代码\n然后再在 struct MaterialMask 中设立新子项\nfloat beacon;复制代码\n\n\n\n\nPTGI_Mat1.png (140.9 KB, 下载次数: 0)\n\n下载附件\n\n2020-8-20 13:19 上传\n\n\n\n\n\n\n最后再在函数 MaterialMask CalculateMasks(float materialID, vec2 coord) 中添加新子项的处理：\nlwuCPRviuc.beacon         = GetMaterialMask(MAT_ID_BEACON, materialID);复制代码\n\n\n\n\nPTGI_Mat2.png (168.38 KB, 下载次数: 0)\n\n下载附件\n\n2020-8-20 13:19 上传\n\n\n\n\n\n\n这样就定义好了一个可用的新MAT_ID：MAT_ID_BEACON。不过目前即使在gbuffers_terrain.vsh里面引用也不会有效果，还需要给它定义实际的效果。\n\n注：由于PTGI版本的不同，部分变量/函数名称可能不一致\n\n\ndeferred10.fsh\n（在PTGI HRR Test中为deferred12）\n（定义各个MAT_ID实际的贴图发光效果）\n\n\n直接来到文件底部，存在如下代码：\nif(z.glowstone>.5)\n  r.xyz+=v.albedo.xyz*GI_LIGHT_BLOCK_INTENSITY;\nif(z.torch>.5)\n  r.xyz+=v.albedo.xyz*pow(length(v.albedo.xyz),2.)*.5*GI_LIGHT_TORCH_INTENSITY;\nif(z.lava>.5)\n  r.xyz+=v.albedo.xyz*.75*GI_LIGHT_BLOCK_INTENSITY;\nif(z.fire>.5)\n  r.xyz+=v.albedo.xyz*3.*GI_LIGHT_TORCH_INTENSITY;\nif(z.litFurnace>.5)\n  {\n    float R=saturate(v.albedo.x-(v.albedo.y+v.albedo.z)*.5-.2);\n    r.xyz+=v.albedo.xyz*R*2.*GI_LIGHT_TORCH_INTENSITY*vec3(2.,.35,.025);\n  }\n复制代码\n这些代码定义了各个贴图发光类型的实际表现。由于之前在 struct MaterialMask 中新增的子项为beacon，因此额外添加的判断为if(z.beacon>.5)。\n\n我自己为1.14+原版信标设计的贴图发光规则如下：\nif(z.beacon>.5)\n  {\n    float d=(v.albedo.y)/(v.albedo.z);\n    if(d>1.01||(d<1.009&&d>=1.))\n      r.xyz+=v.albedo.xyz*GI_LIGHT_BLOCK_INTENSITY;\n  }\n复制代码\n判断内对r.xyz的操作即为贴图发光详细类型。v.albedo.xyz为材质本身的RGB颜色。\n\n我的操作是判断绿色分量除以蓝色分量的值，通过对原版材质取色判断区间，使得信标的玻璃部分不发光而核心部分发光。\n\n同时我略微修改了MAT_ID_FURNACE的发光机制，以解决原版熔炉火焰中的纯白像素不发光的情况：\nif(z.litFurnace>.5)\n  {\n    float d=saturate(v.albedo.x-(v.albedo.y+v.albedo.z)*.5-.2);\n    if(d>0.||(v.albedo.x==1.&&v.albedo.y==1.&&v.albedo.z==1.))\n      r+=v.albedo.xyz*length(v.albedo.xyz)*GI_LIGHT_TORCH_INTENSITY*vec3(2.,.35,.025);\n  }\n复制代码\n这样我们就成功的完整设置了一个新的贴图发光规则 MAT_ID_BEACON 。\n\n\n\n\n\n\n\n\nPBR贴图自发光通道\n\n====主要修改文件====\n\n一系列gbuffers_xxxxx.fsh文件、deferred10.fsh（在PTGI HRR Test中为deferred12）\n\ngbuffers_xxxxx.fsh\n（获取PBR贴图的发光通道）\n\n\n其实Sonic Ether在PTGI内置了对PBR贴图B通道自发光的支持，在他的gbuffer数据解包/打包函数中就包括了emissive（发光强度），但是不知为何（可能是他发现支持PBR贴图自发光的资源包太少了），在绝大部分文件中，获取到emissive之后将其赋值为0（在terrain中是 gbuffer.emissive = saturate(specTex.a); 即赋值PBR贴图的alpha通道数据，并且限制在0~1），而且也没有对解包后的gbuffer数据中的emissive进行处理的部分。这里的修改主要是让emissive数据获取正确的值并且打包到gbuffer数据中。\n\n在整个shaders文件夹中搜索如下内容（当然不嫌麻烦的话也可以一个个打开gbuffers_xxxxx.fsh，看看有没有对应部分之后再改）\ngbuffer.emissive = 0.0;复制代码\n正常情况下会有4个搜索结果（entity，hand，textured，textured_lit）打开每一个搜索结果，将 gbuffer.emissive = 0.0; 改为 gbuffer.emissive = emissive; 同时在gbuffers_terrain.fsh中将 gbuffer.emissive = saturate(specTex.a); 也改为emissive。其他文件中可能存在获取emissive数据的情况，但是并未打包进gbuffer数据。\n\n\ndeferred10.fsh\n（在PTGI HRR Test中为deferred12）\n（处理emissive数据）\n\n\n首先确认main函数开头获取到的gbuffer数据的名称。例如，在PTGI HRR Test中，获取到的gbuffer数据存储在v中：\nGBufferData v=GetGBufferData(Texcoord);复制代码\n所以之前存储到gbuffer数据中的emissive就转移在了v.emissive中。\n\n由于PTGI中有一个默认的发光规则（之前说过的MAT_ID部分），如果需要通过PBR决定发光强度，则需要屏蔽默认发光规则。我本人修改如下（如果有更好的方案欢迎提出）：\n某像素的emissive数据大于0时，使用PBR贴图决定发光强度；反之则使用默认发光强度。\nif(v.emissive>0.)\n  {\n    r+=v.albedo.xyz*v.emissive*GI_LIGHT_BLOCK_INTENSITY;\n  }\nelse\n  {\n    if(z.glowstone>.5)\n      r+=v.albedo.xyz*GI_LIGHT_BLOCK_INTENSITY;\n    if(z.torch>.5)\n      r+=v.albedo.xyz*pow(length(v.albedo.xyz),2.)*.5*GI_LIGHT_TORCH_INTENSITY;\n    if(z.lava>.5)\n      r+=v.albedo.xyz*.75*GI_LIGHT_BLOCK_INTENSITY;\n    if(z.fire>.5)\n      r+=v.albedo.xyz*3.*GI_LIGHT_TORCH_INTENSITY;\n    if(z.litFurnace>.5)\n      {\n        float d=saturate(v.albedo.x-(v.albedo.y+v.albedo.z)*.5-.2);\n        if(d>0.||(v.albedo.x==1.&&v.albedo.y==1.&&v.albedo.z==1.))\n          r+=v.albedo.xyz*length(v.albedo.xyz)*GI_LIGHT_TORCH_INTENSITY*vec3(2.,.35,.025);\n      }\n    if(z.beacon>.5)\n      {\n        float d=(v.albedo.y)/(v.albedo.z);\n        if(d>1.01||(d<1.009&&d>=1.))\n          r+=v.albedo.xyz*GI_LIGHT_BLOCK_INTENSITY;\n      }\n  }\n复制代码\n\n\n====拓展部分====\n\n为发光强度通道提供光影设置\n\n\n在PTGI中，光滑度和金属性通道都可以在光影设置里面调整，设置位于选项>视频设置>光影>光影设置>Sueface Options内。默认的光滑度通道为R（红色），默认的粗糙度通道为G（绿色）。\n\n要添加设置，首先需要知道Optifine的光影设置相关内容。Optifine采用 #define 识别光影设置，并在shaders.properties读取可用于调整的光影设置。格式如下：\n\n开关型：\n#define xxx（默认开）\n// #define xxx（默认关）\n\n调整数值型：\n#define xxx value1 //默认描述 [value1 value2 value3 ...]\n\nPTGI的所有可调整设置都集中在lin/Uniforms.inc中。光滑度通道与金属性通道的名称分别为 SPEC_CHANNEL_SMOOTHNESS 和 SPEC_CHANNEL_METALNESS 。为了便于以后维护（真的会有人去维护自己乱改的光影吗），建议仿照光滑度与金属性通道的设置，增加如下代码：\n#define SPEC_CHANNEL_EMISSIVE b // Which channel (red, green, blue, or alpha) to read from the specular texture to determine emissive. SEUS uses the blue channel by default [r g b a]\n复制代码\n然后再在 shaders.properties 中的 screen.SURFACE 项后面加上新添加的 SPEC_CHANNEL_EMISSIVE 。\n\n当然也可以去 lang/en_US.lang 里面添加正式名称，比如添加一行 option.SPEC_CHANNEL_EMISSIVE=Specular Tex Emissive\n\n接下来就是将上面修改过的几个文件中的 float emissive = specTex.b; 更改为 float emissive = specTex.SPEC_CHANNEL_EMISSIVE; 就可以在光影设置里面调整PBR贴图的发光强度通道了。\n\n\n为PBR发光贴图提供开关\n\n\n由于许多材质包使用的都是传统反射贴图，大部分反射贴图（_s.png，PBR贴图也使用这张贴图）都有蓝色分量。所以贸然加入PBR贴图B通道自发光很容易导致加载一些比较老的材质的时候一堆方块十分明亮，所以为PBR贴图自发光准备一个开关（而且最好默认为关）是很有必要的。\n\n同样，先在lin/Uniforms.inc内定义一个开关：\n// #define SPEC_EMISSIVE // Enables emissive channel for specular texture. 复制代码\n然后再在 shaders.properties 的 screen.SURFACE 里添加 SPEC_EMISSIVE；\n\n最后在上面修改过的几个文件中添加如下代码：\n（注意一定要添加在gbuffer.emissive = emissive; 的后面， OutputGBufferDataSolid(gbuffer, frag0, frag1, frag2, frag3); 的前面）\n#ifndef SPEC_EMISSIVE\ngbuffer.emissive = 0.0;\n#endif\n复制代码\n#ifndef的作用就是在没有define所选内容的时候执行一些代码。如果在Optifine的光影设置里面关闭某一开关，其对应的字符串的define就会失效，而对应的ifndef中的内容就会启用。\n\n这样就成功添加了一个默认关闭的PBR发光贴图开关。\n\n\n提供Lab PBR选项\n\nLab PBR是一个相对较新的PBR标准，目前不少光影和材质包已经跟进。与传统PBR（R光滑度，G金属性，B发光强度）不同，它将RGBA四个通道都使用了。可以前往Github上的LabPBR WIKI了解详情。\n\n其大致内容为红色通道存储光滑度（即反相的粗糙度），绿色通道存储金属性，而蓝色通道在0~64存储孔隙度，用于调整下雨时其表面各项属性的变化，65及以上时用于次表面反射。不透明度通道用于发光强度，0-254发光强度逐渐增强，255（即100%不透明）时不发光。\n\nPTGI内由于系统复杂，不好添加孔隙度系统，可以考虑只修改发光强度通道的属性（也就额外添加个emissive为1时转成0）。\n\nLabPBR的兼容作为各位读者的一个小作业（其实是我懒得弄了），具体思路为增加一个开关，开关关闭时用传统PBR规则，开关开启后用LabPBR规则。可以将原传统PBR部分用ifndef括起来，以便开启LabPBR时禁用传统PBR部分。\n\n\n\n\n\n\n\n方块ID的判断及修复\n\n====主要修改文件====\n\nshadow.vsh\n\n在 基础级别修改——mod兼容与添加光源 章节中，shadow.vsh里面存在一段如果火把类光源不发光就修改的代码：\nif(f.x==50.||f.x==76.)\n  {\n    x=0.;\n    if(m.y<.5)\n      x=1.;\n  }\n复制代码\n实际上这段代码所位于的函数 vec3 d(vec3 v,vec3 m,vec2 n,vec2 y,vec4 i,vec4 f,inout float x,out vec2 r) 就是在判断是否在某一方块空间内应用正在渲染的方块的ID。方块模型的每一个元素都会进行一遍这样的判断，来确认是否需要给这个方块空间赋予ID。\n\n由于方块模型的每一个元素都会进行一次判断，所以对于部分模型比较特殊的方块，使用默认的判断机制会导致本身的方块空间没有被赋予ID，或者邻近的方块空间的ID被“同化”\n\n通常情况下绝大部分方块ID都会通过最顶上的一行代码来判断：\nbool s=fract(v.x*2.)>.01&&fract(v.x*2.)<.99||fract(v.y*2.)>.01&&fract(v.y*2.)<.99||fract(v.z*2.)>.01&&fract(v.z*2.)<.99;复制代码\n这行代码的具体作用我们无从得知（因为变量全部混淆，寻根溯源相对很麻烦），但是所有未在下方经过特殊处理的方块ID均通过这行代码判断。这也就是PTGI在没有给花草树苗等特殊方块特别弄一个方块ID的情况下它们依然不会拥有完整方块的遮光体积的原因。不过也正是因为这段代码，一些在原版就模型特殊的方块（酿造台等）会有完整的遮光体积。\n\nbool s 那一段最好不要轻易更改，以免影响到普通方块遮光体积的判断。我们需要做的是针对不同的方块ID，对它们的方块ID判断进行单独的修正。\n\nvec3 d () 函数的模型顶点判断大体分为两端，第一段靠 vec3 m 进行判断，而第二段的判断则融入了o和S。\n\n完整的函数如下：\n\nvec3 d(vec3 v,vec3 m,vec2 n,vec2 y,vec4 i,vec4 f,inout float x,out vec2 r)\n {\n   bool s=fract(v.x*2.)>.01&&fract(v.x*2.)<.99||fract(v.y*2.)>.01&&fract(v.y*2.)<.99||fract(v.z*2.)>.01&&fract(v.z*2.)<.99;\n   s=!s;\n   if(f.x==8||f.x==9||f.x==79||f.x<1.||!s||f.x==20.||f.x==171.||min(abs(m.x),abs(m.z))>.2)\n     x=1.;\n   if(f.x==50.||f.x==76.)\n     {\n       x=0.;\n       if(m.y<.5)\n         x=1.;\n     }\n   if(f.x==51)\n     x=0.;\n   if(f.x>255)\n     x=0.;\n   vec3 z,c;\n   if(m.x>.5)\n     z=vec3(0.,0.,-1.),c=vec3(0.,-1.,0.);\n   else\n      if(m.x<-.5)\n       z=vec3(0.,0.,1.),c=vec3(0.,-1.,0.);\n     else\n        if(m.y>.5)\n         z=vec3(1.,0.,0.),c=vec3(0.,0.,1.);\n       else\n          if(m.y<-.5)\n           z=vec3(1.,0.,0.),c=vec3(0.,0.,-1.);\n         else\n            if(m.z>.5)\n             z=vec3(1.,0.,0.),c=vec3(0.,-1.,0.);\n           else\n              if(m.z<-.5)\n               z=vec3(-1.,0.,0.),c=vec3(0.,-1.,0.);\n   r=clamp((n.xy-y.xy)*100000.,vec2(0.),vec2(1.));\n   float o=.15,S=.15;\n   if(f.x==10.||f.x==11.)\n     {\n       if(abs(m.y)<.01&&s||m.y>.99)\n         o=.1,S=.1,x=0.;\n       else\n          x=1.;\n     }\n   if(f.x==51)\n     o=.5,S=.1;\n   if(f.x==76)\n     o=.2,S=.2;\n   if(f.x-255.+39.>=103.&&f.x-255.+39.<=113.)\n     S=.025,o=.025;\n   z=normalize(i.xyz);\n   c=normalize(cross(z,m.xyz)*sign(i.w));\n   vec3 e=v.xyz+mix(z*o,-z*o,vec3(r.x));\n   e.xyz+=mix(c*o,-c*o,vec3(r.y));\n   e.xyz-=m.xyz*S;\n   return e;\n }\n复制代码\n\nm.xyz该顶点所在面的法线向量朝向。x则决定是否赋予方块ID，0为赋予，1为忽略。m.xyz正负值对应的方向暂未测试。\n\n而o和S则是一些辅助参数，用于改变最终是否赋予方块ID的判断。o的用途暂时未知（只知道能影响岩浆的判断），但是S的用途似乎已知（知道一部分，但是不完全清楚具体如何工作）。\n\n对于大部分不正常工作的方块（例如没有遮光体积，或者光源不发光），可以直接通过赋值x=0解决。例如末地烛：\nif(f.x==198.)\n  i=0.;\n复制代码\n对于大部分会“同化”周边方块ID的方块而言，它们似乎都有一个特点：如果有距离方块空间边缘很近（小于S）但是方向相反的面（例如朝向北的面接近方块空间的南边），则会同化所邻近的方块。对于大部分这种类型的方块来说，设置 S=.025 通常可以解决问题。不过对于一些特殊的方块，例如火，则需要将S设置的非常小（例如直接设为0）才能解决“同化”周围方块ID的问题。\n\n同时，S设置的过小（例如 1e-10，即1乘以10的-10次方）会由于渲染器精度问题无法体现出与0的差距。建议使用比1e-5更高的值。\n\n我本人的修改如下：\n（由于直接复制了HRR Test2中的修改部分，并且删除了部分无用参数/计算式，代码和上方原函数不一致）\n（由于修改/合并/添加了部分数字ID，以下的部分方块ID在修改原版PTGI时不具备参考价值）\n\nvec3 d(vec3 v,vec3 m,vec2 x,vec2 y,vec4 n,vec4 f,inout float i,out vec2 s)\n {\n   bool r=abs(fract(v.x*2.)-0.5)<.49||abs(fract(v.y*2.)-0.5)<.49||abs(fract(v.z*2.)-0.5)<.49;\n   if(f.x<1.||r||min(abs(m.x),abs(m.z))>.2)\n     i=1.;\n   if(f.x==50.||f.x==52.||f.x==76.||abs(f.x-190.5)<2.)\n     {\n       i=0.;\n       if(m.y<.5)\n         i=1.;\n     }\n   if(f.x==51||f.x==53||f.x==198.||f.x>255.)\n     {\n       i=0.;\n       if(f.x==320.)\n         i=1.;\n     }\n   s=clamp((x.xy-y.xy)*100000.,vec2(0.),vec2(1.));\n   float G=0.025,e=.025;\n   if(f.x==18.||f.x==138.)\n     G=.5,e=0.0001;\n   if(abs(f.x-424.5)<1.)\n     e=0.0001;\n   if(f.x==10.||f.x==11.)\n     {\n       G=.025,e=0.,i=0.;\n       if(abs(m.x)<.5&&abs(m.z)<.5)\n         {\n           e=.025;\n           if(m.x<0.&&m.z<0.)\n             G=-.025;\n         }\n     }\n   if(f.x==51||f.x==53)\n     G=.5,e=0.;\n   vec3 z=normalize(n.xyz);\n   vec3 a=normalize(cross(z,m.xyz)*sign(n.w));\n   vec3 l=v.xyz+(mix(1.,-1.,s.x)*z+mix(1.,-1.,s.y)*a)*G-m.xyz*e;\n   return l;\n }\n复制代码\n\n我的大体修改思路：\n对于非完整方块（末地烛、酿造台等），先和火把一块处理，看下情况；如果不行的话，再对o，S赋值0.025处理。绝大部分情况下对o，S赋值后可以解决。极少数情况（例如岩浆、火等）则进行单独的调试。\n\n上述判断代码并不完善，例如岩浆里正在下落的岩浆中最下方还未接触到方块的一格仍然会同化四周方块，而且在平面流动的岩浆中也有少部分没有被赋予方块ID，不过已经能解决大部分异常情况。如果有更好的判断代码，欢迎各位提出。\n\nUpdate 2020.12.28：岩浆完成修复工作。参见接近代码底部 f.x==10.&&f.x==11. 时的处理部分。\n\n\n\n\n\n\n\n自定义光追遮光体积\n\n====主要修改文件====\n\ncomposite.fsh，deferred.fsh（在PTGI HRR Test中是deferred2）\n\ndeferred.fsh\n（在PTGI HRR Test中是deferred2）\n（定义各个ID的遮光体积，composite的修改与之类似）\n\nSEUS PTGI每个方块的遮光体积都是写死的。在老版本中，PTGI只有完整方块和完全透光两种遮光体积。在比较新的版本中，Sonic Ether在block.properties里为部分特殊形状的方块分配了新的数字ID，并且在composite和deferred（在PTGI HRR Test中是deferred2）中存储了各个数字ID对应的遮光体积。composite中存储的是反射（例如水面反射、染色玻璃反射、PBR材质产生的镜面反射等）中的形状，而deferred（在PTGI HRR Test中是deferred2）中存储的是计算光追光照中的遮光体积形状。两者用于计算的函数相同。\n\n原版遮光体积计算函数如下：\n\nbool d(vec3 v,float y,Ray z,bool x,inout float i,inout vec3 f)\n {\n   bool m=false,r=false;\n   #if RAYTRACE_GEOMETRY_QUALITY==0\n   if(x)\n     return false;\n   if(y>=67.)\n     return false;\n   r=d(v,v+vec3(1.,1.,1.),z,i,f);\n   m=r;\n   #else\n   if(y<40.)\n     return r=d(v,v+vec3(1.,1.,1.),z,i,f),r;\n   if(y==40.||y==41.||y>=43.&&y<=54.)\n     {\n       float t=.5;\n       if(y==41.)\n         t=.9375;\n       r=d(v+vec3(0.,0.,0.),v+vec3(1.,t,1.),z,i,f);\n       m=m||r;\n     }\n   if(y==42.||y>=55.&&y<=66.)\n     r=d(v+vec3(0.,.5,0.),v+vec3(1.,1.,1.),z,i,f),m=m||r;\n   if(y==43.||y==46.||y==47.||y==52.||y==53.||y==54.||y==55.||y==58.||y==59.||y==64.||y==65.||y==66.)\n     {\n       float t=.5;\n       if(y==55.||y==58.||y==59.||y==64.||y==65.||y==66.)\n         t=0.;\n       r=d(v+vec3(0.,t,0.),v+vec3(.5,.5+t,.5),z,i,f);\n       m=m||r;\n     }\n   if(y==43.||y==45.||y==48.||y==51.||y==53.||y==54.||y==55.||y==57.||y==60.||y==63.||y==65.||y==66.)\n     {\n       float t=.5;\n       if(y==55.||y==57.||y==60.||y==63.||y==65.||y==66.)\n         t=0.;\n       r=d(v+vec3(.5,t,0.),v+vec3(1.,.5+t,.5),z,i,f);\n       m=m||r;\n     }\n   if(y==44.||y==45.||y==49.||y==51.||y==52.||y==54.||y==56.||y==57.||y==61.||y==63.||y==64.||y==66.)\n     {\n       float t=.5;\n       if(y==56.||y==57.||y==61.||y==63.||y==64.||y==66.)\n         t=0.;\n       r=d(v+vec3(.5,t,.5),v+vec3(1.,.5+t,1.),z,i,f);\n       m=m||r;\n     }\n   if(y==44.||y==46.||y==50.||y==51.||y==52.||y==53.||y==56.||y==58.||y==62.||y==63.||y==64.||y==65.)\n     {\n       float t=.5;\n       if(y==56.||y==58.||y==62.||y==63.||y==64.||y==65.)\n         t=0.;\n       r=d(v+vec3(0.,t,.5),v+vec3(.5,.5+t,1.),z,i,f);\n       m=m||r;\n     }\n   if(y>=67.&&y<=82.)\n     r=d(v+vec3(6.,0.,6.)/16.,v+vec3(10.,16.,10.)/16.,z,i,f),m=m||r;\n   if(y==68.||y==69.||y==70.||y==72.||y==73.||y==74.||y==76.||y==77.||y==78.||y==80.||y==81.||y==82.)\n     {\n       float t=8.,c=8.;\n       if(y==68.||y==70.||y==72.||y==74.||y==76.||y==78.||y==80.||y==82.)\n         t=0.;\n       if(y==69.||y==70.||y==73.||y==74.||y==77.||y==78.||y==81.||y==82.)\n         c=16.;\n       r=d(v+vec3(t,6.,7.)/16.,v+vec3(c,9.,9.)/16.,z,i,f);\n       m=m||r;\n       r=d(v+vec3(t,12.,7.)/16.,v+vec3(c,15.,9.)/16.,z,i,f);\n       m=m||r;\n     }\n   if(y>=71.&&y<=82.)\n     {\n       float t=8.,w=8.;\n       if(y>=71.&&y<=74.||y>=79.&&y<=82.)\n         w=16.;\n       if(y>=75.&&y<=82.)\n         t=0.;\n       r=d(v+vec3(7.,6.,t)/16.,v+vec3(9.,9.,w)/16.,z,i,f);\n       m=m||r;\n       r=d(v+vec3(7.,12.,t)/16.,v+vec3(9.,15.,w)/16.,z,i,f);\n       m=m||r;\n     }\n   #if RAYTRACE_GEOMETRY_QUALITY==2\n   if(y>=83.&&y<=86.)\n     {\n       vec3 t=vec3(0),c=vec3(0);\n       if(y==83.)\n         t=vec3(0,0,0),c=vec3(16,16,3);\n       if(y==84.)\n         t=vec3(0,0,13),c=vec3(16,16,16);\n       if(y==86.)\n         t=vec3(0,0,0),c=vec3(3,16,16);\n       if(y==85.)\n         t=vec3(13,0,0),c=vec3(16,16,16);\n       r=d(v+t/16.,v+c/16.,z,i,f);\n       m=m||r;\n     }\n   if(y>=87.&&y<=102.)\n     {\n       vec3 t=vec3(0.),c=vec3(1.);\n       if(y>=87.&&y<=94.)\n         {\n           float w=0.;\n           if(y>=91.&&y<=94.)\n             w=13.;\n           t=vec3(0.,w,0.)/16.;\n           c=vec3(16.,w+3.,16.)/16.;\n         }\n       if(y>=95.&&y<=98.)\n         {\n           float w=13.;\n           if(y==97.||y==98.)\n             w=0.;\n           t=vec3(0.,0.,w)/16.;\n           c=vec3(16.,16.,w+3.)/16.;\n         }\n       if(y>=99.&&y<=102.)\n         {\n           float s=13.;\n           if(y==99.||y==100.)\n             s=0.;\n           t=vec3(s,0.,0.)/16.;\n           c=vec3(s+3.,16.,16.)/16.;\n         }\n       r=d(v+t,v+c,z,i,f);\n       m=m||r;\n     }\n   if(y>=103.&&y<=113.)\n     {\n       vec3 t=vec3(0.),n=vec3(1.);\n       if(y>=103.&&y<=110.)\n         {\n           float s=float(y)-float(103.)+1.;\n           n.y=s*2./16.;\n         }\n       if(y==111.)\n         n.y=.0625;\n       if(y==112.)\n         t=vec3(1.,0.,1.)/16.,n=vec3(15.,1.,15.)/16.;\n       if(y==113.)\n         t=vec3(1.,0.,1.)/16.,n=vec3(15.,.5,15.)/16.;\n       r=d(v+t,v+n,z,i,f);\n       m=m||r;\n     }\n   #endif\n   #endif\n   return m;\n }\n复制代码\n\n很容易的可以看出y对应的是数字ID。y与block.properties里定义的数字ID的关系在shadow.vsh里被定义：\nif(mc_Entity.x>255)\n  vMaterialIDs=mc_Entity.x-255.+39.;\n复制代码\n也就是说block.properties里的数字ID减去255再加上39就是遮光体积函数中的y。\n\n从该函数中可以轻易推断出添加自定义遮光体积的通用代码块：\nif(y在某一区间)\n  {\n    vec3 起点1;\n    vec3 终点1;\n    r=d(v+起点1,v+终点1,z,i,f);\n    m=m||r;\n    vec3 起点2;\n    vec3 终点2;\n    r=d(v+起点2,v+终点2,z,i,f);\n    m=m||r;\n    ......\n    return m;   //这段return代码为我自己添加，若此数字ID没有需要继续处理的部分，此处直接return可以避免在下方持续判断if，提升性能。\n  }\n复制代码\n起点和终点的xyz就对应着每一小块遮光体积的xyz，每一个方块的遮光体积可以由多个小块组成，xyz的取值范围均为0-1。对于Minecraft Java版方块模型有了解的读者应该能轻松掌握这一部分，只需要将Java版模型每个元素的xyz数据除以16就可以直接代入。\n\n例如末地传送门框架的起点为 vec3(0.,0.,0.) ，终点为 vec3(1.,13./16.,1.)；如果再加上安放的末影之眼的话，再以起点为 vec3(4.,13.,4.)/16. ，终点为 vec3(12.,16.,12.)/16. 的计算。带末影之眼的末地传送门的代码如下：\n（由于直接复制的PTGI E12的修改部分，部分变量和函数名称有变）\nif(y==140.)\n  {\n    vec3 r=vec3(0.),s=vec3(1.);\n    r=vec3(0.,0.,0.)/16.,s=vec3(16.,13.,16.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    r=vec3(4.,13.,4.)/16.,s=vec3(12.,16.,12.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    return i;\n  }\n复制代码\n修改后在游戏内重载光影即可看见遮光体积的变化。\n\n如果要使反射中也出现对应的形状，则需要在composite.fsh中也进行类似的修改。由于二者的几何体计算函数相同，可以在deferred（在PTGI HRR Test中是deferred2）内修改完成后直接将整个函数复制到composite，并修改函数名称为原composite中的函数名。如果不在意反射中不会出现部分方块，可以不修改composite以节省性能。\n\n由于PTGI的自定义几何体只会加载一张贴图，所以反射中部分方块的颜色会与正常情况下有很大的不同，例如许多方块的六面都是侧面的贴图（草方块、熔炉等）。可以通过加载一个将数张小贴图合并为一张大贴图（即每个方块只使用一张材质）的材质包来解决，但是这个材质包所有的材质分辨率必须一致。\n\n在添加各个自定义几何体时，类似的几何体尽量先以一个if判断，然后再在此if内判断各个数字ID并进行分别的处理。例如各个方向的铁砧：\nif(y>=108.&&y<=109.)\n  {\n    vec3 r=vec3(0.),s=vec3(1.);\n    r=vec3(2.,0.,2.)/16.,s=vec3(14.,4.,14.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    if(y==108.)\n      {\n        r=vec3(4.,4.,3.)/16.,s=vec3(12.,5.,13.)/16.;\n        m=d(v+r,v+s,f,x,t);\n        i=i||m;\n        r=vec3(6.,5.,4.)/16.,s=vec3(10.,10.,12.)/16.;\n        m=d(v+r,v+s,f,x,t);\n        i=i||m;\n        r=vec3(3.,10.,0.)/16.,s=vec3(13.,16,16.)/16.;\n        m=d(v+r,v+s,f,x,t);\n        i=i||m;\n        return i;\n      }\n    r=vec3(3.,4.,4.)/16.,s=vec3(13.,5.,12.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    r=vec3(4.,5.,6.)/16.,s=vec3(12.,10.,10.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    r=vec3(0.,10.,3.)/16.,s=vec3(16.,16,13.)/16.;\n    m=d(v+r,v+s,f,x,t);\n    i=i||m;\n    return i;\n  }\n复制代码\n这种写法通常情况下比起在 y==108. 和 y==109. 时各写一个if能节省一些性能，除非世界中存在着巨量的铁砧。\n\n\n\n\n\n\n\n水雾相关项修正\n\n====岩浆内“水雾”修正====\n\n主要修改文件：lib/Common.inc\n\nPTGI内的水雾写在 composite4.fsh 中，但是我们不需要修改 composite4 ，因为其计算水雾时直接引用了 lib/Common.inc 内的 void UnderwaterFog 函数。我们只需要修改 UnderwaterFog 函数即可。\n\n前置知识：在Optifine的shader文档中，使用 isEyeInWater 判断摄像机（即玩家的眼睛）是否在水或者岩浆中。数值为0表示正常情况，1表示在水中，2表示在岩浆中。由于PTGI的 UnderwaterFog 函数只考虑 isEyeInWater > 0 的情况，所以水中和岩浆中被统一处理。\n\nUnderwaterFog 函数及其引用的函数完整如下：（已删除注释掉的部分）\n\nvec3 GetWaterAbsorption()\n{\n    vec3 a = vec3(0.25, 0.04, 0.01);\n    return a;\n}\n\nvoid UnderwaterFog(inout vec3 color, float eyeLength, vec3 eyeDir, vec3 skyColor, vec3 sunColor)\n{\n    float underwaterDepth = 1.0 - (eyeBrightnessSmooth.y / 240.0);\n\n    float x = eyeLength;\n    vec3 wAK = GetWaterAbsorption();\n    float fD = WaterM;\n    vec3 wFA = vec3(0.15);\n    float eWD = underwaterDepth;\n    float v = eyeDir.y;\n\n    color *= exp(-wAK*x - fD*x);\n\n    vec3 w = -((fD*wFA)/(exp(eWD*(fD + wAK))*((-1.0 + v)*(fD + wAK)))) + \n    (fD*wFA)/(exp((fD + wAK)*(eWD + x - v*x))*((-1.0 + v)*(fD + wAK)));\n\n    if (isEyeInWater == 0) {\n        w *= eyeBrightnessSmooth.y / 240.0;\n    }\n\n    color += max(vec3(0.0), w * (sunColor * 0.5 * (1.0 - wetness * 0.75) + skyColor * 0.25 * (1.0 - wetness * 0.5)));\n}\n复制代码\n\n其中 GetWaterAbsorption() 函数返回的是水对光线的吸收，返回值为 vec3(0.25, 0.04, 0.01) 即大幅吸收红光，小幅吸收绿光，几乎不吸收蓝光。\n\n为了适应岩浆中的情况，我们可以创建一个 GetLavaAbsorption() 函数，在 isEyeInWater > 1 的时候调用。我个人的 GetLavaAbsorption() 函数返回值为 vec3(0.0, 0.05, 0.2) ，各位读者可以自行调整。\n\n这样在原 UnderwaterFog 函数中，可以在wAK被赋予 GetWaterAbsorption() 的返回值后加上一行代码：\nif(isEyeInWater>1)\n    wAK = GetLavaAbsorption();\n复制代码\nGetWaterAbsorption() 和我们新加的 GetLavaAbsorption() 处理的是方块的表面的渲染。这时候岩浆顶面的贴图已经会在远处变为橙红色了，但是水下的“雾气”依然是蓝色的。这是由于参与“雾气”的颜色判断的是函数的输入值 skyColor 和 sunColor 。由于岩浆内显然不会受到阳光和天空的影响，也不会受到 wetness 的影响，可以将最后的一行\ncolor += max(vec3(0.0), w * (sunColor * 0.5 * (1.0 - wetness * 0.75) + skyColor * 0.25 * (1.0 - wetness * 0.5)));复制代码\n修改为:\nif (isEyeInWater > 1)\n    color += max(vec3(0.0), w * vec3(R, G, B));\nelse\n    color += max(vec3(0.0), w * (sunColor * 0.5 * (1.0 - wetness * 0.75) + skyColor * 0.25 * (1.0 - wetness * 0.5)));\n复制代码\n上述 vec3(R, G, B) 为自定义的岩浆内雾气的颜色。我个人的设置为 vec3(1.,.08,0.) ，各位读者可以自行调整。\n\n同时，由于岩浆内的能见度明显会比水里低得多，因此我们还需要调整岩浆雾的浓度。\n\n易知（直觉就完事了）函数 UnderwaterFog 的输入值 float eyeLength 就是屏幕上每个像素点对应的位置到摄像机位置的距离，因此将这个数值乘以一定的倍率，就可以通过让较近的物体在计算上更远来达到拉低能见度的效果。\n\n由于 UnderwaterFog 函数中，eyeLength 被赋值给了x，然后整个函数中都是采用的x计算，因此可以稍微修改上述添加的第一段内容，修改为：\nif(isEyeInWater>1){\n    wAK = GetLavaAbsorption();\n    x *= 3.;\n}\n复制代码\nx *= 3.可以改为其他的数字以提高/降低能见度。\n\n修改完成后，岩浆内的效果即可相对正常。\n\n====透过染色玻璃的水雾渲染====\n\n主要修改文件：composite.fsh\n\nPTGI中水雾在composite4.fsh中渲染，透过染色玻璃的渲染在composite.fsh中完成，而透过染色玻璃的渲染使用的是deferred12的输出。因此在原版PTGI中透过染色玻璃观察时水雾会消失不见。\n\n只需要修改composite.fsh中的main函数下部：\n\nif(s.stainedGlass>.5)\n {\n   vec3 K=normalize(y.albedo.xyz+.0001)*pow(length(y.albedo.xyz),.5);\n   M.xyz*=mix(vec3(1.),K,vec3(pow(y.albedo.w,.2)));\n   M.xyz*=mix(vec3(1.),K,vec3(pow(y.albedo.w,.2)));\n }\n复制代码\n这一段处理了透过染色玻璃的渲染。\n\n仿照染色玻璃处理上方的水处理中对UnderwaterFog的引用，在这段代码中加入一段水雾渲染：\n\nif(s.stainedGlass>.5)\n {\n   vec3 K=normalize(y.albedo.xyz+.0001)*pow(length(y.albedo.xyz),.5);\n   if(isEyeInWater>0)\n     UnderwaterFog(M.xyz,H,r,colorSkyUp,colorSunlight);\n   M.xyz*=mix(vec3(1.),K,vec3(pow(y.albedo.w,.2)));\n   M.xyz*=mix(vec3(1.),K,vec3(pow(y.albedo.w,.2)));\n }\n复制代码\n即可在透过染色玻璃观察时正常渲染水雾。不过水下体积光仍然不会正常渲染，目前暂无解决方案。\n\n\n\n\n\n\n\n矿车上遮光体积位置错误修正\n\n====主要修改文件====\n\nshadow.vsh\n\n经过反复的实验后，我个人认为坐在矿车上时的遮光体积位置偏移是由于shadow.vsh内定位精度问题造成的。\n\n进一步测试后，发现触发扳机为x轴或者z轴坐标的小数部分为0.5000时触发，坐标在256以下时只是偶尔闪现，256以上时，上下矿车后若不移动，效果会常驻。\n\n修改的代码块在shadow.vsh的main函数偏底部，内容如下：\n\ntrJAJcpymT=0.;\n{\n vec2 f;\n vec3 r=d(v.xyz,gl_Normal.xyz,vTexcoord.xy,mc_midTexCoord.xy,at_tangent,mc_Entity,trJAJcpymT,f);\n if(mc_Entity.x>255)\n   vMaterialIDs=mc_Entity.x-255.+39.;\n r=floor(r);\n r-=cameraPosition.xyz;\n int c=t();\n r=n(r,c);\n lJXEyGgdno=G(r,f,RqJoQHZCrm,trJAJcpymT);\n if(mc_Entity.x==51||mc_Entity.x==50||mc_Entity.x==76)\n   RqJoQHZCrm+=.9;\n}\n复制代码\n这段代码的用途就是判断当前渲染位置的方块ID，其中引用的部分函数在前面的章节有提到。\n\n我个人的修复如下：\n\ntrJAJcpymT=0.;\n{\n vec2 f;\n vec3 r=d(v.xyz,gl_Normal.xyz,vTexcoord.xy,mc_midTexCoord.xy,at_tangent,mc_Entity,trJAJcpymT,f);\n if(mc_Entity.x>255)\n   vMaterialIDs=mc_Entity.x-255.+39.;\n r=floor(r);\n r-=cameraPosition.xyz;\n int c=t();\n\n /***** Minecart Fix Start *****/\n if(abs(cameraPosition.x)>256)\n   r.x-=0.00005;\n if(abs(cameraPosition.z)>256)\n   r.z-=0.00005;\n /****** Minecart Fix End ******/\n\n r=n(r,c);\n lJXEyGgdno=G(r,f,RqJoQHZCrm,trJAJcpymT);\n if(mc_Entity.x==51||mc_Entity.x==50||mc_Entity.x==76)\n   RqJoQHZCrm+=.9;\n}\n复制代码\n在 1.16.3 的 Optifine G4 Pre1 与 1.12.2 的 Optifine F6 Pre1 下测试的结果是大部分情况下不会再出现遮光体积偏移的情况，不过错位现象依然会偶尔一闪而过，在PTGI HRR Test的TAA降噪下并不太明显，基本可视为一切正常。\n\n\n\n\n\n\n\n\n水下水面反射折射平滑处理\n\n====主要修改文件====\n\ncomposite.fsh\n\n众所周知，当玩家位于水下时，PTGI会给水面渲染反射和折射，并且以一种极为突兀的边界将反射与折射隔离开来。\n混合算法如下：（位于文件偏底部的 main 函数中）\n\nif(d.water>.5&&isEyeInWater>0)\n  {\n    if(length(refract(q,V,1.3333))<.5)\n      T=1.;\n    else\n      T=0.;\n  }\n复制代码\nT 为渲染中反射的占比，q 为当前屏幕像素对应位置相对玩家的方向，V 为水面的法向量。\nrefract为GLSL中的折射算法，输入入射光、交界面法向量与折射率，输出折射向量，length为GLSL中求取向量长度的算法。\n\n而在现实生活中，反射与折射并不会有如此突兀的边缘。在全反射的边界以外，反射与折射是逐渐混合的。\n\n经过我的多次测试，单纯修改 length(refract(q,V,1.3333))<.5 中的.5的数值，除非调至1.或者0.之类的极端值，否则并不会产生多大的影响，因此我们需要另辟蹊径。\n\n在这里我将使用我的想法进行讲解。\n\nq 和 V 已经预先进行了标准化（长度为1），因此我们可以获取一个标准化的折射向量，再通过计算折射向量与法向量之间的角度，判断折射与反射的混合比例。\n\n我的算法如下：\n\nif(d.water>.5&&eyeInWater)\n  {\n    vec3 refractDirection=normalize(refract(q,V,1.3333));\n    float angle=dot(refractDirection,-V);\n    T=1.;\n    if(angle<=1.)\n      T-=UNDERWATER_REFLECTION_STRENGTH*pow(angle,2.);\n  }\n复制代码\nnormalize 为GLSL中标准化向量的预置函数。dot 为计算向量点积的函数。UNDERWATER_REFLECTION_STRENGTH 为我自己设置的比例，调高数值可以降低靠近头顶的部分的反射强度。UNDERWATER_REFLECTION_STRENGTH 应至少设置为1。\n\n在我的算法中，默认反射强度为1。当折射开始时，折射强度为 1 减去 折射向量与法向量的角度的cos值的平方。这样折射开始时可以与全反射部分形成平滑过渡，同时在头顶附近反射强度归零。\n\n这样就实现了在全反射界面边缘的反射与折射混合。\n\n对比图：（由于用于对比的为已经经过我较多魔改的PTGI，除去折射与反射的混合外无参考价值）\n\n原版PTGI：\n\n\n\n\nfile_1603592073000.jpg (103.44 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-25 10:14 上传\n\n\n\n\n\n\nUNDERWATER_REFLECTION_STRENGTH 设置为 2.0 ：\n\n\n\n\nfile_1603592095000.jpg (128.76 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-25 10:14 上传\n\n\n\n\n\n\nUNDERWATER_REFLECTION_STRENGTH 设置为 1.0 ：\n\n\n\n\nfile_1603592095000.jpg (119.85 KB, 下载次数: 0)\n\n下载附件\n\n2020-10-25 10:14 上传\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "loverocean",
            "timestamp": 1578483420,
            "txt_content": "这个我试了一下，成功的添加了mod的灯具发光，添加的是火把类型，但是问题就是，同样是加在火把那边。在block.properties里面的id 50后面直接加，如下\nblock.50=minecraft:torch quark:candle chinjufumod:lit_andon\n但是在游戏里面，火把能照亮好几个方块，我添加的chinjufumod:lit_andon，就只能照亮一个小圈圈。\n就算我新建一个blockid，照亮范围也不如火把，这是为什么？"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1578485460,
            "txt_content": "loverocean 发表于 2020-1-8 19:37\n这个我试了一下，成功的添加了mod的灯具发光，添加的是火把类型，但是问题就是，同样是加在火把那边。在blo ...\n即使直接在block.properties的方块ID50后面加也不可以么？Minecraft版本多少？"
        },
        {
            "author": "loverocean",
            "timestamp": 1578487440,
            "txt_content": "GeForceLegend 发表于 2020-1-8 20:11\n即使直接在block.properties的方块ID50后面加也不可以么？Minecraft版本多少？\n是的，block.properties的方块ID50后面加，光源效果也没有火把本身好，版本是1.12.2。\n是不是其他方块对火把这个物品光源的反射也做了适配啊。\n我目前用的渣笔记本测试，mx250的显卡，等我回去换2080ti也测试一下。"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1578494100,
            "txt_content": "loverocean 发表于 2020-1-8 20:44\n是的，block.properties的方块ID50后面加，光源效果也没有火把本身好，版本是1.12.2。\n是不是其他方块对 ...\nblock.properties的1.12兼容貌似挺多bug的，我按照1.14修改以兼容1.12，弯曲的楼梯的遮光体积无论怎么搞都是和直型的一样，1.13部分的修改就没这个问题"
        },
        {
            "author": "去玩儿剖",
            "timestamp": 1581424200,
            "txt_content": "PTGI使用了代码混淆，想要改怕是有点麻烦，不过我记得Tahnass修改过E10（B站有他关于E10的视频，其中特别强烈的体积光就是他的杰作），他可能已经搞好了反混淆吧，有时间我去问问他"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1581424920,
            "txt_content": "去玩儿剖 发表于 2020-2-11 20:30\nPTGI使用了代码混淆，想要改怕是有点麻烦，不过我记得Tahnass修改过E10（B站有他关于E10的视频，其中特别强 ...\n我这个只涉及光追光源的添加与修改，由于方块ID是不会给你混淆的，我修改的部分不需要反混淆"
        },
        {
            "author": "pspupsp",
            "timestamp": 1581439260,
            "txt_content": "楼主在这么乱的代码里能搞出这个，厉害！"
        },
        {
            "author": "帅帅的小石",
            "timestamp": 1582862040,
            "txt_content": "diferred.fsh\n这个应该是deferred.fsh吧，您是不是打错了（不好意思我不会引用）"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1582862700,
            "txt_content": "帅帅的小石 发表于 2020-2-28 11:54\ndiferred.fsh\n这个应该是deferred.fsh吧，您是不是打错了（不好意思我不会引用） ...\n好像是的，感谢指正"
        },
        {
            "author": "帅帅的小石",
            "timestamp": 1582882980,
            "txt_content": "能不能写个信标的"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1582884120,
            "txt_content": "帅帅的小石 发表于 2020-2-28 17:43\n能不能写个信标的\n信标的数字ID在原版的block.properties里面就有，138"
        },
        {
            "author": "帅帅的小石",
            "timestamp": 1582893840,
            "txt_content": "GeForceLegend 发表于 2020-2-28 18:02\n信标的数字ID在原版的block.properties里面就有，138\n光源类型怎么定义？"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1582894560,
            "txt_content": "帅帅的小石 发表于 2020-2-28 20:44\n光源类型怎么定义？\nshadow.vsh里面（你应该仔细看看再来问的）"
        },
        {
            "author": "huaji5126",
            "timestamp": 1582895880,
            "txt_content": "        MCBBS有你更精彩~"
        },
        {
            "author": "Bistard",
            "timestamp": 1597770660,
            "txt_content": " 本帖最后由 Bistard 于 2020-8-19 01:13 编辑 \n\nC:\\Users\\22326\\Desktop请问按照文中方法修改之后末地烛只会自己亮而不会产生光线的是哪里出了问题？\n\n\n\n\n\n\nQQ图片20200819011048.jpg\n(69.12 KB, 下载次数: 1)\n\n\n\n\n下载附件\n\n\n2020-8-19 01:12 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1597799040,
            "txt_content": "Bistard 发表于 2020-8-19 01:11\n请问按照文中方法修改之后末地烛只会自己亮而不会产生光线的是哪里出了问题？ ...本文件中可能需要修改一个之前两个文件都有但是忽略掉的地方：\n（SEUS PTGI E11原版文件第178行）\nif(f.x==50.||f.x==76.)\n    {\n        i=0.;\n            if(m.y<.5)\n                i=1.;\n    }\nSEUS PTGI的方块类光源在使用了部分自定义模型的情况下，以及极少数火把类光源（其它类型光源未知），即使在其他地方都做了对应修改，在游戏内也只有贴图发光并没有实际影响到路径追踪的环境光，这种情况下在此处进行修改：添加不发光的光源对应的数字ID在绝大多数情况下可以解决问题。末影箱、潮涌核心等实体无论如何修改也无法发光。\nshadow.vsh中修改这一部分\n"
        },
        {
            "author": "彬胖胖",
            "timestamp": 1597801140,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "晨鸢",
            "timestamp": 1597832820,
            "txt_content": "666666666666666666666666666666666666666666666666666666666666666666666666666"
        },
        {
            "author": "帅帅的小石",
            "timestamp": 1601893020,
            "txt_content": "如果想要实现像基岩版光追那样的混凝土方块发光能做到吗"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1601894700,
            "txt_content": "帅帅的小石 发表于 2020-10-5 18:17\n如果想要实现像基岩版光追那样的混凝土方块发光能做到吗\n在block.properties里面把混凝土丢到萤石的方块ID下"
        },
        {
            "author": "帅帅的小石",
            "timestamp": 1601895120,
            "txt_content": "GeForceLegend 发表于 2020-10-5 18:45\n在block.properties里面把混凝土丢到萤石的方块ID下\n可以实现不同颜色吗"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1601895240,
            "txt_content": "帅帅的小石 发表于 2020-10-5 18:52\n可以实现不同颜色吗\n萤石、海晶灯、红石灯等的ID在shadow.vsh里面被统一为31输出，它们的发光颜色取决于贴图本身的颜色"
        },
        {
            "author": "675101028",
            "timestamp": 1606532040,
            "txt_content": "好想修改啊 可惜看不懂啊"
        },
        {
            "author": "恶人棂",
            "timestamp": 1606712580,
            "txt_content": "E12中 下雨时看不见雨滴下落的效果 有没有什么办法能解决？"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1606713720,
            "txt_content": "恶人棂 发表于 2020-11-30 13:03\nE12中 下雨时看不见雨滴下落的效果 有没有什么办法能解决？\nSE特意设置了不渲染天气，就算强制渲染，在1.16下也和粒子一样只有在一些奇怪的角度下才看得到，而1.14下只会在背后有方块时渲染。\n\n你要强制渲染的话可以这么改：（这是我的改法，可能有更好的方案）\n\ngbuffers_weather.vsh：\n#version 330 compatibility\n\nout vec4 color;\nout vec4 texcoord;\nout vec4 preDownscaleProjPos;\n\n#include \"lib/Uniforms.inc\"\n#include \"lib/Common.inc\"\n\nvoid main() {\n\n        color = gl_Color;\n\n        texcoord = gl_MultiTexCoord0;\n\n        vec4 localWorldPos = gbufferModelViewInverse * gl_ModelViewMatrix * gl_Vertex;\n\n        gl_Position = gl_ProjectionMatrix * gbufferModelView * localWorldPos;\n\n        FinalVertexTransformTAA(gl_Position, preDownscaleProjPos);\n\n}\n复制代码\ngbuffers_weather.fsh：\n#version 330 compatibility\n\nin vec4 color;\nin vec4 texcoord;\nin vec4 preDownscaleProjPos;\n\n#include \"lib/Uniforms.inc\"\n#include \"lib/Common.inc\"\n\nvoid main() \n{        \n        if (PixelOutOfScreenBounds(preDownscaleProjPos)) {\n                discard;\n                return;\n        }\n\n        vec4 albedo = texture2D(texture, texcoord.st, 0);\n        albedo *= color;\n\n        gl_FragData[0] = albedo;\n        gl_FragData[1] = vec4(0.0);\n        gl_FragData[2] = vec4(0.0);\n\n}\n\n/* DRAWBUFFERS:012 */\n复制代码\n\n"
        },
        {
            "author": "恶人棂",
            "timestamp": 1606728300,
            "txt_content": "GeForceLegend 发表于 2020-11-30 13:22\nSE特意设置了不渲染天气，就算强制渲染，在1.16下也和粒子一样只有在一些奇怪的角度下才看得到，而1.14下 ...\n感谢大佬提供的方法，虽然效果并不理想\n"
        },
        {
            "author": "GeForceLegend",
            "timestamp": 1606728360,
            "txt_content": "恶人棂 发表于 2020-11-30 17:25\n感谢大佬提供的方法，虽然效果并不理想\n是的，只有在背后有方块的时候才会渲染，我也不知道是怎么回事（悲）"
        },
        {
            "author": "1587898",
            "timestamp": 1611126420,
            "txt_content": "多多少少有点6在里面"
        },
        {
            "author": "冰封yhn蓝色",
            "timestamp": 1611546780,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽\n"
        }
    ]
}