{
    "title": "Minecraft Forge 1.9实现的自定义BOSS血条",
    "author": "52Dora",
    "replyCount": 1,
    "timestamp": 1459784160,
    "txt_content": "联动：https://dorajdj.github.io/custom-bossbar-in-minecraft-1-9.html\n\n实际上这个post早在上周就发到本人的GitHub Pages里了，今天才搬到MCBBS里(:3JZ若有错误欢迎指正\n\n虽然这篇文章看起来有点类似于教程一样的东西，但实际上我觉得这篇文章比较重理论，所以选了开发讨论的分类，版主若有疑问可以提出\n\n若要搬运请注明出处，谢谢茄子（不过自己研究出来的垃圾除了垃圾平台站之外还有谁会去转载？）\n\n诸位，这里是DoraJDJ。\n\n最近Minecraft Forge的1.9版本已经开发到一定程度了，而且之前下界末地的地形BUG也得到修复，本人决定先接触一下1.9的Mod开发。就在随便乱翻源代码的时候，一个类吸引到了我…\n\n昂？什么类吸引到了你？\n\n这个类位于net.minecraft.world里头，一个叫做BossInfo的抽象类，在翻BOSS源代码的时候发现的。\n\n简单翻阅了下这个类以及它的子类，初步判断是用来创建BOSS条的一个神奇的类。\n\n昂？BOSS条？为何这玩意能吸引到你？\n\n据我所知，在1.9之前要弄出自定义的BOSS条，要么写一个BOSS；要么刷出一个无AI，带有自定义名称的BOSS；要么弄一个插件，用NMS向玩家发包，或者用第三方API弄出一个BOSS条，特别麻烦。\n\n1.9开始，BOSS条允许同时显示多条且互不干扰，虽然只是一个小修改，但这意味着BOSS条相关的代码需要大修大补，于是BossInfo这个类就诞生了。\n\n有了BossInfo这个类，Minecraft就可以更加方便地获取多个BOSS条的信息并渲染到客户端中。当然我们这篇文章主要是说通过这个类实现自定义BOSS条，所以抛开客户端渲染不谈，让我们来看看它的构建方法是什么样的：\n\n// 注释是编者后加上去的，以便了解\npublic BossInfo(UUID uniqueIdIn, ITextComponent nameIn, BossInfo.Color colorIn, BossInfo.Overlay overlayIn)\n{\n    this.uniqueId = uniqueIdIn; // 定义这个BOSS条的UUID，方便辨认\n    this.name = nameIn; // 定义这个BOSS条的名称（即BOSS名字）\n    this.color = colorIn; // 定义这个BOSS条的颜色\n    this.overlay = overlayIn; // 定义这个BOSS条的样式\n    this.percent = 1.0F; // BOSS条默认百分比为100%（满）\n}复制代码\n看，你可以新建一个BOSS条，而且还可以自定义它的名称、颜色以及样式！正是这种可定制性，成功吸引到了我。\n\n昂？那它有什么用途？\n\n刚才我们也说过了，新版的BossInfo可以自定义BOSS条的名称、颜色以及样式，这意味着制作自定义BOSS条变得更加简单。正是因为这样的可定制性，你可以将它用于：\n\n类似一些服务端插件一样的BOSS条公告系统更加方便地制作属于自己的BOSS，并带上酷炫的血条制作类似定时炸弹一样的倒计时效果或许还有其他用途？\n\n\n昂？听起来很有意思，能告诉我更多的东西吗？\n\n实际上，前面所提到的BossInfo，它实际上是一个抽象类，仅仅是一些基础的东西，并没有实际用途。\n\n你可能会有点失望，因为它根本没什么用。不过既然它是一个抽象类，那么它一定会有跟它相关的子类。那么BossInfo的子类是什么呢？它们是BossInfoLerping和BossInfoServer。\n\n\n// BossInfo的子类\n\n嗯？你说为何会分成两个子类？原因很简单——要是只有一个子类还不如不弄抽象类。\n\n咳咳，严肃点说吧，这两个子类是差不多的，区别只是这玩意是在客户端还是在服务器中使用罢了。\n\n首先我们看看BossInfoLerping的一些源码：\n\n// 注释是编者后加上去的，以便了解\n@SideOnly(Side.CLIENT) // FML特有的SideOnly Annotation，以便区别某些东西是仅在客户端还是仅在服务端可用。在这里标记的是仅限客户端。\npublic class BossInfoLerping extends BossInfo\n{复制代码// 注释是编者后加上去的，以便了解\npublic BossInfoLerping(SPacketUpdateEntityNBT packetIn) // 看它的构造方法，可见这个子类是处理客户端接收服务器的数据包的。\n{复制代码\n通过以上这些代码，我们可以了解到BossInfoLerping这个子类的主要信息：\n\n它仅在客户端内可用它主要处理来自服务端的BOSS条数据包\n\n\n也就是说，若你要制作一个自定义BOSS条且数据能够与服务端同步，BossInfoLerping并不是你所需要的。\n\n那再看看BossInfoServer吧，当我们看到这个类名时，第一眼就知道这肯定是运行在服务端的，让我们来看看它的部分代码：\n\n// 注释是编者后加上去的，以便了解\npublic class BossInfoServer extends BossInfo\n{\n    private final Set<EntityPlayerMP> players = Sets.<EntityPlayerMP>newHashSet(); // 定义玩家列表\n    private final Set<EntityPlayerMP> readOnlyPlayers; // 只读版的玩家列表，避免一些愚蠢的Modder强制修改玩家列表自作聪明\n    private boolean visible;复制代码// 注释是编者后加上去的，以便了解\nprivate void sendUpdate(SPacketUpdateEntityNBT.Operation operationIn) // 定义用于向玩家发包的方法\n{\n    if (this.visible) // 检测这个BOSS条是否可见\n    {\n        SPacketUpdateEntityNBT spacketupdateentitynbt = new SPacketUpdateEntityNBT(operationIn, this); // 若BOSS条可见，创建一个数据包\n\n        for (EntityPlayerMP entityplayermp : this.players) // 遍历玩家列表里的玩家\n        {\n            entityplayermp.playerNetServerHandler.sendPacket(spacketupdateentitynbt); // 向玩家发送数据包\n        }\n    }\n}复制代码\n通过以上代码，我们可以了解到BossInfoServer的主要信息：\n\n它可在服务端中使用它可以确认BOSS条的可见性，以及目标玩家它通过向对应玩家发包让对方客户端显示BOSS条\n\n\n当你了解了这两个子类的功能，那么你就可以开始制作属于你自己的BOSS条了…吗？还没。\n\n昂？莫非还有更多的内幕？\n\n不…并不是内幕，只是了解BossInfo的相关重要方法罢了。\n\n在接下来的几个章节里，主要了解BossInfoServer，至于另外一个客户端用的子类请自行研究。\n\n构造方法\n\npublic BossInfoServer(ITextComponent nameIn, BossInfo.Color colorIn, BossInfo.Overlay overlayIn)复制代码\n通过这个构造方法，开发者可以创建一个BOSS条的实例，举个例子：\n\n// 注释是编者后加上去的，以便了解\n// 此代码片段取自net.minecraft.entity.boss.EntityWither\nprivate final BossInfoServer bossInfo = (BossInfoServer)(new BossInfoServer(this.getDisplayName(), BossInfo.Color.PURPLE, BossInfo.Overlay.PROGRESS)).setDarkenSky(true); // 创建一个名字为凋灵，颜色为紫色，样式为默认，自带暗色天空特效的BOSS条复制代码\n该构造方法的参数如下：\n\nnameIn：类型为ITextComponent（即之前的IChatComponent）的对象，定义BOSS条的名称\ncolorIn：类型为BossInfo.Color的枚举值，定义BOSS条的颜色\noverlayIn：类型为BossInfo.Overlay的枚举值，定义BOSS条的样式\n\ngetUniqueId\n\npublic UUID getUniqueId()复制代码\n获取该BOSS条的UUID，基本上没什么大用。\n\ngetName/setName\n\npublic ITextComponent getName()\n\n@SideOnly(Side.CLIENT)\npublic void setName(ITextComponent nameIn)复制代码\n获取或更改BOSS条的名称，很奇怪的是更改名称的方法因为只有BossInfoLerping在用而被标上仅客户端的标记。\n\ngetName的返回值和setName的参数都是一个ITextComponent实例。\n\ngetPercent/setPercent\n\npublic float getPercent()\n\npublic void setPercent(float percentIn)复制代码\n获取或更改BOSS条的百分比，1.0F为100%，0.0F为0%。\n\ngetPercent的返回值和setPercent的参数都是一个单精度浮点数。\n\ngetColor/setColor\n\npublic BossInfo.Color getColor()\n\n@SideOnly(Side.CLIENT)\npublic void setColor(BossInfo.Color colorIn)复制代码\n获取或更改BOSS条的颜色，很奇怪的是更改颜色的方法因为只有BossInfoLerping在用而被标上仅客户端的标记。\n\ngetColor的返回值和setColor的参数都是一个BossInfo.Color枚举值。\n\ngetOverlay/setOverlay\n\npublic BossInfo.Overlay getOverlay()\n\n@SideOnly(Side.CLIENT)\npublic void setOverlay(BossInfo.Overlay overlayIn)复制代码\n获取或更改BOSS条的样式，很奇怪的是（同上）。\n\ngetOverlay的返回值和setOverlay的参数都是一个BossInfo.Overlay枚举值。\n\nshouldDarkenSky/setDarkenSky\n\npublic boolean shouldDarkenSky()\n\npublic BossInfo setDarkenSky(boolean darkenSkyIn)复制代码\n判断或设置是否自带暗色天空效果，就像下图这样。\n\n\n// 暗色天空效果\n\nshouldDarkenSky返回一个布尔值，而setDarkenSky的参数同为布尔值，但返回的是BossInfo实例（兄啊你知道链式吗）。\n\nshouldPlayEndBossMusic/setPlayEndBossMusic\n\npublic boolean shouldPlayEndBossMusic()\n\npublic BossInfo setPlayEndBossMusic(boolean playEndBossMusicIn)复制代码\n判断或设置是否自带特殊背景音乐效果。\n\nshouldPlayEndBossMusic返回一个布尔值，而setPlayEndBossMusic的参数同为布尔值，但返回的是BossInfo实例。\n\nshouldCreateFog/setCreateFog\n\npublic boolean shouldCreateFog()\n\npublic BossInfo setCreateFog(boolean createFogIn)复制代码\n判断或设置是否自带大雾效果，就像下图这样。\n\n\n// 大雾效果\n\nshouldCreateFog返回一个布尔值，而setCreateFog的参数同为布尔值，但返回的是BossInfo实例。\n\n有关于BossInfo.Color\n\n目前BOSS条自带有七种颜色，如下：\n\nPINK：粉色，末影龙的血条颜色BLUE：蓝色RED：红色GREEN：绿色YELLOW：黄色PURPLE：紫色，凋灵的血条颜色WHITE：白色\n\n\n\n// 不同种BOSS条颜色的显示效果\n\n有关于BossInfo.Overlay\n\n目前BOSS条自带有五种样式，如下：\n\nPROGRESS：默认样式，纯进度条NOTCHED_6：将整个进度条分成六等分NOTCHED_10：将整个进度条分成十等分NOTCHED_12：将整个进度条分成十二等分NOTCHED_20：将整个进度条分成二十等分\n\n\n可能以上说明并不详细，读者可以将生存模式下的经验条与BOSS血量条作比较，当然下面这张图也可以作为参考。\n\n\n// 不同种BOSS条样式的显示效果（忘了截20等分的效果了PAP）\n\n好了，听你罗嗦那么多了，是时候开始了\n\n那么，接下来就是案例时间了。接下来我们来制作属于自己的BOSS条吧！\n\n开发环境\n\nForge版本：1.9-12.16.0.1797\n\n使用IDE：Intellij IDEA 2016.1\n\n目标\n\n制作一个物品，玩家在使用这个物品时将会创建一个BOSS条并显示在该玩家的界面上。\n\n注意：本案例将跳过创建物品的步骤，请自行Google或在MCBBS等社区内寻找教程或可参考的源码。\n\n操作\n\nStep 1：在你所创建的物品的类中添加一个重写的onItemUse方法\n\n\n\n@Override\npublic EnumActionResult onItemUse(ItemStack stack, EntityPlayer playerIn, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)\n{\n    return super.onItemUse(stack, playerIn, worldIn, pos, hand, facing, hitX, hitY, hitZ);\n}复制代码\nStep 2：将返回值改为EnumActionResult.SUCCESS或EnumActionResult.PASS\n\n@Override\npublic EnumActionResult onItemUse(ItemStack stack, EntityPlayer playerIn, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)\n{\n    return EnumActionResult.SUCCESS;\n}复制代码\nStep 3：添加一些代码到方法中，可以按照自己的需要进行修改\n\n@Override\npublic EnumActionResult onItemUse(ItemStack stack, EntityPlayer playerIn, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)\n{\n    if (!worldIn.isRemote) // 判断该世界是否为客户端世界\n    {\n        BossInfoServer bis = new BossInfoServer(new TextComponentString(\"宇宙无敌大萌王沫红\"), BossInfo.Color.GREEN, BossInfo.Overlay.PROGRESS); // 若不是，开始操作，此为创建一个BOSS条实例\n        bis.setCreateFog(true); // （可选）让这个BOSS条在出现的时候大雾弥漫\n        bis.setDarkenSky(true); // （可选）让这个BOSS条在出现的时候天空变暗\n        bis.addPlayer(playerIn); // 将使用者添加到玩家列表中，让使用者显示BOSS条\n    }\n\n    return EnumActionResult.SUCCESS;\n}复制代码\nStep 4：启动游戏查看效果，bingo！\n\n\n\n还能再给力点吗，老师？\n\n当然能！不过本文章主要讲的是简单实现，至于进阶版本人就懒得写了w\n\n简单地讲，你可以配合BOSS条实现一些功能，例如利用Java的Daemon Thread（守护线程）可以实现循环播放的BOSS公告（主线程不冻结）。\n\n嘛，就是这样了，撤！\n\nby.DoraJDJ\n2016-03-27",
    "replies": [
        {
            "author": "微与笑",
            "timestamp": 1581325740,
            "txt_content": "这东西是不是只能在服务器里面用，客户端不能用啊？"
        }
    ]
}