{
    "title": "[1.16.x][Fabric开发教程#2]添加新的药水配方",
    "author": "Mocoder",
    "replyCount": 1,
    "timestamp": 1596457980,
    "txt_content": " 本帖最后由 Mocoder 于 2020-8-4 21:03 编辑 \n\n本文Minecraft游戏文件采用Yarn反混淆\n绪论Minecraft自1.12版本起，采用了json文件作为合成配方以及烧炼配方的存储方法，这使得自定义合成及烧炼变得简单。然而酿造配方仍然写死在源代码里，且不允许直接向相关的类BrewingRecipeRegistry中加入代码来增加及改变配方，因为相关函数registerPotionRecipe，相关类BrewingRecipeRegistry.Recipe均不为public在原版数据包的开发中（https://zhangshenxing.gitee.io/vanillamodtutorial/#9.5_NBT酿造），采用了“偷天换日”的方案。但是这样做在Mod开发里并不方便。现在我们手里有相关代码，就可以开始改造BrewingRecipeRegistry类，使得它能够被成功注入自定义代码。注入方案在作者个人开发的Mod Carbonate（汽水）（https://www.mcbbs.net/thread-1092796-1-1.html）里，首先需要将水瓶和糖做成糖水，这涉及到修改原版药水配方；而加入药水（划掉）快乐水，则涉及到增加药水配方。在查找一番后，在 https://forums.spongepowered.org/t/mixin-how-to-shadow-a-field-with-private-inner-class/30163 找到了可行的方案：利用反射机制强制访问private方法强制访问在BrewingRecipeMixin类中，加入成员brrprivate static Class brr=BrewingRecipeRegistry.class;\n复制代码\n用以获取待修改的类本身，接下来加入成员addPotion获取私有方法registerPotionRecipe： private static Method addPotion;\n\n    static {\n        try {\n            addPotion = brr.getDeclaredMethod(\"registerPotionRecipe\", Potion.class, Item.class,Potion.class);\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n    }\n复制代码\n此时的addPotion就可以作为方法registerPotionRecipe使用，只需要调用addPotion.invoke方法。泛型注入BrewingRecipeRegistry.Recipe是一个泛型类，这个类的泛型在编译期会被擦除，但是反射在运行期运行，所以并不能直接利用反射向药水列表添加新药水以及注入registerPotionRecipe进行改变药水配方的操作，因为药水列表和方法registerPotionRecipe均用到了Recipe泛型类。得不到Recipe的泛型实例，但是可以通过反射获得Recipe类本身。private static Class recp;\n\n    static {\n        try {\n            recp = Class.forName(\"net.minecraft.recipe.BrewingRecipeRegistry$Recipe\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n复制代码\n这样，利用泛型的类型推导，就可以成功使用recp字段的方法构造Recipe的实例。并加入BrewingRecipeRegistry中的药水列表POTION_RECIPES:private static Field pr;\n\n    static {\n        try {\n            pr = brr.getDeclaredField(\"POTION_RECIPES\");\n            pr.setAccessible(true);\n        } catch (NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n复制代码\nPOTION_RECIPES是一个List对象，我们需要获得List类，并获得其add方法用于添加药水配方，来修改原版的registerPotionRecipe方法。private static Class listClass= List.class;\n\n    private static Method add;\n\n    static {\n        try {\n            add = listClass.getDeclaredMethod(\"add\",Object.class);\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n    }\n复制代码\n其中add的参数是Object.class，是因为List是一个泛型类，未初始化时无法获取类型，因此使用所有类的基类Object.class来匹配泛型\n快乐地修改现在可以修改了@Overwrite\n    private static void registerPotionRecipe(Potion input, Item item, Potion output) throws Exception{\n        if(item==Items.SUGAR)\n        {\n            add.invoke(pr.get(new Object()),recp.getDeclaredConstructors()[0].newInstance(input, Ingredient.ofItems(Items.SUGAR), SUGAR_DRINK));\n        }\n        else\n        {\n            add.invoke(pr.get(new Object()),recp.getDeclaredConstructors()[0].newInstance(input, Ingredient.ofItems(item), output));\n        }\n    }\n\n    @Inject(method=\"registerDefaults\",at=@At(\"RETURN\"))\n    private static void rdInj(CallbackInfo ci) throws Exception{\n        addPotion.invoke(null,SUGAR_DRINK,CDOBOTTLE,AWKWARD_COLA);\n   }\n复制代码注意：反射里面使用的方法名在发布时需要改成混淆后的名字！！！\n",
    "replies": [
        {
            "author": "2678378225",
            "timestamp": 1596462960,
            "txt_content": "很不错~~~~~"
        }
    ]
}