{
    "title": "[搬运+翻译][从零学编程]Python3Ⅴ：更多类型",
    "author": "45gfg9",
    "replyCount": 7,
    "timestamp": 1584682200,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-20 13:23 编辑 \n\n索引贴\n答案帖\nPrev: Python3Ⅳ：异常 & 文件\nNext: None\n\n\n1 None\n\n1.1 None（一）\n\nNone对象用来表示值的缺失。\n它与其他编程语言中的null类似。\n与其他“空”值，例如0、[]和空字符串一样，它在转换为布尔值时为False。\n在Python控制台中输入时，它以一个空字符串表示。\n>>> None == None\nTrue\n>>> None\n>>> print(None)\nNone\n>>>\n\nPart题：\n“None”常用来表示什么？\nA. 缺失值\nB. 假值\nC. 无效值\n\n1.2 None（二）\n\nNone会在当函数不显式返回值的时候返回。\ndef some_func():\n  print(\"Hi!\")\n\nvar = some_func()\nprint(var)\n结果：\n>>>\nHi!\nNone\n>>>\n\nPart题：\n下面代码输出什么？\nfoo = print()\nif foo == None:\n  print(1)\nelse:\n  print(2)\n\n\n\n2 字典\n\n2.1 字典（一）\n\n[ruby=Dictionaries]字典[/ruby]是一种用来任意将[ruby=key]键[/ruby]映射到[ruby=value]值[/ruby]的数据类型。\n列表可以想成有确定范围整数键的字典。\n字典可以用与列表相同的方式来索引，即包含键的方括号。\n例\nages = {\"Dave\": 24, \"Mary\": 42, \"John\": 58}\nprint(ages[\"Dave\"])\nprint(ages[\"Mary\"])\n出\n>>>\n24\n42\n>>>\n字典内每个元素都以键：值对表示。\nPart题：\n填空创建有两个元素的有效字典。\ncars = {\"BMW\" _ \"blue\" _ \"Volvo\": \"red\" _\n\n\n2.2 字典（二）\n\n尝试索引不属于字典的一个键会返回KeyError。\n例\nprimary = {\n  \"red\": [255, 0, 0], \n  \"green\": [0, 255, 0], \n  \"blue\": [0, 0, 255], \n}\n\nprint(primary[\"red\"])\nprint(primary[\"yellow\"])\n出\n>>>\n[255, 0, 0]\n\nKeyError: 'yellow'\n>>>\n如你所见，字典可以以任意类型数据作为值。\n空字典用{}定义。\nPart题：\n下面代码的结果是？\ntest = { }\nprint(test[0]}\nA. KeyError\nB. None\nC. 0\n\n2.3 字典（三）\n\n只有[ruby=immutable]不可变[/ruby]对象才能作为字典的键。不可变对象是不能被改变的对象。到现在，你见过所有的[ruby=mutable]可变[/ruby]对象只有列表和字典。尝试用可变对象作为字典键会产生TypeError。\nbad_dict = {\n  [1, 2, 3]: \"one two three\", \n}\n出\n>>>\nTypeError: unhashable type: 'list'\n>>>\n\nPart题：\n下面哪个不能用作字典的键？\nA. \"one two three\"\nB. False\nC. {2: 4, 3: 9, 4: 16,}\n\n\n3 字典函数\n\n3.1 字典（四）\n\n与列表相似，字典的键也可以被赋值。\n但字典不像列表的是，一个新的键也可以被赋值，而不是只能赋给存在的键。\nsquares = {1: 1, 2: 4, 3: \"error\", 4: 16,}\nsquares[8] = 64\nsquares[3] = 9\nprint(squares)\n出\n{1: 1, 2: 4, 3: 9, 4: 16, 8: 64}\n\nPart题：\n下面代码的输出是？\nprimes = {1: 2, 2: 3, 4: 7, 7: 17}\nprint(primes[primes[4]])\n\n\n3.2 字典（五）\n\n若要确定一个字典里是否含某个键，可以用in和not in，就像用在列表上一样。\n例\nnums = {\n  1: \"one\",\n  2: \"two\",\n  3: \"three\",\n}\nprint(1 in nums)\nprint(\"three\" in nums)\nprint(4 not in nums)\n出\n>>>\nTrue\nFalse\nTrue\n>>>\n\nPart题：\n用选项填空，如果\"pairs\"字典中有112为键，就输出\"Yes\"。\nif ______ ______ ______:\n  print(\"Yes\")\npairs        print        in        112        not        if\n\n3.3 字典（六）\n\n一个有用的字典方法是get。它与索引干同样的事，但如果字典中找不到键，它会返回另一个指定的值（默认是None）。\n例\npairs = {1: \"apple\",\n  \"orange\": [2, 3, 4], \n  True: False, \n  None: \"True\",\n}\n\nprint(pairs.get(\"orange\"))\nprint(pairs.get(7))\nprint(pairs.get(12345, \"not in dictionary\"))\n出\n>>>\n[2, 3, 4]\nNone\nnot in dictionary\n>>>\n\nPart题：\n下面代码的结果是？\nfib = {1: 1, 2: 1, 3: 2, 4: 3}\nprint(fib.get(4, 0) + fib.get(7, 5))\n\n\n\n4 元组\n\n4.1 元组（一）\n\n[ruby=Tuples]元组[/ruby]与列表很相似，除了它们是不可变的。还有，它们是用圆括号而不是方括号创建的。\n例\nwords = (\"spam\", \"eggs\", \"sausages\",)\n你可以索引元组的值，与列表一样：\nprint(words[0])\n尝试给元组元素重新赋值会产生TypeError。\nwords[1] = \"cheese\"\n出\n>>>\nTypeError: 'tuple' object does not support item assignment\n>>>\n与列表和字典相似，元组可以嵌套。\nPart题：\n填空分别创建列表、字典和元组。\n# 列表\nlist = _ \"one\", \"two\" _\n\n# 字典\ndict = _ 1:\"one\", 2:\"two\" _\n\n# 元组\ntp = _ \"one, \"two\" _\n\n\n4.2 元组（二）\n\n元组可以不用括号，只要将值用逗号分隔来创建。\nmy_tuple = \"one\", \"two\", \"three\"\nprint(my_tuple[0])\n出\n>>>\none\n>>>\n空的元组可以用一对空的圆括号创建。\ntpl = ()\n元组比列表效率更高，但不能被改变。\nPart题：\n下面代码的结果是？\ntuple = (1, (1, 2, 3))\nprint(tuple[1])\nA. (1, 2, 3)\nB. 1\nC. ((1, 2, 3))\n\n\n\n5 列表切片\n\n5.1 列表切片（一）\n\n[ruby=List slices]列表切片[/ruby]提供了一种更高级的从列表中取值的方法。基本的列表切片涉及到用两个冒号分隔的整数索引列表。这会返回一个新的列表，包含以前列表中两个索引中间的所有值。\nsquares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(squares[2:6])\nprint(squares[3:8])\nprint(squares[0:1])\n出\n>>>\n[4, 9, 16, 25]\n[9, 16, 25, 36, 49]\n[0]\n>>>\n与range的参数类似，切片中包含第一个索引，但不包含第二个。\nPart题：\n下面代码的结果？\nsqs = [0, 1, 4, 9, 16, 25, 36, 49, 64]\nprint(sqs[4:7])\nA. [25, 36, 49]\nB. [16, 25, 36]\nC. [16, 25, 36, 49]\n\n5.2 列表切片（二）\n\n如果略去切片中第一个数，会从列表起始切片。\n如果略去第二个数，会切片至列表末尾。\n例\nsquares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(squares[:7])\nprint(squares[7:])\n出\n>>>\n[0, 1, 4, 9, 16, 25, 36]\n[49, 64, 81]\n>>>\n元组也可以切片。\nPart题：\n填空，取列表的前两个值。\nlist = [\"a\", \"b\", \"c\", \"d\"]\na = list[0 __ ]\n\n\n5.3 列表切片（三）\n\n列表切片也可以有第三个数，指定步进数，只包括切片中间隔的值。\nsquares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(squares[::2])\nprint(squares[2:8:3])\n出\n>>>\n[0, 4, 16, 36, 64]\n[4, 25]\n>>>\n[2:8:3]在第二个到第八个元素中每隔两个元素取一个。\nPart题：\n下面代码的输出？\nsqs = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(sqs[1::4])\nA. 出错\nB. [1, 25, 81]\nC. [0, 1, 4]\nD. [1, 25]\n\n5.4 列表切片（四）\n\n负数也可以用于列表切片（和普通的列表索引）。当负数用在切片索引的第一个或第二个数时，会从列表末尾算起。\nsquares = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(squares[1:-1])\n出\n>>>\n[1, 4, 9, 16, 25, 36, 49, 64]\n>>>\n如果用负数作为步进值，那么切片从后往前完成。\n用[::-1]切片是一种常用且地道的将列表倒序的方法。\nPart题：\n下面代码输出？\nsqs = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nprint(sqs[7:5:-1])\nA. []\nB. [49, 36]\nC. [49]\n\n\n6 列表推导式\n\n6.1 列表推导式（一）\n\n[ruby=List comprehension]列表推导式[/ruby]是一种有用且快捷的创建那种值遵循某个简单规律的列表。\n举例，我们可以这样做：\n# 一个列表推导式\ncubes = [i**3 for i in range(5)]\n\nprint(cubes)\n出\n>>>\n[0, 1, 8, 27, 64]\n>>>\n列表推导式的灵感来源于数学中的[ruby=set-builder notation]集合建构式符号[/ruby]。\nPart题：\n下面这个列表推导式会产生什么？\nnums = [i*2 for i in range(10)]\nA. 一个有0-10之间所有偶数的列表\nB. 一个有0-18之间所有偶数的列表\nC. 一个有0-10之间所有数字的列表\n\n6.2 列表推导式（二）\n\n列表推导式也可以包含if语句，确保列表中的元素都符合条件。\n例\nevens=[i**2 for i in range(10) if i**2 % 2 == 0]\n\nprint(evens)\n出\n>>>\n[0, 4, 16, 36, 64]\n>>>\n\nPart题：\n创建一个包含0-20内3的倍数的列表。\na = _ i for i in range(20) __ i% _ ==0]\n\n\n6.3 列表推导式（三）\n\n尝试用列表推导式创建一个非常大的列表会产生MemoryError。\n下面代码展示列表推导式用尽内存的情况。\neven = [2*i for i in range(10**100)]\n出\n>>>\nMemoryError\n>>>\n这个问题可以用[ruby=generators]生成器[/ruby]解决，在下一模块讲。\nPart题：\n填空创建一个5-9范围内数字乘10的列表。\na = [x*10 ___ x __ range( _ , 9)]\n\n\n\n7 字符串格式化\n\n7.1 字符串格式化（一）\n\n到现在，要想将字符串与非字符串合并，你需要先转换为字符串再相加。\n字符串格式化提供了一种更强大的方法，能将非字符串嵌入字符串。字符串格式化用到字符串的format方法来替换字符串中的参数。\n例\n# 字符串格式化\nnums = [4, 5, 6]\nmsg = \"Numbers: {0} {1} {2}\". format(nums[0], nums[1], nums[2])\nprint(msg)\n出\n>>>\nNumbers: 4 5 6\n>>>\nformat函数中每个实参都对应字符串中的一个位置，由花括号{ }指定。\nPart题：\n下面代码的结果？\nprint(\"{0}{1}{0}\".format(\"abra, \"cad\"))\n\n\n7.2 字符串格式化（二）\n\n字符串故事也可用命名参数完成。\n例\na = \"{x}, {y}\".format(x=5, y=12)\nprint(a)\n出\n>>>\n5, 12\n>>>\n\nPart题：\n下面代码的输出？\nstr=\"{c}, {b}, {a}\".format(a=5, b=9, c=7)\nprint(str)\nA. 5, 9, 7\nB. 9, 7, 5\nC. 7, 9, 5\n\n\n8 一些有用的函数\n\n8.1 字符串函数\n\nPython包含许多有用的内置函数和方法来完成常见任务。\njoin - 将一列表的字符串以另一个字符串为分隔符合并。\nreplace - 将一个字符串的子串用另一个字符串替换。\nstartswith和endswith - 判断字符串是否以一个子串开始或结束。\n要改变字符串的大小写，你可以用lower和upper。\nsplit方法与join相反，将一个字符串以某分隔符分割成列表。\n举一些例：\nprint(\", \".join([\"spam\", \"eggs\", \"ham\"]))\n#输出 \"spam, eggs, ham\"\n\nprint(\"Hello ME\".replace(\"ME\", \"world\"))\n#输出 \"Hello world\"\n\nprint(\"This is a sentence.\".startswith(\"This\"))\n# 输出 \"True\"\n\nprint(\"This is a sentence.\".endswith(\"sentence.\"))\n# 输出 \"True\"\n\nprint(\"This is a sentence.\".upper())\n# 输出 \"THIS IS A SENTENCE.\"\n\nprint(\"AN ALL CAPS SENTENCE\".lower())\n#输出 \"an all caps sentence\"\n\nprint(\"spam, eggs, ham\".split(\", \"))\n#输出 \"['spam', 'eggs', 'ham']\"\n\nPart题：\n填空将字符串转大写。\na = \"Spam\"\nb = a._____()\n\n\n8.2 数字函数\n\n用max或min函数确定列表中的最大值或最小值。\n用abs计算一个数字与0的距离（绝对值）。\n用round将一个数字舍入到某个确定的小数位。\n用sum计算列表的总和。\n举一些例：\nprint(min(1, 2, 3, 4, 0, 2, 1))\nprint(max([1, 4, 9, 2, 5, 6, 8]))\nprint(abs(-99))\nprint(abs(42))\nprint(sum([1, 2, 3, 4, 5]))\n出\n>>>\n0\n9\n99\n42\n15\n>>>\n\nPart题：\n下面代码的输出是？\na=min([sum([11, 22]), max(abs(-30), 2)])\nprint(a)\n\n\n8.3 列表函数\n\n在条件语句中常常用到的有all和any，它们分别检测是否所有的元素都算为True和是否至少有一个元素算为True。\nenumerate函数可以用来同时遍历列表的索引和值。\n例\nnums = [55, 44, 33, 22, 11]\n\nif all([i > 5 for i in nums]):\n   print(\"All larger than 5\")\n\nif any([i % 2 == 0 for i in nums]):\n   print(\"At least one is even\")\n\nfor v in enumerate(nums):\n   print(v)\n出\n>>>\nAll larger than 5\nAt least one is even\n(0, 55)\n(1, 44)\n(2, 33)\n(3, 22)\n(4, 11)\n>>>\n\nPart题：\n下面代码的输出是？\nnums = [-1, -2, -3, -4, -5]\nif all([abs(i) < 3 for i in nums]):\n  print(1)\nelse:\n  print(2)\n\n\n\n9 文本分析器\n\n9.1 文本分析器\n\n接下来是一个示例项目，此程序可以分析一个范例文件，找出每个字符在文本中出现的百分比。\n这一节展示如何打开并读取文件。\nfilename = input(\"Enter a filename: \")\n\nwith open(filename) as f:\n   text = f.read()\n\nprint(text)\n出\n>>>\nEnter a filename: test.txt\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcenfr fv orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabthu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orgnf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba bg thrff.\nGurer fubhyq or bar-- naq cersrenoylbayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arrire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\n这只是一个用于演示用途的样例内容。\nPart题：\n填空用with语句读取文件内容。\n____ open(filename) __ f:\n  text = f.read()\n\n\n9.2 文本分析器（二）\n\n这部分程序展示一个能统计字符在字符串中出现次数的函数。\ndef count_char(text, char):\n  count = 0\n  for c in text:\n    if c == char:\n      count += 1\n  return count\n这个函数的参数是文件的文本和一个字符，返回的是文本中字符出现的次数。\n接下来我们可以对文件内容调用它了。\nfilename = input(\"Enter a filename: \")\nwith open(filename) as f:\n  text = f.read()\n\nprint(count_char(text, \"r\"))\n出\n>>>\nEnter a filename: test.txt\n83\n>>>\n字符\"r\"在文件中出现了83次。\nPart题：\n为什么要将字符计数代码放在函数中？\nA. 这样就能读取文件了\nB. 这样就能复用了\nC. 这样就能跑得更快了\n\n9.3 文本分析器（三）\n\n程序的下一部分是按字母表顺序找出每个字母出现频率的占比。\nfor char in \"abcdefghijklmnopqrstuvwxyz\":\n  perc = 100 * count_char(text, char) / len(text)\n  print(\"{0} - {1}%\".format(char, round(perc, 2)))\n让我们组合在一起运行程序：\ndef count_char(text, char):\n  count = 0\n  for c in text:\n    if c == char:\n      count += 1\n  return count\n\nfilename = input(\"Enter a filename: \")\nwith open(filename) as f:\n  text = f.read()\n\nfor char in \"abcdefghijklmnopqrstuvwxyz\":\n  perc = 100 * count_char(text, char) / len(text)\n  print(\"{0} - {1}%\".format(char, round(perc, 2)))\n出\nEnter a filename: test.txt\na - 4.68%\nb - 4.94%\nc - 2.28%\n...\n\nPart题：\n上面代码中round函数的作用是？\nA. 减少输出的小数位数\nB. 使输出更精确\nC. 节省内存\n\n\n模块测试\n\n1. 元组能切片吗？\n\n2. 下面哪个切片会反向排序列表numbers？\nA. numbers[::-1]\nB. numbers[::]\nC. numbers[-1::]\n\n3. 下面哪个可以描述为“不可变的列表”？\nA. 元组\nB. 字典\nC. 数字\n\n4. 无return语句的函数会返回什么？\nA. 0\nB. False\nC. None\n\n5. 下面代码的输出是？\nnums = (55, 44, 33, 22)\nprint(max(min(nums[:2]), abs(-42)))\n\n",
    "replies": [
        {
            "author": "ItsZeroHikari",
            "timestamp": 1584683160,
            "txt_content": "45又翻新教程了 爽啦\n你坛就我什么也不会了罢"
        },
        {
            "author": "SeaGame",
            "timestamp": 1588655940,
            "txt_content": "可惜我都已经学过了。最开始是抱着试试看的心理看完了楼主的所有文章，后来感到非常失望。"
        },
        {
            "author": "hacyellow",
            "timestamp": 1588659780,
            "txt_content": "虽然mcbbs不是很支持大家发教程贴，但我还是来看一下编程教程\n虽然我是一个c语言学生，python一窍不通"
        },
        {
            "author": "QWERTY770",
            "timestamp": 1594817460,
            "txt_content": "格式化字符串用3.6的f-strings不好吗"
        },
        {
            "author": "45gfg9",
            "timestamp": 1594823280,
            "txt_content": "1683239263 发表于 2020-7-15 20:51\n格式化字符串用3.6的f-strings不好吗\n好，而且建议使用f-strings\n\n但本教程是译作，原教程没有用f-strings"
        },
        {
            "author": "QWERTY770",
            "timestamp": 1594855920,
            "txt_content": "45gfg9 发表于 2020-7-15 22:28\n好，而且建议使用f-strings\n\n但本教程是译作，原教程没有用f-strings\n目前推测原教程应该是3.4或以下\n\n因为这里没有async/await（3.5），没有f-strings（3.6），没有:=（3.8）"
        },
        {
            "author": "1539776978",
            "timestamp": 1594895940,
            "txt_content": "        MCBBS有你更精彩~"
        }
    ]
}