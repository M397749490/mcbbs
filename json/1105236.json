{
    "title": "PVPINDemoRL--事件监听循环(二)",
    "author": "William_Shi",
    "replyCount": 1,
    "timestamp": 1597931700,
    "txt_content": " 本帖最后由 William_Shi 于 2020-8-20 21:55 编辑 \n\n本教程系PVPIN教程复刻系列\n索引见https://www.mcbbs.net/thread-1034477-1-1.html\n本教程不做排版，如果你觉得不舒服，可以选择退出本页面\n本教程所有代码全部在coding开源，详见索引\n本教程可能存在一定吞代码问题，总体上以开源地址的代码为准\n\n可以先看前篇\nhttps://www.mcbbs.net/thread-1068558-1-1.html\n我先总结前篇的内容\n具体代码在org.bukkit.plugin.SimplePluginManager类\n\n当调用registerEvents方法时，会扫描整个类当中全部含 @EventHandler注解的方法\n通过方法传入的Event参数的类，确定这个监听是监听哪个事件的\n\n假如有如下代码@EventHandler\npublic void onEventCalled(PlayerMoveEvent event){\n}\n复制代码\n\n那么SimplePluginManager会首先取到PlayerMoveEvent这个类\n然后判断这个类有没有静态方法getHandlerList\n如果没有，抛出异常\n如果有，把这个事件监听加入这个类(PlayerMoveEvent)的Handlers当中\n当有地方采用Bukkit.getPluginManager().callEvent等方式触发事件监听时\n根据传入的这个参数的类的getHandlerList调用监听器\nHandlerList可以理解为是用来储存事件监听器的\n\n总结来说有这么几个特点\n1.HandlerList中的大部分方法，尤其是注册监听的方法，都是Synchronized方法，根本不存在什么插件加载时异步注册事件监听会提高效率这种无稽之谈\n2.事件监听的注册，依据就在于你所监听的那个Event的class（SimplePluginManager的getRegistrationClass方法），不存在什么多态监听，父事件被call同时触发子事件的监听器这种说法，完全就是类与监听的对应，子事件的类对应子事件的监听，父事件的类对应父事件的监听\n\n再具体一点就是假如有如下代码\n\npublic class A implements Listener{\n        @EventHandler(priority = EventPriority.MONITOR)\n        public void onEventCalled(PlayerMoveEvent event){\n                //xxx\n        }\n}\n复制代码\n当调用Bukkit.getPluginManager().registerEvents(new A(), plugin)方法时，首先\n检查这个A类是不是真的实现Listener\n通过A类的getMethods、getDeclaredMethods获取所有方法\n检查这些方法是不是有@ EventHandler注解\n对于有注解的方法，检查其参数是不是只有一个，且是事件的对象\n检查其监听的事件是不是有静态方法getHandlerList，如果没有抛出异常（比如说监听PlayerEvent、BlockEvent是不可行的）\n取到监听的事件对应类的HandlerList，按照注解内的事件监听优先级，把这个监听注册进去\n\n当Bukkit.getPluginManager().callEvent时，按照call的那个类，取其getHandlerList\n然后按照优先级，依次调用被注册的方法\n\n那么现在我们知道了\n如果通过Bukkit.getPluginManager().callEvent(event)\n这个event的类的HandlerList中所有的监听器将被依次序调用\n这些监听都是直接对着event对象去操作的\n也就是说event本身的属性将被改变\n那么最后究竟是如何应用的呢？\n\n我们都知道MC服务器底层是NMS\n因此所有的Event，本质上都是NMS\n本来这里我想拿附魔来举例，因为我研究的挺透，但感觉逻辑还是太复杂，换一个\nnet.minecraft.server.v1_15_R1.EntitySlime\nNMS的史莱姆实体类的die方法\n\n      int j = 2 + this.random.nextInt(3);\n      SlimeSplitEvent event = new SlimeSplitEvent((Slime)getBukkitEntity(), j);\n      this.world.getServer().getPluginManager().callEvent((Event)event);\n      if (!event.isCancelled() && event.getCount() > 0) {\n        j = event.getCount();\n      } else {\n        super.die();\n        return;\n      } \n\n什么意思？j这个变量指的是史莱姆死亡分裂成几个\n本来应该是随机的\n但是它新建了SlimeSplitEvent对象，其构造器内有一个参数是j\n查构造器https://bukkit.windit.net/javado ... t.entity.Slime-int-\n那么这个int就对应了分裂数目\n当监听器调用了https://bukkit.windit.net/javado ... .html#setCount-int-\n此时event对象的int count会被直接修改\n然后这个被修改的count再传递给其他监听器\n当传递完所有的监听器之后，就得到了一个被改得面目全非的SlimeSplitEvent对象\n可以看到 j = event.getCount();\n也就是说我们修改之后的数量被真正应用到服务器上了\n走的是直接修改NMS底层操作数值的办法\n\n那么，该怎么正确写一个自定义的事件监听就很清晰了\n模仿其他的事件监听，也需要静态方法getHandlerList\n同时我们必须手动调用callEvent方法，让监听这个事件的监听器全部处理这个事件\n然后我们得到一个被改动的面目全非的事件对象\n此时我们应该直接使用这个事件被改动过，面目全非的属性，去进行下一步的操作\n\n友情链接：\nhttps://www.acgxt.com/364.html\nhttps://www.jianshu.com/p/4d1c15e02b1b",
    "replies": [
        {
            "author": "为什么那么认真",
            "timestamp": 1597932240,
            "txt_content": "666666666666666666666666666666666\n"
        }
    ]
}