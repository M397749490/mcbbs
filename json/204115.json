{
    "title": "[MC Modding教程：OpenGL、渲染器和特效]第二章：冰之法杖的编写——实体渲染器",
    "author": "DeathWolf96",
    "replyCount": 19,
    "timestamp": 1386588960,
    "txt_content": " 本帖最后由 DeathWolf96 于 2014-8-19 13:43 编辑 \n\nMinecraft Modding教程——OpenGL，渲染器和特效\n第二章：冰之法杖的编写——实体渲染器\n\n系列地址：http://www.mcbbs.net/thread-203554-1-1.html\n\n\n\n\n\n18c03eccf9387a298326ac84.jpg (33.68 KB, 下载次数: 26)\n\n下载附件\n\n2013-12-9 19:45 上传\n\n\n\n\n\n（这次镇楼的当然得是⑨啦~233333)\n\n      法杖，是以魔法、神秘学等为背景的游戏不可缺少的物品之一。以它为载体，魔法师可以释放各种高端洋气（雾）的魔法。接下来，我们就以一把⑨的冰之法杖为例，稍微复习一下物品和实体的代码编写，以及学习实体的渲染。\n\n\n第一步：基础准备\n\n在教程1中，我们已经建立了一个基本的mod构架，并准备好在它的基础上进行后续的编写。为了进行物品的撰写和注册，我还要进行几点小准备……\n\n/registry/GRItems.java:\nGRItems是物品实例的摆放位置。通过在主mod的preInit中调用它的加载函数，mod中的所有物品得以注册。\n\npublic class GRItems {\n    \n    public static void init() { //留空，我们会稍后增加内容\n    }\n\n}\n复制代码\n/item/GRGenericItem.java:\nGRGenericItem是以后会写到的所有物品的父类。在这个类中，添加了一些方便的功能，比如添加物品名称、注册物品图标。\n\npublic class GRGenericItem extends Item {\n    \n    private String iconName = \"\";\n\n    public GRGenericItem(int par1) { //构造器\n        super(par1);\n    }\n    \n    protected void setIconName(String str) { //设置物品图标位置\n        iconName = str;\n    }\n    \n    /**\n     * 方便的快速设置函数。\n     */\n    protected void setIAndU(String str) {\n        setUnlocalizedName(str);\n        setIconName(str);\n    }\n    \n    /**\n     * 为物品添加名字的方便函数。请务必在设置了unlocalizedName后调用。\n     */\n    protected final void addLocalization(String str) {\n        LanguageRegistry.addName(this, str);\n    }\n复制代码\n注意接下来的registerIcons函数。在这里，我们的GRGenericItem直接替子类管理了贴图的注册。我们只需要在物品的构造器中调用setIconName(String)，就可以快速的设置物品贴图。\n\n    /**\n     * 进行物品贴图的注册。\n     */\n    @SideOnly(Side.CLIENT)\n    public void registerIcons(IconRegister iconRegister)\n    {\n        if(!iconName.equals(\"\"))\n            itemIcon = iconRegister.registerIcon(iconName);\n    }\n\n}\n复制代码\n/proxy/GRClientProps.java:\nGRClientProps是客户端相关信息的摆放位置。目前是个空类，不过很快就会用到的。\npublic class GRClientProps {\n\n}复制代码\n\n\n*这一部分的代码风格可能因人有很大不同。有很多Modder把物品的实例和其他信息直接放在Mod的主类。我个人不是太喜欢这种做法，它会导致mod的结构混乱、访问冗余，从而降低运行效率。总而言之，保证干净简洁的原则，按照你喜欢的方式写就可以=w=\n第二步：法杖物品的撰写\n在经过艰辛（哪有）的准备以后，我们终于可以开始写我们mod的第一个物品了。那么，这就开始了哟~！\n\n我们先来分析一下⑨之法杖的属性和功能：\n-不可堆叠\n-有限的使用次数\n-通过右键使用，释放魔法实体\n\n很简单，结构也很清晰。在了解了我们要实现的内容以后，剩下的就是用代码将它表现出来了。首先通过物品加载时的设置函数对物品的基本属性进行设定，其次就是在玩家按下使用键（右键）时，进行相应的功能处理。\n\n/item/ItemFrozenWand.java:\n这是实际的法杖物品类。首先，我们在构造器中进行一些基本参数的设定。\n\npublic class ItemFrozenWand extends GRGenericItem {\n\n    /**\n     * 法杖物品的构造器。\n     */\n    public ItemFrozenWand(int par1) {\n        super(par1);\n        this.setIAndU(\"graphrevo:frozen_wand\"); //设置图标名和内部名称\n        this.addLocalization(\"Frozen Wand\"); //添加物品名称\n        this.setCreativeTab(GraphRevo.cct); //设置所属创造模式物品栏\n        this.setMaxStackSize(1); //不可堆叠\n        this.setMaxDamage(15); //最高可使用15次\n    }\n复制代码顺手把法杖物品拷到工作目录里去吧~\n/textures/items/frozen_wand.png\n\n\n\n\nfrozen_wand.png (6.75 KB, 下载次数: 44)\n\n下载附件\n\n2013-12-9 19:59 上传\n\n\n\n\n\n\n\n知识点：1.4.7以后的物品贴图注册，以及资源文件的搜寻\n\n在MC1.4.7及以前版本，MC中的物品贴图使用一张大小256x256的自定贴图，并且对每一个物品，指定其中的一个16x16的区块作为一个物品的图标。这样的贴图管理方法可复用性很低，每次改一张贴图都要修改整张大贴图。在MC1.5以后，mod的贴图注册方式发生了巨变。MC引入了Icon（图标）类，用来指示一个物品/方块的图标。\nIcon类一般需要在Item或者Block的registerIcons(IconRegister)函数中进行统一注册。在所有物品注册完毕以后，MC会将它们绘制到一张统一的大png图中（也就是terrains.png和items.png），并且用内部管理的坐标进行绘制。这样既保证了运行效率，又降低了美工的工作量。\n在1.5和1.6时代，很多modder纠结的文件位置问题，其实非常简单：\n\n贴图文件/资源文件的指定格式： \"[名称空间]:[贴图名 or 资源名]\"\n\n其中，名称空间用来区分贴图文件所属的mod。它可以和主类中modid所指定的名称有所不同。你可以任意给你的mod贴图选择一个命名空间: \"mymod\", \"ic2\", \"lambdacraft\", ... 只要你觉得舒服都行。在1.6以后，MC会在以下的工作路径搜索一般的资源文件：\n\"[工作路径]/assets/[名称空间]/...\"\n\n其中，对于mod来说，工作路径就是mod压缩包的根目录。\n\n对于物品的贴图加载，MC会在以下路径中搜寻相关贴图：\n\n\"[工作路径]/assets/[名称空间]/textures/items/[贴图名].png\"\n\n在上面的法杖注册代码中，我使用了setIcon(\"graphrevo:frozen_wand\") 函数。这样，当注册Icon的时候，MC就会到 “assets/graphrevo/textures/items/frozen_wand.png” 搜寻贴图文件。\n\n那么基本信息的注册就到此完成了。接下来，我们为这个法杖添加它核心的功能：右键的处理，放出实体。\n关于接下来的代码，注意一个onPlayerStoppedUsing的小细节：我们只在服务端生成实体。MC会通过网络通信，自动将服务端实体的数据同步到客户端。\n\n    /**\n     * 当按下右键时被调用的函数。\n     * Called whenever this item is equipped and the right mouse button is pressed. Args: itemStack, world, entityPlayer\n     */\n    public ItemStack onItemRightClick(ItemStack itemStack, World world, EntityPlayer entityPlayer)\n    {\n        entityPlayer.setItemInUse(itemStack, getMaxItemUseDuration(itemStack)); //设置为当前使用物品\n        return itemStack;\n    }\n    \n    /**\n     * 玩家松开右键时被调用，释放实体。\n     * called when the player releases the use item button. Args: itemstack, world, entityplayer, itemInUseCount\n     */\n    public void onPlayerStoppedUsing(ItemStack itemStack, World world, EntityPlayer entityPlayer, int par4) {\n        \n        if(!world.isRemote) { //仅在服务端生成\n            int damage = par4 / 10 + 4;\n            if(damage > 15) damage = 15; //计算伤害\n        \n            world.spawnEntityInWorld(new EntityFrozen(world, entityPlayer, damage));\n        }\n        \n    }\n    \n    /**\n     * 获取最长的使用时间（ticks)\n     */\n    public int getMaxItemUseDuration(ItemStack itemStack)\n    {\n        return 200; //200ticks=10s\n    }\n\n}\n复制代码\n/entity/EntityFrozen.java:\n物品的代码做完了，接下来我们编写生成的实体：\n实体的编写实际上确实具有一定的难度，这里由于是OpenGL教程所以就不多加展开了，看代码吧~\nEntityFrozen继承的是EntityThrowable，它同时也是MC中雪球、火焰弹一类实体的父类，为这一类实体提供了一些很好的辅助功能。\n\npublic class EntityFrozen extends EntityThrowable {\n\n    //伤害值\n    int damage = 4;\n    \n    /**\n     * 在客户端同步时被调用的构造器。\n     */\n    public EntityFrozen(World par1World) {\n        super(par1World);\n        setSize(0.8F, 0.8F); //大小0.8格\n    }\n\n    /**\n     * 我们在服务端生成时调用的构造器。\n     */\n    public EntityFrozen(World par1World, EntityLivingBase par2EntityLivingBase, int dmg) {\n        super(par1World, par2EntityLivingBase);\n        this.damage = dmg;\n        setSize(0.8F, 0.8F); //大小0.8格\n    }\n\n    /**\n     * 当实体碰撞到其他世界物品时被调用。进行碰撞计算。\n     */\n    @Override\n    protected void onImpact(MovingObjectPosition mop) {\n        Vec3 vec3 = mop.hitVec; //获取碰撞结果的“碰撞位置”Vec3\n        int beginX = (int) (vec3.xCoord - 4),\n            beginY = (int) (vec3.yCoord - 2),\n            beginZ = (int) (vec3.zCoord - 4);\n        \n        for(int x = beginX + 8; x >= beginX; x--) //替换水\n            for(int y = beginY + 3; y >= beginY; y--)\n                for(int z = beginZ + 8; z >= beginZ; z--) {\n                    int blockID = worldObj.getBlockId(x, y, z);\n                    if(blockID != 0) { //无差别冰冻方块\n                        worldObj.setBlock(x, y, z, Block.ice.blockID, 0, 0x03);\n                    }\n                }\n        \n        //伤害实体\n        if(mop.typeOfHit == EnumMovingObjectType.ENTITY) {\n            mop.entityHit.attackEntityFrom(DamageSource.causeThornsDamage(this), damage);\n        }\n        \n        this.setDead();\n    }\n    \n    /**\n     * 获取实体的初速度值。\n     */\n    protected float func_70182_d()\n    {\n        return 1.0F;\n    }\n    \n    /**\n     * 获取重力加速度的大小。\n     */\n    protected float getGravityVelocity()\n    {\n        return 0.001F; //重力影响极小\n    }\n\n}\n复制代码\n/GraphRevo.java:\n别忘了，回到Mod的主类中，对物品和实体进行注册，这样在Server端生成的实体才会在Client端同步出现。\n这时候，我们的GRItems也派上用场了。\n这里又偷懒写了一个统一注册函数，反正怎么方便怎么写嘛~\n    /**\n     * 加载第一阶段。\n     */\n    @EventHandler()\n    public void preInit(FMLPreInitializationEvent event) {\n        //... 之前所写的内容\n        GRItems.init(); //进行物品注册！\n        proxy.preInit();\n    }\n\n    /**\n     * 加载第二阶段。\n     */\n    @EventHandler()\n    public void init(FMLInitializationEvent event) {\n        proxy.init();\n        registerEntity(EntityFrozen.class, \"entity_frozen\");\n    }\n    \n    static int nextEntityID = 0; //id计数器\n    private void registerEntity(Class<? extends Entity> entityClass, String name) {\n        EntityRegistry.registerModEntity(entityClass, name, ++nextEntityID, GraphRevo.instance, 32, 3, true);\n    }\n复制代码/GRItems.java：\n\n    public static ItemFrozenWand frozenWand;\n    \n    public static void init() {\n        frozenWand = new ItemFrozenWand(7777);\n    }\n复制代码物品和实体的代码编写不是本教程的重点，相信代码中的注释也已经很好的解释了每一段的功能。到目前为止，冰之法杖的功能就已经完成。接下来，我们打开游戏试试效果吧——\n\n\n\n\n\n2014-08-19_13.17.37.jpg (124.27 KB, 下载次数: 27)\n\n下载附件\n\n2014-8-19 13:41 上传\n\n\n\n\n\n很好，冰冻效果拔群，但是……\n\n\n\n\n\n2014-08-19_13.09.56.jpg (56.18 KB, 下载次数: 26)\n\n下载附件\n\n2014-8-19 13:41 上传\n\n\n\n\n\n\n发现没有？效果……十分值得吐槽。法杖所发出的魔法光球实体被渲染成了一个纯白色的立方体，毫无美感可言。\n如何让魔法光球真正具有漂亮的冰冻效果呢？接下来，我们就将进入本教程的重点——实体的渲染环节。第三步：绚丽特效走你！~\\(≧▽≦)/~\n\n终于进入正题了……首先，让我们对渲染器有关的概念做一些了解吧。\n知识点：实体渲染的绑定、Render类\n\n作为MC中渲染的重要环节，Forge毫无疑问提供了方便的为实体进行渲染的途径。通过 RenderingRegistry.registerEntityRenderer(Class <? extends Entity>, Render) 函数，我们可以为一种Entity绑定渲染器。当这类实体在Client端生成时，便会调用相应的渲染器进行渲染。\n绑定的渲染器是一个Render对象，它需要实现如下方法：\n    public void doRender(Entity entity, double x, double y, double z,  float f, float f1)；\n    protected ResourceLocation getEntityTexture(Entity entity)；\n\n其中，第一个doRender函数是进行渲染的关键。如果Entity出现在玩家视野内，这个函数会在每一帧被调用以进行渲染。至于具体如何编写，我们会在后文中详细阐述。\n而getEntityTexture函数，字面意义是获取实体的贴图文件。不过目前意义不明，似乎Forge也没有帮你绑定贴图。return null就可以了~\n\n知识点：相关函数和方法\n\nMinecraft使用的图形API是OpenGL，因此所有OpenGL的图形函数在渲染器中都适用。\n常见的几个渲染函数：\nglTranslate ： 将坐标进行位移变换。\nglRotate：将坐标进行旋转变换。\nglScale：将坐标进行缩放变换。\nglEnable、glDisable：打开/关闭某种特定功能。\nglBlendFunc(int, int)：设置融合方法。\nglColor：设置当前绘制颜色。\nglPushMatrix(), glPopMatrix()：推入/弹出栈。\nOpenGL是一个内容极其丰富的API，在此不作更多列举。关于具体函数的功能和使用，在之后的教程中会逐步进行说明。\n\n对于Minecraft，它的渲染方法在OpenGL的基础上有所扩充和修改。\n首先，在图形的绘制方面，Minecraft使用了一个统一的镶嵌器（Tessellator），来接管顶点和多边形的绘制工作，同时进行一些统一的光照处理，所有的图形绘制工作都要调用tessellator的实例才能完成。\n对于实体、物品的渲染之类，它已经事先替Modder做好了局部坐标的变换，Modder只需要在一个相对固定的局部坐标系里进行绘制，减小了工作量。\n实际上这里个人认为MCP开发组把这个类翻译为Tessellator很不恰当，毕竟只提供了一些辅助的功能嘛0w0\n关于镶嵌（曲面细分）：维基百科\n\n关于贴图绑定等动作，MC也有自己的一套机制。在MC1.6.2以后，所有的资源文件（声音，贴图）统一使用ResourceLocation进行定位，MC也为此提供了相应的绑定方法。\n常见的MC渲染方法：\nTessellator t = Tessellator.instance; //获取着色器\nt.startDrawingQuads(); //开始绘制 类比glBegin()\nt.addVertex(); //绘制一个顶点 类比glVertex3f()\nt.addVertexWithUV(); //绘制一个带UV坐标的顶点\nt.draw(); //结束绘制，将信息存储到绘制缓存 类比glEnd()\nt.setColorOpaque_f(R, G, B, A); //设置绘制颜色 相当于glColor4f\nMinecraft.getMinecraft().renderEngine.bindTexture(ResourceLocation) //绑定贴图\nOpenGlHelper.setLightMapTextureCoords(...) //设置光表面贴图坐标\n......\n\n题外话：关于ResourceLocation\n\nResourceLocation是MC中用来表示资源文件位置的特殊类，它在MC1.6以后被引入。从MC1.6以后，MC的文件系统发生了巨变，不过在文件结构的控制上，对Modder来说方便了很多。\nResourceLocation的定位方法：\n在MC164中，和贴图文件的命名规则一样，你可以用两个字符串精确定位一个资源文件的位置——名称空间和路径。\n如果我要绑定一个位于\"/assets/mymod/textures/test.png\"的贴图文件，我可以这么写：\n\nResourceLocation rl = new ResourceLocation(\"mymod:textures/test.png\");\nMinecraft.getMinecraft().renderEngine.bindTexture(rl);\n复制代码\nMC会通过冒号自动分隔命名空间和路径，并且以此定位正确的文件。\n\n\n那么基础知识就是这些了，在了解了mc基本渲染机制的前提下，让我们开始吧——\n\n首先，我们新建一个空渲染器……\n/client/render/RenderFrozen.java:\n\n/**\n * 冰冻魔法效果的渲染器。\n */\npublic class RenderFrozen extends Render {\n\n    /* \n     * 进行实际渲染的函数。\n     */\n    @Override\n    public void doRender(Entity entity, double x, double y, double z,\n            float f, float f1) {\n    }\n\n    @Override\n    protected ResourceLocation getEntityTexture(Entity entity) {\n        return GRClientProps.TEX_FROZEN_MAGIC; //我也不知道这个函数有什么用\n    }\n}\n复制代码\n并在GRClientProxy的init()函数中注册它。\n/proxy/GRClientProxy.java:\n\n    public void init() {\n        RenderingRegistry.registerEntityRenderingHandler(EntityFrozen.class, new RenderFrozen()); //注册渲染器\n        super.init();\n    }\n复制代码\n现在如果你打开游戏，会发现已经看不到原来的白色豆腐块了。那是因为我们现在的空渲染器已经接管了默认渲染器的渲染工作。接下来，只要为渲染器添加实际的绘制代码，就可以让我们的特效表现出来了。\n那么，首先还是特效的构思和贴图的绘制……\n作为魔法的特效，首先应该有光球（废话），一条发光的尾迹也是必不可少的。这样的话，我们就用交叉绘制两张半透明贴图的方法，把光球和尾迹表现出来。\n其实这样正交绘制的方法是最简单的绘制方法了，而且效果也谈不上是很好。不过作为最初的教学，我们就从简单的开始吧~\n\n贴图的绘制——\n\n\n\n\nfrozen_magic.png (125.36 KB, 下载次数: 57)\n\n下载附件\n\n2013-12-12 12:31 上传\n\n\n\n\n\n（不要吐槽它=-=作为一个程序，美工基础不是很好，不过作为演示应该够了吧QwQ）\n\n接下来，把它放到/assets/graphrevo/textures/entities/frozen_magic.png，并且在mod代码中添加它的路径：\n/proxy/GRClientProps.java:\n在绑定贴图的时候，统一访问GRClientProps，这样管理起来也很方便。\n\n    public static final ResourceLocation \n        TEX_FROZEN_MAGIC = new ResourceLocation(\"graphrevo:textures/entities/frozen_magic.png\"); //贴图路径\n复制代码\n\n\n准备工作完成，那么接下来就是实际的渲染代码编写了~\n\n由于代码内容较多，再加上GL绘制语句的阅读方法稍有不同（你马上就会知道的），所以先把渲染器代码列出来，然后再对其中的细节逐个讲解吧：\n/client/render/RenderFrozen.java:\n\n    @Override\n    public void doRender(Entity entity, double x, double y, double z,\n            float f, float f1) {\n        Tessellator t = Tessellator.instance; //获取实例\n        TextureManager renderEngine = Minecraft.getMinecraft().renderEngine; //获取渲染引擎（读作TextureManager 233）\n        final double WIDTH = 1.0F, LENGTH = 2 * WIDTH; //实际上是半WIDTH和半LENGTH\n        \n        GL11.glPushMatrix(); //推栈\n        \n        renderEngine.bindTexture(GRClientProps.TEX_FROZEN_MAGIC); //绑定贴图\n        GL11.glDisable(GL11.GL_LIGHTING); //关闭光照\n        GL11.glEnable(GL11.GL_BLEND); //开启混合\n        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA); //混合模式设定\n        GL11.glDisable(GL11.GL_CULL_FACE); //关闭面剔除\n        \n        GL11.glTranslated(x, y, z); //位移到Entity位置\n        GL11.glRotatef(entity.rotationYaw, 0.0F, 1.0F, 0.0F); //横向旋转\n        GL11.glRotatef(-entity.rotationPitch, 1.0F, 0.0F, 0.0F);//上下旋转\n        \n        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240f, 240f); //光照相关\n        t.startDrawingQuads(); //开始绘制\n        t.setBrightness(15728880); //光照相关\n        \n        //典型的正交绘制方法，横向+纵向\n        t.addVertexWithUV(-WIDTH, 0, -LENGTH, 0.0, 0.0); //左上\n        t.addVertexWithUV(WIDTH, 0, -LENGTH, 0.0, 1.0); //左下\n        t.addVertexWithUV(WIDTH, 0, LENGTH, 1.0, 1.0); //右下\n        t.addVertexWithUV(-WIDTH, 0, LENGTH, 1.0, 0.0); //右上\n        \n        t.addVertexWithUV(0, -WIDTH, -LENGTH, 0.0, 0.0); //左上\n        t.addVertexWithUV(0, WIDTH, -LENGTH, 0.0, 1.0); //左下\n        t.addVertexWithUV(0, WIDTH, LENGTH, 1.0, 1.0); //右下\n        t.addVertexWithUV(0, -WIDTH, LENGTH, 1.0, 0.0); //右上\n        \n        t.draw();\n        \n        //恢复原本设定\n        GL11.glEnable(GL11.GL_CULL_FACE);\n        GL11.glEnable(GL11.GL_LIGHTING);\n        GL11.glDisable(GL11.GL_BLEND); \n        GL11.glPopMatrix(); //弹栈\n    }\n复制代码以上就是我们渲染器的最终代码。\n\n\n\n首先，我们为实际的绘制做了几个基本的准备工作……\n        Tessellator t = Tessellator.instance;\n        TextureManager renderEngine = Minecraft.getMinecraft().renderEngine;\n        final double WIDTH = 1.0F, LENGTH = 2 * WIDTH;\n复制代码第一个语句获取了着色器实例，方便后续绘制。\n第二个语句从MC实例中获取了渲染引擎，在后面的代码中会用它来绑定贴图。\n第三个语句则用两个final double常量定义了渲染特效在世界中的几何特征（长宽），方便之后的绘制。\n\n然后，开始实际的绘制……\n\nGL11.glPushMatrix();\n//...\nGL11.glPopMatrix();\n复制代码\n注意到，在实际的绘制代码前，我调用了glPushMatrix(), 在绘制后则调用了glPopMatrix()。顾名思义，这两个函数的作用分别是“推栈”和“弹栈”。GL使用栈的机制来管理渲染管线，当你Push以后，可以当做进入了一个子渲染块。在PushMatrix()和PopMatrix()之间，你对所有坐标所做的旋转、变换、缩放，都只对在这个子渲染块中进行的绘制有用。你可以当做PushMatrix和PopMatrix函数为你的绘制构建了一个定义域，让它的坐标变换只在定义域内起作用。调用glPopMatrix之后，这个”子渲染块“从栈中弹出，和其他的世界坐标一起，进行更高层次的坐标变换。\n\n*所有的实体、物品等的绘制代码都需要摆放在glPushMatrix()和glPopMatrix()之间。否则？自己试试看会有什么神奇的效果~\\(≧▽≦)/~\n\n然后，是对渲染内容的基本设定和预处理。\n        renderEngine.bindTexture(GRClientProps.TEX_FROZEN_MAGIC); //绑定贴图\n        GL11.glDisable(GL11.GL_LIGHTING); //关闭光照\n        GL11.glEnable(GL11.GL_BLEND); //开启混合\n        GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA); //混合模式设定\n        GL11.glDisable(GL11.GL_CULL_FACE); //关闭面剔除\n复制代码首先，我为当先绘制操作绑定贴图，然后关闭了GL光照。（魔法当然不需要随着黑夜降临变暗不是么？！）\n不过关闭GL光照还不足以让魔法一直发亮，因为MC还有一套自己的光照机制，在后文会有提到。\n通过glEnable(GL_BLEND)，我开启了贴图混合。所谓混合，也就是”透明“效果。它让png中的alpha通道得以激活，并且与后层的内容混合，体现出透明效果。如果不打开它，我们便会看见一坨不透明的迷の物体飞过（你够）。\n\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA) 则是设置了上下层的混合模式。其中第一个参数制定了源层（也就是我们的绘制层）的透明模式，第二个参数制定了目标层（背景层）的透明模式。\n这个函数有以下可用参数：\n\nGL_ONE 始终为1 （全颜色）\nGL_ZERO 始终为0 （无颜色）\nGL_SRC_COLOR 源像素的亮度值\nGL_SRC_ALPHA 源像素的ALPHA值\nGL_DST_COLOR 目标像素的亮度值\nGL_DST_ALPHA 目标像素的ALPHA值\nGL_ONE_MINUS_SRC_COLOR 1-源像素的亮度值\n……\n复制代码通过将源模式设置为GL_SRC_ALPHA, 目标模式设置为GL_ONE_MINUS_SRC_ALPHA，我们让贴图呈现出标准的透明效果。\n最后，我关闭了面剔除。在常见的绘制情况中，常有绘制的四边形只需要看见一面的情况（如：方块只需要看见外表面）。在这种情况，使用默认开启的面剔除，可以提高绘制效率，升高fps。在这里，因为两面都需要渲染，所以关闭了它。\n\n然后，是旋转和变换？\n        GL11.glTranslated(x, y, z); //位移到Entity位置\n        GL11.glRotatef(entity.rotationYaw, 0.0F, 1.0F, 0.0F); //横向旋转\n        GL11.glRotatef(-entity.rotationPitch, 1.0F, 0.0F, 0.0F);//上下旋转\n复制代码这三句代码，是对于绘制物体的变换函数。在后续代码的绘制中，我在（0, 0, 0）附近，绘制了两个面向Ｚ轴正方向，垂直相交的平面。通过这三个语句，两张正交贴图得以进行正常的旋转和唯一，渲染到我们需要的位置。\n你可能有疑问了：为什么需要先变换再绘制呢？这不合逻辑啊！实际上在OpenGL最终的调用中，确实是先进行的绘制，再进行的变换。其原因，还是由于OpenGL的栈。\n\n知识点：OpenGL的栈机制\n\n在绘制代码中，我们实际需要把绘制代码倒过来读。在这里，我的绘制顺序其实是这样的：\n调用着色器绘制->上下旋转->横向旋转->位移到Entity位置\n\n其原因，在于栈的存储机制。栈使用的是一种后进先出的存储。就像往装乒乓球的盒子里顺序塞乒乓球，我们拿出来的第一个球一定是我们最后装进去的那一个。在我们调用了绘制和变换函数之后，OpenGL把它们存储在栈中。在实际的绘制之中，再把它们倒着拿出来。这样，就造成了我们需要倒序进行代码的书写。\n\n\n在理解了绘制的顺序之后，剩下的工作也就水到渠成了。首先，我们使用mc的镶嵌器把贴图以矩形平面的形式绘制出来：\n\n        t.startDrawingQuads(); //开始绘制\n        t.setBrightness(15728880); //光照相关\n        \n        //典型的正交绘制方法，横向+纵向\n        t.addVertexWithUV(-WIDTH, 0, -LENGTH, 0.0, 0.0); //左上\n        t.addVertexWithUV(WIDTH, 0, -LENGTH, 0.0, 1.0); //左下\n        t.addVertexWithUV(WIDTH, 0, LENGTH, 1.0, 1.0); //右下\n        t.addVertexWithUV(-WIDTH, 0, LENGTH, 1.0, 0.0); //右上\n        \n        t.addVertexWithUV(0, -WIDTH, -LENGTH, 0.0, 0.0); //左上\n        t.addVertexWithUV(0, WIDTH, -LENGTH, 0.0, 1.0); //左下\n        t.addVertexWithUV(0, WIDTH, LENGTH, 1.0, 1.0); //右下\n        t.addVertexWithUV(0, -WIDTH, LENGTH, 1.0, 0.0); //右上\n        \n        t.draw();\n复制代码Tessellator.addVertexWithUV(double x, double y, double z, double u, double v)\n\n这个函数是绘制的核心函数，不过理解起来应该相当简单。\nx、y、z，是这个顶点对应的世界坐标。而u、v，是这个顶点对应的二维贴图坐标。\n\n关于三维顶点和二维贴图坐标的对应，见下图~\n\n\n\n\nuvaxis.jpg (11.94 KB, 下载次数: 24)\n\n下载附件\n\n2014-8-19 13:41 上传\n\n\n\n\n\n\n\n\n\n3daxis.jpg (12.08 KB, 下载次数: 28)\n\n下载附件\n\n2014-8-19 13:41 上传\n\n\n\n\n\n\n\n最后，进行上下的旋转变换……\nGL11.glRotatef(-entity.rotationPitch, 1.0F, 0.0F, 0.0F);//上下旋转\n关于glRotate函数：第一个参数angle是你所需要旋转的角度。而后三个参数，则代表的是旋转所围绕轴的向量坐标。比如在这里，代表的就是围绕X轴正方向，旋转-entity.rotationPitch度（顺时针）。对了，旋转围绕的是（0, 0, 0），也就是坐标原点，所以务必要先旋转再变换坐标哟~\n\n左右旋转变换……\n        GL11.glRotatef(entity.rotationYaw, 0.0F, 1.0F, 0.0F); //横向旋转\n注意，这里左右和上下旋转不能颠倒。想想为什么？\n\n最后，是空间坐标的位移……\nGL11.glTranslated(x, y, z);\nglTranslate(x, y, z) 这个函数应该相当容易理解了。它将当前绘制的所有坐标位移(x, y, z)个单位。在这里，x、y、z是由MC传入，代表实体与玩家位置的相对坐标。\n\n第四步：大工告成!\n在进行了所有的工作以后，我们的渲染器终于完成了！打开游戏试一试效果吧！\n\n\n\n\n2013-12-11_20.32.31.jpg (31.35 KB, 下载次数: 24)\n\n下载附件\n\n2013-12-12 13:49 上传\n\n\n\n\n走你=w=\n\n\n\n\n\n2013-12-11_20.36.36.jpg (11.28 KB, 下载次数: 28)\n\n下载附件\n\n2013-12-12 13:49 上传\n\n\n\n\n\n晚上的话更漂亮哟~~\n\n由于是渲染有关的第一篇教程，所以对各种基本概念做了比较详细的叙述，希望没有让你嫌烦呢……QwQ\n实际上，这种正交绘制的方法效果不是很好。在某些角度，我们的魔法实体几乎无法被看见。在之后，我会努力向大家介绍更多的渲染方法，比如说使用代码渲染球体，动态尾烟，粒子特效……在几章之后，我们会回到这一个冰之法杖，并且将它的特效更加完善。\n那么，这就是整篇教程的结束了，希望你能在这篇教程中有所收获。谢谢！~\\(≧▽≦)/~\n\n附：本次教程Commit地址",
    "replies": [
        {
            "author": "719_Lokii",
            "timestamp": 1386589020,
            "txt_content": "啊啊啊，图挂了，虽然我知道代码才是本帖的重要部分、\n"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1386589020,
            "txt_content": "719220502 发表于 2013-12-9 19:37 \n啊啊啊，图挂了，虽然我知道代码才是本帖的重要部分、\n还没上图呢0w0请稍等片刻"
        },
        {
            "author": "Aikawastep",
            "timestamp": 1386589740,
            "txt_content": "{:10_566:}← ←正好最近想学[求第1章地址OLO]"
        },
        {
            "author": "ali16",
            "timestamp": 1386589800,
            "txt_content": "不错 赞一个……{:10_495:}"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1386589920,
            "txt_content": "Aikawastep 发表于 2013-12-9 19:49 \n← ←正好最近想学[求第1章地址OLO]\n教程1那里直接加了超链接的说www，系列目录里应该也有"
        },
        {
            "author": "Aikawastep",
            "timestamp": 1386589980,
            "txt_content": "DeathWolf96 发表于 2013-12-9 19:52 \n教程1那里直接加了超链接的说www，系列目录里应该也有\n{:10_566:}围观去~"
        },
        {
            "author": "zero28",
            "timestamp": 1386647580,
            "txt_content": "跳啊跳啊的到了重点部分发现是待续"
        },
        {
            "author": "simon3000",
            "timestamp": 1386658980,
            "txt_content": "看不懂啊看不懂\n一点都看不懂"
        },
        {
            "author": "simon3000",
            "timestamp": 1386661380,
            "txt_content": "飞翔的雪块~~~"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1386827160,
            "txt_content": "完工走你。。还有一张图等过段时间补上0w0"
        },
        {
            "author": "WYSIWYG",
            "timestamp": 1387006380,
            "txt_content": "新手学习了，谢谢楼主分享。"
        },
        {
            "author": "DeathWolf96",
            "timestamp": 1387601460,
            "txt_content": "由于之前的长期脑卡所以把Tessellator错译成了“着色器”，实际上应该是“镶嵌器”，请民那桑务必注意T^T"
        },
        {
            "author": "mamacmm",
            "timestamp": 1388210940,
            "txt_content": " 本帖最后由 mamacmm 于 2013-12-28 14:10 编辑 \n\n自己编译后，用法杖往水里右键，如下图，在水中的效果。。速度好慢哦\n\n\n\n\n\n20131228140347.jpg (7.47 KB, 下载次数: 0)\n\n下载附件\n\n2013-12-28 14:07 上传\n\n\n\n\n\n"
        },
        {
            "author": "AG3",
            "timestamp": 1389170400,
            "txt_content": "可以留个联系方式么~~谢谢大大！"
        },
        {
            "author": "kehebai",
            "timestamp": 1392731520,
            "txt_content": "好吧，支持一下~~~"
        },
        {
            "author": "grady栗",
            "timestamp": 1456422960,
            "txt_content": "太酷了，这篇教程真的太有帮助了"
        },
        {
            "author": "~~末影少女-_-",
            "timestamp": 1486026660,
            "txt_content": "请问lz怎么使子弹能够被透视。。。\n我试过glclear，结果水也被透视了"
        },
        {
            "author": "wangzhaoyang",
            "timestamp": 1590148800,
            "txt_content": "哈哈哈哈哈哈哈哈哈"
        },
        {
            "author": "wangzhaoyang",
            "timestamp": 1590148860,
            "txt_content": "先这样做 在那样做 你学废了吗"
        }
    ]
}