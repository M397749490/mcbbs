{
    "title": "指令方块自定烟花，烟花色彩RGB转DEC数值（140种）",
    "author": "DomJackson",
    "replyCount": 10,
    "timestamp": 1430488680,
    "txt_content": " 本帖最后由 DomJackson 于 2015-5-1 22:21 编辑 \n\n           这几天正做跑酷地图，正好用到指令方块发射烟花，所以研究了几天后写出这个帖子（刚才发错版块被删了一次···哭！）\n         我发这个帖子是在看了   PotatoMaster101  的（MC1.7：指令方块自定义烟花教程    http://www.mcbbs.net/thread-212751-1-1.html）后有了发个帖子的想法！希望能给新手们带来帮助（因为我是新手），高手们就不用再去计算了！呵呵！\n\n以下是具体内容：\n\n计算格式：B+256*G+65536*R = x         PotatoMaster101在他的帖子里提供的\n\n指令方块自定义烟花色彩RGB转换DEC数值：\n\n\n\n\n\n\n\n\n\n\n\n\n各种颜色的演示（可能会少几个）到网盘里下吧！\n\n\nhttp://pan.baidu.com/s/1qWp3FrQ\n\n\n\n下面这段是我改的一段代码（彩虹烟花）\n<font size=\"2\">/summon FireworksRocketEntity ~ ~4 ~ {LifeTime:20,FireworksItem:{id:401,Count:1,tag:{Fireworks:{Explosions:[\n{Flicker:10000,Trail:0,Type:1,Colors:[14423100],FadeColors:[14423100]},\n{Flicker:10000,Trail:0,Type:1,Colors:[255],FadeColors:[255]},\n{Flicker:10000,Trail:0,Type:1,Colors:[65280],FadeColors:[65280]},\n{Flicker:10000,Trail:0,Type:1,Colors:[16776960],FadeColors:[16776960]},\n{Flicker:10000,Trail:0,Type:1,Colors:[65535],FadeColors:[65535]},\n{Flicker:10000,Trail:0,Type:1,Colors:[16753920],FadeColors:[16753920]},\n{Flicker:10000,Trail:0,Type:1,Colors:[8388736],FadeColors:[8388736]}]}}}}</font>复制代码最后把我计算用的Excel表分享一下，如果我算错了大家可以自己算算！\n\n\n\n\n\n\n\n\n\n\n我的世界烟花颜色对照表.zip\n\n\n2015-5-1 22:21 上传\n点击文件名下载附件\n\n\n\n\n515.87 KB, 下载次数: 67\n\n\n这里是个Excel表\n\n\n",
    "replies": [
        {
            "author": "cyqsimon",
            "timestamp": 1430493300,
            "txt_content": "支持支持！顺便宣传一下我当年做的烟花自定义小工具吧哈哈哈（算半个黑历史吧），配合使用效果更佳哦"
        },
        {
            "author": "DomJackson",
            "timestamp": 1430530800,
            "txt_content": "cyqsimon 发表于 2015-5-1 23:15\n支持支持！顺便宣传一下我当年做的烟花自定义小工具吧哈哈哈（算半个黑历史吧），配合使用效果更佳哦 ...\n我这小帖子对于  腐竹  来说是小巫见大巫了！"
        },
        {
            "author": "Linyb25",
            "timestamp": 1443233220,
            "txt_content": "太高能了，我不懂啊"
        },
        {
            "author": "andylizi",
            "timestamp": 1443253980,
            "txt_content": "，呃，这个  B+256*G+65536*R = pixel 的计算公式虽然没错，但是并不是标准的，其实在程序代码里的表现形式为：\npixel = (r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF) << 0);复制代码\n不过我知道你什么也没看懂。。\n哎呀，你那个计算方法也可以啦，所以这不重要A.A\n不过，我想到，DEC颜色不只是有rgb，还有一个a(alpha，透明度)值，如果mc支持透明度，那么是不是可以做出透明的烟花？。。。\n如果加上透明度，那么计算公式会变为：\npixel = ((a & 0xFF) << 24 | (r & 0xFF) << 16 | (g & 0xFF) << 8 | (b & 0xFF) << 0);复制代码\n以我们能看懂的计算公式就是：\npixel = B+256*G+65536*R+4294967296*A\n呃，我似乎说了一堆废话\n好吧 请无视"
        },
        {
            "author": "DomJackson",
            "timestamp": 1444793400,
            "txt_content": "andylizi 发表于 2015-9-26 15:53\n，呃，这个  B+256*G+65536*R = pixel 的计算公式虽然没错，但是并不是标准的，其实在程序代码里的表现形式 ...\n不是废话哇！很高能呦！{:10_520:}"
        },
        {
            "author": "chyx",
            "timestamp": 1444903140,
            "txt_content": " 本帖最后由 chyx 于 2015-10-15 18:04 编辑 \nandylizi 发表于 2015-9-26 15:53\n，呃，这个  B+256*G+65536*R = pixel 的计算公式虽然没错，但是并不是标准的，其实在程序代码里的表现形式 ...\n我是不懂编程的 但看你的式子怎么就像是把这三个值前两个左移再连在一起的感觉\n我有一点不明白 0xFF是什么？&和|像是按位与和或的感觉"
        },
        {
            "author": "andylizi",
            "timestamp": 1444906440,
            "txt_content": "chyx 发表于 2015-10-15 17:59\n我是不懂编程的 但看你的式子怎么就像是把这三个值前两个左移再连在一起的感觉\n我有一点不明白 0xFF是什么 ...\n\n对 没错，就是把这三个值前两个左移再连在一起\n比如说\n有一个颜色，它的\nR，的二进制表示是0011\nB，的二进制表示是1001\nG，的二进制表示是0100\n\n然后通过这个方法组合\n组合完毕后，二进制表示是\n0000 0011 1001 0100\n（前4位是透明度）\n这样就把3个数连接在一起了，但是转化为十进制得到的数字谁也看不懂A.A\n然后需要的时候再拆开\n使用按位与和或的原因是，它们可以取出二进制数字的一部分\n-------------------------------------\n比如说，原来R是0000 0000 0000 0011，它只要后面那一部分（4位二进制也就是0~255，这就是为什么这个方法不能操纵过大数字的原因），G是0000 0000 0000 1001，但R应该要变成0011 0000 0000 0000（就是把它移到前面），所以得使用左移运算符<<，移动16位，就到了指定位置。\n然后G呢，它要变成0000 0000 1001 0000，于是<<8位\nB它本来就是在最后面的（0000 0000 0000 0100），不需要移动\n\n然后把R的0000 0011 0000 0000和G的0000 1001 0000 0000和B的0000 0000 0000 0100给按位或|\n（也就是只要3个二进制中，某一位为1，结果就为1），就变成了\n0000 0011 1001 0100\n组合了吧？\n--------------------------------------\n然后不光是要组合，还要拆开：\n使用\n0000 0000 0000 1111 （这就是你刚刚说的0xFF的二进制表现）\n和\n0000 0011 1001 0100\n进行按位与&（只有两个参数的二进制位都为1，结果的二进制位才为1）\n就能取出\n0000 0000 0000 0100\n为什么前面的A，R，G没了呢？因为刚刚是跟0000 0000 0000 1111进行按位与，只会保留后四位。这就是为什么一定要使用0xFF的原因。\n然后A，R，G以此类推，不过呢，比如G它按刚刚的方法进行按位与后，得到的是0000 0000 1001 0000，还需要再左移8位，才能得到原来的0000 0000 0000 1001\n\n看得懂吧？。。"
        },
        {
            "author": "chyx",
            "timestamp": 1444911240,
            "txt_content": "andylizi 发表于 2015-10-15 18:54\n对 没错，就是把这三个值前两个左移再连在一起\n比如说\n有一个颜色，它的\n你说的我已经猜到了 不过为何0xff是1111？"
        },
        {
            "author": "andylizi",
            "timestamp": 1444911420,
            "txt_content": "chyx 发表于 2015-10-15 20:14\n你说的我已经猜到了 不过为何0xff是1111？\n0xFF是十六进制，转二进制就是1111"
        },
        {
            "author": "WinHD",
            "timestamp": 1444999200,
            "txt_content": "{:10_521:}"
        }
    ]
}