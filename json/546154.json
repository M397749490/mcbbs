{
    "title": "红石计算器简化方案 01-全/半加器",
    "author": "TSStudio",
    "replyCount": 5,
    "timestamp": 1453762740,
    "txt_content": " 本帖最后由 20050811 于 2016-1-26 07:01 编辑 \n\n大家看到 在http://www.mcbbs.net/thread-493558-1-1.html这个帖子 半加器的体积是非常大的 因为全加器是两个半加器 所以只讲半加器 半加器是由一个XOR gate(异或门)和一个AND gate(同或门)组成的 怎么缩小异或门呢 这里给出一种方案\n\n\n\n\n\n\n\n\n注意此时的输出应加一个非门才是异或门 不加是同或门\n\n\n\n\n\n再建一个 异或门和以前一样 与门不一样请注意：\n\n\n\n\n\n\n\n\n\n这样就OK了 \n最后一张图上面是输出 下面是输入 输入从左到右Ci:上一位的进位 A:输入1 B:输入2\n输出从左到右\nA:输出 C:进位 用于连接下一位的Ci\n拓展阅读:\n最早的CPU的原理\n\n现代CPU无法在MC实现\n最早CPU只会算加法 就像上面的加法器 减法是补码做到的\n\n如:\n1-1\n=1+(-1)\n负数怎么表示:先确定计算器是几位元的 就是1Byte(字节)=多少Bit(一个二进制位)自行百度 Bit的数量X8就是多少位元.\n确定是64位元 应1Byte=8bit OK 8位\n负数的最前面一位是1 正数是0\n-1就是10000001\n00000001+10000001\n(众人:这根本不等于零)\n别喷 计算另有方法\n负数除最前面的一位 取反 是11111110 再加1 11111111+00000001=00000000\n聪明人发现了 11111111+00000001根本不等于0\n是100000000 但是已确定是八位所以这个计算机发生了一个溢出错误 但是结果是对的\n\n乘法:\n复习一下小学数学:比如我们要算2x2 换到二进制就是10x10 怎么算呢 看竖式\n       10\n     x10\n ----------\n         0\n(+)10\n------------\n     100\n只是移位 把10移到了下一位 再相加 也是基于加法\n\n除法:\n一位一位比大小 大了 就在对应位的商输出1 然后减法输出结果给下一位 (减法也是用补码在做加法)\n到了(1)位 无法再比 直接输出余数\n\n",
    "replies": [
        {
            "author": "nianbing",
            "timestamp": 1453762980,
            "txt_content": "{:10_492:}到处都是大触，我这红石渣红石仰望就好"
        },
        {
            "author": "雷地嘎嘎",
            "timestamp": 1453767480,
            "txt_content": "我记得这个帖子在哪里看过，百度贴吧里面的"
        },
        {
            "author": "日常收小麦",
            "timestamp": 1453774800,
            "txt_content": "到处都是大神。红石渣飘过"
        },
        {
            "author": "719823597",
            "timestamp": 1453779660,
            "txt_content": "这种设计和现在常用的不是一个时代的"
        },
        {
            "author": "一只深沉",
            "timestamp": 1453786560,
            "txt_content": "花瓶触的东西直接搬过来了吗XD实际上并不用再反向，两个nxor和l两个XOR的效果是一样的XD"
        }
    ]
}