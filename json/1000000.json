{
    "title": "[搬运+翻译][从零学编程]C++Ⅵ：再谈类",
    "author": "45gfg9",
    "replyCount": 34,
    "timestamp": 1585385100,
    "txt_content": " 本帖最后由 45gfg9 于 2020-8-31 17:01 编辑 \n\n\n索引贴\n答案帖\nPrev: C++Ⅴ：类与对象\nNext: C++Ⅶ：继承 & 多态\n\n\n\n1 为类创建单独文件\n\n1.1 创建新类\n\n一般地，在单独的文件里定义你要用的新类是好习惯。这会让维护和阅读代码更简单。\n要这样做的话，在CodeBlocks中这样做：\n点击File->New->Class...\n给你的新类起个名，取消选择\"Has destructor\"并选择\"Header and implementation file shall be in same folder\"，然后点击\"Create\"按钮。\n\n\n注意到有两个新文件已经添加到你的项目了：\n\n新文件就是我们新类的模板。MyClass.h是头文件。MyClass.cpp是源文件。\nPart题：\n通常，哪两个文件定义一个类？\nA. 头文件和主文件\nB. 类文件和源文件\nC. 头文件和源文件\nD. 头文件和体文件\n\n1.2 源文件 & 头文件（一）\n\n头文件 (.h) 包含了函数声明（原型）和变量声明。\n它现在包含我们新的MyClass类的模板，有一个默认构造函数。\nMyClass.h\n#ifndef MYCLASS_H\n#define MYCLASS_H\n\nclass MyClass\n{\n  public:\n    MyClass();\n  protected:\n  private:\n};\n\n#endif // MYCLASS_H\n类的实现和方法体放在源文件 (.cpp) 中。\n目前它只包括一个空的构造函数。\nMyClass.cpp\n#include \"MyClass.h\"\n\nMyClass::MyClass()\n{\n   //ctor\n}\n头文件中的#ifndef和#define语句接下来的课程讲。\nPart题：\n头文件作用是？\nA. 函数原型和变量声明\nB. 只有构造函数\nC. 函数源码\nD. 什么都没有\n\n1.3 作用域解析运算符\n\n源文件 (.cpp) 中的双冒号叫做[ruby=Scope Resolution Operator]作用域解析运算符[/ruby]，在构造函数的定义中有用到：\n#include \"MyClass.h\"\n\nMyClass::MyClass()\n{\n   //ctor\n}\n作用域解析运算符用来定义一个特定的类的已经声明了的成员函数。记住，我们在头文件中定义构造函数原型。\n所以基本上讲，MyClass::MyClass()指的是MyClass()成员函数——或者在本例中，MyClass类的构造函数。\nPart题：\n用选项填空，创建一个属于demo类的函数test。\n______ :: ______ ()\n{\n}\ntest        class        make        function        demo\n\n1.4 源文件 & 头文件（二）\n\n要在main中使用我们的类的话，我们需要包含头文件。\n\n举例，如果在main中用我们新创建的MyClass：\n#include <iostream>\n#include \"MyClass.h\"\nusing namespace std;\n\nint main() {\n  MyClass obj;\n}\n头文件声明了类（或者不管实现的是什么）会\"做什么\"，而cpp源文件定义了它\"如何做\"。\nPart题：\n要使用类，main.cpp中要包含什么？\nA. 类的源文件\nB. 源文件和头文件都要\nC. 类的头文件\n\n\n2 析构函数\n\n2.1 析构函数（一）\n\n还记得构造函数么？它们是当对象被创建时调用的特殊成员函数。\n[ruby=Destructors]析构函数[/ruby]也是特殊函数。它们会在当对象被销毁或删除时调用。\n对象在离开定义域时会被销毁，或者将delete表达式应用到指向这个类对象的指针时会被删除。\nPart题：\n下面关于C++中构造函数和析构函数的表述中，哪条正确？\nA. 构造函数在对象被创建时调用；析构函数当其被删除时调用\nB. 构造函数在当对象被删除时调用\nC. 析构函数在当对象被创建时调用\n\n2.2 析构函数（二）\n\n析构函数的名字也与类名一致，只是有一个波浪号 (~)前缀。析构函数不能返回值，也不能有参数。\nclass MyClass {\n  public: \n    ~MyClass() {\n     // some code\n    }\n};\n析构函数在程序中释放资源时非常有用。这可以包括关闭文件、释放内存等等。\nPart题：\n什么是析构函数符号？\n\n2.3 析构函数（三）\n\n举个例子，我们来给我们的MyClass类声明一个析构函数，在MyClass.h头文件中：\nclass MyClass\n{\n  public:\n   MyClass();\n   ~MyClass();\n};\n这个我们的MyClass类声明了一个析构函数。\nPart题：\n用选项填空，给MyClass类声明一个析构函数。\nclass MyClass {\npublic:\n  MyClass();\n  ______;\n};\n~MyClass()        destructor()        !MyClass()        MyClass~~\n\n2.4 析构函数（四）\n\n在头文件中声明析构函数之后，我们可以在源文件MyClass.cpp中写实现了：\n#include \"MyClass.h\"\n#include <iostream>\nusing namespace std;\n\nMyClass::MyClass()\n{\n  cout<<\"Constructor\"<<endl;\n}\n\nMyClass::~MyClass()\n{\n  cout<<\"Destructor\"<<endl;\n}\n注意到我们使用了<iostream>头文件，以来使用cout。\n\nPart题：\n用选项填空，给类MyClass声明一个析构函数，其向屏幕输出文字。\nMyClass:: ______ {\n  ______ ______ \"some text\";\n}\n>>        cout        ~MyClass()        <<        destructor\n\n2.5 析构函数（五）\n\n因为析构函数不能有参数，所以其不能被重载。\n每个类只会有一个析构函数。\n析构函数不是必须的；如果不需要用就可以不用定义。\nPart题：\n下面的表述哪些正确？\nA. 析构函数不能重载\nB. 析构函数永远返回double\nC. 析构函数不能有任何参数\nD. 析构函数无名称\n\n2.6 析构函数（六）\n\n回到main吧。\n#include <iostream>\n#include \"MyClass.h\"\nusing namespace std;\n\nint main() {\n  MyClass obj;\n\n  return 0;\n}\n我们包含了类的头文件并创建了那个类型的对象。这会有如下输出：\nConstructor\nDestructor\n程序运行时，它先创建一个对象并调用构造函数。程序执行完成后，对象被销毁，析构函数被调用。\n我们在构造函数中输出了\"Constructor\"，在析构函数中输出了\"Destructor\"。\nPart题：\n析构函数...\nA. ...在对象被删除时调用\nB. ...在构造函数没有被调用时调用\nC. ...是成员变量\n\n\n3 箭头成员运算符\n\n3.1 #ifndef & #define\n\n我们给我们的类创建了单独的头文件和源文件，头文件如下：\n#ifndef MYCLASS_H\n#define MYCLASS_H\n\nclass MyClass\n{\n  public:\n  MyClass();\n  protected:\n  private:\n};\n\n#endif // MYCLASS_H\nifndef意味[ruby=if not defined]如果没有被定义[/ruby]。第一对语句告诉程序，如果还未定义MyClass头文件，就定义它。\nendif结束这个条件。\n这会防止同一个头文件被包含超过一次。\nPart题：\n#ifndef和#define语句的意图是什么？\nA. 让程序跑得更快\nB. 防止同一头文件在一个文件内被包含多于一次\nC. 是std命名空间的需要\n\n3.2 成员函数\n\n我们来给类创建一个示例函数myPrint()。\nMyClass.h\nclass MyClass\n{\n  public:\n   MyClass();\n   void myPrint();\n};\nMyClass.cpp\n#include \"MyClass.h\"\n#include <iostream>\nusing namespace std;\n\nMyClass::MyClass() {\n}\n\nvoid MyClass::myPrint() {\n  cout <<\"Hello\"<<endl;\n}\n因为myPrint()是普通成员函数，所以在声明和定义中都必须标注其返回类型。\nPart题：\n用选项填空，在Sally类中创建myPrint函数原型。\n______ Sally {\n______ :\n  Sally();\n  void ______ ();\n};\npublic        myPrint        function        class        prototype\n\n3.3 点运算符\n\n接着来创建一个MyClass类型的对象，然后用点 (.) 运算符调用其myPrint()函数：\n#include \"MyClass.h\"\n\nint main() {\n  MyClass obj;\n  obj.myPrint();\n}\n\n// 输出 \"Hello\"\n\nPart题：\n用选项填空，声明一个Sally类对象，并用点 (.) 运算符调用其myPrint成员函数。\nint main() {\n  ______ obj;\n  ______ . ______;\n}\nclass        obj        myPrint()        dot        Sally\n\n3.4 指针（四）\n\n我们也可以用指针访问对象成员。\n下面的指针指向obj对象。\nMyClass obj;\nMyClass *ptr = &obj;\n指针类型是MyClass，其指向那个类型的对象。\nPart题：\n填空声明一个指向obj的指针：\nSally obj;\nSally _ sallyPtr = _ obj;\n\n\n3.5 箭头成员运算符\n\n[ruby=arrow member selection operator]箭头成员选择运算符[/ruby]用于用指针访问对象成员。\nMyClass obj;\nMyClass *ptr = &obj;\nptr->myPrint();\n当使用对象时，用点成员选择运算符 (.)。\n当使用指向对象的指针时，使用箭头成员选择运算符 (->)。\nPart题：\n填上缺失的箭头运算符来通过sallyPtr调用myPrint()函数。\nSally obj;\nSally *sallyObj = &obj;\nsallyPtr __ myPrint();\n\n\n\n4 常量对象\n\n4.1 常量\n\n常量是有固定值的表达式。在程序运行时，它不能被改变。\n用const关键字定义常量。\nconst int x = 42;\n任何常量都必须在创建时初始化。\nPart题：\n填空声明double类型的常量var。\n_____ double ___ = 3.4;\n\n\n4.2 常量对象（一）\n\n如内置类型一样，我们也可以用const关键字创建常量对象。\nconst MyClass obj;\n所有的const变量都必须在创建时初始化。对类而言，初始化由构造函数完成。如果函数不是用带参构造函数创建的，那么必须提供一个公有默认构造函数——如果没有提供公有默认构造函数，则会产生编译错误。\n\n当const对象通过构造函数创建时，你不能修改对象的成员变量。这既包括对public成员变量的修改，也包括通过成员函数修改成员变量。\n当你用const声明对象时，在对象生命期内无法改变其数据成员。\nPart题：\n用选项填空，声明一个Student类型的对象st，并调用其printAge()函数。\n______ st;\nst. ______;\n~Student        class        st        Student        printAge()\n\n4.3 常量对象（二）\n\n只有非const对象才能调用非const函数。\n一个常量对象无法调用普通函数。因此，要使用常量对象，必须需要一个常量函数。\n\n要声明一个函数为const成员，函数原型的右圆括号后，必须跟const关键字。对于那些在类定义外定义的const成员函数，const关键字必须在函数原型和定义中都要有。举例：\nMyClass.h\nMyClass.h\nclass MyClass\n{\n  public:\n    void myPrint() const;\n};\nMyClass.cpp\n#include \"MyClass.h\"\n#include <iostream>\nusing namespace std;\n\nvoid MyClass::myPrint() const {\n  cout <<\"Hello\"<<endl;\n}\n现在myPrint()函数是一个常成员函数了。既然如此，我们的常量对象可以调用它了：\nint main() {\n  const MyClass obj;\n  obj.myPrint();\n}\n// 输出 \"Hello\"\n\nPart题：\n填上缺失的关键字，为Student类声明一个常成员函数printAge()。\n_____ Student {\npublic:\n  void printAge() _____ ;\n};\n\n\n4.4 常量对象（三）\n\n尝试在常量对象内调用普通函数会产生错误。\n另外，当任何const成员函数尝试改变成员变量或调用非const成员函数时产生编译错误。\n定义常量对象和常函数确保对应的数据成员不会被意外修改。\nPart题：\n常成员函数...\nA. ...不能被调用\nB. ...能修改非const数据成员\nC. ...不能修改任何非const数据成员\n\n\n5 成员初始化\n\n5.1 成员初始化（一）\n\n回忆一下，常量是值无法改变的变量，所有const变量都必须在创建时初始化。\n\nC++提供了一种顺手的语法用来初始化类成员，叫做[ruby=member initializer list]成员初始化列表[/ruby]（也叫[ruby=constructor initializer]构造函数初始化器[/ruby]）。\n\nPart题：\n常量...\nA. ...必须不被初始化\nB. ...不能被改变\nC. ...能被修改\n\n5.2 成员初始化（二）\n\n考虑下面的类：\nclass MyClass {\n  public:\n   MyClass(int a, int b) {\n    regVar = a;\n    constVar = b;\n   }\n  private:\n    int regVar;\n    const int constVar;\n};\n此类有两个成员变量，regVar和constVar。它也有一个构造函数接受两个参数，用于初始化成员变量。\n运行此代码会产生错误，因为它其中的一个成员变量是常量，不能在声明后改变值。\n\n在这种例子中，成员初始化列表能用来给成员变量赋值。\nclass MyClass {\n public:\n  MyClass(int a, int b)\n  : regVar(a), constVar(b)\n  {\n  }\n private:\n  int regVar;\n  const int constVar;\n};\n注意到上面语法，初始化列表跟着构造函数形参。列表由冒号 (:) 开始，接着列出了要初始化的变量和要赋的值，以逗号分隔。\n用语法变量(值)赋值。\n初始化列表消除了在构造函数体内显式赋值的必要。而且，初始化列表不需以分号结束。\nPart题：\n你有一个类Student，有两个成员age和num。填空用对应的值在构造函数初始化器中初始化成员。\nStudent::Student(int a, int b)\n  _ age(a),\n    ___ (b) {\n}\n\n\n5.3 成员初始化（三）\n\n让我们用独立头文件和源文件重写前例。\nMyClass.h\nclass MyClass {\n  public:\n   MyClass(int a, int b);\n  private:\n   int regVar;\n   const int constVar;\n};\nMyClass.cpp\nMyClass::MyClass(int a, int b)\n: regVar(a), constVar(b)\n{\n  cout << regVar << endl;\n  cout << constVar << endl;\n}\n我们在构造函数中添加了cout语句来输出成员变量的值。\n下一步就是在main创建一个我们类的对象，并用构造函数赋值。\n#include \"MyClass.h\"\n\nint main() {\n  MyClass obj(42, 33);\n}\n\n/*输出\n42\n33\n*/\n构造函数用于创建对象，通过成员初始化列表用形参给成员变量赋值。\nPart题：\n用选项填空，在构造函数初始化列表中初始化成员，然后在构造函数体内输出。\nStudent:: ______ (int a, int b)\n  : regVar(a),\n    constVar(b)\n{  cout << ______ <<\n  constVar ______ endl;\n}\nregVar        ::        <<        >>        Student\n\n5.4 成员初始化（四）\n\n成员初始化列表可以用在普通变量上，必须用在常量上。\n即使成员变量不是常量，用成员初始化语法也很有用。\nPart题：\n常成员变量...\nA. ...必须在构造函数体内初始化\nB. ...必须在构造函数初始化列表中初始化\nC. ...怎么初始化随你\n\n\n6 组合（第一部分）\n\n6.1 组合（一）\n\n在现实生活中，复杂对象基本是用更小更简单的对象建造的。举例，一辆车用金属框架、引擎、轮胎，和大量其他部件组装。这个过程叫[ruby=composition]组合[/ruby]。\n\n在C++中，对象组合是通过将类作为其他类的成员而完成的。\n这个示例程序演示了组合的使用。它包含Person和Birthday类，每个Person都会有一个Birthday对象作为其成员。\nBirthday:\nclass Birthday {\n public:\n  Birthday(int m, int d, int y)\n  : month(m), day(d), year(y)\n  { \n  }\n private:\n   int month;\n   int day;\n   int year;\n};\n我们的Birthday类有三个成员变量。它也有通过成员初始化列表初始化成员的构造函数。\n为了简洁，这个类在单文件中声明。你也可以分开源文件和头文件。\nPart题：\n填空在构造函数初始化列表中初始化Birthday类成员。\nBirthday::Birthday(int m, int d, int y)\n  _ month(m),\n  day(d),\n  year( _ )\n{\n}\n\n\n6.2 组合（二）\n\n让我们给Birthday类也加一个printDate()函数。\nclass Birthday {\n public:\n  Birthday(int m, int d, int y)\n  : month(m), day(d), year(y)\n  {\n  }\n  void printDate()\n  {\n   cout<<month<<\"/\"<<day\n   <<\"/\"<<year<<endl;\n  }\n private:\n  int month;\n  int day;\n  int year;\n};\n这给我们的Birthday类添加了printDate()函数。\nPart题：\n用选项填空，创建类People，有三个私有整型成员：birthMonth，birthDay，birthYear。\nclass ______ {\npublic:\n  People();\n______\n  int ______ ;\n  int birthDay;\n  ______ birthYear;\n};\npublic        People        private:        int        birthMonth        var\n\n6.3 组合（三）\n\n接着，我们可以创建Person类了，其包含Birthday类。\n#include <string>\n#include \"Birthday.h\"\n\nclass Person {\n public:\n  Person(string n, Birthday b)\n  : name(n),\n   bd(b)\n  {\n  }\n private:\n  string name;\n  Birthday bd;\n};\nPerson类有name和Birthday成员，和一个初始化它们的构造函数。\n确保包含了对应的头文件。\n下一节继续讲组合！\nPart题：\n用选项填空，声明People类，有两个私有成员：类型string的name和类型Birthday的dateOfBirth。别忘记包含string类型的头文件和Birthday.h。\n#include < ______ >\n#include \" ______ \"\nclass ______ {\npublic:\n People(string n, Birthday bo);\nprivate:\n string name;\n ______ dateOfBirth;\n};\nBirthday.h        Birthday        People        string\n\n\n7 组合（第二部分）\n\n7.1 组合（四）\n\n现在，我们的Person类有Birthday类的成员了：\nclass Person {\n public:\n  Person(string n, Birthday b)\n  : name(n),\n    bd(b)\n  {\n  }\n private:\n  string name;\n  Birthday bd;\n};\n组合常被用在有包含关系的对象上，如“[ruby=Person]人[/ruby]有[ruby=Birthday]生日[/ruby]”。\nPart题：\n填空声明People的构造函数，接受两个参数并初始化其私有成员：name和dateOfBirth。\nPeople::People(string x, Birthday bo)\n  _ name( _ ), dateOfBirth(bo)\n{\n}\n\n\n7.2 组合（五）\n\n让我们来给Person类添加一个printInfo()函数，输出对象的数据：\nclass Person {\n public:\n  Person(string n, Birthday b)\n  : name(n),\n  bd(b)\n  {\n  }\n  void printInfo()\n  {\n   cout << name << endl;\n   bd.printDate();\n  }\n private:\n  string name;\n  Birthday bd;\n};\n注意到我们可以调用成员bd的printDate()函数，因为它是Birthday类型，且定义了那个函数。\nPart题：\n用选项填空，定义printInfo()函数，输出[ruby=\"People's\"]“人”的[/ruby][ruby=name]姓名[/ruby]和[ruby=birthdate]生日[/ruby]，用dateOfBirth的printDate()函数。\nvoid People:: ______ () {\n  cout << name << endl;\n  ______ . ______ ();\n}\nprintDate        const        printInfo        dateOfBirth        class\n\n7.3 组合（六）\n\n现在我们有了Birthday类和Person类，可以去main，创建一个Birthday对象，并传给Person对象了。\nint main() {\n  Birthday bd(2, 21, 1985);\n  Person p(\"David\", bd);\n  p.printInfo();\n}\n\n/*输出\nDavid\n2/21/1985\n*/\n我们创建了Birthday对象，代表日期1985年2月21日。接着，我们创建了一个Person对象，并将Birthday对象传给其构造函数。最终，我们用Person对象的printInfo()函数输出其数据。\n一般来说，组合旨在将每个类保持得相对简单明了，只执行一项任务。这也允许每个子对象变得自包含，确保了重用性（我们可在其他类中使用Birthday类）。\nPart题：\n用选项填空，声明一个People类型的对象，其接受一个字符串作为第一个参数，一个Birthday对象作为第二个参数。在传递给People构造函数前，声明一个Birthday对象birthObj。\n______ birthObj(10, 30, 1989);\nPeople john(\"John\", ______ );\nbirthObj        Birthday        string        class        People\n\n\n8 friend关键字\n\n8.1 友元函数（一）\n\n通常，一个类的私有成员不能被其外界访问。\n然而，声明一个非成员函数为类的[ruby=friend]友元[/ruby]允许它访问这个类的私有成员。这是通过在类中包含一个这个外部函数的声明，并用friend关键字放在声明前来达成的。\n下例中，someFunc()，不是类的成员函数，是MyClass的友元，可以访问其私有成员。\nclass MyClass {\n public:\n  MyClass() {\n   regVar = 0;\n  }\n private:\n  int regVar;\n\n  friend void someFunc(MyClass &obj);\n};\n注意到我们给函数传递对象时，我们需要用&运算符通过引用传递。\nPart题：\n什么是声明友元的关键字？\n\n8.2 友元函数（二）\n\nsomeFunc()函数在类外以正常函数的方式定义。它接受一个MyClass类型的对象作为其形参，并有权访问那个对象的私有数据成员。\nclass MyClass {\n public:\n  MyClass() {\n   regVar = 0;\n  }\n private:\n  int regVar;\n\n friend void someFunc(MyClass &obj);\n};\n\nvoid someFunc(MyClass &obj) {\n  obj.regVar = 42;\n  cout << obj.regVar;\n}\nsomeFunc()函数改变了对象的私有成员并输出其值。\n要使其对象可访问，类需要在其定义内将函数声明为友元。如果类没有“将访问权限给出”，你就不能“使”这个函数成为类的友元。\nPart题：\n填上缺失的关键字，使函数foo成为MyClass类的友元。\nclass MyClass {\npublic:\n  ______ void foo();\n};\n\n\n8.3 友元函数（三）\n\n现在我们可以在main中创建对象并调用someFunc()函数了。\nint main() {\n  MyClass obj;\n  someFunc(obj);\n}\n\n//输出 42\nsomeFunc()有权修改对象的私有成员并输出其值。\n\n友元函数的典型用例是可能涉及访问两个不同类的私有成员的函数。\n你可以在任意数量的类中声明一个函数是其友元。\n与友元函数类似，你可以定义友元类，其有权限访问另一个类的私有成员。\nPart题：\n友元函数...\nA. ...只能修改公有成员\nB. ...不能修改类的私有成员\nC. ...可以修改包括私有成员在内的类的所有成员\n\n\n9 this关键字\n\n9.1 this（一）\n\nC++中每个对象都可访问自己的地址，通过一种重要的指针，叫做this指针。\n在成员函数中，this可以用来指代调用对象。\n我们来创建一个示例类。\nclass MyClass {\n public:\n  MyClass(int a) : var(a)\n  { }\n private:\n  int var;\n};\n友元函数没有this指针，因为友元不是类的成员。\nPart题：\n用选项填空，声明一个Hannah类，有一个一参构造函数，一个printCrap()函数，和一个私有整型变量。\nclass Hannah {\n _____ :\n  Hannah(int);\n  void printCrap();\n private:\n  ______ h;\n};\nint        private        public        friend        class\n\n9.2 this（二）\n\nprintInfo()方法提供了三种输出类的成员变量的方式。\nclass MyClass {\n public:\n  MyClass(int a) : var(a)\n  { }\n  void printInfo() {\n   cout << var<<endl;\n   cout << this->var<<endl;\n   cout << (*this).var<<endl; \n  }\n private:\n  int var;\n};\n三种方式输出相同。\nthis是一个指向对象的指针，所以箭头选择符用于选择成员变量。\nPart题：\n对于一个名为mem的成员，选择两项可以正确输出它的方式。\nA. cout << this->mem;\nB. cout << this>>mem;\nC. cout << mem;\nD. cout ** mem;\n\n9.3 this（三）\n\n要看到结果，我们可以创建一个我们类的对象并调用成员函数。\n#include <iostream>\nusing namespace std;\n\nclass MyClass {\n public:\n  MyClass(int a) : var(a)\n  { }\n  void printInfo() {\n   cout << var <<endl;\n   cout << this->var <<endl;\n   cout << (*this).var <<endl; \n  }\n private:\n  int var;\n};\n\nint main() {\n  MyClass obj(42);\n  obj.printInfo();\n}\n\n/* 输出\n42\n42\n42\n*/\n所有三种访问成员变量的方式都有效。\n注意到只有成员函数有this指针。\nPart题：\n什么是存储当前对象地址的关键字？\n\n9.4 this（四）\n\n你也许在想可以直接指定变量时，为什么要用this关键字。\n\nthis关键字在[ruby=operator overloading]运算符重载[/ruby]中有举足轻重的地位，接着我们会讲到。\n\nPart题：\n对于类MyClass，有一个私有成员名为mem，填空在printValue()函数中通过this关键字输出其值。\nvoid MyClass::printValue() {\n  cout << ____ -> ___;\n}\n\n\n\n10 运算符重载\n\n10.1 运算符重载（一）\n\nC++中大多运算符都可以被重定义或重载。\n因此，用户定义的类型也可以使用各种运算符（例如你可以将两个对象相加）。\n\n下表列出可以重载的运算符。\n\n不能重载的运算符包括 :: | .* | . | ?:\nPart题：\n用选项填空，声明类Sally，公有范围内只有构造函数。\n______ Sally\n{\n ______ :\n  ______ ();\n};\n~Sally        private        public        Sally        class\n\n\n10.2 运算符重载（二）\n\n让我们声明一个示例类，用于演示运算符重载：\nclass MyClass {\n public:\n  int var;\n  MyClass() {}\n  MyClass(int a)\n  : var(a) { }\n};\n我们的类有两个构造函数和一个成员变量。\n我们会重载+运算符，允许我们相加两个我们的类对象。\nPart题：\n填空声明类Sally，有两个构造函数，一个是默认构造函数（无参），另一个有一个整型参数。\n_____ Sally\n{\n______ :\n  Sally();\n  Sally( ___ );\n};\n\n\n10.3 运算符重载（三）\n\n重载的运算符是函数，由关键字operator后跟要重载运算符的符号定义。\n被重载的运算符与其他函数类似，有返回类型和形参列表。\n\n在我们的例子中，我们会重载+运算符。它会返回一个我们类的对象并接受一个我们类的对象作为其形参。\nclass MyClass {\n public:\n  int var;\n  MyClass() {}\n  MyClass(int a)\n  : var(a) { }\n\n  MyClass operator+(MyClass &obj) {\n  }\n};\n现在，我们要定义函数的行为。\nPart题：\n哪个选项是在C++中重载运算符的关键字？\nA. operator\nB. this\nC. overload_it\nD. friend\n\n10.4 运算符重载（四）\n\n我们需要我们的+运算符返回一个新的MyClass对象，其成员变量等于两个对象成员变量之和。\nclass MyClass {\n public:\n  int var;\n  MyClass() {}\n  MyClass(int a)\n  : var(a) { }\n\n  MyClass operator+(MyClass &obj) {\n   MyClass res;\n   res.var= this->var+obj.var;\n   return res; \n  }\n};\n在这，我们声明了一个新res对象。之后我们将当前对象(this)和形参对象(obj)的成员变量之和赋给res对象的成员变量var。res对象作为结果返回。\n\n这给我们在main中创建对象并用被重载的+运算符相加对象的能力。\nint main() {\n  MyClass obj1(12), obj2(55);\n  MyClass res = obj1+obj2;\n\n  cout << res.var;\n}\n\n//输出 67\n有了重载运算符，你可以使用任何需要的自定义逻辑了。然而，无法改变运算符优先级、组合或操作数数量。\nPart题：\n用选项填空，定义Test类的被重载的+运算符。\nTest Test:: ______ (Test obj) {\n  ______ newObj;\n  newObj.mem =\n    mem ______ obj.mem;\n  return newObj;\n}\nTest        class        +        operator+        const\n\n本章测试\n\n1. 填空声明Student类的析构函数。\nclass Student {\npublic:\n  Student();\n  _ Student();\n};\n\n2. 填空声明指向st的指针，st类型是Student，之后通过指针调用printAge()。\nStudent st;\nStudent _ stPtr = _ st;\nstPtr __ printAge();\n\n3. 填上缺失的关键字，声明一个Person类型的常量对象：\n_____ Person obj;\n\n4. 对于类P，其有一个double型常成员weight，填空在构造函数初始化列表中初始化weight。\nP::P(double w) _\n  ______ (w)\n{\n}\n\n5. 什么是允许你指定一个函数是类的友元函数的关键字？\nA. this\nB. friendly\nC. friend\nD. make_friend\n\n6. 对于类Test，其有两个私有成员名为mem和mem2，填空在printValues()函数内使用this关键字输出其值。\nvoid Test::printValues() {\n  cout << ____ -> ___;\n  cout << this __ mem2;\n}\n\n7. C++中重载运算符的关键字是？\n",
    "replies": [
        {
            "author": "langyo",
            "timestamp": 1585385280,
            "txt_content": "草\n\n还以为你这个是索引\n\n没想到是零散的东西\n\n以及你可以细致讲一讲五三法则"
        },
        {
            "author": "langyo",
            "timestamp": 1585385460,
            "txt_content": " 本帖最后由 langyo 于 2020-3-28 16:52 编辑 \n\n仔细看了下，你还缺了一堆东西\n\n- =default 和 =delete 去哪里了？\n- 拷贝构造函数需要更细致的讲解，配合五三讲比较好……\n- 模板类有考虑讲不？\n- 友元 operator 何时入手？"
        },
        {
            "author": "45gfg9",
            "timestamp": 1585385880,
            "txt_content": "langyo 发表于 2020-3-28 16:51\n仔细看了下，你还缺了一堆东西\n\n- =default 和 =delete 去哪里了？\n1. 2. 原文没有 我溜了\n我觉得=default和=delete是进阶特性了awa\n而且是C++11加的 而这篇教程大概还在用C++98（那咋办嘛）\n\n3. 有（在C++Ⅷ了，不知道什么时候更新233）\n\n4. 友元operator没得 以读者的水平应该可以自己写（逃）"
        },
        {
            "author": "⚡️👮",
            "timestamp": 1585388340,
            "txt_content": "百万贴大佬"
        },
        {
            "author": "天空的大楼",
            "timestamp": 1585388640,
            "txt_content": "这个帖子值得纪念，是一个有意义的教程帖子。"
        },
        {
            "author": "Hueihuea",
            "timestamp": 1585390320,
            "txt_content": " 本帖最后由 Hueihuea 于 2020-3-28 22:53 编辑 \n\n咦 TID100W拍照留念\n\n咦 挨卡了XD"
        },
        {
            "author": "屑弟弟楚儿",
            "timestamp": 1585394880,
            "txt_content": "大草\n（本来以为至少是在茶馆出现的  教学贴爆冷门）\n（反手给我打了一个大嘴巴子）"
        },
        {
            "author": "1784234383",
            "timestamp": 1585407120,
            "txt_content": " 本帖最后由 1784234383 于 2020-3-30 16:19 编辑 \n\n还带章末测试 lz有心了"
        },
        {
            "author": "FireworkPolymer",
            "timestamp": 1585438800,
            "txt_content": "虽然没看懂，但是C++在java版我的世界中有什么用吗（基岩版倒是C++开发的）"
        },
        {
            "author": "BiggayJN",
            "timestamp": 1585444500,
            "txt_content": "淦，百万帖不发锭不过这也是个不错的教程"
        },
        {
            "author": "45gfg9",
            "timestamp": 1585444500,
            "txt_content": "FireworkDLC 发表于 2020-3-29 07:40\n虽然没看懂，但是C++在java版我的世界中有什么用吗（基岩版倒是C++开发的）\n一般来说没有（捂脸）\n\n这个系列与Minecraft无关，就是纯粹的编程入门"
        },
        {
            "author": "FireworkPolymer",
            "timestamp": 1585444740,
            "txt_content": "45gfg9 发表于 2020-3-29 09:15\n一般来说没有（捂脸）\n\n这个系列与Minecraft无关，就是纯粹的编程入门\n所以“我的世界”中文论坛为什么要开这个板块"
        },
        {
            "author": "Salt_lovely",
            "timestamp": 1585451700,
            "txt_content": "话说C++会不会有一天可以用于Java版的插件开发？（好像不太可能，跨平台就要重新编译了吧）"
        },
        {
            "author": "洞穴夜莺",
            "timestamp": 1585453800,
            "txt_content": "FireworkDLC 发表于 2020-3-29 07:40\n虽然没看懂，但是C++在java版我的世界中有什么用吗（基岩版倒是C++开发的）\n有用，写启动器"
        },
        {
            "author": "FloatingBlocks",
            "timestamp": 1585468560,
            "txt_content": "这个\n只学到函数的我瑟瑟发抖\n\n感觉我那本书太详细了堪比手册\n\n这个知识密度太高了，改天当手册用吧\n\n支持lz（还是百万帖子恭喜了"
        },
        {
            "author": "冷枫小乐",
            "timestamp": 1585504020,
            "txt_content": "恭喜成为100w贴，雾，好评"
        },
        {
            "author": "88453877",
            "timestamp": 1585546440,
            "txt_content": "我就是来水个帖子的"
        },
        {
            "author": "剑眉狼",
            "timestamp": 1585548900,
            "txt_content": "百万贴，恭喜恭喜\n纯干货嗷，先收藏为敬了"
        },
        {
            "author": "丶追忆",
            "timestamp": 1585558140,
            "txt_content": "哇。没抢到锭，真难受"
        },
        {
            "author": "nidb",
            "timestamp": 1585558440,
            "txt_content": "C艹乃秃头源泉"
        },
        {
            "author": "遗忘的流髑",
            "timestamp": 1585565640,
            "txt_content": "百万帖恭喜！"
        },
        {
            "author": "一只小水怪",
            "timestamp": 1585734660,
            "txt_content": "100w贴！！!"
        },
        {
            "author": "AzureZeng",
            "timestamp": 1585893000,
            "txt_content": "就是你抢了TID1000000? 原来是存草稿了，我们还以为被删了"
        },
        {
            "author": "hjxhjx2",
            "timestamp": 1585983240,
            "txt_content": " 本帖最后由 hjxhjx2 于 2020-4-4 14:55 编辑 \n\n谔谔C++OIer表示我不管这块\n我只会算法QAQ（红黑树什么的）\n只有2,4,5,8,9,10部分是我熟悉的。。。\n（关于class。。。struct不香吗。。。class在OI中很废的...）\n话说friend是不是可以用const代替来着啊。。。。\nlz不打算另外出个帖子讲一下吗"
        },
        {
            "author": "馄饨=w=",
            "timestamp": 1586097120,
            "txt_content": "dalao，百万，考古\n\n[编辑于2080-1-1：]一亿前来考古"
        },
        {
            "author": "45gfg9",
            "timestamp": 1586098860,
            "txt_content": "hjxhjx2 发表于 2020-4-4 14:54\n谔谔C++OIer表示我不管这块\n我只会算法QAQ（红黑树什么的）\n只有2,4,5,8,9,10部分是我熟悉的。。。\n算法我完全痴呆（\n\nfriend和const是完全不同的两个东西啊\n\n以及如果有需要的话 可能未来（大概）会开一个答疑帖吧"
        },
        {
            "author": "hjxhjx2",
            "timestamp": 1586138760,
            "txt_content": "45gfg9 发表于 2020-4-5 23:01\n算法我完全痴呆（\n\nfriend和const是完全不同的两个东西啊\n但是我用STL重载运算符时似乎必须要加个friend或者const（？？）\n(好吧我对于一些语法并不了解。。。)"
        },
        {
            "author": "屈子墨",
            "timestamp": 1586148060,
            "txt_content": "看完这个后 我竟不知道是先学java还是c++了"
        },
        {
            "author": "池恩TwT",
            "timestamp": 1590033660,
            "txt_content": "1000000 留念"
        },
        {
            "author": "小凡Eric",
            "timestamp": 1591500240,
            "txt_content": "百万考古留恋"
        },
        {
            "author": "Garyjel",
            "timestamp": 1595771280,
            "txt_content": "自编2048\n#include <bits/stdc++.h>\n#include <windows.h>\n#include <conio.h>\nusing namespace std;\nlong long a[1001][1001],s,h,n,pl;\nint ct(int i,int j)\n{\n        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),8);\n        cout<<\"║ \";\n        if(a[i][j]==0) cout<<\"  \";\n        if(a[i][j]==1)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |FOREGROUND_GREEN | FOREGROUND_BLUE);\n                cout<<\"□\";\n        }\n        if(a[i][j]==2)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),3);\n                cout<<\"□\";\n        }\n        if(a[i][j]==4)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);\n                cout<<\"□\";\n        }\n        if(a[i][j]==8)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN |FOREGROUND_BLUE);\n                cout<<\"□\";\n        }\n        if(a[i][j]==16)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |FOREGROUND_GREEN);\n                cout<<\"□\";\n        }\n        if(a[i][j]==32)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED);\n                cout<<\"■\";\n        }\n        if(a[i][j]==64)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),3);\n                cout<<\"■\";\n        }\n        if(a[i][j]==128)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN);\n                cout<<\"■\";\n        }\n        if(a[i][j]==256)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_GREEN |FOREGROUND_BLUE);\n                cout<<\"■\";\n        }\n        if(a[i][j]==512)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY | FOREGROUND_RED |FOREGROUND_GREEN);\n                cout<<\"■\";\n        }\n        if(a[i][j]==1024)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY);\n                cout<<\"○\";\n        }\n        if(a[i][j]==2048)\n        {\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_INTENSITY);\n                cout<<\"◎\";\n        }\n}\nint f(int x)\n{\n        if(x==119)//up\n        {\n                for(int j=1;j<=n;j++)\n                        for(int i=1;i<=n;i++)\n                        {\n                                int xl=i;\n                                while(a[xl-1][j]==0&&xl>1)\n                                {\n                                        a[xl-1][j]=a[xl][j];\n                                        a[xl][j]=0;\n                                        xl--;\n                                }\n                                if(a[xl-1][j]==a[xl][j])\n                                {\n                                        a[xl][j]=0;\n                                        a[xl-1][j]*=2;\n                                }\n                        }\n        }\n        if(x==115)//down\n        {\n                for(int j=1;j<=n;j++)\n                        for(int i=n;i>=1;i--)\n                        {\n                                int xl=i;\n                                while(a[xl+1][j]==0&&xl<n)\n                                {\n                                        a[xl+1][j]=a[xl][j];\n                                        a[xl][j]=0;\n                                        xl++;\n                                }\n                                if(a[xl+1][j]==a[xl][j])\n                                {\n                                        a[xl][j]=0;\n                                        a[xl+1][j]*=2;\n                                }\n                        }\n        }\n        if(x==97)//left zuo\n        {\n                for(int i=1;i<=n;i++)\n                        for(int j=1;j<=n;j++)\n                        {\n                                int yl=j;\n                                while(a[i][yl-1]==0&&yl>1)\n                                {\n                                        a[i][yl-1]=a[i][yl];\n                                        a[i][yl]=0;\n                                        yl--;\n                                }\n                                if(a[i][yl-1]==a[i][yl])\n                                {\n                                        a[i][yl]=0;\n                                        a[i][yl-1]*=2;\n                                }\n                        }\n        }\n        if(x==100)//right you\n        {\n                for(int i=1;i<=n;i++)\n                        for(int j=n;j>=1;j--)\n                        {\n                                int yl=j;\n                                while(a[i][yl+1]==0&&yl<n)\n                                {\n                                        a[i][yl+1]=a[i][yl];\n                                        a[i][yl]=0;\n                                        yl++;\n                                }\n                                if(a[i][yl+1]==a[i][yl])\n                                {\n                                        a[i][yl]=0;\n                                        a[i][yl+1]*=2;\n                                }\n                        }\n        }\n}\nint main()\n{\n        n=4;\n        while(s<n*n)\n        {\n                s=0; h=0;\n                int xl,s1=0,zl=1;\n                for(int i=1;i<=n;i++)\n                        for(int j=1;j<=n;j++)\n                                if(!a[i][j]) s1++;\n                                else h+=a[i][j];\n                if(s1==0)\n                {\n                        cout<<\"GAME OVER --------\"<<h;\n                        return 0;\n                }\n                srand(time(0));\n                xl=rand();\n                zl=rand();\n                zl%=2; xl%=s1;\n                zl++; xl++;\n                for(int i=1;i<=n;i++)\n                        if(xl)\n                        {\n                                for(int j=1;j<=n;j++)\n                                        if(!a[i][j])\n                                        {\n                                                if(xl==1)\n                                                {\n                                                        a[i][j]=zl;\n                                                }\n                                                xl--;\n                                        }\n                        }\n                        else break;\n                system(\"cls\");\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),8);\n                cout<<\"╔\";\n                for(int i=1;i<=n-1;i++) cout<<\" ═ ╦\";\n                cout<<\" ═ ╗\"<<endl;\n                for(int i=1;i<=n-1;i++)\n                {\n                        for(int j=1;j<=n;j++)\n                        {\n                                ct(i,j);\n                        }\n                        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),8);\n                        cout<<\"║\"<<endl<<\"╠\";\n                        for(int i=1;i<=n-1;i++) cout<<\" ═ ╬\";\n                        cout<<\" ═ ╣\"<<endl;\n                }\n                for(int j=1;j<=n;j++)\n                {\n                        ct(n,j);\n                }\n                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),8);\n                cout<<\"║\";\n                cout<<endl<<\"╚\";\n                for(int i=1;i<=n-1;i++) cout<<\" ═ ╩\";\n                cout<<\" ═ ╝\";\n                int z=getch();\n                f(z);\n        }\n        cout<<\"GAME OVER --------\"<<h;\n        return 0;\n}"
        },
        {
            "author": "ilegole",
            "timestamp": 1596329400,
            "txt_content": "#在这里快速回复#        百万留名 你火了"
        },
        {
            "author": "dingbohao",
            "timestamp": 1596888060,
            "txt_content": "2020年8月8日前来考古"
        },
        {
            "author": "kayn-",
            "timestamp": 1597670760,
            "txt_content": "感谢大佬翻译和转载"
        }
    ]
}