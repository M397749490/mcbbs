{
    "title": "[Tutorial][Bukkit][Bone Studio]如何自定义你的实体",
    "author": "602723113",
    "replyCount": 18,
    "timestamp": 1533996660,
    "txt_content": " 本帖最后由 602723113 于 2019-5-3 15:52 编辑 \n\n\n如何自定义你的实体目录:\n导读实体的定义利用EntityZombie来制作你的自定义僵尸实体的WASD移动PathfinderGoal (实体AI)Navigation (实体的寻路系统)\n\n导读本教程使用的 Spigot1.10.2-R0.1-SNAPSHOT 和 Spigot1.11.2-R0.1-SNAPSHOT 核心\n在阅读之前请确保你具有阅读混淆代码的能力和NMS基础和Java基础以及反射(reflect)的知识\n(没有我也会适当的解释的吧)\n实体的定义 内容如果你已经知道了什么是 实体，无生命的实体(Insentient Entity)，那么你就可以跳过这一小节去看下面的了\n\n实体是Entity包括在Minecraft中所有动态的、移动中的对象\n所有的实体都有以下性质:\n具有速度、位置和旋转角度。占有特定的空间大小。此空间是一个固定长宽高的三维长方体（实体不偏斜时，俯视图为正方形）即碰撞箱(Hitbox/AxisAlignedBB/BoundingBox)当前的生命值。当着火时，生命值逐渐减少，实体显示出被火焰包围的样子（在携带版中两格高或以上的实体火会显示在臀部）。状态效果，主要由药水产生\n——摘抄自中文MinecraftWiki\n在BukkitAPI当中，所有的实体接口都继承了Entity接口，而实体有分为无生命实体和有生命实体，例如有生命实体:ZombieCreeperPlayer...\n无生命实体:\nArmorStand (盔甲架)Arrow (射出的箭)ExpOrb (经验球)...\n所有有生命的实体接口都会继承于LivingEntity接口，我们可以在此查看所有继承了LivingEntity接口的实体接口们赞美中文BukkitAPI而无生命的实体接口就不会继承于LivingEntity接口\n利用EntityZombie来制作你的自定义僵尸 在阅读这一小节之前，我要分为1.11以下与1.11以上(包括1.11)两个版本进行讲解，因为在1.11这个版本出现时，Mojang新增了一个叫MinecraftKey的东西，取代了1.11之前使用Integer来表示实体网络ID，当然了它在1.12里面也用于advancement的一个使用\n\n由于在1.8-1.13对实体的实现都是差不多的，所以对于1.11这个分水岭我只讲它们两个注册的不同之处，具体实现请读者自行反编译阅读代码实现！\n在BukkitAPI当中，没有什么特殊的操作可以用于自定义一个实体（如果有可以告知我），所以我们就需要进入NMS下对实体进行一个操作\n\n我们新建一个类叫做 MyZombie，之后让它继承于EntityZombie\nimport net.minecraft.server.v1_10_R1.EntityZombie;\n\npublic class MyZombie extends EntityZombie {\n    \n}复制代码然后我们需要实现一个构造方法，这里我使用BukkitAPI里的Location作为它的参数\npublic MyZombie(Location location) {\n    super(((CraftWorld) location.getWorld()).getHandle());\n    this.setCustomName(\"我的僵尸\");\n    this.setCustomNameVisible(true);\n    // 需要设置该实体的Position才会出现在对应的Location\n    this.setPosition(location.getX(), location.getY(), location.getZ());\n}\n\n之后我们可以复写一些在EntityZombie或其父类里的一些方法，比如我这里复写这个方法（这里要注意的是不同版本的NMS该方法名会有些不同，所以可以通过该方法的参数名来判断是哪个参数）@Override\n    public boolean a(EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack) {\n        // 以下的if判断了这些东西\n        // 空值判断\n        // 物品类型判断是否为金苹果\n        // 判断附加值(耐久, 损坏值)\n        // 判断是否为村民\n        // 判断是否拥有虚弱Buff\n        if ((itemstack != null) && (itemstack.getItem() == Items.GOLDEN_APPLE) && (itemstack.getData() == 0) && (isVillager()) && (hasEffect(MobEffects.WEAKNESS))) {\n            if (!entityhuman.abilities.canInstantlyBuild) { // 判断该玩家是否是 可以立即建立的模式 即创造模式\n                itemstack.count -= 1; // 减少物品\n            }\n            if (!this.world.isClientSide) { // 判断是否为客户端\n                a(this.random.nextInt(2401) + 3600); // 执行下方截图的代码\n            }\n            return true;\n        }\n        return false;\n    }\n在这里，如果你有丰富的游戏经验的话，不难看出上方的方法其实就是将僵尸村民吃金苹果转换为普通村民的一个方法，那么在MCP中它又叫什么呢？这里我使用了MCP Query这个工具查到了以下的内容\nsrg: func_184645_a\nname: processInteract\nside: Both\nnotch: zi.a\nreturn: boolean\n根据上方的信息我们不难看出，在MCP当中，这个NMS下的a()方法其实叫processInteract，并且是一个双向的方法，可以用于客户端上也可以用与服务器上\n那么我们重写一下这个方法\npublic boolean a(EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack) {\n        if (itemstack == null) {\n            return false;\n        }\n        if (itemstack.getItem() == Items.APPLE) {\n            if (!entityhuman.abilities.canInstantlyBuild) {\n                itemstack.count -= 1;\n            }\n            entityhuman.getBukkitEntity().sendMessage(\"真香\");\n        } else {\n            entityhuman.getBukkitEntity().sendMessage(\"我不喜欢这个...\");\n        }\n        return false;\n    }复制代码如果你自定义的实体是有生命的实体那么就需要对其注册！\nBelow 1.11 Version —— 低于1.11版本的注册方式\n在NMS当中，有个类叫做EntityTypes，该类主要用于注册实体，（具体的注册方式请读者自己去反编译查看），我们可以通过反射的方式来进行注册，看我下面的操作\nstatic {\n    ((Map) getPrivateField(\"c\", EntityTypes.class, null)).put(\"MyZombie\", MyZombie.class);\n    ((Map) getPrivateField(\"d\", EntityTypes.class, null)).put(MyZombie.class, \"MyZombie\");\n    // 如果我们想覆盖NMS内的僵尸的话那么就可以加上下面那行注释起来的代码\n    //((Map) getPrivateField(\"e\", EntityTypes.class, null)).put(54, MyZombie.class);\n    ((Map) getPrivateField(\"f\", EntityTypes.class, null)).put(MyZombie.class, 54);\n    (Map) getPrivateField(\"g\", EntityTypes.class, null)).put(\"MyZombie\", 54);\n}\n\nprivate static Object getPrivateField(String fieldName, Class clazz, Object object) {\n    Field field;\n    Object obj = null;\n    try {\n        field = clazz.getDeclaredField(fieldName);\n        field.setAccessible(true);\n        obj = field.get(object);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    return obj;\n}\n（论坛日常吞代码）\n我们在MyZombie类下新增了一个静态初始化块，用于注册我们的实体，而下面我们需要利用反射获取到EntityTypes下对于所有实体控制的那几个Map（别看它多，其实就是两个双向的Map就可以达到的目的）\n\n这里有人会问了，那个54是什么意思呢？\n在1.11版本之前，所有的实体都会有一个实体ID，也就是我们上方代码中字段e的那个Map所表示的那样，实体ID -> 对应实体的class\n不同的实体会有不同的实体ID，所有的实体ID都可以在这里找到~\nhttps://wiki.vg/Entity_metadata#Mobs  （那个表格，最左边就是，最右边的是1.11版本当中的minecraftkey）\n\n这样我们就做好了在1.11版本以下的实体的一个注册After 1.11 Version —— 高于1.11版本的注册方式\n在1.11之后，注册就变得简单起来了，因为在EntityTypes当中，之前的那些private Map都改成了public static RegisterMaterial，方便大众（当然我不懂是不是md_5自己改的..）\n这里要注意的是在不同版本该变量名有所不同例如1.13中它变成了EntityTypes.REGISTRYpublic class MyZombie extends EntityZombie {\n\n    private static MinecraftKey minecraftKey;\n\n    static {\n        // 给我们的自定义实体做一个MinecraftKey\n        minecraftKey = new MinecraftKey(\"my_zombie\"); // minecraft:my_zombie\n        // 实体注册\n        EntityTypes.d.add(minecraftKey); // 将此key添加至EntityTypes的列表里\n        EntityTypes.b.a(54, minecraftKey, MyZombie.class); // 对其注册\n\n\n        // 如果想取消对该实体的注册那么可以执行下方的代码\n        EntityTypes.d.remove(minecraftKey);\n        MinecraftKey oldKey = EntityTypes.b.b(EntityZombie.class); // minecraft:zombie\n        EntityTypes.b.a(54, oldKey, EntityZombie.class); // 把54号id所对应的minecraft:key和entity class进行覆盖\n    }\n\n    public static MinecraftKey getMinecraftKey() {\n        return minecraftKey;\n    }\n}复制代码从上方的代码可以看出，我们不再需要反射来对实体进行注册了\n这样你就学会了怎么在1.11版本之后对实体进行注册了\n\n具体生成代码:通过反编译查找到World#spawnEntity可以看出在CraftWorld下会有一个方法叫做addEntity(net.minecraft.server.XXX.Entity entity, SpawnReason reason)于是我们可以得到下方的代码Location location = player.getLocation();// 对自定义进行实例化MyZombie myZombie = new MyZombie(location);// 生成至世界内CraftWorld craftWorld = (CraftWorld) location.getWorld();craftWorld.addEntity(myZombie, CreatureSpawnEvent.SpawnReason.CUSTOM);\n具体效果:\n\n\n\n实体的WASD移动实体的WASD移动，在EntityLiving中，有个叫做g(float, float)的方法，以下是它的MCP信息\nsrg: func_70612_e\nname: moveEntityWithHeading\nside: Both\nnotch: su.g\n\n从上方的信息不难看出，该方法用于控制实体的头向转动和移动\n那么我们借用上方的MyZombie来做我们的\"载具\"，首先我们需要重写该方法\npublic class MyZombie extends EntityZombie {\n\n    /**\n     * Move entity with Heading\n     *\n     * @param sideMotion  向左右的偏移值\n     * @param frontMotion 向前或向后的偏移值\n     */\n    @Override\n    public void g(float sideMotion, float frontMotion) {\n        super.g(sideMotion, frontMotion);\n    }\n        \n}复制代码之后我们就可以开始写具体的WASD移动了\n以下代码适用于1.11.2public class MyZombie extends EntityZombie {\n\n    private static Field isJump = null; // 跳跃字段\n\n    static {\n            // 反射一下EntityLiving里的跳跃字段\n        try { \n            isJump = EntityLiving.class.getDeclaredField(\"bd\"); // 在1.11版本当中, 该字段称为bd, 而在1.10.2中该字段称为be\n            isJump.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e1) {\n            e1.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Move entity with Heading\n     *\n     * @param sideMotion  向左右的偏移值\n     * @param frontMotion 向前或向后的偏移值\n     */\n    @Override\n    public void g(float sideMotion, float forwardMotion) {\n        if (this.passengers != null && !this.passengers.isEmpty()) { // 判断有无乘客\n            EntityLiving passenger = (EntityLiving) this.passengers.get(0); // 获取该乘客\n\n            // 设置该实体的俯仰角(pitch)、航向角(yaw)跟乘客的俯仰角、航向角一致\n            this.yaw = passenger.yaw;\n            this.lastYaw = this.yaw;\n            this.pitch = (passenger.pitch * 0.5F);\n            setYawPitch(this.yaw, this.pitch);\n            this.aN = this.yaw;\n            this.aP = this.aN;\n\n            float speedAmplifier = 2F; // 这里可以设置你的速度放大器\n            // 在1.10.2当中下方的 passenger.be <=> passenger.bf, passenger.bf <=> passenger.bg\n            sideMotion = passenger.be * speedAmplifier;\n            forwardMotion= passenger.bf * speedAmplifier;\n            if (forwardMotion<= 0.0F) { // 如果向前方的偏移值小于0则说明是后退\n                forwardMotion*= 0.25F; // 然后将其设置得慢一点\n            }\n\n            if (isJump != null && this.onGround) { // 判断实体是否在地上, 不在地上就不能跳\n                try {\n                    if (isJump.getBoolean(passenger)) { // 判断乘客是否跳跃了\n                        float jumpHeight = 0.5F; // 跳跃高度\n                        this.motY = jumpHeight; // 将该实体在Y轴上进行偏移\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            super.g(sideMotion, forwardMotion); // 作用回EntityLiving\n        }\n    }\n}复制代码那么上面的那些 aN, aQ还有be，bf的字段我是怎么知道的呢？我们反编译EntityHorseAbstract#g(float, float)就可以发现，不同版本这些字段也是不同的，而这在上放的一些字段里，大多都是关于实体的偏移值和一些欧拉角参数的字段，为了能够找到对应版本所对应的字段，请读者自己反编译该方法就可以找到对应的字段了\n例如: 1.10.2下的代码以下代码适用于1.10.2public class MyZombie extends EntityZombie {\n\n    private static Field isJump = null; // 跳跃字段\n\n    static {\n        // 反射一下EntityLiving里的跳跃字段\n        try {\n            isJump = EntityLiving.class.getDeclaredField(\"be\");\n            isJump.setAccessible(true);\n        } catch (NoSuchFieldException | SecurityException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    /**\n     * Move entity with Heading\n     *\n     * @param sideMotion  向左右的偏移值\n     * @param forwardMotion向前或向后的偏移值\n     */\n    @Override\n    public void g(float sideMotion, float forwardMotion) {\n        if (this.passengers != null && !this.passengers.isEmpty()) { // 判断有无乘客\n            EntityLiving passenger = (EntityLiving) this.passengers.get(0); // 获取该乘客\n\n            // 设置该实体的俯仰角(pitch)、航向角(yaw)跟乘客的俯仰角、航向角一致\n            this.yaw = passenger.yaw;\n            this.lastYaw = this.yaw;\n            this.pitch = (passenger.pitch * 0.5F);\n            setYawPitch(this.yaw, this.pitch);\n            this.aO = this.yaw;\n            this.aQ = this.aO;\n\n            float speedAmplifier = 2F; // 这里可以设置你的速度放大器\n            // bf bg\n            sideMotion = passenger.bf * speedAmplifier;\n            forwardMotion= passenger.bg * speedAmplifier;\n            if (forwardMotion<= 0.0F) { // 如果向前方的偏移值小于0则说明是后退\n                forwardMotion*= 0.25F; // 然后将其设置得慢一点\n            }\n\n            if (isJump != null && this.onGround) { // 判断实体是否在地上, 不在地上就不能跳\n                try {\n                    if (isJump.getBoolean(passenger)) { // 判断乘客是否跳跃了\n                        float jumpHeight = 0.5F; // 跳跃高度\n                        this.motY = jumpHeight; // 将该实体在Y轴上进行偏移\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            super.g(sideMotion, forwardMotion); // 作用回EntityLiving\n        }\n    }\n}复制代码具体效果:\n\n\nPathfinderGoal (实体AI)其实这个内容在论坛里面已经有了相关的帖子，这里我就懒得再说了。。\n比如: \n[上古之石]Pathfinder插件教程 —— zghh008[插件NMS教程]PathfinderGoal —— Tsumiki\n所以这里就随便讲讲了\n\n以下的讲解所使用的Spigot版本为1.11.2在NMS当中，所有的EntityInsentient都会有自己的一套AI系统，比如说EntityZombie，我们反编译该类可以发现一个Zombie有以下的AI\n0 -> Float (在水里浮着 感谢12楼的补充)1 -> HurtByTarget<EntityPigZombie> (欲与猪人五五开)2 -> ZombieAttack (僵尸式攻击)2 -> NearestAttackableTarget<EntityHuman> (攻击玩家)3 -> NearestAttackableTarget<EntityVillager, EntityIronGolem> (攻击村民，铁傀儡)5 -> MoveTowardsRestriction (走向限制)6 -> MoveThroughVillage (穿过村庄)7 -> RandomStrollLand (随机行走)8 -> LookAtPlayer (看向玩家)8 -> RandomLookaround (四处看)\n我在每一个AI的前面都标上了他们的优先级，级别越低越最先执行\n\n如果我们想制作一个善良的僵尸的话我们就可以把NearestAttackableTarget<EntityHuman, EntityVillager, EntityIronGolem>这几个AI给删去\n\n我们来看看下面的操作\npublic class MyZombie extends EntityZombie {\n\n    @Override\n    protected void r() {\n        this.goalSelector.a(0, new PathfinderGoalFloat(this));\n        this.goalSelector.a(2, new PathfinderGoalZombieAttack(this, 1.0D, false));\n        this.goalSelector.a(5, new PathfinderGoalMoveTowardsRestriction(this, 1.0D));\n        this.goalSelector.a(7, new PathfinderGoalRandomStrollLand(this, 1.0D));\n        this.goalSelector.a(8, new PathfinderGoalLookAtPlayer(this, EntityHuman.class, 8.0F));\n        this.goalSelector.a(8, new PathfinderGoalRandomLookaround(this));\n        this.dk();\n    }\n\n    @Override\n    protected void dk() {\n        this.goalSelector.a(6, new PathfinderGoalMoveThroughVillage(this, 1.0D, false));\n        this.targetSelector.a(1, new PathfinderGoalHurtByTarget(this, true, EntityPigZombie.class));\n        // 将其攻击生物的AI删除\n//        this.targetSelector.a(2, new PathfinderGoalNearestAttackableTarget(this, EntityHuman.class, true));\n//        if (this.world.spigotConfig.zombieAggressiveTowardsVillager) {\n//            this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget(this, EntityVillager.class, false));\n//        }\n\n//        this.targetSelector.a(3, new PathfinderGoalNearestAttackableTarget(this, EntityIronGolem.class, true));\n    }\n}复制代码进游戏后你就会发现，这个僵尸不会再攻击你了\n\n自定义AI:\n基本上所有的AI都是以PathfinderGoal为基础的，如果我们想自己写一套AI的话，那么我们就需要将这个类继承与PathfinderGoal，在PathfinderGoal里面有几个需要开发者实现的方法\n一个PathfinderGoal基类里面有以下的方法\nabstarct boolean a()\nMCP称为: shouldExecute (该方法用于判断该AI任务应该什么时候开始执行)\n\nboolean b()\nMCP称为: continueExecuting (返回正在进行的AI任务是否应继续执行)\n\nvoid c()\n// MCP称为: startExecuting (执行一次性任务或开始执行连续任务)\n\nvoid d()\n // MCP称为: resetTask (重置任务的内部状态。 当此AI任务被另一个AI任务中断时调用)\n\nvoid e()\n// MCP称为: updateTask(继续执行已经启动的连续AI任务)\n\n在一般情况下，我们一般重写 a()，b()，c()，这几个方法足以，具体的自定义AI，我将在下方的Navigation里介绍\n\nNavigation (实体的寻路系统)在NMS当中，所有的EntityInsentient都会有一个寻路系统，即Navigation，那么我们要怎么用它呢？我们来看下面的几个例子\n\n首先，该系统通常跟实体AI相结合，我们来看下面的一个例子，我们就知道了（顺便把自定义AI也带上了）import net.minecraft.server.v1_11_R1.EntityInsentient;\nimport net.minecraft.server.v1_11_R1.Navigation;\nimport net.minecraft.server.v1_11_R1.PathfinderGoal;\nimport org.bukkit.Location;\n\n/**\n * 使一个实体走动至一个坐标的AI\n *\n * @author Zoyn\n * @since 2018/8/13\n */\npublic class PathfinderGoalWalkToLoc extends PathfinderGoal {\n\n    /**\n     * 实体移动速度\n     */\n    private double speed;\n    /**\n     * 实体对象\n     */\n    private EntityInsentient entity;\n    /**\n     * 坐标\n     */\n    private Location loc;\n    /**\n     * 实体导航系统\n     */\n    private Navigation navigation;\n\n    public PathfinderGoalWalkToLoc(EntityInsentient entity, double speed, Location loc) {\n        this.entity = entity;\n        this.navigation = (Navigation) this.entity.getNavigation();\n        this.speed = speed;\n        this.loc = loc;\n    }\n\n    @Override\n    public boolean a() {\n        return true;\n    }\n\n    @Override\n    public boolean b() {\n        return false;\n    }\n\n    @Override\n    public void c() {\n        if (loc != null) {\n            this.navigation.a(loc.getX(), loc.getY(), loc.getZ(), speed);\n        }\n    }\n}\n复制代码在上方的代码中，我们看到c()方法，可以很明显的看到这一行\nthis.navigation.a(loc.getX(), loc.getY(), loc.getZ(), speed);\n那么这一行就是使实体进行移动的一个例子，而在最后面的那个参数是实体移动的速度\n\n那么我们在实体的AI里添加上它\npublic class MyZombie extends EntityZombie {\n\n    @Override\n    protected void r() {\n            // 其他的AI我这里予以省略\n        this.goalSelector.a(6, new PathfinderGoalWalkToLoc(this, 1.0D, 你的坐标));\n                // 为了防止实体在移动过程中随意走动, 我们把随意走动的AI删除\n                // this.goalSelector.a(7, new PathfinderGoalRandomStrollLand(this, 1.0D));\n    }\n}复制代码那么同理，我们可以利用Navigation做出让实体巡逻的一个AI，看下面的代码import com.google.common.collect.Lists;\nimport net.minecraft.server.v1_11_R1.EntityInsentient;\nimport net.minecraft.server.v1_11_R1.Navigation;\nimport net.minecraft.server.v1_11_R1.PathfinderGoal;\nimport org.bukkit.Location;\n\nimport java.util.List;\n\n/**\n * 使一个实体进行循环式的巡逻AI\n *\n * @author Zoyn\n * @since 2018/8/13\n */\npublic class PathfinderGoalPatrol extends PathfinderGoal {\n\n    /**\n     * 实体移动速度\n     */\n    private double speed;\n    /**\n     * 实体对象\n     */\n    private EntityInsentient entity;\n    /**\n     * 所有的坐标\n     */\n    private List<Location> loc;\n    /**\n     * 实体导航系统\n     */\n    private Navigation navigation;\n    /**\n     * 当前应走的坐标的下标\n     */\n    private int currentLocationIndex;\n\n    public PathfinderGoalPatrol(EntityInsentient entity, double speed, Location... locations) {\n        this.entity = entity;\n        this.navigation = (Navigation) this.entity.getNavigation();\n        this.speed = speed;\n        loc = Lists.newArrayList(locations.clone());\n        currentLocationIndex = 0;\n    }\n\n    public PathfinderGoalPatrol(EntityInsentient entity, double speed, List<Location> locations) {\n        this.entity = entity;\n        this.navigation = (Navigation) this.entity.getNavigation();\n        this.speed = speed;\n        loc = locations;\n        currentLocationIndex = 0;\n    }\n\n    @Override\n    public boolean a() {\n        // 循环\n        Location entityLocation = entity.getBukkitEntity().getLocation();\n        if (entityLocation.distance(this.loc.get(currentLocationIndex)) < 1) { // 判断实体的坐标与当前需要走到的坐标之间的距离\n            if (currentLocationIndex + 1 >= loc.size()) {\n                currentLocationIndex = 0; // 自动返回至第一项\n                return true;\n            }\n            currentLocationIndex++;\n        }\n        return true;\n    }\n\n    @Override\n    public boolean b() {\n        return !this.navigation.n(); // 判断实体是否已经到达\n    }\n\n    @Override\n    public void c() {\n        // 执行移动\n        this.navigation.a(loc.get(currentLocationIndex).getX(), loc.get(currentLocationIndex).getY(), loc.get(currentLocationIndex).getZ(), speed);\n    }\n}复制代码具体效果:\n\n\n那么有人就会想问，如果我想用A*算法来做寻路算法要怎么做呢？\n你可以选择重写NavigationAbstract里的MC寻路算法，然后自己实现即可\n（当然我觉得没有几个人想写...）\n\n结语又是一篇没有什么质量的教程，看来我终究写不出来有质量的教程....了吧，希望读者在阅读了本篇教程后可以有自主意识，而不是只顾着CV代码，能写出自己的东西才是最值得的\n\n实体这一块其实主要要配合MCP来阅读源码，这样才会那些混淆过的字段名方法名什么的有个基本概念，这样就会有更多的实体黑科技了~\n\n—— 一个快要高三的普高文科生\n2018.8.13\n\n[groupid=1306]Bone Studio[/groupid]",
    "replies": [
        {
            "author": "午申",
            "timestamp": 1533997560,
            "txt_content": "那么对于盔甲架该怎么办？"
        },
        {
            "author": "粘兽",
            "timestamp": 1533998220,
            "txt_content": " 本帖最后由 粘兽sama 于 2018-8-11 22:49 编辑 \n\n奠老nb\n奠老nb\n奠老nb"
        },
        {
            "author": "Hai_tun",
            "timestamp": 1534166580,
            "txt_content": "莫老nb\n有点看不懂(懒)"
        },
        {
            "author": "mmmmm_ccccc",
            "timestamp": 1534861440,
            "txt_content": "很牛逼，收藏了以后再看"
        },
        {
            "author": "Fram",
            "timestamp": 1534994400,
            "txt_content": "挺好的教程，但是我 不具有阅读混淆代码的能力和NMS基础和Java基础以及反射(reflect)的知识"
        },
        {
            "author": "楠木i",
            "timestamp": 1535179500,
            "txt_content": "请问我可否将此教程转载至 www.mcres.cn ？\n我将注明原帖处"
        },
        {
            "author": "602723113",
            "timestamp": 1535195220,
            "txt_content": "1957863988 发表于 2018-8-25 14:45\n请问我可否将此教程转载至 www.mcres.cn ？\n我将注明原帖处\nAccepted，请注明原帖地址"
        },
        {
            "author": "楠木i",
            "timestamp": 1535260440,
            "txt_content": "602723113 发表于 2018-8-25 19:07\nAccepted，请注明原帖地址\n嗯感谢。"
        },
        {
            "author": "936796603",
            "timestamp": 1537876140,
            "txt_content": " 本帖最后由 936796603 于 2018-9-25 21:36 编辑 \n\nisJump = EntityLiving.class.getDeclaredField(\"be\");\n这个be字段我反编译之后没有找到，在1.10.2里面\n\n我想知道它在1.9.4对应的方法名，所以需要和1.10.2对照一下。"
        },
        {
            "author": "qiangshuiya",
            "timestamp": 1538096940,
            "txt_content": "nbnb 看不懂在说什么"
        },
        {
            "author": "弱鸡绿毛怪",
            "timestamp": 1556857140,
            "txt_content": "补充:\nFloat是在水里浮着\n如果没有了会沉下去"
        },
        {
            "author": "轻光233",
            "timestamp": 1563687300,
            "txt_content": "那么，1.7就不配拥有姓名吗awa"
        },
        {
            "author": "子德",
            "timestamp": 1563754920,
            "txt_content": "为什么不用spfa呢？信竞算法大法好"
        },
        {
            "author": "w_cn",
            "timestamp": 1564282860,
            "txt_content": "1.11.2的迷性问题,重构类就不会生成在世界 求解。\n有进行设置Position"
        },
        {
            "author": "狡诈师",
            "timestamp": 1578739140,
            "txt_content": "1.12.2时发现帖子所指向网页中id已经不支持了\n\n而这个有效：https://minecraft.gamepedia.com/ ... attening/Entity_IDs"
        },
        {
            "author": "guanmouren",
            "timestamp": 1581584460,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "MikuScarlet",
            "timestamp": 1583060220,
            "txt_content": "不覆盖实体的话，服务器重启会变成默认的僵尸吗？"
        },
        {
            "author": "luanmenglei",
            "timestamp": 1589630220,
            "txt_content": " 本帖最后由 luanmenglei 于 2020-5-16 20:53 编辑 \n\n1.8不能用wiki.vg上的参数"
        }
    ]
}