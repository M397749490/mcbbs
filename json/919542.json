{
    "title": "[已解决]高手帮忙看看，这段代码有什么问题吗？",
    "author": "stevenldj",
    "replyCount": 13,
    "timestamp": 1570780920,
    "txt_content": " 本帖最后由 stevenldj 于 2019-10-19 17:43 编辑 \n\n这是一个自定义的瓶子，功能：左键将“村民”或“动物”装入瓶中，右键从瓶中放出，环境 Forge-1.10.2-12.18.3.2185\n\n实际测试中发现在游戏中可以正常转移实体，但是退出游戏，重新进入后，部分村民其实并没有转移，还在原地。\n\n有人知道什么原因吗？\npackage com.catcher;\n\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.passive.EntityVillager;\nimport net.minecraft.entity.passive.EntityAnimal;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.EnumActionResult;\nimport net.minecraft.util.EnumHand;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.World;\nimport net.minecraft.util.EnumFacing;\n\npublic class Bottle extends Item {\n    private Entity prey = null;\n\n    public Bottle() {\n        // 禁止堆叠\n        this.setMaxStackSize(1);\n        // 在创造模式的“杂物”类别中\n        this.setCreativeTab(CreativeTabs.MISC);\n    }\n\n    // 左键：将实体装入瓶中\n    @Override\n    public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity) {\n        World world = player.worldObj;\n        // 只对村民和动物有效\n        if ((entity instanceof EntityVillager)\n                || EntityAnimal.class.isAssignableFrom(entity.getClass())) {\n            if (prey == null && !world.isRemote) {\n                prey = entity;\n                world.removeEntity(entity);\n            }\n            return true; // 不攻击实体\n        }\n        return false; // 攻击实体\n    }\n\n    // 右键：从瓶中放出实体\n    @Override\n    public ActionResult<ItemStack> onItemRightClick(ItemStack itemStackIn, World worldIn,\n            EntityPlayer playerIn, EnumHand hand) {\n        World world = playerIn.worldObj;\n        if (prey != null && !world.isRemote) {\n            // 计算实体放出的坐标\n            BlockPos pos = playerIn.getPosition();\n\n            EnumFacing facing = playerIn.getHorizontalFacing();\n            if (facing == EnumFacing.EAST) {\n                pos = pos.add(2, 0, 0);\n            } else if (facing == EnumFacing.WEST) {\n                pos = pos.add(-2, 0, 0);\n            } else if (facing == EnumFacing.SOUTH) {\n                pos = pos.add(0, 0, 2);\n            } else if (facing == EnumFacing.NORTH) {\n                pos = pos.add(0, 0, -2);\n            }\n            // 放出实体\n            prey.setPositionAndUpdate(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);\n            prey.isDead = false;\n            world.spawnEntityInWorld(prey);\n\n            prey = null;\n\n            return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, itemStackIn);\n        }\n        return new ActionResult<ItemStack>(EnumActionResult.FAIL, itemStackIn);\n    }\n}\n复制代码\n",
    "replies": [
        {
            "author": "土球球",
            "timestamp": 1570785480,
            "txt_content": "Item 代表的是物品类型，因此你是不能在 Item 的实例里存 Entity 的实例的，同时这样存还会强引用一个 Entity，从而带来内存泄露的问题，真正代表一组物品的是 ItemStack。\n你应该使用 Capability 系统，或者直接读写 NBT，在 ItemStack 里存储序列化成 NBT 的 Entity，序列化和反序列化 Entity 可以参照其 serializeNBT 和 deserializeNBT 两个方法。"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570806720,
            "txt_content": "土球球 发表于 2019-10-11 17:18\n[markdown]\n`Item` 代表的是物品**类型**，因此你是不能在 `Item` 的实例里存 `Entity` 的实例的，同时这样 ...\n谢谢版主回复，看了半天 Capability 系统，看不懂，感觉好复杂，要实现的东西太多，照着 FluidHandlerItemStack 勉强写出下面的代码（只存取村民），又不知道怎么用。\n\n如果不使用 Capability 系统，而是直接读写 NBT，应该在哪个函数里面编写代码呢？\n\npackage com.catcher;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport net.minecraft.entity.passive.EntityVillager;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.util.EnumFacing;\nimport net.minecraft.world.World;\nimport net.minecraftforge.common.capabilities.Capability;\nimport net.minecraftforge.common.capabilities.CapabilityInject;\nimport net.minecraftforge.common.capabilities.ICapabilityProvider;\n\npublic class VillagerHandlerItemStack implements IVillagerHandler, ICapabilityProvider {\n    public static final String VILLAGER_NBT_KEY = \"Villager\";\n    protected final ItemStack container;\n\n    @CapabilityInject(IVillagerHandler.class)\n    public static Capability<IVillagerHandler> VILLAGER_HANDLER_CAPABILITY = null;\n\n        public VillagerHandlerItemStack(ItemStack container) {\n                this.container = container;\n        }\n\n        @Override\n        public EntityVillager getVillager(World world) {\n                NBTTagCompound tagCompound = container.getTagCompound();\n                if (tagCompound == null || !tagCompound.hasKey(VILLAGER_NBT_KEY)) {\n            return null;\n        }\n                EntityVillager entity = new EntityVillager(world);\n                entity.deserializeNBT(tagCompound.getCompoundTag(VILLAGER_NBT_KEY));\n                return entity;\n        }\n\n        @Override\n        public void setVillager(EntityVillager villager) {\n                if (!container.hasTagCompound()) {\n            container.setTagCompound(new NBTTagCompound());\n        }\n                if (villager == null) {\n                        container.getTagCompound().removeTag(VILLAGER_NBT_KEY);\n                } else {\n                        NBTTagCompound villagerTag = new NBTTagCompound();\n                        villager.writeToNBT(villagerTag);\n\n                        container.getTagCompound().setTag(VILLAGER_NBT_KEY, villagerTag);\n                }\n        }\n\n        @Override\n        public boolean hasCapability(@Nonnull Capability<?> cap, @Nullable EnumFacing facing) {\n                return cap == VILLAGER_HANDLER_CAPABILITY;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Nullable\n        @Override\n        public <T> T getCapability(@Nonnull Capability<T> cap, @Nullable EnumFacing facing) {\n                if (cap == VILLAGER_HANDLER_CAPABILITY) {\n                        return (T) this;\n                } else {\n                        return null;\n                }\n        }\n}复制代码package com.catcher;\n\nimport net.minecraft.entity.passive.EntityVillager;\nimport net.minecraft.world.World;\n\npublic interface IVillagerHandler {\n        public EntityVillager getVillager(World world);\n        public void setVillager(EntityVillager villager);\n}复制代码\n\n"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570807080,
            "txt_content": "@森林蝙蝠现在还用2185你也不怕炸了\n\n炸了是什么意思？我从 Forge 官网下载的 1.10.2 的稳定版 MDK 就是这个版本啊。我是新手，对 Forge 不是很熟悉，别笑我 :)"
        },
        {
            "author": "森林蝙蝠",
            "timestamp": 1570813800,
            "txt_content": "stevenldj 发表于 2019-10-11 23:18\n@森林蝙蝠 \n\n炸了是什么意思？我从 Forge 官网下载的 1.10.2 的稳定版 MDK 就是这个版本啊。我是新手，对 F ...\n你没玩过多少mod吧？forge1.10.2最新版本是2511，和你这个差别很大，2185已经“不稳定”了，另，现在开发的都是1.12的mod，你弄1.10要干什么呢？"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570841040,
            "txt_content": "森林蝙蝠 发表于 2019-10-12 01:10\n你没玩过多少mod吧？forge1.10.2最新版本是2511，和你这个差别很大，2185已经“不稳定”了，另，现在开发 ...\n谢谢解答，我学习写 mod 还不到一个月的时间，了解的不是很多。写 1.10 的 mod 是因为我想玩“[RTG]真实地形生成”mod，它目前只稳定支持 1.10.2，所以我就写一些简单的 1.10.2 的 mod 自己玩玩而已。我写的都是很小的 mod，转成 1.12.2 也很简单，等 [RTG] 稳定支持 1.12.2 了，我再把我的 mod 改成 1.12.2 版本就好了。"
        },
        {
            "author": "3TUSK",
            "timestamp": 1570854780,
            "txt_content": " 本帖最后由 3TUSK 于 2019-10-12 12:39 编辑 \n\nMinecraft 1.12.2, Forge 14.23.5.2836, MCP stable_39\n\n/*\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n * \n * For more information, please refer to <http://unlicense.org/>\n */\n\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.EntityList;\nimport net.minecraft.entity.item.EntityItem;\nimport net.minecraft.entity.passive.EntityAnimal;\nimport net.minecraft.entity.passive.EntityVillager;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.init.Items;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.EnumActionResult;\nimport net.minecraft.util.EnumHand;\nimport net.minecraft.util.math.RayTraceResult;\nimport net.minecraft.world.World;\nimport net.minecraftforge.event.RegistryEvent;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\n\n@Mod(modid = \"trap_bottle\", name = \"Trap Bottle\", version = \"1.0.0\")\n@Mod.EventBusSubscriber(modid = \"trap_bottle\")\npublic final class Trap {\n       @SubscribeEvent\n       public static void item(RegistryEvent.Register<Item> event) {\n              event.getRegistry().register(new Item() {\n                     @Override\n                     public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity) {\n                            if (stack.hasTagCompound()) {\n                                   // 瓶子里有生物时不做任何操作。\n                                   return super.onLeftClickEntity(stack, player, entity);\n                            }\n                            // 只对村民和动物有效\n                            if (!entity.world.isRemote && (entity instanceof EntityVillager || entity instanceof EntityAnimal)) {\n                                   stack.setTagCompound(entity.serializeNBT());\n                                   entity.world.removeEntity(entity);\n                                   return true; // 不攻击实体\n                            }\n                            return false; // 攻击实体\n                     }\n\n                     @Override\n                     public ActionResult<ItemStack> onItemRightClick(World world, EntityPlayer player, EnumHand hand) {\n                            if (!world.isRemote && player.getHeldItem(hand).hasTagCompound()) {\n                                   ItemStack stack = player.getHeldItem(hand);\n                                   NBTTagCompound data = stack.getTagCompound();\n                                   if (data != null) {\n                                          Entity e = EntityList.createEntityFromNBT(data, world);\n                                          if (e != null) {\n                                                 RayTraceResult traceResult = world.rayTraceBlocks(player.getPositionEyes(0F), player.getPositionEyes(0F).add(player.getLook(0F).scale(5D)));\n                                                 if (traceResult == null) {\n                                                        // 光线追踪未能获得可靠坐标，跳过反序列化流程\n                                                        return ActionResult.newResult(EnumActionResult.PASS, stack);\n                                                 }\n                                                 e.setPositionAndUpdate(traceResult.hitVec.x, traceResult.hitVec.y, traceResult.hitVec.z);\n                                                 world.spawnEntity(e);\n                                                 stack.setTagCompound(null); // 清理数据\n                                                 return ActionResult.newResult(EnumActionResult.SUCCESS, stack);\n                                          } else {\n                                                 stack.setTagCompound(null); // 实体生成失败，清理无效数据\n                                                 return ActionResult.newResult(EnumActionResult.FAIL, stack);\n                                          }\n                                   } else {\n                                          stack.setTagCompound(null);\n                                          return ActionResult.newResult(EnumActionResult.FAIL, stack);\n                                   }\n                            }\n                            return ActionResult.newResult(EnumActionResult.PASS, player.getHeldItem(hand));\n                     }\n              }.setTranslationKey(\"trap_bottle.trap_bottle\").setRegistryName(\"trap_bottle\", \"trap_bottle\"));\n       }\n}\n复制代码\n\n没错这段代码是 7space 缩进的。"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570869720,
            "txt_content": " 本帖最后由 stevenldj 于 2019-10-12 16:46 编辑 \n3TUSK 发表于 2019-10-12 12:33\nMinecraft 1.12.2, Forge 14.23.5.2836, MCP stable_39\n谢谢 3TUSK 的代码，帮我解决了 NTB 存取的问题，而且实现了准确定位目标坐标，非常感谢。\n\n由于我想在 1.10.2 中使用，所以我把它转换成了 1.10.2 的代码。另外，我喜欢你的 unlicense，所以也把它加在了我的代码里面，感觉很好 :)\n\n只是还有一个问题，无论是 1.10.2 还是 1.12.2，这个 mod 在处理村民时都有 bug，当把村民装进瓶子后，退出游戏，再重新进入，会发现之前收入瓶中的村民依然在世界中存在（能看见），但是瓶子里已经有数据了，右键后能看到释放村民时的手臂动作，但除此之外，什么也没发生。\n\n这个 mod 对动物的处理是没有问题的，我想，在 EntityVillager 中应该有什么地方没有考虑到，我看了 EntityVillager 的代码，但是没找到有用的信息，有高手能帮忙指点一下迷津吗？先在此谢过！\n\nForge-1.10.2-12.18.3.2511   MCP:snapshot_20161111\n/*\n * This is free and unencumbered software released into the public domain.\n *\n * Anyone is free to copy, modify, publish, use, compile, sell, or\n * distribute this software, either in source code form or as a compiled\n * binary, for any purpose, commercial or non-commercial, and by any\n * means.\n *\n * In jurisdictions that recognize copyright laws, the author or authors\n * of this software dedicate any and all copyright interest in the\n * software to the public domain. We make this dedication for the benefit\n * of the public at large and to the detriment of our heirs and\n * successors. We intend this dedication to be an overt act of\n * relinquishment in perpetuity of all present and future rights to this\n * software under copyright law.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n *\n * For more information, please refer to <http://unlicense.org/>\n */\n\nimport net.minecraft.creativetab.CreativeTabs;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.EntityList;\nimport net.minecraft.entity.passive.EntityVillager;\nimport net.minecraft.entity.passive.EntityAnimal;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.util.ActionResult;\nimport net.minecraft.util.EnumActionResult;\nimport net.minecraft.util.EnumHand;\nimport net.minecraft.util.math.RayTraceResult;\nimport net.minecraft.world.World;\n\npublic class ItemBottle extends Item {\n\n    public ItemBottle() {\n        // 禁止堆叠\n        this.setMaxStackSize(1);\n        // 在创造模式的“杂物”类别中\n        this.setCreativeTab(CreativeTabs.MISC);\n    }\n\n    // 左键：将实体装入瓶中\n    @Override\n    public boolean onLeftClickEntity(ItemStack stack, EntityPlayer player, Entity entity) {\n        // 只对村民和动物有效\n        if (entity instanceof EntityVillager || entity instanceof EntityAnimal) {\n            // 瓶子必须为空，在服务器端操作\n            if (!stack.hasTagCompound() && !entity.worldObj.isRemote) {\n                // 保存实体数据\n                stack.setTagCompound(entity.serializeNBT());;\n                // 从世界中移除实体\n                entity.worldObj.removeEntity(entity);\n            }\n            // 不攻击动物和村民\n            return true;\n        }\n        // 攻击其它实体\n        return super.onLeftClickEntity(stack, player, entity);\n    }\n\n    // 右键：从瓶中放出实体\n    @Override\n    public ActionResult<ItemStack> onItemRightClick(ItemStack itemStackIn, World worldIn,\n            EntityPlayer playerIn, EnumHand hand) {\n        // 1.12.2 版本中不再有 ItemStack 参数，所以这里也不使用该参数，便于将来过渡到高版本\n        ItemStack stack = playerIn.getHeldItem(hand);\n        // 瓶子不能为空，在服务器端操作\n        if (stack.hasTagCompound() && !worldIn.isRemote) {\n            // 读取实体数据\n            NBTTagCompound data = stack.getTagCompound();\n            if (data == null) {\n                stack.setTagCompound(null);\n                return ActionResult.newResult(EnumActionResult.FAIL, stack);\n            }\n            // 计算实体放置坐标\n            RayTraceResult traceResult = worldIn.rayTraceBlocks(playerIn.getPositionEyes(0F),\n                    playerIn.getPositionEyes(0F).add(playerIn.getLook(0F).scale(5D)));\n            if (traceResult == null) {\n                // 光线追踪未能获得可靠坐标，跳过反序列化流程\n                return ActionResult.newResult(EnumActionResult.PASS, stack);\n            }\n            // 创建实体\n            Entity entity = EntityList.createEntityFromNBT(data, worldIn);\n            if (entity == null) {\n                stack.setTagCompound(null); // 实体生成失败，清理无效数据\n                return ActionResult.newResult(EnumActionResult.FAIL, stack);\n            }\n            // 放出实体\n            entity.setPositionAndUpdate(traceResult.hitVec.xCoord, traceResult.hitVec.yCoord, traceResult.hitVec.zCoord);\n            worldIn.spawnEntityInWorld(entity);\n\n            stack.setTagCompound(null);\n            return ActionResult.newResult(EnumActionResult.SUCCESS, stack);\n        }\n        return ActionResult.newResult(EnumActionResult.FAIL, stack);\n    }\n}复制代码\n代码着色怎么这么奇怪？"
        },
        {
            "author": "3TUSK",
            "timestamp": 1570906560,
            "txt_content": "stevenldj 发表于 2019-10-12 16:42\n谢谢 3TUSK 的代码，帮我解决了 NTB 存取的问题，而且实现了准确定位目标坐标，非常感谢。\n\n由于我想在 1. ...\n论坛现在用的代码高亮似乎有问题。\n\n\n\n重新测试了一遍，并没有你说的问题。村民进瓶子里后退出游戏，然后重新进游戏仍可放出来。试试把 entity.worldObj.isRemote 的检查放到最外面？"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570932720,
            "txt_content": " 本帖最后由 stevenldj 于 2019-10-13 10:52 编辑 \n3TUSK 发表于 2019-10-13 02:56\n重新测试了一遍，并没有你说的问题。村民进瓶子里后退出游戏，然后重新进游戏仍可放出来。试试把 entity.worldObj.isRemote 的检查放到最外面？\n这个问题似乎在多次重新登陆后才会出现，我录制了一段视频显示了这个问题（直接使用你给出的代码进行的测试），而且之后我对动物的测试也出现了同样的问题，看来不是村民特有的 bug。\n\n\n\n\n\n1.gif (828.31 KB, 下载次数: 0)\n\n下载附件\n\n2019-10-13 09:59 上传\n\n\n\n\n\n测试过程：在浅色栅栏中放入 3 个村民，然后用 mod 移到深色栅栏中，重新登陆，再从深色栅栏移回去，再重新登陆，结果村民并没被移回去，还在深色栅栏中，继续测试，将一个村民装入瓶中，再重新登陆，结果瓶中的村民出现在浅色栅栏中，右键有释放动作，但没有新的村民被放出。\n\n\n\n在我昨天的测试中，我反复将多个村民在两个地点之间来回转移，后来发现，有时候村民被移走后，它的碰撞箱还在，当将另一个村民放出来的时候，明明那里是一片空地，可还是会被残留的碰撞箱挤走。还有，晚上，当僵尸看上屋子里的一个村民后，我从窗户把村民移走，结果僵尸还是对村民原来的位置感兴趣，我把房门打破，僵尸进屋后，就走到村民原来的位置，不停的挥舞胳膊，好像那里有个目标似的，一直不肯离开。（测试的时候也进行过多次重新登陆）\n\n总感觉是数据同步的问题，但搞不清楚到底是哪里出的问题。\n\n\n\n"
        },
        {
            "author": "3TUSK",
            "timestamp": 1570944120,
            "txt_content": "stevenldj 发表于 2019-10-13 10:12\n这个问题似乎在多次重新登陆后才会出现，我录制了一段视频显示了这个问题（直接使用你给出的代码进行的测 ...\n说句实话，这个情况挺可疑的。\n试试 Entity.setDead()（func_70106_y）？这个方法的名字起得不是很好，有迹象显示它更接近“标记为待清除”（markForRemoval）的意思。stable_39 之后的 MCP 里这个方法也换了个名字叫 remove。"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570972020,
            "txt_content": " 本帖最后由 stevenldj 于 2019-10-13 21:31 编辑 \n3TUSK 发表于 2019-10-13 13:22\n说句实话，这个情况挺可疑的。\n试试 Entity.setDead()（func_70106_y）？这个方法的名字起得不是很好，有 ...\n这个不好的名字似乎没起到什么作用，无论加在 removeEntity 之前还是之后，不过我在日志文件中发现了这个：\n[20:13:44] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 40c96675-ae14-4bc2-b473-8b96cfbf1908\n[20:13:44] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID db3eec73-d5f7-4d77-880a-2b4d761b4cdf\n[20:13:44] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID a5ce16d3-10f0-4bf8-8e10-8bfad702fa2d复制代码我不知道这个警告是哪个函数发出的，如果能找到它的源头，应该能发现点什么。\n\n同时我试图修改新生成的村民的 UUID，结果重新登陆后，出现了两组一模一样的村民，可以想到，旧的村民并没有被删除，新的 UUID 导致了新村民的产生。\n\n我想，现在的问题应该就是“旧的村民为什么被 Keeping？”，除了调用 removeEntity()，还应该做点什么？"
        },
        {
            "author": "stevenldj",
            "timestamp": 1570973340,
            "txt_content": "下面这个日志是我反复移动同一个村民并反复重新登陆后产生的，可以看到，多个具有相同 UUID 的村民被保留，由于 UUID 相同，所以世界中只显示了一个村民，但是其它未显示的村民依然被创建出来了，因为可以感觉到它们的碰撞箱：当我把村民放出去的时候，被那些隐形的村民挤来挤去。\n\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756\n[21:21:41] [Server thread/WARN] [net.minecraft.world.WorldServer]: Keeping entity minecraft:villager that already exists with UUID 3eaec950-9e6d-4e0f-9d01-8daa7d262756复制代码\n\n如果 MC 不删除旧村民，那么有没有一种办法，可以保留旧村民的实例，在需要的时候对其进行隐藏或显示？"
        },
        {
            "author": "stevenldj",
            "timestamp": 1571478000,
            "txt_content": "我好像找到原因了，问题出在 setPositionAndUpdate() 上面，它必须放在 spawnEntity() 之后才不会出错。但是在 spawnEntity() 之前还需要调用 setPosition() 设置实体的出生点，否则放出来的实体还在它原来的位置。需要改动的代码如下（以 3TUSK 给出的代码为基础，改动第 31 和 32 行，其它地方不需要改动）：\n\ne.setPosition(traceResult.hitVec.x, traceResult.hitVec.y, traceResult.hitVec.z);\nworld.spawnEntity(e);\ne.setPositionAndUpdate(traceResult.hitVec.x, traceResult.hitVec.y, traceResult.hitVec.z);复制代码\n\n我经过简单的测试，没有再出现之前的问题了，而且日志中也不再出现之前的警告了。\n\n很开心，感谢各位的热心帮助，特别感谢 3TUSK，你的代码给了我很多帮助，非常感谢！\n"
        }
    ]
}