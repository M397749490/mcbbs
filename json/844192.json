{
    "title": "1.13手把手教学，用指令写一个黄金矿工！",
    "author": "Sairos",
    "replyCount": 21,
    "timestamp": 1550136120,
    "txt_content": " 本帖最后由 Sairos 于 2019-2-14 17:21 编辑 \n\n1、游戏简介\n\n1.1 原版黄金矿工游戏介绍\n黄金矿工是一款益智类小游戏。该游戏中，可以通过\"挖矿\"获得积分并不断升级。在规定的时间内得到规定的金钱时即可进入下一关。 其游戏方式就是按下一个键，矿工的抓钩就会发射出去，若与矿物接触则会把矿物带回来。\n\n\n\n\n20190211_173538_20190211173634.gif (809.86 KB, 下载次数: 6)\n\n下载附件\n\n2019-2-11 17:36 上传\n\n\n\n\n\n\n1.2 Minecraft黄金矿工游戏介绍\n黄金矿工在Minecraft里面还是会在一个面上抓取矿物进行游戏，基本和原版黄金矿工差不多，只是外观上不一样，矿物也或多或少不一样（比如原版里面有骨头、头颅和移动的耗子，还有商店，我在Minecraft写完了黄金矿工再去玩原版才发现的...所以在本作品里面没有以上所述元素.....） \n游戏展示：\n\n\n\n\n2.gif (860.8 KB, 下载次数: 9)\n\n下载附件\n\n2019-2-11 19:07 上传\n\n\n\n\n\n\n\n\n\nfile_1549883291000.jpg (213.19 KB, 下载次数: 6)\n\n下载附件\n\n2019-2-11 19:08 上传\n\n\n\n\n\n\n 之后我会尽量一步一步详细讲解指令写出这样的小游戏\n2、地图设置\n2.1 创建地图\n我觉得这步骤没什么好说的....单人游戏->创建新的世界->世界类型->自定义->预设->虚空\n2.2 创建函数\n找到自己的saves地图文件，datapacks->创建文件夹main并打开->创建一个文本文档并改名为pack后缀名mcmeta，右键打开方式记事本打开，输入以下内容{\n   \"pack\": {\n      \"pack_format\": 1,\n      \"description\": \"xxxxx\"\n   }\n}\n\n（关于书写function我用的是notepad++，记事本也是可以的） 再创建一个文件夹data并打开->创建一个文件夹minecraft并打开->创建两个文件夹分别为functions和tags->\n在tags里面创建一个文件夹functions，在里面新建一个文本文档改名为tick后缀json打开并在里面输入：\n{\n        \"values\": [\n                \"minecraft:main\"\n        ]\n}\n再返回打开第一个functions文件夹，创建以下之后需要用到的function：\nmain.mcfunction\nmapsettings.mcfunction\npass.mcfuntion\nq.mcfunction\nrotatedhead.mcfunction\nscore.mcfuntion\nsummonore.mcfunction\ntime.mcfuntion\n\n\n\n2.3 地图布置\n\n其实这个也没什么好说的，把以下指令写入mapsettings就行了\nfill 20 9 -13 20 9 10 stone\nfill 21 10 14 21 10 -14 stone\nfill 22 11 -16 22 11 16 stone\nfill 23 12 -16 23 12 16 stone\nfill 24 13 -16 24 13 16 stone\nfill 25 14 -16 25 14 16 stone\nfill 26 15 -16 26 15 16 stone\nfill 27 16 -16 27 16 16 stone\nfill 28 17 -16 28 17 16 stone\nfill 29 18 -16 29 18 16 stone\nfill 30 19 -16 30 19 16 stone\nfill 31 20 -16 31 20 16 stone\nfill 32 21 -16 32 21 16 stone\nfill 17 3 -17 17 31 17 minecraft:orange_terracotta\nfill 16 3 17 16 31 17 minecraft:spruce_log\nfill 16 3 -17 16 31 -17 minecraft:spruce_log\nfill 16 31 -16 16 31 16 minecraft:spruce_log\nfill 15 7 -17 15 31 17 minecraft:barrier\nfill 16 4 16 16 6 -16 minecraft:obsidian replace minecraft:air\nsetblock 0 19 0 minecraft:barrier\nfill 1 18 -1 -1 18 1 minecraft:barrier复制代码放入main函数用function minecraft:mapsettings激活就行了。关于地图部分，我都是以我自己做的为例来写，不一定要我这样的。\n\n3、游戏制作\n注：在阅读该部分内容之前，若有对指令不熟悉者.....请详看如下两个链接.....\n（重点在execute、scoreboard，其次看data等其他相关指令操作）\nhttps://minecraft-zh.gamepedia.com/%E5%91%BD%E4%BB%A4\nhttps://minecraft-zh.gamepedia.com/%E8%AE%B0%E5%88%86%E6%9D%BF#.E5.91.BD.E4.BB.A4.E5.88.97.E8.A1.A8\n3.1 抓钩制作\n\n既然要制作抓钩相关的，首先要有抓钩对吧，（main.mcfunction）\nreplaceitem entity @a hotbar.0 minecraft:carrot_on_a_stick{display:{Name:\"\"火箭机械手\"\"}}复制代码emmmm至于为什么这个叫做火箭机械手就别管了......\n这会用到以下几个计分板：\n/scoreboard objectives add Q minecraft.used:minecraft.carrot_on_a_stick\n/scoreboard objectives add q dummy\n/scoreboard objectives add time dummy\n/scoreboard objectives add suiji dummy复制代码\n     很明显第一个计分板就是针对使用抓钩的，它是一个萝卜钓竿，拿着它右键一次，名为Q的计分板就会+1\n     第二个计分板是名为q的计分板，是用来做标记用\n     第三个计分板time，顾名思义，记录时间，它将会用来记录抓钩的存在时间\n     第四个计分板，等讲到矿物相关部分再做说明\n\n（q.mcfunction）：\nexecute as @a if entity @a[nbt={SelectedItem:{id:\"minecraft:carrot_on_a_stick\",tag:{display:{Name:\"\"火箭机械手\"\"}}}}] run tag @s add jqr\nexecute as @a unless entity @a[nbt={SelectedItem:{id:\"minecraft:carrot_on_a_stick\",tag:{display:{Name:\"\"火箭机械手\"\"}}}}] run tag @s remove jqr\n复制代码\n     在q.mcfunction里面写入这两条指令，表示玩家是否手持名为火箭机械手的萝卜钓竿，当玩家拿着它时，给玩家加一个名为jqr的tag，当没有拿着时，则去除这个tag\n\n     我们要实现的是，玩家拿着萝卜钓竿右键，抓钩就会发射出去这样的效果，那么很明显，玩家是能够自由移动的，而抓钩本身的位置应该是固定的，那么，在打成这样的效果之前，要有一个固定的抓钩对吧？\n在main函数里面要写入这两条指令（main.mcfuntion）：\nexecute unless entity @e[name=222,type=minecraft:armor_stand] run summon minecraft:armor_stand 16 27 0 {Invisible:1b,CustomNameVisible:0b,ArmorItems:[{},{},{},{id:\"minecraft:creeper_head\",Count:1b,Damage:0s}],CustomName:\"222\",NoGravity:1b,Pose:{Head:[0f,1f,0f]},Tags:[\"jia\",\"jqr\"]}\nexecute unless entity @e[name=555,type=minecraft:armor_stand] run summon minecraft:armor_stand 16 29 0 {CustomName:\"\"555\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:stone\",Count:1b,Damage:0s}],Tags:[\"canzao\"]}\n复制代码\n     这两条指令表示当世界没有名为222和555的盔甲架实体的时候他会召唤这样的两个实体到指定位置(这算我自己写的一个瑕疵，name=222和name=555，我写的里面没有加type=盔甲架，这样会导致有可能有些玩家名字就叫做222和555的，从而导致世界一直在生成这样的盔甲架，请自行修改了就好了)\n\n     名为555头带石头的盔甲架实体，在之后的步骤中会随着名为222的实体的视线移动而移动，这个实体就是一个参照，这会方便玩家在发射钩子的时候，知道钩子会以两个实体构成的直线发射，使玩家发射钩子抓东西更加精确，name=555这个实体内容在下一个小节会讲\n且看指令（q.mcfunction）：\n<font size=\"4\">&1\nexecute as @e[tag=gouzi] at @s run particle minecraft:crit ~ ~0.8 ~ 0.1 0.1 0.1 0.1 20\n&2\nexecute if entity @a[scores={Q=1..}] run tag @a add yes\nexecute if entity @e[tag=gouzi] run tag @a remove yes\n&3\nexecute as @a[tag=jqr,tag=yes,scores={Q=1..}] at @e[name=222,tag=you] run summon minecraft:armor_stand ~ ~ ~ {Rotation:[0f,0f],Tags:[\"gouzi\"],Invisible:1b,CustomNameVisible:0b,ArmorItems:[{},{},{},{id:\"minecraft:creeper_head\",Count:1b,Damage:0s}],CustomName:\"2333\",Pose:{Head:[0F,0F,0F]},NoGravity:1b}\nexecute as @a[tag=jqr,tag=yes,scores={Q=1..}] at @e[name=222,tag=zuo] run summon minecraft:armor_stand ~ ~ ~ {Rotation:[180f,0f],Tags:[\"gouzi\"],Invisible:1b,CustomNameVisible:0b,ArmorItems:[{},{},{},{id:\"minecraft:creeper_head\",Count:1b,Damage:0s}],CustomName:\"2333\",Pose:{Head:[0F,0F,0F]},NoGravity:1b}\n&4\nexecute as @a[tag=jqr,scores={Q=1..}] at @s run tag @e[name=2333,tag=gouzi] add q\n&5\nscoreboard players set @a[scores={Q=1..},tag=jqr] Q 0\n&6\nscoreboard players add @e[name=2333,tag=q] q 1\nexecute as @e[name=2333,tag=gouzi,scores={q=1},tag=q] at @s store result entity @s Rotation[1] float 1 run scoreboard players get @e[limit=1,name=222] rotate\n&7\nexecute as @e[tag=gouzi,name=2333,scores={q=6..}] at @s run tag @s remove q\nexecute as @e[name=2333,scores={q=2..},tag=!caught] at @s run tp ^ ^ ^0.7</font>复制代码名为222的苦力怕头颅的盔甲架实体，在玩家右键萝卜钓竿后，会以它为中心，它的朝向发射一个名为2333的实体       &1部分就是粒子效果，加给tag=gouzi的\n     &2部分则是确保一次只能发射一个钩子，且看&3部分，当Q=1..也就是玩家使用了萝卜钓竿，tag=yes，之后，以name=222，tag=you/zuo 的盔甲架实体为中心召唤一个带有tag=gouzi的盔甲架，而这个tag=yes，正是&2部分的内容，当玩家Q=1..时，给玩家tag=yes，只要玩家有了tag=yes才能保证&3部分能正常执行，为什么说&2部分能保证玩家一次只能发射一次？正是该部分的第二条指令，当tag=gouzi的实体存在时，就会除掉玩家的tag=yes，这样就保证了任凭玩家如何使用萝卜钓竿，没有tag=yes，都是不会再生成发射出去的钩子了。\n     注意！！！!&2部分的指令必须放在这儿！只有这样放才能完成这样的逻辑，否则就失效了\n     &4部分给发射出去的钩子加了一个tag q，这就是为了执行之后的动作做铺垫了\n     &5部分初始化了玩家使用萝卜钓竿的分数\n     &6部分第二条指令就是获取name=555的盔甲架的朝向，然后让tag=gouzi也即发射出去的钩子的朝向与name=555的一致，也就是name=555的盔甲架往哪儿看，钩子就往哪儿发射，该部分的第一条指令是一直给钩子加分\n，因为在第二条指令激活的条件是q=1的时候，如果q不等于1那就无法调整发射角度。\n     这该如何理解?为什么这么做，是因为funtion每次执行里面的指令的时候，他都是从上往下一条一条的扫描下去，如果满足触发指令要求，就执行一次，不满足，则不执行\n\n且看其中的逻辑：\n执行第一次q.mcfunction：\n  召唤钩子（q=0） -> 给钩子的记分板名为q的加1分（q=1）-> 满足@e[name=2333,tag=gouzi,scores={q=1},tag=q]（因为q=1） 调整角度 -> 后续处理.....\n执行第二次q.mcfunction：\n  钩子已经召唤，无需召唤（q=1）-> 给钩子的记分板名为q的加1分（q=2）-> 不满足\n@e[name=2333,tag=gouzi,scores={q=1},tag=q]（因为q=2>1）不调整角度 -> 后续处理....\n     该逻辑其实与之前的保证一次只能发射一个钩子是一样的\n     &7部分也即处理完朝向问题后，将钩子发射出去\n接下来是钩子发射出去之后的处理\n&8\nscoreboard players add @e[name=2333] time 1\nexecute</b> as @e[tag=gouzi,scores={time=224..}] at @s run kill @s\nexecute as @e[tag=gouzi,scores={time=34..}] at @s run tag @s add caught\n&9\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao] run tag @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] add caught\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao] run tag @e[tag=!jqr,distance=..1,limit=1,tag=!gouzi] add caught\n复制代码\n&10\nexecute as @e[tag=gouzi,tag=caught] at @s run tp @e[tag=caught,tag=!gouzi] ~ ~0.8 ~\n&11\nexecute as @e[tag=gouzi,tag=caught] at @s facing entity @e[name=222] feet run tp ^ ^ ^0.8\n\nexecute as @e[tag=gouzi] at @s if entity @e[tag=jqr,distance=..2] run tag @e[tag=!gouzi] remove caught\nexecute as @e[tag=gouzi] at @s if entity @e[tag=jqr,distance=..2] run tag @e[tag=!gouzi] remove q\n\nexecute as @e[tag=gouzi,tag=caught] at @s if entity @e[tag=jqr,distance=..1] run kill @s\n\nexecute as @e[tag=ore1] at @s if entity @e[tag=jqr,distance=..2] run kill @s复制代码\n\n     &8部分就是决定钩子的存在时间，当钩子发射出去之后，其记分板time就会一直加分，当加到224或以上后，会kill掉钩子，当加到34以后，会给钩子一个tag=caught，这个caught干嘛的，指令往后看\n     &9部分就是给与钩子挨得最近的一个实体加tag=caught，同时也给自己加caught，caught对应英文，被抓住，之后自然就是在有了被抓住的tag=caught的处理了\n     &10部分就是让被抓住的实体（即带有tag=caught的）一直往钩子上方0.8处tp，也即模拟矿物被钩子抓住然后跟着钩子走\n     &11部分自然就是钩子满足一定条件后收回来咯，然后就是一旦有了caught这个tag，就会执行这一条，往前面指令看明显有两个情况，一是抓到了其他实体，也即矿物，二就是当其分数time=34..的时候，就会有caught这个tag然后执行该部分指令\n     之后就是抓回来的处理了，被抓物去掉tag，kill掉钩子\n\n3.2 抓钩摆动\n因为钩子的发射角度是根据名为222的盔甲架的头朝向来判断的，所以需要不断的改变其头颅朝向，至于为什么要改头颅的朝向是因为多少做个动画啊对吧，因为盔甲架的rotation在y轴方向变化是看不到的，所以用头颅转向就肉眼可见了（rotatehead.mcfunction）\n#/scoreboard objectives add rotate dummy\n#/summon minecraft:armor_stand ~ ~ ~ {CustomName:\"\"555\"\",CustomNameVisible:1b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:stone\",Count:1b,Damage:0s}],Tags:[\"canzao\"]}\n&1\ntag @e[name=555] add xuanzhuan\nexecute if entity @e[tag=gouzi] run tag @e[name=555] remove xuanzhuan\nexecute as @e[type=minecraft:armor_stand,name=222] at @s store result entity @s Rotation[1] float 1 run scoreboard players get @s rotate\nexecute as @e[name=\"555\",tag=xuanzhuan] at @e[name=\"222\"] rotated as @e[name=\"222\"] run tp @s ^ ^ ^2\n&2\ntag @e[name=222] add xuanzhuan\nexecute if entity @e[tag=gouzi] run tag @e[name=222] remove xuanzhuan\nexecute as @e[type=minecraft:armor_stand,name=222,tag=xuanzhuan] at @s store result entity @s Pose.Head[0] float 1 run scoreboard players get @s rotate\n&3\nscoreboard players add @e[tag=jia] rotate 3\nscoreboard players remove @e[tag=jian] rotate 3\n&4\nexecute as @e[name=222,scores={rotate=90..},tag=zuo] at @s run data merge entity @s {Rotation:[0f,0f]}\nexecute as @e[name=222,scores={rotate=90..},tag=you] at @s run data merge entity @s {Rotation:[180f,0f]}\n&5\ntag @e[nbt={Rotation:[0f,0f]}] add you\ntag @e[nbt={Rotation:[0f,0f]}] remove zuo\n\ntag @e[nbt={Rotation:[180f,0f]}] add zuo\ntag @e[nbt={Rotation:[180f,0f]}] remove you\n\ntag @e[scores={rotate=90..}] remove jia\ntag @e[scores={rotate=90..}] add jian\n\ntag @e[scores={rotate=..0}] remove jian\ntag @e[scores={rotate=..0}] add jia复制代码\n我们知道转向范围是在下半圆，而盔甲架头颅从朝向从x轴角度转到y轴角度是0到90度，\n如图，\n\n\n\n\n55{6W[FU~ZFI}I$%8GOLD.png (245.64 KB, 下载次数: 12)\n\n下载附件\n\n2019-2-14 12:53 上传\n\n\n\n\n\n     比如从下半圆的点1转到点2的位置，再转到点3，单纯从角度考虑，是0->90->0\n     那么我们一开始的思路可以是，让计分板从0加分加到90再从90减到0，然后把分数store入头颅的朝向\n     但是就有一个问题，直接这样做你会发现，他只会在四分之一圆，左下半圆或则右下半圆来回转动，其原因就在于其盔甲架自身朝向的问题...所以我们需要做的工作是，头颅朝向从0度转到90度（也即点1到点2），盔甲架身体转180度，头颅再从90度转到0度（这时候就是点二到点三）\n     这期间的头颅转向角度和身体转向的判定，我就是用四个tag来实现，zuo，you，jia，jian，\n也就是&5部分\n当盔甲架身体朝向是0时，加tag=you，去掉tag=zuo\n当盔甲架身体朝向是180时，加tag=zuo，去掉tag=you\n当盔甲架rotate分数大于90时，加tag=jian，去掉tag=jia\n当盔甲架rotete分数小于0时，加tag=jia，去掉tag=jian\n     而tag=zuo和tag=右就是用于判断身体是朝着左边还是有边，tag=jia和tag=jian就是判断头颅转角是增加还是减少，这分别就对应了&4 &3 &2的第三条指令\n那就还剩下了&1部分和&2的前两条指令，&1的第三第四条指令就是name=555的盔甲架，如上一小节所述，这个盔甲架就是随着头颅转动而运动，用于方便玩家判断自己发射钩子的角度，两个盔甲架连成的一条直线，钩子发射的轨迹就在这条直线上\n     在原版黄金矿工里面，有很奇怪的一点，那就是钩子发射出去，再收回来的时候你会发现，收回来之后钩子的调度并不是对应的发射出去的角度，如图：\n\n\n\n\n20190214_132046_20190214132637.gif (678.57 KB, 下载次数: 12)\n\n下载附件\n\n2019-2-14 13:27 上传\n\n\n\n\n\n     而我这里正是模仿了原版的这一点，所以就有了&1部分的前两条与&2部分的前两条指令，这四条指令都会分别影响到这两部分之后的指令执行，这里实现的就是，只有在有tag=xuanzhuan的情况下，记分板分数才会store入两个盔甲架的转向角度，当发射出去的钩子（name=2333这个盔甲架）存在的时候，就会remove掉该tag，这样盔甲架就不会获取记分板分数从而不转向保持在发射钩子这个角度，而&3部分就是记分板分数的增加与减少，不管有没有这个tag，记分板都会自己运算，当钩子回收，tag add xuanzhuan之后，盔甲架继续获取记分板的值，这之后，盔甲架角度就会转到之后记分板继续计算的角度了，正好也就实现了原版游戏里那奇怪的一点.....\n     看不懂这一段的读者，可以在写该游戏的时候自行体会\n\n3.3 引入矿物\n\n     抓钩做好了，我们就需要引入矿物部分了，跟去写出的抓钩的特性，很明显矿物是实体，我这里就用隐形的盔甲架头戴不同的矿物来代表了。\n\n\n\n\nCW]70]4$(7YYMK6X30D]D`Y.png (185.13 KB, 下载次数: 9)\n\n下载附件\n\n2019-2-14 13:40 上传\n\n\n\n\n\n\n\n\nW~P}$WS50J~{~13C%}]M~]L.png (147.79 KB, 下载次数: 13)\n\n下载附件\n\n2019-2-14 13:41 上传\n\n\n\n\n\n     以上两张图都是第一关，但是矿物的位置却是不同的，在这里我可以理解为，矿物的位置是随机放的，而我们在MC里就要实现每关矿物都是随机放置\n     在这里我们就涉及产生随机数的问题，学过编程的人应该知道，对于随机数我们一般是有对应的函数来获取的，比如python中，random.randint(0,100)就可以获取0-100的随机数，比如C语言中，rand()%101也是获取0-100的随机数，当然这是有对应的函数来实现的，前者需要导入random，后者需要引入stdlib.h，如果不用函数库提供给我们的函数，也可以自己写一个函数来产生随机数。 \n     在Minecraft里面就没有直接获取随机数的，所以随机放置矿石，其中一个办法就是自己生产随机数，然后将随机数赋值给矿物实体的坐标。产生随机数就简单了啊，比如我们要产生0-100范围的随机数，那就让一个计分板变量从0加到100，当自己需要的时候就让这个变量的分数赋值给另外一个变量，这样产生的随机数就是在0-100之间了，但是这样做有一个很明显的瑕疵，计分板每次+1从0加到100需要5s，如果熟悉这个计分板，那就可以根据时间得到自己大致想要的分数范围，所以可以细化，第一个变量每次+10，从0加到90，第二个变量每次加1，从0加到9，然后获取随机数的时候先让着两个变量相加再将其赋值给第三个变量，这样发生每一轮随机数就从5秒缩减到了0.5s。\n     emmmm，以上内容，跟矿物随机放置位置无关......只是简单说一下mc随机数的问题（这个方**在设置矿物的时候会用到）在这里我要用的是另一个办法，我选择就地取材，在mc里面虽然不能直接获取随机数，但是也有与随机相关的东西，没错，spreadplayers，读到这里，你或许就奇怪了，这个指令随机散步玩家条件是要有落地点，也就是直接使用该指令，矿物是不会落进游戏屏幕里面的，那spreadplayers怎么用？这个在前文其实有了铺垫，在第二节的第三小节的内容里面，是不是有好些个fill stone？fill那么多stone，就是为了在这里使用，我并不打算spreadplayers让盔甲架直接落进屏幕里面，而是散布到这些石头上面。如图：\n\n\n\n\nfile_1550124427000.jpg (176.4 KB, 下载次数: 15)\n\n下载附件\n\n2019-2-14 14:07 上传\n\n\n\n\n\n在游戏屏幕后面有这样一个石头构成的阶梯，我会让召唤的矿物散布在这个阶梯上，然后让他们移动进入屏幕内，\n在讲这个之前，先做这样一个工作：（main.mcfunction）\nexecute unless entity @e[name=golds] run summon minecraft:armor_stand 44 16 5 {CustomName:\"\"golds\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:gold_ore\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=stones] run summon minecraft:armor_stand 44 16 4 {CustomName:\"\"stones\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:stone\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=coals] run summon minecraft:armor_stand 44 16 3 {CustomName:\"\"coals\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:coal_ore\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=irons] run summon minecraft:armor_stand 44 16 2 {CustomName:\"\"irons\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:iron_ore\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=obsidians] run summon minecraft:armor_stand 44 16 1 {CustomName:\"\"obsidians\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:obsidian\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=diamonds] run summon minecraft:armor_stand 44 16 0 {CustomName:\"\"diamonds\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:diamond_ore\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=chests] run summon minecraft:armor_stand 44 16 -1 {CustomName:\"\"chests\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:chest\",Count:1b,Damage:0s}]}\nexecute unless entity @e[name=tnts] run summon minecraft:armor_stand 44 16 -2 {CustomName:\"\"tnts\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:tnt\",Count:1b,Damage:0s}]}\n复制代码这些名为golds stones等等的，只是用于参照，以它们为中心summon我们需要的矿物\n\n\n现在以金矿为例：（summonore.mcfunction）\nexecute as @e[name=golds] at @s if score @e[limit=1,name=golds] ores matches 1.. run summon minecraft:armor_stand ~ ~ ~ {CustomName:\"\"gold\"\",CustomNameVisible:0b,NoGravity:1b,Invisible:1b,ArmorItems:[{},{},{},{id:\"minecraft:gold_ore\",Count:1b,Damage:0s}],Tags:[\"gold\",\"pre_spread\",\"ore\",\"ore1\"]}\nexecute if score @e[limit=1,name=golds] ores matches 0.. run scoreboard players remove @e[name=golds] ores 1\nexecute if score @e[limit=1,name=golds] ores matches 0 run spreadplayers 27 0 3 12 false @e[tag=pre_spread]\nexecute if score @e[limit=1,name=golds] ores matches 0 run tag @e[tag=gold,tag=pre_spread] remove pre_spread\nexecute if entity @e[tag=ore,tag=!pre_spread] as @e[tag=ore,tag=!pre_spread] at @s run tp @s ~-0.8 ~ ~\nexecute as @e[tag=ore,tag=!pre_spread] at @s if block ~-1 ~ ~ minecraft:barrier run tag @s remove ore复制代码\n\n指令逻辑：\n当名为golds的实体ores分数大于等于1时，召唤名为gold的矿物（有四个tag，分别为gold，pre_spread，ore，ore1）-> \n如果golds的ores分数大于等于0 让该实体的ores分数减1 ->\n当golds的ores分数等于0时，散布tag=pre_spread的矿物 ->\n当golds的ores分数等于0时，去掉tag=gold的实体的tag=pre_spread ->\n传送实体tag=ore，tag=!pre_spread的实体  ->\n当实体x轴的-1位置有屏障时，去掉实体的tag=ore\n\n这一串指令即解决了矿物散布问题，也解决了每一关各种矿物的数量问题，为什么这么说，第一条与第二条指令就是要先判断分数才能执行，比如我要召唤2个金矿实体，我需要scoreboard players set @e[name=golds] ores 2,然后他开始第一条判断，是否分数大于等于1，大于则召唤矿物实体，然后分数减1（这时候分数为1），第二轮执行，再次判断，大于则召唤矿物实体，然后分数减1（这时候分数为0），等到下一轮的时候，就不会再召唤实体，这就实现了分数控制矿物数量\n\n3.4 设置矿物\n\n这一小节的内容，指令部分并不是放在别的一个function里面，而是就在抓钩的q.mcfunction内，这一小节内容的指令将会实现抓钩抓取不同的矿物，获得不同的分数，同时拥有不同的“重量”。在原版的黄金矿工里面，我们知道，抓不同的矿物，抓钩回收的速度也会不同。\n（q.mcfunction）：\n&1\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=gold] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 1\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=diamond] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 2\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=iron] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 3\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=coal] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 4\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=obsidian] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 5\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=tnt] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 6\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=stone] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 7\nexecute as @e[tag=gouzi] at @s if entity @e[tag=!gouzi,distance=..1,tag=!jqr,tag=!canzao,tag=chest] run scoreboard players set @e[tag=!jqr,distance=..1,limit=1,tag=gouzi] collision 8\n#抓到tnt\nexecute as @e[tag=tnt,tag=caught] at @s run scoreboard players add @s time 1\nexecute as @e[tag=tnt,scores={time=2}] at @s run playsound minecraft:block.end_gateway.spawn player @a ~ ~ ~ 10000\nexecute as @e[tag=tnt,scores={time=2}] at @s run particle minecraft:explosion ~ ~ ~\nexecute as @e[tag=tnt,scores={time=2}] at @s run kill @e[tag=!gouzi,tag=!jqr,tag=!canzao,distance=1..6]\n&2\nexecute as @e[tag=gouzi,tag=caught,scores={collision=1}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.72\nexecute as @e[tag=gouzi,tag=caught,scores={collision=2}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.2\nexecute as @e[tag=gouzi,tag=caught,scores={collision=3}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.6\nexecute as @e[tag=gouzi,tag=caught,scores={collision=4}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.4\nexecute as @e[tag=gouzi,tag=caught,scores={collision=5}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.73\nexecute as @e[tag=gouzi,tag=caught,scores={collision=6}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.1\nexecute as @e[tag=gouzi,tag=caught,scores={collision=7}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.55\nexecute as @e[tag=gouzi,tag=caught,scores={collision=8}] at @s facing entity @e[name=222] feet run tp ^ ^ ^-0.35\n&3\nexecute as @e[tag=ore1,tag=gold] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到500分\"]\nexecute as @e[tag=ore1,tag=gold] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 500\nexecute as @e[tag=ore1,tag=diamond] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到700分\"]\nexecute as @e[tag=ore1,tag=diamond] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 700\nexecute as @e[tag=ore1,tag=iron] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到250分\"]\nexecute as @e[tag=ore1,tag=iron] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 250\nexecute as @e[tag=ore1,tag=coal] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到100分\"]\nexecute as @e[tag=ore1,tag=coal] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 100\nexecute as @e[tag=ore1,tag=obsidian] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到50分\"]\nexecute as @e[tag=ore1,tag=obsidian] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 50\nexecute as @e[tag=ore1,tag=tnt] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到20分\"]\nexecute as @e[tag=ore1,tag=tnt] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 20\nexecute as @e[tag=ore1,tag=stone] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到11分\"]\nexecute as @e[tag=ore1,tag=stone] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players add @a[tag=jqr] scores 11\nscoreboard players add @e[name=chest] suiji 5\nexecute as @e[scores={suiji=600..},name=chest] run scoreboard players set @s suiji 0\nexecute as @e[tag=ore1,tag=chest] at @s if entity @e[tag=jqr,distance=..2] run tellraw @a [\"\\u00a7e您得到\",{\"score\":{\"objective\":\"suiji\",\"name\":\"@e[tag=ore1,tag=chest,limit=1]\"}},\"分\"]\nexecute as @e[tag=ore1,tag=chest] at @s if entity @e[tag=jqr,distance=..2] run scoreboard players operation @a scores += @s suiji\n\n复制代码先不讲，先把&1部分放到第三节的第一小节的&10部分前面，把这里的&2部分放到第三节第一小节的&11部分的第一条指令后面\n把这里的&3部分放入第三节第一小节&11部分最后一条指令前面\n\n放好了再来看，&1部分就是检测是否有即将被抓钩抓到的实体，若有就给玩家记分，至于这里为什么用记分板而不用分数，有兴趣可以去试试用tag...我是试过了，有一个有趣的bug....\n&2部分就是抓到矿物后抓钩回收的速度问题，因为抓钩如果没有抓到任何矿物实体，那他将会反方向返回，速度默认0.8，所以对于如何减速就很简单了，在原本的基础上减去一定速度就可以了，比如当抓到了gold，会有一个tp ^ ^ ^-0.72,这时候抓钩的速度就成了0.8-0.72=0.08了，应该很好理解\n&3部分就是矿物抓回来得分的问题，在矿物抓回来要清除掉矿物前给一个分数并告知玩家即可。这一部分就有一个特别的东西，在原版里就是一个问号袋子，在mc里面就是箱子，抓住它后会给玩家一个随机的分数，这里涉及的随机数问题，在上一小节有讲，再结合&3部分的最后四条指令很好理解。\n\n3.5 关卡分数\n\n我们知道，黄金矿工通关条件就是通过抓矿得到的总分要超过关卡分数，而我发现，在原版黄金矿工里面，每一关的分数都是有规律的\n第一关 650分\n第二关 1195分\n第三关 2010分\n第四关 3095分\n第五关 4450分\n第六关 6075分\n可以看出，第一关是650分，往后则是上一关分数+270*关卡分数+5\n既然知道了每一关分数规律，那就好办了（score.mcfunction）：\n&1\nscoreboard players operation 目标分数 scores = lastpass scores\nexecute if score pass pass matches 1 run scoreboard players set 目标分数 scores 650\nexecute if score pass pass matches 1 run scoreboard players operation lastpass scores = 650 scores\n&2\nexecute if score pass pass matches 2.. run scoreboard players operation temp1 scores = pass pass\nexecute if score pass pass matches 2.. run scoreboard players operation temp1 scores *= 270 scores\nexecute if score pass pass matches 2.. run scoreboard players operation temp1 scores += 5 scores\nexecute if score pass pass matches 2.. run scoreboard players operation temp1 scores += lastpass scores\nexecute if score pass pass matches 2.. run scoreboard players operation 目标分数 scores = temp1 scores\nexecute if score pass pass matches 2.. run scoreboard players operation lastpass scores = temp1 scores\n复制代码\n&1部分就是第一关的分数&2部分就是对于往后关卡的分数计算，简单的数学计算题...我觉得我就不需要讲了吧.....\n\n3.6 时间逻辑\n\n关卡分数也计算好了，接下来设置关卡时间逻辑，这里跟原版一样，每一关都有60秒的时间，与原版不同的是，我在每次通关后都加了一个等待一段时间再进入下一关的逻辑...（time.mcfunction）：\n&1\nexecute as @a[tag=start] at @s run scoreboard players set pass pass 1\nexecute as @a[tag=start] at @s run scoreboard players set @a scores 0\nexecute as @a[tag=start] at @s run scoreboard players set @a time1 1200\nexecute as @a[tag=start,scores={time1=1198..}] at @s run title @a title [\"\\u00a7e游戏开始\"]\nexecute as @a[tag=start] at @s run function minecraft:score\nexecute as @a[tag=start] at @s run function minecraft:pass\nexecute as @a[tag=start] at @s run kill @e[tag=ore1]\nexecute as @a[tag=start] at @s run tag @a add start1\nexecute as @a[tag=start] at @s run tag @a remove waiting\nexecute as @a[tag=start] at @s run tag @a remove passed\nexecute as @a[tag=start] at @s run tag @a remove nopass\nexecute as @a[tag=start] at @s run tag @a remove start\n&2\nexecute as @a[tag=start1] at @s run scoreboard players remove @s time1 1\n&3\nexecute as @a[tag=start1,scores={time1=..0}] at @s if score @a[limit=1] scores >= 目标分数 scores run tag @a add passed\nexecute as @a[tag=start1,scores={time1=..0}] at @s if score @a[limit=1] scores <= 目标分数 scores run tag @a add nopass\n&4\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run title @a subtitle [\"\\u00a74您没有达到目标分数\"]\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run title @a title [\"\\u00a74Game Over\"]\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run scoreboard players reset pass pass\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run scoreboard players reset lastpass scores\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run scoreboard players operation 目标分数 scores = lastpass scores\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run kill @e[tag=ore1]\nexecute as @a[tag=start1,tag=nopass,scores={time1=..0}] at @s run tag @a remove start1\n&5\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 run scoreboard players add pass pass 1\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 if score pass pass matches ..18 run title @a subtitle [\"10s后进入下一关\"]\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 if score pass pass matches ..18 run title @a title [\"\\u00a76恭喜\"]\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 run kill @e[tag=ore1]\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 run tag @a add waiting\nexecute if score @a[limit=1,tag=start1,tag=passed] time1 matches ..0 run tag @a remove start1\n&6\nexecute as @a[tag=waiting] at @s run tag @s add waiting1\nexecute as @a[tag=waiting] at @s run scoreboard players set @s time 200\nexecute as @a[tag=waiting1] at @s run tag @a remove waiting \nexecute as @a[tag=waiting1] at @s run scoreboard players remove @a time 1\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run function minecraft:pass\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run function minecraft:score\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run title @a title [\"\\u00a76进入下一关\"]\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run scoreboard players set @a time1 1200\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run tag @a add start1\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run tag @a remove passed\nexecute as @a[tag=waiting1,scores={time=..0}] at @s run tag @a remove waiting1\n\n&7\nexecute if score pass pass matches 19 run title @a title [\"\\u00a76恭喜通关！\"]\nexecute if score pass pass matches 19 run tag @a remove passed\nexecute if score pass pass matches 19 run tag @a remove waiting1\nexecute if score pass pass matches 19 run tag @a remove waiting\nexecute if score pass pass matches 19 run scoreboard players reset pass pass\nexecute if score pass pass matches 19 run scoreboard players reset lastpass scores\nexecute if score pass pass matches 19 run scoreboard players operation 目标分数 scores = lastpass scores\nexecute if score pass pass matches 19 run kill @e[tag=ore1]\n复制代码&1部分就是针对第一关，也就是游戏开始的内容，关于游戏如何开始，也源于这里，要开始游戏，就需要给自己加一个tag：tag @a add start，输入该指令后，time的&1部分就开始执行了，初始化各数据，初始化完成就去掉自己的tag=start，并给予自己tag=start1，进入之后的部分\n&2部分就是游戏时间了，因为游戏每关要求60s，所以记分板需要设置初始值为1200，每秒会减掉20，时间剩余多少这需要告诉玩家，我在这里用的bossbar来显示时间，自行输入：\n/bossbar add time \"剩余时间\"\n/bossbar set minecraft:time max 12000\n/bossbar set minecraft:time players @a\n/scoreboard objectives add time1 dummy\n/scoreboard players set @a time 12000复制代码\n（main.mcfunction）：\nexecute store result bossbar minecraft:time value run scoreboard players get @a[limit=1] time1复制代码\n这样就能看到剩余时间随着记分板变化而变化了\n且看time.mcfunction，&3部分就是判断分数是否达到要求，也就是玩家得分是否大于目标分数，若大于，给玩家加tag=passed，若小于，则加tag=nopass\n如果是tag=nopass，就进入&4部分的逻辑，删除实体，清除计分板等操作\n如果是tag=passed，就进入&6部分执行逻辑，等待一段时间进入下一关\n&7部分则是最大关卡的问题，我在我这个游戏中设置了18关，也就是如果18关也通过了，那就是整个游戏通关了\n\n3.7 关卡设置\n\n这一小节的内容，自然就是对于每一个关卡的设置，在pass.mcfunction里面，就是通过设置一系列的ores记分板的分数，来达到不同关卡有不同的矿物。\n这个可以自己去设置，也可以用我已经写好的function来做参照\n\n4、小结\n\n\n     这个游戏简单，也算是我玩的童年游戏之一了，关于游戏的教程已经结束了，之后要做的就是自己去测试，自己去debug了，当然我自己写的这个没有什么明显的bug，可以直接食用，因为实体用的盔甲架，碰撞体积相对较大，玩起来也容易不少，玩了4次，3次通关感觉还是不错的，然后我去玩了下原版\n\n\n\n\n7YUO}%22A0USV5C[NO)O~JX.png (67.96 KB, 下载次数: 9)\n\n下载附件\n\n2019-2-14 17:14 上传\n\n\n\n\n\nQAQ我果不其然的是个手残23333333333\n\n黄金矿工地图下载：\nhttp://www.mcbbs.net/thread-844978-1-1.html\n\n",
    "replies": [
        {
            "author": "虎水小骥",
            "timestamp": 1550137320,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "沙雕猫",
            "timestamp": 1550142000,
            "txt_content": "用这个做个抓娃娃机怎么样"
        },
        {
            "author": "Koin_F",
            "timestamp": 1550143500,
            "txt_content": "神乎其技，不服不行。支持一波。"
        },
        {
            "author": "SPGoding",
            "timestamp": 1550147940,
            "txt_content": " 本帖最后由 SPGoding 于 2019-2-14 20:40 编辑 \n\n很有趣。\n\n\n再创建一个文件夹data并打开->创建一个文件夹minecraft并打开->创建两个文件夹分别为functions和tags教程其实是不用写这么细的，直接说「添加一个函数 minecraft:main」大家都能看懂的。\n\n然后就是建议不要把所有东西全都在 minecraft 命名空间下，建立一个自己的命名空间可以避免一些可能的冲突（吧）\n\n（你这个命名一会儿英文一会儿拼音甚至还有数字看得我想打人）\n\n然后我注意到你所有坐标用的都是绝对坐标，其实这样对游戏的迁移不太友好，不过如果作为带上地图发布的整份地图的话这样也没错就是了。\n\n这算我自己写的一个瑕疵，name=222和name=555，我写的里面没有加type=盔甲架，这样会导致有可能有些玩家名字就叫做222和555的用 tag 来选择实体的话可能会更好\n\n直接这样做你会发现，他只会在四分之一圆，左下半圆或则右下半圆来回转动，其原因就在于其盔甲架自身朝向的问题我悄悄地告诉你，盔甲架的 Rotation[1] 可以是负数，可以超过 90f，甚至可以超过 360f。\n\n你做随机的方式很巧妙，把我惊艳了一下下。贰逼写过一个随机函数 http://www.mcbbs.net/thread-706030-1-1.html 可以看看，虽然在这个场景下用起来可能没你现在做法方便（\n至于你把矿物移到屏幕内的做法其实有点诡异。如前面第四条（零基索引第三条）所述，你使用的是绝对坐标，因此你可以直接把 tag=ore,tag=!pre_spread 的实体的 Pos[0] 修改到屏幕内，不需要这么一点一点地 tp。\n\n\n总之系统整体的逻辑还是不错的，只是有些地方可能会有更合适或者更同用的做法。加油啊（）"
        },
        {
            "author": "Sairos",
            "timestamp": 1550200020,
            "txt_content": "SPGoding 发表于 2019-2-14 20:39\n很有趣。\n\n\n没记错的话function的tag好像命名空间必须是minecraft才能用，因为我之前因为没用minecraft的命名空间直接用tick发现是不能运作的.....\n关于rotation可以是负的这里....我前文说到了为了显示有动画效果不是用的rotation[1].rotation[1]是看不到盔甲架姿态变化的.....所以用了pos.head......而pos.head[0]若为负的就是抬头向上看了...\n\n谢谢大佬的点评"
        },
        {
            "author": "Sairos",
            "timestamp": 1550200020,
            "txt_content": "虎水小骥 发表于 2019-2-14 17:42\n预设里的虚空并非完全虚空，个人常用的办法是在上方输入“3;0;1;0”不带引号\n ...\n好勒，了解"
        },
        {
            "author": "波西666",
            "timestamp": 1550201220,
            "txt_content": "哇，巨佬"
        },
        {
            "author": "(=°ω°)丿",
            "timestamp": 1550202060,
            "txt_content": " 本帖最后由 Teenager_Yang 于 2019-2-15 11:47 编辑 \nSairos 发表于 2019-2-15 11:07\n没记错的话function的tag好像命名空间必须是 minecraft 才能用，因为我之前因为没用minecraft的命名空间直 ...\nfunction 的 tag 的命名空间是任意的，\n你说的 “ 因为没用minecraft的命名空间直接用 tick 发现是不能运作的 ” 是因为\nMojang 规定了必须有 minecraft:tick 标签的函数才会在每一刻开始的时候运行，\n而不是 foo:tick 、test:tick 等 。\n哪里都有 SPGoding dalao ……\n"
        },
        {
            "author": "lirui11",
            "timestamp": 1550217180,
            "txt_content": "看起来似乎抓石头和抓金矿的钩子收回速度都是一样的，嗯……\n既然盔甲架的Rotation[1]变化肉眼看不见，为什么不试试zombie呢\n\n黄金矿工真好玩，童年的回忆"
        },
        {
            "author": "kongbaiyo",
            "timestamp": 1550455080,
            "txt_content": "wow!石头阶梯spreadplayers的方法有点东西！"
        },
        {
            "author": "ruhuasiyu",
            "timestamp": 1550480280,
            "txt_content": "你说的第一种随机数生成应该是错的，你这不就相当于每10tick循环10个数么……"
        },
        {
            "author": "分享",
            "timestamp": 1550483460,
            "txt_content": "有点东西 学到了awa"
        },
        {
            "author": "Sairos",
            "timestamp": 1552962540,
            "txt_content": "ruhuasiyu 发表于 2019-2-18 16:58\n你说的第一种随机数生成应该是错的，你这不就相当于每10tick循环10个数么…… ...\n如果要严格照随机数概念来讲- -那这确实不是随机数- -至少在我们概率论老师的讲述中，真正的随机数都是物理性的比如抛硬币投骰子一类，在实际应用叫伪随机数，那就是一种重复性的计算方法产生的，既然是伪随机数也就是不是真正的随机，这里的随机数生成，从概念上讲应该也不算是错误的吧....当然这种方法就很偷懒了，不过也一定程度上达到了效果，所以到底算不算随机数，谁知道呢....."
        },
        {
            "author": "WSHANG",
            "timestamp": 1556595060,
            "txt_content": "效果图也很有意思"
        },
        {
            "author": "炽热未来",
            "timestamp": 1556790900,
            "txt_content": "腻害          "
        },
        {
            "author": "awa?owo?",
            "timestamp": 1556791380,
            "txt_content": "厉害啊..."
        },
        {
            "author": "railgun_",
            "timestamp": 1556793960,
            "txt_content": "这个不错啊"
        },
        {
            "author": "薄荷的馒tou",
            "timestamp": 1556798940,
            "txt_content": "MCBBS有你更精彩~"
        },
        {
            "author": "yuen27787231",
            "timestamp": 1558210200,
            "txt_content": "嘩 這個應該要改成地圖小遊戲來發佈\n連這種小遊戲都能製作到 MC真的無所不能"
        },
        {
            "author": "cf6513272991",
            "timestamp": 1558830600,
            "txt_content": "\n效果图也很有意思 有点东西 学到了"
        },
        {
            "author": "lxt123qwe",
            "timestamp": 1598081280,
            "txt_content": "效果图也很有意思"
        }
    ]
}