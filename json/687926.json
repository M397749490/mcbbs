{
    "title": "[2b]新版本链式cb特性的部分研究（检测最大渲染距离）",
    "author": "⭐✔️",
    "replyCount": 2,
    "timestamp": 1492791600,
    "txt_content": " 本帖最后由 贰逼 于 2017-4-22 00:27 编辑 \n\n研究并不全面，只是包含部分目前能想到的内容。\n更新的具体内容总之就是在命令链里面现在可以通过指令来对链里的cb进行操作。\n简单来说就是：对方块操作的优先级大于了下一gt的加载。\n\n举个例子，之前icb→ccb(command:往链后面再放置一个ccb)，\n输出的结果就是ccb确实执行了，但是后面通过这条指令生成的ccb没有执行；\n而现在，放置的这个新的ccb也能成功被cb链调用。\n\n你可以这样理解，就是链中执行的对方块的指令立即生效（不包括未加载的方块）。但是更重要的是，现在我们可以随意的操作cb链的线路，控制方式，以及对cb链进行无限复制。\n衍生出一些关于逻辑指令的cb链摆法：\n多输出的并联结构：\n\n\n\n\n\n2017-04-22_00.02.08.png (88.75 KB, 下载次数: 2)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n打个比方，cb链就是一个管道，通过前面cb的检测来改变这个管道的通向，信号就顺着这个管道流向出口（输出）\n具体实现的方法就是制作一个\"闸门\"\n\n\n\n\n2017-04-22_00.02.14.png (96.36 KB, 下载次数: 3)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n▲一个简单的例子（并非最优方案，只是为了演示）：检测玩家分数，并对应相应输出。\na=1 → /say 1\na=2 → /say 2\na=3 → /say 3\n图解已经很详细了，信号从右边进入，然后开始检测玩家分数，一一对应地去改变最中心的cb的指向，指向的就是对应的输出。\n而这个最中心的方块，就是换向器，也就是前面说的\"闸门\"。\n\n\n\n\n2017-04-22_00.09.28.png (129.19 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n\n\n\n\n2017-04-22_00.09.34.png (127.3 KB, 下载次数: 2)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n\n\n\n\n2017-04-22_00.10.14.png (180.25 KB, 下载次数: 5)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n我将这个\"闸门\"里面设定了一条固定的指令，大家可以发现每次都可以输出，目的是为了说明这个\"闸门\"不管线路指向何方都会有输出，所以我们把它算进了主模块中。在实际运用中，如果不需要额外的主模块指令，你也可以选择将\"闸门\"的指令留空。\n//检测模块\n/execute @p[score_a=1,score_a_min=1] ~ ~ ~ /setblock 20 4 19 minecraft:chain_command_block facing=east replace {auto:1b,Command:\"say 你拥有分数\"}\n/execute @p[score_a=2,score_a_min=2] ~ ~ ~ /setblock 20 4 19 minecraft:chain_command_block facing=north replace {auto:1b,Command:\"say 你拥有分数\"}\n/execute @p[score_a=3,score_a_min=3] ~ ~ ~ /setblock 20 4 19 minecraft:chain_command_block facing=west replace {auto:1b,Command:\"say 你拥有分数\"}\n//闸门\nsay 你拥有分数\n//输出模块\n/say 你的分数是1\n/say 你的分数是2\n/say 你的分数是3复制代码串联结构中的非：\n\n\n\n\n\n2017-04-22_00.13.29.png (89.24 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n这个非的意思就是如果前面的cb的检测条件满足了，非的指令不会执行。\n\n\n\n\n2017-04-22_00.13.41.png (46.31 KB, 下载次数: 6)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n//检测条件\n/execute @p[score_a_min=0] ~ ~ ~ blockdata 11 4 21 {auto:0b}\n//被设为非的指令\nsay 你分数小于零\n//重置非\n/blockdata 11 4 21 {auto:1b}\n//串联输出\n/say 你按下了按钮复制代码\n\n\n\n\n2017-04-22_00.18.13.png (168.07 KB, 下载次数: 3)\n\n下载附件\n\n2017-4-21 23:14 上传\n\n\n\n\n\n\n\n\n\n2017-04-22_00.18.31.png (130.37 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n结合上面的指令和输出情况，简单分析一下过程：\n当玩家分数≥0，就将设为非的指令调成\"红石激活\"模式，那么当信号流动至此处便不会激活。接着重置为\"保持开启\"模式；\n当玩家分数＜0，检测不成功，因此不会进行任何操作，那么当信号流动至此处便会激活；\n不管玩家分数如何，串联的命令都会输出。\n用icb链充当rcb链（使一个icb的链也能被保持高频状态）\n\n这是一个rcb的链，在0.4s（1个红石中继器满延迟）内执行8次\n\n\n\n\n2017-04-22_00.10.22.png (186.14 KB, 下载次数: 3)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n这是一个icb的链，在0.4s内执行7次\n是什么让一个icb的单次执行的链也能高频执行？\n\n\n\n\n2017-04-22_00.10.50.png (62.17 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n在icb链的末端接上两个指令：\n/blockdata X Y Z {auto:0b}\n/blockdata X Y Z {auto:1b}复制代码其中XYZ表示该icb链起始的icb坐标\n当链中信号到达这两个命令方块，相当于链被自身刷新，于是能再次执行，以此类推，保持高频状态。\n而要阻断这个链的高频刷新，只能破坏这个链（在这里的处理方式是重新setblock一个起始的icb）\n至于为什么只输出7次，其实这个高频的速度和rcb一样，都是1gt一次，但是因为最后一次被强行破坏了起始的icb，所以没有输出。对一个链无限复制（获取玩家的最大渲染距离、服务器的最大加载距离）\n除了setblock外，其实fill和clone这类指令都优先于下一gt执行了。\n\n\n\n\n2017-04-21_23.06.39.png (62.42 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n在上述的模块中，当你按下按钮，icb会在末端复制一次ccb链，但由于信号又会到达ccb链末端，ccb末端的指令又是在末端复制一次ccb链，从而使这3个ccb链被无限复制下去（其实被你的渲染距离局限，因为clone只会在加载区块中进行）。而这一切都在1gt内完成。\n将say 1、say 2分别改成了：\n/scoreboard players add @p a 1\n/summon minecraft:area_effect_cloud ~ ~ ~ {Duration:1000000,Tags:[a]}复制代码于是在1gt内，ccb链每被复制一次，a计分板分数就+1，每个ccb链都有一个 位置标记用的tag=a的实体marker。\n\n\n\n\n2017-04-22_00.20.39.png (118.33 KB, 下载次数: 3)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n\n\n\n\n2017-04-21_23.15.59.png (108.82 KB, 下载次数: 4)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n再按下按钮之后，得到的值是复制次数。\n\n\n\n\n2017-04-22_00.19.00.png (119.44 KB, 下载次数: 2)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n进一步操作这个值，我们加上了一个处理模块：\n//清除ccb链\n/execute @e[tag=a] ~ ~ ~ fill ~ ~ ~1 ~ ~ ~-1 air 0 replace chain_command_block\n//计算渲染距离\n/scoreboard players set 6 a 6\n/scoreboard players operation @p a *= 6 a\n//输出与重置\n/tellraw @p [\"\",{\"text\":\"你的最大加载距离是\"},{\"score\":{\"name\":\"@p\",\"objective\":\"a\"}}]\n/scoreboard players reset * a复制代码复制次数*3(ccb链包含3个ccb)*2(渲染是双向的)=渲染距离\n\n\n\n\n1.png (5.29 KB, 下载次数: 2)\n\n下载附件\n\n2017-4-22 00:12 上传\n\n\n\n\n\n\n\n\n\n2017-04-21_23.55.18.png (125.68 KB, 下载次数: 1)\n\n下载附件\n\n2017-4-21 23:13 上传\n\n\n\n\n\n\n\n\n\n2.png (4.61 KB, 下载次数: 2)\n\n下载附件\n\n2017-4-22 00:12 上传\n\n\n\n\n\n\n\n\n\n2017-04-21_23.56.00.png (170.59 KB, 下载次数: 1)\n\n下载附件\n\n2017-4-21 23:31 上传\n\n\n\n\n\n只是粗略的估算（因为ccb链是否被完整复制我们不知道，只是笼统的乘以3），但与真实值只有个位数的误差。[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "chyx",
            "timestamp": 1492793760,
            "txt_content": " 本帖最后由 chyx 于 2017-4-22 01:08 编辑 \n\n看起来是B版本啊\n\n但是对一个链无限复制\n你这里连的长度是3 如果某次复制完了刚好由于方块更新加载了下一个区块 也不会加载再下一个 因为区块长16\n\n刚才我试了长度是1 于是一直加载了65536格。\n\n\n怎么这样就有贡献。。。\n\n\n"
        },
        {
            "author": "volta薯片~",
            "timestamp": 1492823580,
            "txt_content": "啥都没看懂，我就是个辣鸡XD"
        }
    ]
}