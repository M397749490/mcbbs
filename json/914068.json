{
    "title": "PlayerMoveEvent会导致大量资源消耗吗？是否应该避免使用此事件？",
    "author": "18278436235",
    "replyCount": 15,
    "timestamp": 1568633280,
    "txt_content": "如题，最近在写一些插件的时候用此事件会比较方便，但是害怕此事件会导致大量资源消耗",
    "replies": [
        {
            "author": "wshycaa",
            "timestamp": 1568634660,
            "txt_content": "也没有那么巨大啦。。监听事件并不会特别特别消耗资源。"
        },
        {
            "author": "粘兽",
            "timestamp": 1568634780,
            "txt_content": "不管你用不用 这个事件一样会触发\n你要做的应该是 合理的使用这个事件"
        },
        {
            "author": "弥猫うた",
            "timestamp": 1568634780,
            "txt_content": "tim一下看看就知道了"
        },
        {
            "author": "风障",
            "timestamp": 1568639160,
            "txt_content": "他只是记录事件,如果你不安装这个插件,事件还是触发的。\n记录不会太多的资源消耗。合理配置就好。"
        },
        {
            "author": "吕易天",
            "timestamp": 1568639520,
            "txt_content": " 本帖最后由 吕易天 于 2019-10-9 22:09 编辑 \n\n你如果在里面写异步操作（操作实体之类的要回到主线程操作）那是影响不大的，如果是同步操作要注意监听处理器的时间占用"
        },
        {
            "author": "shutong",
            "timestamp": 1569427080,
            "txt_content": "往里面写一个 sleep"
        },
        {
            "author": "RE_OVO",
            "timestamp": 1569594060,
            "txt_content": "不写耗时操作就行"
        },
        {
            "author": "Windowsredstone",
            "timestamp": 1569821460,
            "txt_content": "要监听event的话时间复杂度尽量控制在O(n^2)，能O(n)或者O（n log n）更好。最高不要超过O(n^3 log n)"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1569836640,
            "txt_content": "移动事件触发频率非常高, 但是由于事件处理都是 \"观察者模式\" 的一种, 本质上就是一次函数调用, 如果执行次数多了得到了编译器(JIT)优化, 那开销就更小了(只是小, 并不是没有. 所以我给的建议如果能够使用其他事件代替, 最好使用其他对象)\n\n另外关于方法体内的代码也给楼主两个建议:\n\n第一, 楼上有部分人建议使用所谓的多线程(异步), 那纯粹是扯淡. 所有监听器中的阻塞操作都应该异步调用, 并不是只在这个事件中才这样. 而且是否使用多线程是要根据代码执行时间和是否可能阻塞来决定\n\n第二, 对于 Move 这类触发频率非常高的事件, 没必要为每一次触发都执行一遍方法体. 所以可以在方法之初弄一个随机数, 以一定概率执行此事件. 当概率设置为 1/20 时, 理论上此事件就降低到一秒钟触发一次了. 当然, 这有一个前提: 执行方法体内代码的开销要远大于判断是否执行的开销才行"
        },
        {
            "author": "Himmelt",
            "timestamp": 1570604460,
            "txt_content": "鸭蛋只吃黄 发表于 2019-9-30 17:44\n移动事件触发频率非常高, 但是由于事件处理都是 \"观察者模式\" 的一种, 本质上就是一次函数调用, 如果执行次 ...\n“所有监听器中的阻塞操作都应该异步调用”  这也是扯淡。\n是否可以使用异步，要看你代码执行的内容，执行操作的对象是否支持 异步操作 。Bukkit 官方给出建议，不要在任何操作游戏内内容(玩家等实体，世界，方块等等)的代码上使用异步，游戏内内容都是不支持异步的。"
        },
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1570607880,
            "txt_content": " 本帖最后由 鸭蛋只吃黄 于 2019-10-9 16:04 编辑 \nHimmelt 发表于 2019-10-9 15:01\n“所有监听器中的阻塞操作都应该异步调用”  这也是扯淡。\n是否可以使用异步，要看你代码执行的内容，执 ...\n...你非要抬杠那我也没办法, bukkit 当然禁止在多线程中操作数据, 多去看看 BukkitRunnable 的文档吧, 在那里你能学到更多.\n如果你反对我说的 “所有监听器中的阻塞操作都应该异步调用” 的话, 那你想怎么样呢? 同步阻塞? 主线程访问数据库? 6 翻了\n\n另外, 是否可以使用异步, 和你说的那些屁关系都没有, 因为 BukiitRunnable 给出了明确的方法, 可以让你在多线程中操作你想要的任何数据. 所以我说, 多看看文档, 别张嘴就说别人扯淡.\n"
        },
        {
            "author": "Himmelt",
            "timestamp": 1570624500,
            "txt_content": "鸭蛋只吃黄 发表于 2019-10-9 15:58\n...你非要抬杠那我也没办法, bukkit 当然禁止在多线程中操作数据, 多去看看 BukkitRunnable 的文档吧, 在 ...\n狗屁，这本应是看到你私信之前的回复，我的“扯淡”是回复你回复别人的扯淡，我这里回复你狗屁也是因为你先回复了我。但是我觉得吵架没有意义。\n\n既然你私信我了，我就不吵架了。\nBukkitRunnable 里明确指出 Asynchronous tasks should never access any API in Bukkit.\n你都不看的吗？\n它给出的明确方法上面没有明确的Javadoc吗？\n阻塞操作怎么办？当然是异步了，查询数据库肯定是异步，但这个异步获取结果之后必须 回到 同步执行游戏内容。所以，你说的 可以让你在多线程中操作你想要的任何数据，这个“任何”就是不对的。游戏内的对象应该使用同步操作，尽管异步操作不一定会出错。"
        },
        {
            "author": "容岩",
            "timestamp": 1570660200,
            "txt_content": " 本帖最后由 容岩 于 2019-10-10 06:34 编辑 \n\n编辑掉了..............."
        },
        {
            "author": "EmptyIrony",
            "timestamp": 1571927700,
            "txt_content": "尽快返回就行了，一直拖着肯定会卡住主线程"
        },
        {
            "author": "ffffpctm",
            "timestamp": 1585637880,
            "txt_content": "Windowsredstone 发表于 2019-9-30 13:31\n要监听event的话时间复杂度尽量控制在O(n^2)，能O(n)或者O（n log n）更好。最高不要超过O(n^3 log n) ...\n这个n是指什么"
        }
    ]
}