{
    "title": "PVPINDemoRL——正确地在Bukkit插件中加载JavaScript代码",
    "author": "William_Shi",
    "replyCount": 0,
    "timestamp": 1597118220,
    "txt_content": "\n        PVPIN传统艺能——JavaScript插件开发\n\n        [url = https://www.mcbbs.net/thread-1098464-1-1.html]https://www.mcbbs.net/thread-1098464-1-1.html[/url]\n        在这里，进行了充分讨论\n        感谢@Karlatemp @洞穴夜莺 @阴阳师元素祭祀 的帮助\n\n        首先，我们需要了解自己的目标，即：运行Bukkit插件时动态加载JavaScript脚本。\n        通常采用这种方法：\n               \n        ScriptEngineManager manager = new ScriptEngineManager();\n        ScriptEngine engine = manager.getEngineByName(\"js\");\n        复制代码\n\n        The ScriptEngineManager implements a discovery and instantiation mechanism for ScriptEngine classes and also maintains a collection of key / value pairs storing state shared by all engines created by the Manager.\n        也就是说，ScriptEngineManager就是用来方便地管理ScriptEngine对象的，同时提供方法，方便使用者提供不同的方式获取到这些对象。\n        也就是我们通常所使用的getEngineByName\n\n        回到正题，当我们在JavaScript中，尝试使用Java.type获取某个插件的类时，往往会报错ClassNotFoundException。\n        它类似于这样\n       \n        Caused by: java.lang.RuntimeException: java.lang.ClassNotFoundException: x.x.xxxx.xxxxx.x.xxxx\n        at jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:397) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:449) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:406) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:402) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:155) ~[nashorn.jar:?]\n        at javax.script.AbstractScriptEngine.eval(Unknown Source) ~[?:1.8.0_241]\n        Caused by: java.lang.ClassNotFoundException: x.x.xxxx.xxxxx.x.xxxx\n        at java.net.URLClassLoader.findClass(Unknown Source) ~[?:1.8.0_241]\n        at java.lang.ClassLoader.loadClass(Unknown Source) ~[?:1.8.0_241]\n        at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source) ~[?:1.8.0_241]\n        at java.lang.ClassLoader.loadClass(Unknown Source) ~[?:1.8.0_241]\n        at java.lang.Class.forName0(Native Method) ~[?:1.8.0_241]\n        at java.lang.Class.forName(Unknown Source) ~[?:1.8.0_241]\n        at jdk.nashorn.internal.runtime.Context.findClass(Context.java:1051) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.objects.NativeJava.simpleType(NativeJava.java:498) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.objects.NativeJava.type(NativeJava.java:322) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.objects.NativeJava.type(NativeJava.java:314) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.objects.NativeJava.type(NativeJava.java:310) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.scripts.Script$Recompilation$1$25$\\ ^ eval\\_.main(<eval>:5) ~[?:?]\n        at jdk.nashorn.internal.scripts.Script$\\^eval\\_.:program(<eval>:1) ~[?:?]\n        at jdk.nashorn.internal.runtime.ScriptFunctionData.invoke(ScriptFunctionData.java:637) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.runtime.ScriptFunction.invoke(ScriptFunction.java:494) ~[nashorn.jar:?]\n        at jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:393) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:449) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:406) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:402) ~[nashorn.jar:?]\n        at jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:155) ~[nashorn.jar:?]\n        at javax.script.AbstractScriptEngine.eval(Unknown Source) ~[?:1.8.0_241]\n        复制代码\n        当然我省略了部分插件内调用ScriptEngine执行js代码的堆栈，这些不重要\n        当我们注意到java.net.URLClassLoader findClass方法的时候，应当有感觉，这就是PluginClassLoader的问题\n        因为PluginClassLoader根本没有和AppClassLoader进行什么组合，实现双亲委派，它打破了双亲委派\n        所以导致，常规方法创建的ScriptEngine根本无法访问到由PluginClassLoader加载的类\n        具体原因是什么呢？\n\n        我们从ScriptEngineManager开始看\n        对于ScriptEngineManager的使用者来说，ScriptEngineManager就是用来方便地获取ScriptEngine的\n        提供多种查找的方式，当然最常用的就是by name\n\n        来看ScriptEngineManager的构造器\n\n       \n        public ScriptEngineManager() {\n                ClassLoader ctxtLoader = Thread.currentThread().getContextClassLoader();\n                init(ctxtLoader);\n        }\n\n        /**\n        *..........\n        * @param loader ClassLoader used to discover script engine factories.\n        */\n        public ScriptEngineManager(ClassLoader loader) {\n                init(loader);\n        }\n\n        private void init(final ClassLoader loader) {\n                globalScope = new SimpleBindings();\n                engineSpis = new HashSet < ScriptEngineFactory > ();\n                nameAssociations = new HashMap < String, ScriptEngineFactory > ();\n                extensionAssociations = new HashMap < String, ScriptEngineFactory > ();\n                mimeTypeAssociations = new HashMap < String, ScriptEngineFactory > ();\n                initEngines(loader);\n        }复制代码\n\n        engineSpis等变量都放在了类的最末尾进行定义，如果你在看jdk源码，请往下翻到底\n        最重要是engineSpis存储了所有加载了的ScriptEngineFactory\n\n       \n        /** Set of script engine factories discovered. */\n        private HashSet<ScriptEngineFactory> engineSpis;\n\n        /** Map of engine name to script engine factory. */\n        private HashMap<String, ScriptEngineFactory> nameAssociations;\n\n        /** Map of script file extension to script engine factory. */\n        private HashMap<String, ScriptEngineFactory> extensionAssociations;\n\n        /** Map of script script MIME type to script engine factory. */\n        private HashMap<String, ScriptEngineFactory> mimeTypeAssociations;\n\n        /** Global bindings associated with script engines created by this manager. */\n        private Bindings globalScope;\n\n        复制代码\n\n        没有存储ScriptEngine，而是存储了ScriptEngineFactory\n        ScriptEngineManager本质上是用来加载、管理ScriptEngineFactory的\n        这个ScriptEngineFactory是一个接口，它提供了方法，为你创建ScriptEngine对象，可以说是工厂类\n        翻一翻ScriptEngineManager方法的返回值，发现，通过ScriptEngineManager你不能直接得到ScriptEngineFactory对象\n        ScriptEngineManager会间接地通过其加载的ScriptEngineFactory，直接给你一个ScriptEngine执行脚本\n\n        查看构造器，发现，如果无参new ScriptEngineManager则会取ContextClassLoader调用initEngines\n        否则就使用你所定义的ClassLoader，调用initEngines\n        继续阅读后文代码\n\n       \n        private ServiceLoader<ScriptEngineFactory> getServiceLoader(final ClassLoader loader) {\n            if (loader != null) {\n                return ServiceLoader.load(ScriptEngineFactory.class, loader);\n            } else {\n                return ServiceLoader.loadInstalled(ScriptEngineFactory.class);\n            }\n        }\n\n    private void initEngines(final ClassLoader loader) {\n        Iterator<ScriptEngineFactory> itr = null;\n        try {\n            ServiceLoader<ScriptEngineFactory> sl = AccessController.doPrivileged(\n                new PrivilegedAction<ServiceLoader<ScriptEngineFactory>>() {\n                    @Override\n                    public ServiceLoader<ScriptEngineFactory> run() {\n                        return getServiceLoader(loader);\n                    }\n                });\n\n            itr = sl.iterator();\n        } catch (ServiceConfigurationError err) {\n            System.err.println(\"Can't find ScriptEngineFactory providers: \" +\n                          err.getMessage());\n            if (DEBUG) {\n                err.printStackTrace();\n            }\n            // do not throw any exception here. user may want to\n            // manage his/her own factories using this manager\n            // by explicit registratation (by registerXXX) methods.\n            return;\n        }\n\n        try {\n            while (itr.hasNext()) {\n                try {\n                    ScriptEngineFactory fact = itr.next();\n                    engineSpis.add(fact);\n                } catch (ServiceConfigurationError err) {\n                    System.err.println(\"ScriptEngineManager providers.next(): \"\n                                 + err.getMessage());\n                    if (DEBUG) {\n                        err.printStackTrace();\n                    }\n                    // one factory failed, but check other factories...\n                    continue;\n                }\n            }\n        } catch (ServiceConfigurationError err) {\n            System.err.println(\"ScriptEngineManager providers.hasNext(): \"\n                            + err.getMessage());\n            if (DEBUG) {\n                err.printStackTrace();\n            }\n            // do not throw any exception here. user may want to\n            // manage his/her own factories using this manager\n            // by explicit registratation (by registerXXX) methods.\n            return;\n        }\n    }\n    复制代码\n\n    关于ServiceLoader，这不重要，他是用来管理接口实现类的，ScriptEngineFactory就是接口\n    你可以认为是通过ServiceLoader进行了查找，查找了ScriptEngineFactory的实现类\n    其中查找的参数，包括了ClassLoader\n    而这个ServiceLoader实现的是Iterable<S>，也就是说可以Iterator遍历，事实上也的确是这样遍历的\n   \n    Iterator<ScriptEngineFactory> itr = null;\n    ServiceLoader<ScriptEngineFactory> sl =  .....\n    itr = sl.iterator();\n    复制代码\n    采用while遍历，结果就抽象出如下代码\n   \n    ScriptEngineFactory fact = itr.next();\n    engineSpis.add(fact);\n    复制代码\n    那么，ServiceLoader负责取到所有可用的ScriptEngineFactory\n    也就是说根据ClassLoader，加载那些可用的ScriptEngineFactory\n    也就是说，调用ScriptEngineManager的构造器时，传入ClassLoader只能决定查找到哪些ScriptEngineFactory\n    接下来我们需要看如何获取到ScriptEngine的\n   \n    public ScriptEngine getEngineByName(String shortName) {\n        if (shortName == null) throw new NullPointerException();\n        //look for registered name first\n        Object obj;\n        if (null != (obj = nameAssociations.get(shortName))) {\n            ScriptEngineFactory spi = (ScriptEngineFactory)obj;\n            try {\n                ScriptEngine engine = spi.getScriptEngine();\n                engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n                return engine;\n            } catch (Exception exp) {\n                if (DEBUG) exp.printStackTrace();\n            }\n        }\n\n        for (ScriptEngineFactory spi : engineSpis) {\n            List<String> names = null;\n            try {\n                names = spi.getNames();\n            } catch (Exception exp) {\n                if (DEBUG) exp.printStackTrace();\n            }\n\n            if (names != null) {\n                for (String name : names) {\n                    if (shortName.equals(name)) {\n                        try {\n                            ScriptEngine engine = spi.getScriptEngine();\n                            engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n                            return engine;\n                        } catch (Exception exp) {\n                            if (DEBUG) exp.printStackTrace();\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n    复制代码\n\n    这些匹配的具体内容，不重要。重在遍历了engineSpis集合（HashSet）\n   \n    for (ScriptEngineFactory spi : engineSpis) {\n                ......\n        ScriptEngine engine = spi.getScriptEngine();\n        engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n        return engine;\n                ......\n    }复制代码\n\n    那么我们必须知道ScriptEngineFactory的实现类\n    因为这是一个接口，定义了getScriptEngine这个方法\n    而我们看到这个方法是无参的\n    说明，ScriptEngineManager的ClassLoader，决定，且仅能决定，查找的ScriptEngineFactory\n\n    采用如下反射：\n   \n    ScriptEngineManager manager = new ScriptEngineManager();\n    Field engineSpisField = ScriptEngineManager.class.getDeclaredField(\"engineSpis\");\n    engineSpisField.setAccessible(true);\n    HashSet set =(HashSet) engineSpisField.get(manager);\n    System.out.println(set);\n    复制代码\n    输出如下\n    [jdk.nashorn.api.scripting.NashornScriptEngineFactory@2f0e140b]\n\n    也就是说在通过Bukkit服务端主线程的AppClassLoader进行查找、加载后\n    得到了一个ScriptEngineFactory，是jdk.nashorn.api.scripting.NashornScriptEngineFactory\n    所以我们去看看NashornScriptEngineFactory的源码\n    关注其如何实现getScriptEngine\n   \n    @Override\n    public ScriptEngine getScriptEngine() {\n        try {\n            return new NashornScriptEngine(this, DEFAULT_OPTIONS, getAppClassLoader(), null);\n        } catch (final RuntimeException e) {\n            if (Context.DEBUG) {\n                e.printStackTrace();\n            }\n            throw e;\n        }\n    }\n\n    private static ClassLoader getAppClassLoader() {\n        // Revisit: script engine implementation needs the capability to\n        // find the class loader of the context in which the script engine\n        // is running so that classes will be found and loaded properly\n        final ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n        return (ccl == null)? NashornScriptEngineFactory.class.getClassLoader() : ccl;\n    }\n    复制代码\n    我们重新整理一遍整个逻辑\n    ScriptEngineManager通过ClassLoader，委托给ServiceLoader去加载ScriptEngineFactory\n    如果你在构造器指定ClassLoader则通过这个ClassLoader去寻找可用ScriptEngineFactory\n    否则就通过ContextClassLoader寻找可用ScriptEngineFactory\n\n    当使用者调用各种getEngine方法，比如getEngineByName时，就匹配对应的ScriptEngineFactory\n    调用其getScriptEngine方法，把获取的ScriptEngine返回给调用者\n\n    在这里，NashornScriptEngineFactory调用自己的getAppClassLoader方法去加载ScriptEngine\n    （因为JavaScript本质上肯定是被编译后加载进JVM的，本质上也有类，只不过类名是无意义的，这些类也有类加载器）\n    而这里的getAppClassLoader本质上则是getContextClassLoader\n\n    换句话说，ScriptEngineManager仅仅需要ClassLoader去获得ScriptEngineFactory\n    至于具体JavaScript加载使用什么ClassLoader和你new ScriptEngineManager传入的ClassLoader完全无关\n    加载JavaScript的ScriptEngine是直接采用了ContextClassLoader的\n\n    但是，我们知道PluginClassLoader与AppClassLoader之间没有双亲委派关系\n    所以如果ContextClassLoader就是加载Bukkit服务端的AppClassLoader的话，势必导致JavaScript代码无法访问到Bukkit插件的类\n    我们就必须篡改ContextClassLoader为PluginClassLoader，这样就可以访问了\n   \n    Thread.currentThread().setContextClassLoader(this.getClassLoader());\n    复制代码\n    这也是当年PVPIN jsrt采用的方法\n    见主类com.pvpin.mod.LearnToProgram的onEnable方法\n    虽说一般情况下只要修改ContextClassLoader再改回去就没有什么问题\n    但是还是不能排除有可能有一些三方库恰好在你修改的时候，通过ContextClassLoader加载\n    那么我们继续往后看\n    \n    /**\n     * Create a new Script engine initialized with the given class loader.\n     *\n     * @param appLoader class loader to be used as script \"app\" class loader.\n     * [url=home.php?mod=space&uid=491268]@Return[/url] newly created script engine.\n     * @throws SecurityException\n     *         if the security manager's {[url=home.php?mod=space&uid=28815]@code[/url] checkPermission}\n     *         denies {@code RuntimePermission(\"nashorn.setConfig\")}\n     */\n    public ScriptEngine getScriptEngine(final ClassLoader appLoader) {\n        return newEngine(DEFAULT_OPTIONS, appLoader, null);\n    }\n    复制代码\n    也就是说，有一个public方法，可以直接指定ClassLoader加载ScriptEngine\n    这正是我们需要的方法，传入PluginClassLoader，不修改ContextClassLoader\n    那么就只需要获取一下ScriptEngineFactory\n    最后，我们不难写出如下代码\n    com.pvpin.pvpincore.modules.PVPINCore代表了任意Bukkit插件的类\n    那段JavaScript，可以看作是调用了System.out.println()语句\n    输出的是com.pvpin.pvpincore.modules.PVPINCore这个类本身\n    当然，是在JavaScript当中访问这个类并输出\n   \n    ScriptEngineManager manager = new ScriptEngineManager();\n    Field engineSpisField = ScriptEngineManager.class.getDeclaredField(\"engineSpis\");\n    engineSpisField.setAccessible(true);\n    HashSet<ScriptEngineFactory> set = (HashSet) engineSpisField.get(manager);\n    NashornScriptEngineFactory engineFac = null;\n    for (ScriptEngineFactory fac : set) {\n        if (fac.getClass() == NashornScriptEngineFactory.class) {\n            engineFac = (NashornScriptEngineFactory) fac;\n            break;\n        }\n    }\n    ScriptEngine engine = engineFac.getScriptEngine(this.getClassLoader());\n    engine.eval(\"Java.type(\"java.lang.System\").out.println(Java.type(\"com.pvpin.pvpincore.modules.PVPINCore\"))\");\n    复制代码\n\n    在1.12和1.15下测试，结果相同：\n    JavaClassStatics[com.pvpin.pvpincore.modules.PVPINCore]\n    返回的是jdk.internal.dynalink.beans下的一个StaticClass，这与JavaScript是动态弱类型语言有关\n    因为在被调用之前没人知道JavaScript中的一个参数是什么类型的，所以Nashorn采用动态的思想去进行编译，不过不重要\n    没错，我们成功了\n    我们在不改变主线程ClassLoader的情况下成功通过PluginClassLoader加载ScriptEngine\n    并且让JavaScript访问到了Bukkit插件的类，成功展现了PVPIN的传统艺能！\n\n    PVPIN，用编程改变世界！\n\n\n",
    "replies": []
}