{
    "title": "[spigot]有关视野、身位的判断——可见|瞄头|背刺",
    "author": "Ir.Nep",
    "replyCount": 7,
    "timestamp": 1575543540,
    "txt_content": " 本帖最后由 Ir.Nep 于 2019-12-5 19:33 编辑 \n\n\n\n前言\n\n该教程适用于1.8以上\n有spigot基础和向量方面知识会更好理解\n贴中配了少许图片以助理解\n\n教程中所有功能都已经整合在一个类中，代码在本楼最下方。\n\nP.S. 排 版 杀 我\nP.S.S. 吞 码 鬼 才Discuss\n\n\n\nPart 0、为判断的视觉化做准备\n\n有时候思考问题如果仅靠数据的计算和大脑的模拟，不仅耗时烧脑，还容易出错。\n因此如果我们能将代码工作过程视觉化(可视化)，往往有助于我们解决问题。\nP.S: 若Part 0看不懂，建议直接转到Part 4使用已经整合好的类，因为Part 1/2/3中做的工作，其实并没有比Part 0多多少。\n\n在视野/身位判断这个问题中，最重要的就是让视线可视化就像在眼睛上装个红外射线\n因此我们先准备两个在MC中绘制线段的函数。\n要画线段，就得知道起点和终点\n于是我们写下\npublic void drawLine(Location start, Location end){}复制代码\n根据初中平面向量知识，在平面中若有A、B两点，用B点坐标减去A点坐标，我们将得到一条从A射向B的射线（向量）。\n于是得到\nVector ray = end.clone().substract(start).toVector();\n复制代码其中ray为从A射向B的射线\nclone()是复制终点\nsubstract(start)是对复制后的终点进行减法操作，减去起点start后得到射线\ntoVector()将得到的射线转为向量。\n\n我们将这个向量称为偏移向量\n因为我们要绘制的是起点到终点这条射线上的数个点\n所以我们还要根据要绘制的点的数量，让偏移向量每次只从起点向终点移动一小段距离\n\n假设我们每隔0.1个距离单位就绘制一个点，那么我们一共要绘制(射线长度/间隔)个点\ndouble dotCount = ray.length() / 0.1;复制代码得到要绘制的点的数量以后，我们还要得到单位偏移向量，即每绘制完一个点之后，向终点移动的向量。\nVector offsetUnit = ray.multiply(1 / times);复制代码有了起点、单位偏移向量、绘制点数，我们就可以开始绘制线段了。\n// 当还有需要绘制的点的时候执行\nfor(; times > 0; times--) {\n        currentLoc.getWorld().spawnParticle(Particle.FLAME, currentLoc, 1, 0, 0, 0, 0);\n        currentLoc.add(offsetUnit);\n}复制代码\n整合一下我们得到\n\npublic void drawLine(Location start, Location end) {\n        // 不同世界无法画线\n        if(start.getWorld() != end.getWorld()) {\n                return;\n        }\n                \n        Vector offsetUnit = end.clone().subtract(start).toVector();\n        double times = offsetUnit.length() / 0.1;\n        offsetUnit.multiply(1 / times);\n        drawLine(start, offsetUnit, times);\n}\n\npublic void drawLine(Location start, Vector offsetUnit, double times) {\n        Location currentLoc = start.clone();\n        // 避免绘制线段过短\n        if(times < 1) {\n                times = 1;\n        }\n        for(; times > 0; times--) {\n                currentLoc.getWorld().spawnParticle(Particle.FLAME, currentLoc, 1, 0, 0, 0, 0);\n                currentLoc.add(offsetUnit);\n        }\n}复制代码接下来的Part 1/2/3中出现的drawLine都是以上两个函数\n将不再重复声明\n\n有了可视化的支持，我们可以大胆开搞了\n\n\nPart 1、判断目标是否以背示人\n\n\n我们先从最简单的背部判定开始\n要知道目标是否以背示人，就是要知道目标是不是背朝我们这边\n背朝我们这边=面朝另一边=面向方向跟我们和目标之间的偏移向量的方向一样\n\n可视化的我们和目标之间的偏移向量：\ndrawLine(player, target);复制代码\n\n\n\n\nimage.png (73.46 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:19 上传\n\n\n\n\n\n\n可视化的目标视线：drawLine(target.getEyeLocation(), target.getLocation().getDirection().multiply(0.2), 100)复制代码\n\n\n\n\nimage.png (170.8 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:20 上传\n\n\n\n\n\n\n两条线段同时绘制：\n\n\n\n\nimage.png (118.51 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:23 上传\n\n\n\n\n\n\n\n\n\nimage.png (150.39 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:23 上传\n\n\n\n\n\n\n可以很明显看出两条线之间有一个角度\n意味着我们可以通过这两条线之间的夹角来判断目标是否背对我们\n即// 获取观察者位置\nLocation loc_player = player.getLocation();\n\n// 获取目标的位置\nLocation loc_target = target.getLocation();\n                \n// 和平面坐标系上 B点坐标减去A点坐标得到A->B 一样\n// 得到空间坐标中起点射向终点的偏移向量\nVector ray = loc_target.subtract(loc_player).toVector();\n\n// 只考虑平面偏移\nray.setY(0);\n\n// 获取目标视线的方向\nVector lookingVec_target = loc_target.getDirection();\n\n// 只考虑平面方向\nlookingVec_target.setY(0);\n\n// 得到两向量夹角，注意单位，若不加Math.toDegrees则为弧度制\ndouble angle = Math.toDegrees(ray.angle(lookingVec_target));复制代码\n由初中/高中向量知识知求两向量夹角应确保向量从同一起点出发\n所以上面代码得到的angle为图中右侧角\n\n\n\n\n无标题.png (6.54 KB, 下载次数: 1)\n\n下载附件\n\n2019-12-5 17:38 上传\n\n\n\n\n\n\nVector类的angle方法使用Math.acos，因此总是返回[0, π)，我们就不需要去考虑所得角度是否为劣弧\n\n至此，我们只需要定一个角度，来确定目标是否背向我们，这里默认为60°角\n只要angle < 60，即上图右侧那个角小于60°，我们就认为目标背对我们\n\n\n\n\nPart 2、判断目标是否在视野内/可见\n\n\n一个目标能被我们看到的前提：\n目标处于我们的视野内从目标位置到我们的眼睛处没有阻碍物（方块/实体）\n\n1、首先是目标是否处于视野内的判断：\n由于我们的视觉器官的物理限制，我们只能看到在我们面前一定角度内的东西。\ndrawLine(player.getEyeLocation(), target.getEyeLocation());复制代码\n可视化的观察者视线以及偏移向量：\n\n\n\n\nimage.png (347.25 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:57 上传\n\n\n\n\n\n\n\n\n\nimage.png (111.65 KB, 下载次数: 0)\n\n下载附件\n\n2019-12-5 17:58 上传\n\n\n\n\n\n可以看到偏移向量和我们的视线向量之间有一个夹角，当这个夹角大到一定程度的时候，目标就会像第二张图一样超出视野。\n由此我们写下第一个判断\n// 获取观察者眼睛位置\n// 该变量将作为起点、中间判断点使用\nLocation loc_start = entity.getEyeLocation();\n\n// 和平面坐标系上 B点坐标减去A点坐标得到A->B 一样\n// 得到空间坐标中起点射向终点的向量\nVector ray = target.getLocation().subtract(loc_start).toVector();\n// 注意对参数loc先克隆后使用，避免影响其在其他函数的作用\n\n// 首先判断观察者是否可能看得见目标\n//\n// 获取观察者视线向量\nVector lookingVec = entity.getLocation().getDirection();\n\n// 获取观察者视线向量与射线向量之间的夹角\n// 注意单位为弧度角\n// 这里也可以用pitch和yaw判断，自行把握\nfloat angle = lookingVec.angle(ray);\n// 如果角度超出了观察者视野最大角度\nif(Math.toDegrees(angle) > FOV) {\n        // 就认为观察者看不见目标位置\n        return false;\n}复制代码\n\n2、从目标位置到我们的眼睛处是否有阻碍物的判断：\n从我们绘制的线段可以看出，如果偏移向量的路径上有阻碍物，那么有阻碍物的那个地方的线段我们是看不见的，意味着我们可以采取和绘制线段一样的方法\n// 根据观察者和目标的距离\n// 得到一路上要判断是否有视野阻碍物的次数\ndouble checkTimes = ray.length() / SPACING;\n\n// 若距离过近，就只进行1次判断\nif(checkTimes < 1) {\n    checkTimes = 1;\n}\n                \n// 得到每次判断之后向目标位置移动的向量，即单位偏移向量\nVector offsetUnit = ray.multiply(1 / checkTimes);\n复制代码将绘制线段上各点(即生成粒子)部分的代码换成判断是否有阻碍物的代码\n[spoiler]\n\n// 每次判断后所需判断次数减一，直到最后到达目标位置\nfor(; checkTimes > 0; checkTimes--) {\n        // 通过材质判断当前所在位置的方块是否可以透视\n        // 也可以用org.bukkit.util.BlockIterator或LivingEntity的getLineOfSight\n        switch(loc_start.getBlock().getType()) {\n        // 添加你认为能透视的材质 TODO\n        // 这里我就举几个很常见的\n        case AIR:  // 空气 \n        case WATER: // 流水\n        case GRASS: // 小草\n                // 如果该方块的材质符合以上任意一项\n                // 就跳出switch进行下一步判断\n                break;\n        default:\n                // 如果该方块的材质我们觉得不能透视\n                // 就返回false，即观察者看不见目标\n                return false;\n        }\n        \n        // 实体判断就用spigot原生函数了\n        //\n        // 获取判断点处的实体列表\n        Collection<Entity> entityList = loc_start.getWorld().getNearbyEntities(loc_start, 0.1, 0.1, 0.1);\n                        \n        // 获取判断点处的实体数量\n        int count = entityList.size();\n        \n        // 如果列表里面包含观察者\n        if(entityList.contains(entity)) {\n                //周围实体数量减一\n                count--;\n        }\n        \n        // 如果列表里面包含目标\n        if(entityList.contains(target)) {\n                //周围实体数量减一\n                count--;\n        }\n                        \n        // 如果列表里还有其他生物\n        if(count > 0) {\n                // 就认为观察者看不见目标\n                return false;\n        }\n        \n        // 向目标位置移动\n        loc_start.add(ray);\n}复制代码\n此处只进行了头部可见性的判断，其他部位也是一样的判断流程\n多点判断意味着成倍消耗，准确性和性能自行把握\n\n\n\n\nPart 3、判断目标的头是否在视野中心\n\n由Part 2中第一项判断知，玩家视线在目标头部时，视线向量和玩家眼睛到目标头部的偏移向量之间的夹角是很小的，我们默认他为5°。\n\n但和Part 2不同，大部分目标的头部都很小，若目标离得有一定距离，误差会有所增加。\n\n因此Part 3我们要多考虑一个变量：距离\n这个变量很好获取\ndouble distance = loc_entity_eye.distance(loc_target_head);复制代码根据常识我们知道，距离越远，目标看起来就越小。近则反之。\n而目标越小，视线和偏移向量之间所允许的最大夹角就越小\n即两者成反比：距离 * 最大夹角 = 常数\n得最大夹角 = 常数 / 距离\n设常数为25\ndouble fov_focus_fixed = 25 / distance;复制代码求得修正后的最大夹角，与angle进行判断后，再进行Part 2中第2部分的判断\n\n类似的，Part 2中如果要追求更高的精确度，也可以进行距离修正。\n\n\n\nPart 4、以上功能代码\n\n使用ViewCheckUtil.instance.xxx()或自行添加静态修饰符\n\n\nimport java.util.Collection;\n\nimport org.bukkit.Location;\nimport org.bukkit.Particle;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.util.Vector;\n\n/**\n * 有关视野的判断\n * 只做了一点点微小的工作\n * \n * 自行判断要不要异线程工作\n * \n * @author Ir.Nep\n *\n */\npublic class ViewCheckUtil {\n        \n        public static final ViewCheckUtil instance = new ViewCheckUtil();\n        \n        // 视野阻碍判断的间隔 TODO\n        public static final double SPACING = 0.2;\n        \n        // 视野最大角度 TODO\n        public static final float FOV = 60;\n        \n        // 聚焦视野最大角度基数 TODO\n        public static final float FOV_FOCUS_NORMAL = 25;\n        \n        // 露出背部的最大角度 TODO\n        public static final float ANGLE_BACK = 60;\n        \n        /**\n         * 观察者是否能看得见目标位置\n         * @param entity 观察者\n         * @param loc 目标位置\n         * @param toIgnore 要忽略的实体列表(不要传入观察者\n         * @return boolean 希望能看到我吧\n         */\n        public boolean isTargetLocationInSight(LivingEntity entity, Location loc, Entity...toIgnore) {\n                // 不同世界无法判断\n                if(entity.getWorld() != loc.getWorld()) {\n                        return false;\n                }\n                \n                // 获取观察者眼睛位置\n                // 该变量将作为起点、中间判断点使用\n                Location loc_entity_eye = entity.getEyeLocation();\n                \n                // 和平面坐标系上 B点坐标减去A点坐标得到A->B 一样\n                // 得到空间坐标中起点射向终点的向量\n                Vector ray = loc.clone().subtract(loc_entity_eye).toVector();\n                // 注意对参数loc先克隆后使用，避免影响其在其他函数的作用\n                \n                // 首先判断观察者是否可能看得见目标\n                //\n                // 获取观察者视线向量\n                Vector lookingVec = entity.getLocation().getDirection();\n                \n                // 获取观察者视线向量与射线向量之间的夹角\n                // 注意单位为弧度角\n                // 这里也可以用pitch和yaw判断，自行把握\n                float angle = lookingVec.angle(ray);\n                \n                // 如果角度超出了观察者视野最大角度\n                if(Math.toDegrees(angle) > FOV) {\n                        // 就认为观察者看不见目标位置\n                        return false;\n                }\n                \n                // 根据观察者和目标位置的距离\n                // 得到一路上要判断是否有视野阻碍物的次数\n                double checkTimes = ray.length() / SPACING;\n                \n                // 若距离过近，就只进行1次判断\n                if(checkTimes < 1) {\n                        checkTimes = 1;\n                }\n                \n                // 得到每次判断之后向目标位置移动的向量\n                ray.multiply(1 / checkTimes);\n                \n                // 每次判断后所需判断次数减一，直到最后到达目标位置\n                for(; checkTimes > 0; checkTimes--) {\n                        \n                        \n                        // 通过材质判断当前所在位置的方块是否可以透视\n                        // 也可以用org.bukkit.util.BlockIterator或LivingEntity的getLineOfSight\n                        switch(loc_entity_eye.getBlock().getType()) {\n                        // 添加你认为能透视的材质 TODO\n                        // 这里我就举几个很常见的\n                        case AIR:  // 空气 \n                        case WATER: // 流水\n                        case GRASS: // 小草\n                                // 如果该方块的材质符合以上任意一项\n                                // 就跳出switch进行下一步判断\n                                break;\n                        default:\n                                // 如果该方块的材质我们觉得不能透视\n                                // 就返回false，即观察者看不见目标位置\n                                return false;\n                        }\n                        \n                        // 实体判断就用spigot原生函数了\n                        //\n                        // 获取判断点处的实体列表\n                        Collection<Entity> entityList = loc_entity_eye.getWorld().getNearbyEntities(loc_entity_eye, 0.1, 0.1, 0.1);\n                        \n                        // 获取判断点处的实体数量\n                        int count = entityList.size();\n                        \n                        // 如果列表里面包含观察者\n                        if(entityList.contains(entity)) {\n                                //周围实体数量减一\n                                count--;\n                        }\n                        \n                        if(toIgnore != null) {\n                                for(Entity entityToIgnore : toIgnore) {\n                                        if(entityList.contains(entityToIgnore)) {\n                                                count--;\n                                        }\n                                }\n                        }\n                        \n                        // 如果列表里还有其他生物\n                        if(count > 0) {\n                                // 就认为观察者看不见目标位置\n                                return false;\n                        }\n                        \n                        // 向目标位置移动\n                        loc_entity_eye.add(ray);\n                }\n                // 当所有判断点都通过了以后\n                // 就认为观察者能看见目标位置\n                return true;\n        }\n        \n        /**\n         * 观察者是否能看得见目标\n         * @param entity 观察者\n         * @param target 目标\n         * @return boolean 希望能看到我吧\n         */\n        public boolean isTargetInSight(LivingEntity entity, Entity target) {\n                // 不同世界无法判断\n                if(entity.getWorld() != target.getWorld()) {\n                        return false;\n                }\n                \n                // 获取目标位置\n                Location loc_target = target.getLocation();\n                \n                // 若目标非活物，这里只判断底部\n                // 若目标是活物，则同时检查目标的头和脚以减小误差\n                // 可以再加上几个身体的判断，服务器资源的消耗和判断的准确性自己把握\n                return isTargetLocationInSight(entity, loc_target, target) || (target instanceof LivingEntity ? isTargetLocationInSight(entity, loc_target.add(0, ((LivingEntity) target).getEyeHeight(), 0), target) : false);\n        }\n        \n        /**\n         * 观察者是否在盯着目标的头看\n         * @param entity 观察者\n         * @param target 目标\n         * @return boolean 盯久了会害羞所以还是false比较好\n         */\n        public boolean isLookingHead(LivingEntity entity, LivingEntity target) {\n                // 不同世界无法判断\n                if(entity.getWorld() != target.getWorld()) {\n                        return false;\n                }\n                \n                // 获取观察者眼睛的位置\n                Location loc_entity_eye = entity.getEyeLocation();\n\n                // 获取观察者视线向量\n                Vector lookingVec = loc_entity_eye.getDirection();\n                \n                // 获取目标头的位置, 大概没有眼睛不在头上的生物吧？！\n                // 有的话就改改 TODO\n                Location loc_target_head = target.getEyeLocation();\n                \n                double distance = loc_entity_eye.distance(loc_target_head);\n                \n                // 得到空间坐标中起点射向终点的向量\n                Vector ray = loc_target_head.subtract(loc_entity_eye).toVector();\n                \n                // 获取观察者视线向量与射线向量之间的夹角\n                float angle = (float) Math.toDegrees(ray.angle(lookingVec));\n                \n                double fov_focus_fixed = FOV_FOCUS_NORMAL / distance;\n                \n                // 如果角度超出了聚焦视野最大角度\n                if(angle > fov_focus_fixed) {\n                        // 就认为观察者没有盯着目标的头看\n                        return false;\n                }\n                \n                // 判断目标是否能被观察者看见\n                return isTargetInSight(entity, target);\n        }\n        \n        /**\n         * 观察者在目标的身后\n         * \n         * @param entity 观察者\n         * @param target 目标\n         * @return boolean 是否在身后\n         */\n        public boolean isBehind(LivingEntity entity, LivingEntity target) {\n                // 不同世界无法判断\n                if(entity.getWorld() != target.getWorld()) {\n                        return false;\n                }\n                \n                // 获取观察者位置\n                Location loc_entity = entity.getLocation();\n\n                // 获取目标的位置\n                Location loc_target = target.getLocation();\n                \n                // 和平面坐标系上 B点坐标减去A点坐标得到A->B 一样\n                // 得到空间坐标中起点射向终点的向量\n                Vector ray = loc_target.subtract(loc_entity).toVector();\n                \n                // 只考虑平面偏移\n                ray.setY(0);\n                \n                // 获取目标正视的方向\n                Vector lookingVec_target = loc_target.getDirection();\n                \n                // 只考虑平面方向\n                lookingVec_target.setY(0);\n                \n                // 得到两向量夹角\n                double angle = Math.toDegrees(ray.angle(lookingVec_target));\n                \n                // 若射线方向跟目标面向方向夹角小于露出背部的最大角度就认为是背对了\n                // 这里我没有判断目标是否在观察者视野里，背对背也是存在的情况\n                return angle < ANGLE_BACK;\n        }\n        \n        public void drawLine(Location start, Location end) {\n                // 不同世界无法画线\n                if(start.getWorld() != end.getWorld()) {\n                        return;\n                }\n                \n                Vector offsetUnit = end.clone().subtract(start).toVector();\n                double times = offsetUnit.length() / 0.2;\n                offsetUnit.multiply(1 / times);\n                drawLine(start, offsetUnit, times);\n        }\n        \n        public void drawLine(Location start, Vector offsetUnit, double times) {\n                Location currentLoc = start.clone();\n                // 避免绘制线段过短\n                if(times < 1) {\n                        times = 1;\n                }\n                for(; times > 0; times--) {\n                        currentLoc.getWorld().spawnParticle(Particle.FLAME, currentLoc, 1, 0, 0, 0, 0);\n                        currentLoc.add(offsetUnit);\n                }\n        }\n}复制代码\n\n\n\n\n",
    "replies": [
        {
            "author": "huanmeng_cn",
            "timestamp": 1575545040,
            "txt_content": "收藏就对了，说不定以后用得上！"
        },
        {
            "author": "云云大魔王",
            "timestamp": 1575551760,
            "txt_content": "这样子说是不是能弄一个（小游戏）别的玩家（或boss）在看你的时候显示“危”"
        },
        {
            "author": "Lao_Ge",
            "timestamp": 1575553740,
            "txt_content": "谢谢，这个对我很有帮助"
        },
        {
            "author": "字幕kall",
            "timestamp": 1575631140,
            "txt_content": "感谢分享，我最近还琢磨怎么弄这个面向的判断来着，想到要用到向量 但是还没什么思路 突然发现这个帖子 醍醐灌顶"
        },
        {
            "author": "asjkdaskljda",
            "timestamp": 1575635340,
            "txt_content": "学习了，有空玩一玩"
        },
        {
            "author": "Kenneth_z",
            "timestamp": 1575678300,
            "txt_content": "收藏了 以后用得上"
        },
        {
            "author": "平平平平海",
            "timestamp": 1575884220,
            "txt_content": "怎么想到的嗷\n这是人干的事嘛"
        }
    ]
}