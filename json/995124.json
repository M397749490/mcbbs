{
    "title": "[搬运+翻译][从零学编程]C++Ⅴ：类与对象",
    "author": "45gfg9",
    "replyCount": 4,
    "timestamp": 1585232400,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-28 16:45 编辑 \n\n\n索引贴\n答案帖\nPrev: C++Ⅳ：函数\nNext: C++Ⅵ：再谈类\n\n\n1 什么是对象\n\n1.1 什么是对象\n\n[ruby=Object Oriented Programming]面向对象编程[/ruby]是一种旨在使编程与现实世界更贴切的编程方式。\n\n在编程中，[ruby=objects]对象[/ruby]是独立的单元，每一个对象都有不同的[ruby=identity]标识[/ruby]，正如现实中的对象（物体）。\n一个苹果是对象；一个马克杯也是。每个物体都有不同的标识。你可以有两个看起来完全一样的杯子，但它们仍然是独立且不同的物体。\nPart题：\n对象有：\nA. 标识\nB. 梦想\nC. 一只手\n\n1.2 对象（一）\n\n一个对象可能会包含其他的对象，但它们仍然是不同的对象。\n\n对象也有能用于描述它们的[ruby=characteristics]特性[/ruby]。举例，车可能是红色或蓝色，杯子可能是满的或空的，等等。这些特性，也叫做[ruby=attributes]属性[/ruby]。属性描述了一个对象的目前[ruby=states]状态[/ruby]。\n对象可以有多个属性（杯子可以是红色、大的、空的）。\n一个对象的状态与其类型不同；一个杯子可能是装满水的，另一个杯子可能是空的。\nPart题：\n属性描述了：\nA .对象的意义\nB. 对象的目前状态\nC. 对象的名称\n\n1.3 对象（二）\n\n现实世界中，每个物体的行为都不同。车可以移动，手机可以响铃等等。对对象来说也一样——行为与类型相关。\n所以，下面的三个角度在面向对象编程语言中能用来描述任何对象：标识、属性、[ruby=behavior]行为[/ruby]。\nPart题：\n面向对象编程语言中的对象能用哪三样东西表示？\nA. 标识 属性 行为\nB. 力量 忠诚 标识\nC. 仅属性\n\n1.4 对象（三）\n\n在编程中，对象是[ruby=self-contained]自包含[/ruby]的，有自己的标识。它与其他对象是分开的。\n每个对象都有自己的属性，描述它当前的状态。每个对象也有自己的行为，描述了它们能做什么。\n\n\n计算中，对象不总是表示一个真实物体。\n举个例，一个编程对象可以表示日期、时间或是银行帐户。银行帐户是无形的；你看不见也摸不到，但它仍然是一个明确的对象——有自己的标识、属性和行为。\n接着来看C++中的面向对象编程（OOP）！\nPart题：\n关于对象，下面哪两种描述是正确的？\nA. 对象不总是可见的东西\nB. 对象总是可见的东西\nC. 对象总是实物\nD. 对象不总是实物\n\n\n2 什么是类\n\n2.1 什么是类\n\n对象由[ruby=class]类[/ruby]创建，类也是OOP的关键部分。\n\n类描述了对象会成为什么，但与对象本身是分开的。\n换句话说，类可以想成对象的蓝图，描述，或定义。\n你可以用一个类作为蓝图创建许多不同的对象。例如，在准备新建大楼时，建筑设计师会先创建一个蓝图，当作要实际建造的大楼的蓝图。一张蓝图能用来建造很多幢大楼。\n\n编程的思路与此类似。我们先定义一个类，作为创建对象的蓝图。\n\n每个类都有其名称，并描述了属性和行为。\n\n编程中，词语“[ruby=type]类型[/ruby]”指一个类的名称：我们创建的对象是有其类型的。\n[ruby=attributes]属性[/ruby]也常被叫做properties或[ruby=data]数据[/ruby]。\nPart题：\n关于类，哪条表述是正确的？\nA. 类只描述对象的属性\nB. 类无名称\nC. 类有名称，并描述了对象的属性和行为\n\n2.2 方法\n\n[ruby=Method]方法[/ruby]是另一个用于类的行为的词语。方法基本上就是属于一个类的函数。\n方法与函数类似——它们是能被调用的代码块，可以执行某个行为并返回值。\nPart题：\n方法是？\nA. 方法是在类中声明的函数\nB. 方法是程序的主函数\nC. 方法是对象\n\n2.3 类的例子\n\n举例，如果我们要创建一个银行程序，那可以给我们的类下面的特性：\n名称：[ruby=银行帐户]BankAccount[/ruby]\n属性：[ruby=帐户号码]accountNumber[/ruby]，[ruby=余额]balance[/ruby]，[ruby=开户日期]dateOpened[/ruby]\n行为：[ruby=打开]open[/ruby]()，[ruby=关闭]close[/ruby]()，[ruby=存款]deposit[/ruby]()\n\n类定义每个对象该有的属性和行为。但它并不指定实际的数据是什么；它只提供定义。\n\n当我们写好类后，就可以接着来基于类创建对象。每个对象都叫做类的[ruby=instance]实例[/ruby]。创建类的过程叫做[ruby=instantiation]实例化[/ruby]。\n每个对象都有自己的标识、数据和行为。\nPart题：\n创建对象的过程叫做...\nA. 实例化\nB. 对象化\nC. 创建\n\n\n3 类的例子\n\n3.1 声明类（一）\n\n用class关键词开始你的类定义。关键字后跟着类名和类体，包装在花括号内。\n下面的代码定义了一个叫做BankAccount的类：\nclass BankAccount {\n\n};\n类定义后必须有分号。\nPart题：\n用于定义类的关键字是？\n\n3.2 声明类（二）\n\n在类体的花括号内定义类所具有的所有属性和行为（或叫做成员）。\n你也可以给类的成员定义[ruby=access specifier]访问修饰符[/ruby]。\n一个用[ruby=公有]public[/ruby]关键字定义的成员，在类的对象的范围内，可以在类之外访问。\n你也可以将类成员指定为[ruby=私有]private[/ruby]或[ruby=受保护]protected[/ruby]。这些东西会在后面讨论细节。\nPart题：\npublic关键字是什么？\nA. 什么都不是\nB. 一个可以访问的数据\nC. 一种访问修饰符\n\n3.3 创建类\n\n让我们创建一个有一个公有方法的类，并让其输出\"Hi\"。\nclass BankAccount {\n  public:\n    void sayHi() {\n      cout << \"Hi\" << endl;\n    }\n};\n下一步是实例化一个我们的BankAccount类的对象。如定义某类型的变量一样，但我们对象的类型会是BankAccount。\nint main() \n{\n  BankAccount test;\n  test.sayHi();\n}\n我们名为test的对象有类定义的所有成员。\n注意到用来访问并调用对象方法的点分隔符 (.)。\n在使用类前必须先定义，正如我们使用函数一样。\nPart题：\n填空声明一个类MyClass，有一个公有函数名为someFunction，其向屏幕输出\"hi from MyClass\"。\n_____ MyClass\n{\n ______ :\n  void someFunction() {\n    ____ << \"hi from MyClass\" << endl;\n  }\n};\n\n\n\n4 抽象化\n\n4.1 抽象化（一）\n\n数据的[ruby=abstraction]抽象化[/ruby]是只向外界提供必要信息的概念。这是一种只表示本质内容而不包括实现细节的过程。\n\n一个好的现实例子是书：你听到词语“书”时，你不知道具体的细节，例如页数、颜色、大小，但你知道书的概念——书的抽象化。\n抽象化的概念是我们关注对象共有的本质，而不关心某个个例有什么特性。\nPart题：\n抽象化是什么意思？\nA. 没有意思\nB. 一种对象类型\nC. 关注某事的本质\n\n4.2 抽象化（二）\n\n抽象化意味着，我们可以有一个想法或概念，它不与任何具体的实例相关。\n这是面向对象编程的核心构成之一。\n\n举例，当你使用cout时，你其实使用的是ostream类的cout对象。它以流的方式处理数据，最后得到标准输出。\ncout << \"Hello!\" << endl;\n在这个例子中，不必知道cout是如何将文字输出到屏幕的。要使用它，你只需知道公共接口。\nPart题：\n下面哪条关于抽象化的表述是正确的？\nA. 我们可以有一个独立于任何具体实例的概念\nB. 抽象化与面向对象编程无关\nC. 抽象化是一种给类定义函数的方式\n\n4.3 抽象化（三）\n\n抽象化允许我们只写一个银行帐户类，然后基于类为不同帐户创建不同对象，而非为每个帐户都新建一个单独的类。\n\n抽象化是其他面向对象基础的基础，例如[ruby=inheritance]继承[/ruby]和[ruby=polymorphism]多态[/ruby]。这些都放在以后的课讲。\nPart题：\n什么是其他面向对象基础，例如继承和多态，的基础？\n\n\n5 封装\n\n5.1 封装（一）\n\n词语[ruby=encapsulation]封装[/ruby]的一部分含义是将一个实体“包裹”起来，不仅仅是为了将里面的内容整合在一起，也是为了保护它。\n在面向对象中，封装不仅仅意味着简单地将属性和行为装在一个类中；也意味着将访问限制在类里。\n\n这里的核心思想是一个对象只暴露出其他部分程序所必需来有效运行应用程序的部分。其他所有东西都对外不可见。\n这被叫做[ruby=data hiding]数据隐藏[/ruby]。\nPart题：\n封装允许你：\nA. 声明一个函数\nB. 隐藏类的实现细节\nC. 将值赋给变量\n\n5.2 封装（二）\n\n用我们的BankAccount类举例，我们不想让程序其他部分不通过deposit()或[ruby=取款]withdraw[/ruby]()行为就访问并修改任何对象的balance。\n我们应该隐藏那个属性，控制它的访问，所以它只能被对象自己访问。\n这样的话，balance不能直接被对象外界改变，只能通过对象的方法来访问。\n这也叫做“[ruby=black boxing]黑箱化[/ruby]”，指关闭对象的工作区，只开放我们想让它开放的部分。\n这让我们可以改变方法的属性和行为，而不用改变整个程序。举例，我们可以之后回来修改balance属性的数据类型。\n总结，封装的好处有：\n控制数据被访问或修改的方式代码更灵活且更易于随新的需求而改变修改一部分代码不会影响其他部分\n\nPart题：\n封装的思想是（选择两项）：\nA. 隐藏对象的一切，只暴露必要的\nB. 封装对象的属性和方法\nC. 为类的用户提供函数\nD. 创建类的实例\n\n\n6 封装的例子\n\n6.1 访问修饰符（一）\n\n访问修饰符用于给特定的类成员设置访问等级。\n三级访问修饰符分别是public，protected和private。\n\n一个公有成员可以在类之外，以及在类对象的范围内访问。\n\n举例：\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass myClass {\n  public:\n    string name;\n};\n\nint main() {\n  myClass myObj;\n  myObj.name = \"SoloLearn\";\n  cout << myObj.name;\n  return 0;\n}\n\n//输出 \"SoloLearn\"\nname属性是公有的；它可以在外部代码访问。\n访问修饰符只需声明一次；多个成员可以跟在一个访问修饰符后面。\n注意到public关键字后面的冒号 (:)。\nPart题：\n填空声明一个类MyClass，有一个数据成员，类型string名为myData，之后在main中给它赋值\"I love C++\"。别忘记包含string数据类型需要的头文件。\n#include <iostream>\n#include < ______ >\n_____ MyClass\n{\n public:\n  string myData;\n};\nint main()\n{\n  MyClass obj;\n  ___ .myData = \"I love C++\";\n}\n\n\n6.2 私有\n\n一个私有成员不能被类的外界访问或甚至看见；它只能在类的内部访问。\n一个公有成员函数可以用于访问私有成员。举例：\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass myClass {\n  public:\n    void setName(string x) {\n      name = x;\n    }\n  private:\n    string name;\n};\n\nint main() {\n  myClass myObj;\n  myObj.setName(\"John\");\n\n  return 0;\n}\nname属性是私有的，在外界无法访问。\n公有setName()方法用于设置name属性。\n如果没有定义访问修饰符，类的所有成员都默认设为私有。\nPart题：\n填空声明一个类MyClass，有一个私有数据成员，类型int名为myData。声明一个公有函数setMyData()，设置myData的值为它的参数。\nclass MyClass\n{\n _______ :\n  int myData;\n ______ :\n  void setMyData( ___ arg) {\n    myData = arg;\n  }\n};\n\n\n6.3 访问修饰符（二）\n\n我们可以添加另一个用于获取属性的值的公有方法。\nclass myClass {\n  public:\n    void setName(string x) {\n      name = x;\n    }\n    string getName() {\n      return name;\n    }\n  private:\n    string name;\n};\ngetName()方法返回私有的name属性的值。\nPart题：\n填空声明一个获取MyClass类数据成员myData的方法。myData的获取方法是一个名为getMyData()，返回myData值的公有函数。\nclass MyClass\n{\n private:\n  int myData;\n public:\n  ___ getMyData() {\n    ______ myData;\n  }\n};\n\n\n6.4 访问修饰符（三）\n\n组合起来：\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass myClass {\n  public:\n    void setName(string x) {\n      name = x;\n    }\n    string getName() {\n      return name;\n    }\n  private:\n    string name;\n};\n\nint main() {\n  myClass myObj;\n  myObj.setName(\"John\");\n  cout << myObj.getName();\n\n  return 0;\n}\n\n//输出 \"John\"\n我们通过封装向外部代码隐藏name属性。然后我们通过公有方法提供对它的访问。我们类的数据只能通过这些方法读取和修改。\n这允许改变方法和属性的实现，而不影响外界代码。\nPart题：\n填空声明一个MyClass对象，设置它的数据成员的值为14，之后输出其值到屏幕。用公有函数setMyData和getMyData完成上述操作。\nint main()\n{\n  MyClass obj;\n  obj.setMyData( __ );\n  cout << ___ .getMyData() << endl;\n}\n\n\n\n7 构造函数\n\n7.1 构造函数（一）\n\n类的[ruby=constructor]构造函数[/ruby]是类的特殊成员函数。它们在当新的类对象创建时执行。\n\n构造函数的名称与类名一致。它们没有返回类型，就连void也没有。\n\n举例：\nclass myClass {\n  public:\n    myClass() {\n      cout <<\"Hey\";\n    }\n    void setName(string x) {\n      name = x;\n    }\n    string getName() {\n      return name;\n    }\n  private:\n    string name;\n};\n\nint main() {\n  myClass myObj;\n\n  return 0;\n}\n\n//输出 \"Hey\"\n现在，在创建myClass类型的对象时，构造函数被自动调用。\nPart题：\n构造函数什么时候调用？\nA. 当类对象被创建\nB. 永远不\nC. 当类被声明\n\n7.2 构造函数（二）\n\n构造函数在为某些成员变量设置初始值时非常有用。\n默认的构造函数没有参数。但当需要时，可以给构造函数加参数。这使你可以在创建对象时给它赋初值，如下例所示：\nclass myClass {\n  public:\n    myClass(string nm) {\n      setName(nm);\n    }\n    void setName(string x) {\n      name = x;\n    }\n    string getName() {\n      return name;\n    }\n  private:\n    string name;\n};\n我们定义了一个构造函数，接受一个变量，并通过setName()方法赋给name属性。\nPart题：\n填空声明一个有构造函数的类my_class。\n_____ my_class\n{\n private:\n  int my_data;\n public:\n  _______ (int arg) {\n    my_data = ___ ;\n  }\n};\n\n\n7.3 构造函数（三）\n\n创建对象时，你现在需要向构造函数传参，与调用函数时一样：\nclass myClass {\n  public:\n    myClass(string nm) {\n      setName(nm);\n    }\n    void setName(string x) {\n      name = x;\n    }\n    string getName() {\n      return name;\n    }\n  private:\n    string name;\n};\n\nint main() {\n  myClass ob1(\"David\");\n  myClass ob2(\"Amy\");\n  cout << ob1.getName();\n}\n//输出 \"David\"\n我们定义了两个对象，通过构造函数给每个对象的name属性赋初值。\n构造函数可以重载。\nPart题：\n填空声明有构造函数的类MyClass。在main函数中创建一个MyClass对象并传递14作为构造函数参数。\n_____ MyClass {\n private:\n  int myData;\n public:\n  MyClass(int arg) {\n    myData = arg;\n  }\n};\nint main() {\n  MyClass obj( __ );\n}\n\n\n期末考试\n\n1. 哪条表述正确？\nA. 对象是类的实例\nB. 对象是类的函数\nC. 对象是类的抽象\n\n2. 用于描述面向对象编程中的对象的三个词分别是属性、行为和？\n\n3. 一个类能有多少函数（方法）？\nA. 一\nB. 二\nC. 任意\n\n4. public和private关键字叫做？\nA. 类函数\nB. 访问修饰符\nC. 数据成员\n\n5. 填空声明类Student，有一个名hello的公有函数。hello()函数输出\"hi from student\"到屏幕。\n_____ Student\n{\n ______ :\n  void hello() {\n    ____ << \"hi from student\" << endl;\n  }\n};\n\n6. 填空声明类Student，有一个int类型的数据成员age。Student类有一个一参构造函数，其设置age数据成员的值。\nclass Student {\n private:\n  int age;\n ______ :\n  Student(int a) {\n    setAge( _ );\n  }\n  void setAge(int a) {\n    age = a;\n  }\n  ___ getAge() {\n    ______ age;\n  }\n};\n\n",
    "replies": [
        {
            "author": "wjwrh",
            "timestamp": 1585405620,
            "txt_content": "无内鬼，来丶类模板？"
        },
        {
            "author": "45gfg9",
            "timestamp": 1585405980,
            "txt_content": "wjwrh 发表于 2020-3-28 22:27\n无内鬼，来丶类模板？\n有内鬼，停止更新\n\n模版在第八章"
        },
        {
            "author": "Night丶R",
            "timestamp": 1594816260,
            "txt_content": "从零开始也想学"
        },
        {
            "author": "辞音",
            "timestamp": 1596476160,
            "txt_content": "从零开始也想学"
        }
    ]
}