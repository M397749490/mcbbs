{
    "title": "私人服务器应急公网IP查看&Ping方案",
    "author": "MeTerminator",
    "replyCount": 6,
    "timestamp": 1594978440,
    "txt_content": "| 引入\n当你想开服，又没钱租用面板/VPS等服务器时，不少人会选择自行使用家中电脑配合nat123&花生壳等软件\n进行内网穿透/动态IP追踪等方式进行开服吧，但用过这些软件的腐竹都知道，花生壳会不定时的进行服务器维护，\nnat123又容易突然断线，如果你在外，那么服务器基本上就GG了(我就是遇到这个问题才有了这个帖子的233)。\n有没有一种方式，能够实时追踪/查看自己服务器的公网IP呢？\n\n\n| 教程\n语言：Python3\n利用软件：https://www.natfrp.com/\n准备：\n    1.一个至少可以开放一个http端口的服务器\n    2.一个域名\n效果：\n\n\n\n\nimage.png (70.12 KB, 下载次数: 0)\n\n下载附件\n\n2020-7-17 17:33 上传\n\n\n\n\n\n\n代码：\n\n\n#!/usr/bin/python env\n# coding:utf-8\nimport requests\nimport re\nimport socket\nimport subprocess\nimport threading\n\n#获取本机公网IP\ndef get_ip():\n    ip = requests.get(\"http://ip.42.pl/raw\").text\n    return ip\n\nip_port = ('0.0.0.0', 9691)\nback_log = 10\nbuffer_size = 1024\n\n\ndef web():\n    print(\"webserver开始运行.\")\n    webserver = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    webserver.bind(ip_port)\n    webserver.listen(back_log)\n\n    while True:\n        try:\n            conn, addr = webserver.accept()\n            print(addr)\n            recvdata = conn.recv(buffer_size)\n\n            alldata = '{\"name\":服务器名称\", \"ip\":\"'+str(get_ip())+'\"}'\n\n            conn.sendall(bytes(\"HTTP/1.1 200 OK\\r\\n\\r\\n\", \"utf-8\"))  # 响应头\n            conn.sendall(bytes(alldata, \"utf-8\"))\n\n            # 文件方式\n            # with open(\"t1.html\",\"rb\") as f:\n            #     data = f.read()\n            #     conn.sendall(bytes(\"HTTP/1.1 201 OK\\r\\n\\r\\n\", \"utf-8\"))  # 响应头\n            #     conn.sendall(data)\n\n            conn.close()\n        except:\n            pass\n\n\nif __name__ == '__main__':\n    web()复制代码\n\n使用此代码后，访问\"http://本机IP:9691/\"即可完成该效果。\n配合Sakura Frp的网页映射即可在外使用公网IP连接到服务器了。\n请先自行设置路由器！\n\n\n\n完结，散花~~~\n第一次发帖，不好见谅\n\n",
    "replies": [
        {
            "author": "JNX",
            "timestamp": 1594984080,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "MeTerminator",
            "timestamp": 1594986660,
            "txt_content": "JNX 发表于 2020-7-17 19:08\n好乱 没看懂\n请先学习Python安装哦，后期可能会出一个更详细的教程。"
        },
        {
            "author": "iphone7s_plus",
            "timestamp": 1594990500,
            "txt_content": "恕我直言，你在干嘛？还是说我太笨了没听懂"
        },
        {
            "author": "xmdhs",
            "timestamp": 1594990500,
            "txt_content": "发现用 go 写也没比用 python 多写几行\npackage main\n\nimport (\n        \"io/ioutil\"\n        \"log\"\n        \"net/http\"\n        \"os\"\n        \"time\"\n)\n\nfunc main() {\n        a := os.Args\n        s := http.Server{\n                Addr:         \":\" + a[1],\n                ReadTimeout:  5 * time.Second,\n                WriteTimeout: 10 * time.Second,\n        }\n        http.HandleFunc(\"/\", h)\n        log.Println(s.ListenAndServe())\n}\n\nvar c *http.Client\n\nfunc getip() string {\n        c = &http.Client{\n                Timeout: 5 * time.Second,\n        }\n        req, err := http.NewRequest(\"GET\", \"https://api.ip.sb/ip\", nil)\n        if err != nil {\n                return err.Error()\n        }\n        reqs, err := c.Do(req)\n        if reqs != nil {\n                defer reqs.Body.Close()\n        }\n        if err != nil {\n                return err.Error()\n        }\n        b, err := ioutil.ReadAll(reqs.Body)\n        if err != nil {\n                return err.Error()\n        }\n        return string(b)\n}\n\nfunc h(w http.ResponseWriter, req *http.Request) {\n        log.Println(req.RemoteAddr)\n        w.Write([]byte(getip()))\n}\n复制代码\n\n虽然编译出来的文件有点大，但是也比 python 小不少（"
        },
        {
            "author": "redfish",
            "timestamp": 1594998480,
            "txt_content": "如果有一个公网服务器，自己搭隧道不香吗"
        },
        {
            "author": "MeTerminator",
            "timestamp": 1595041140,
            "txt_content": "xmdhs 发表于 2020-7-17 20:55\n发现用 go 写也没比用 python 多写几行\n还没写完，后期计划是增加minecraft服务器的支撑，可以查人数，玩家列表，利用站长工具ping(逃)"
        }
    ]
}