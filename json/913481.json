{
    "title": "[编程|开源]TRMobAPI —— 高效地设计和创建自定义怪物|开发者API[1.9-1.14]",
    "author": "BellTune",
    "replyCount": 9,
    "timestamp": 1568436360,
    "txt_content": " 本帖最后由 BellTune 于 2019-9-14 19:01 编辑 \n\nTRMobAPI —— 自定义怪物API\n\n这是什么？\n这是一套给开发者准备的自定义怪物API，\n通过这套API，你可以高效而方便地随心所欲地发挥你的设计，\n并且该API官方自带几个附属插件，例如世界刷新，\n使得你不必关注于设计没有意义的轮子。\n（其实是过中秋，发点福利，把我一直自己用的怪物框架给公开了）\n\n特性：\n· 快速高效：只需新建一个类，一个怪物类便产生了\n· 方便设计：无需关注于注册监听器和写很多轮子\n· 等级系统：无需自己设计怪物等级，已为你准备好\n· 可持续性：即使服务器重启，怪物也不会失效或丢失\n· 提供接口：附属插件可以来回协调工作使得拓展性更大\n· 限制近无：API并不会限制你的设计，可随心所欲发挥\n· Boss血条：仅需实现TRBossBar接口便可自动产生Boss条\n· 自带配置：仅需implements TRJsonConfigurable，无需自己设计\n· 自带命令：调试怪物远比你想的方便得多，不再繁琐\n· 可热拔插：你甚至无需重启服务器便可动态修改怪物\n· 自动更新：尽量不必关心用户版本错位导致的各种报错\n· 官方附属：无需反复设计一些已有的附属内容\n- 未来计划：内置独立数据接口\n- 未来计划：提供更多操作NMS的接口\n\n使用截图：\n\n\n\n\n31.png (91.4 KB, 下载次数: 0)\n\n下载附件\n\n2019-9-14 12:40 上传\n\n\n\n\n\n\n使用教程：\n见翻页，\n其实是作者被和谐了，所以不能发官方教程地址\n第二页为服主教程，第三页为开发者教程\n\n下载地址：\n\n\n\n下载地址.zip\n(251 Bytes, 下载次数: 364)\n\n\n\n2019-9-14 11:02 上传\n点击文件名下载附件\n\n\n\n\n\n\n官方源码仓库\n\n官方附属：\n【TRMobSpawn】自定义怪物生成器：自然刷新或刷新点生成由附属插件设计的怪物类\n【TRExample】官方开源示范API插件：自带了一些测试怪物和测试代码以供参考\n\n*注：本人不是原作者，只转载，有技术问题别问我\n本插件代发自：TRMobAPI-git 原作者是：缇亚祢\n\n\n\nTRMobAPI —— 自定义怪物API\n\n在使用这个插件之前，作为服主你要明白：\n1.这款插件并非MM的设计，你无法直接设计怪物\n2.如果你不懂插件开发，你就只能用已有的附属插件，\n但如果**插件开发，那你可以用这套API设计自己的怪物了，看第二页\n若要查询关于插件的信息，看第一页\n\n目录：\n 第一章 序言 TRMobAPI 第二章 插件的安装，生成第一只怪物，基础命令Load,Spawn,Command 第三章 让怪物自然刷新在世界上/刷新点刷新 TRMobSpawn 第四章 对怪物进行常见的配置讲解 TRJsonConfigurable\n\n第二章 —— 插件的安装，生成第一只怪物，基础命令Load,Spawn,Command\n插件的安装：\n只需要去发布帖地址下载插件本体，然后放入服务器plugins即可\n不过你只安装一个本体是没有任何作用的，你需要安装一个附属\n这里有一个示范用附属：https://gitee.com/vlvxingze/TRMExample\n把两个插件都下载完毕后丢入plugins 后重启就算是完成了\n\n生成第一只怪物：\nTRMExample 附属插件提供了四个示范怪物，\n com.relatev.minecraft.TRMExample.TestZombie 这只僵尸具有等级，最大生命值为20+等级x5，伤害为等级x2，掉落经验为等级x2，若等级大于5级，死亡时还会掉一颗钻石。但它出生时，只有1滴血，每过5五秒会恢复5点生命值直至满血 com.relatev.minecraft.TRMExample.GiantBoss 巨人僵尸拥有血条，不具有等级，每过5秒便会在脚下召唤一只等级为5的TestZombie僵尸，Boss血条显示距离为32M com.relatev.minecraft.TRMExample.TestSkeleton不具有等级，该小白射出的弓箭会在着落点引发半径为1.5M的爆炸 com.relatev.minecraft.TRMExample.FeiSheep 沸羊羊是一只羊，具有等级，其出生生命值为20+等级x5，但它有三条命，每次死亡时都会立即满血，另外，其拥有Boss血条，距离为32M\n输入/trm spawn <怪物ID> 就可以生成一只指定的怪物了\n/trm spawn com.relatev.minecraft.TRMExample.GiantBoss\n由于太长，所以你没有必要打那么完整，插件会模糊匹配名字\n/trm spawn giantboss\n而某些怪物具有等级，输入/trm spawn <怪物ID> <等级> 刷出指定等级的怪物\n/trm spawn testzombie 5\n基础命令：\n插件本身提供的命令并不多，不过附属插件可能会提供更多命令给你\n/trm spawn <ID> (Level) 生成指定等级的怪物\n/trm killall <ID> 清理该ID存活的所有怪物\n/trm list 列表当前服务器已加载的怪物类\n第三章 —— 让怪物自然刷新在世界上/刷新点刷新TRMobSpawn\n我已经讲过了，这个插件本身安装了并没有任何效果，\n但是作者在发布插件的同时也发布了几个附属插件，\n而比较常用的便是这个了：TRMobSpawn\n\n让自然刷新的怪物替换为指定怪物类的怪物：\n将TRMobSpawn插件安装后打开它的配置，里面大概是这样的：\nCustomSpawn:\n  world: #世界名字\n    ELDER_GUARDIAN #要被替换的怪物类型: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ELDER_GUARDIAN\"}' #怪物种类，MaxLevel填的是最高等级，MinLevel填的是最低等级，TRMobID填写怪物类ID名（不可缩写）\n    WITHER_SKELETON: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_WITHER_SKELETON\"}'\n    STRAY: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_STRAY\"}'\n    HUSK: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_HUSK\"}'\n    ZOMBIE_VILLAGER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ZOMBIE_VILLAGER\"}'\n    SKELETON_HORSE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SKELETON_HORSE\"}'\n    ZOMBIE_HORSE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ZOMBIE_HORSE\"}'\n    ARMOR_STAND: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ARMOR_STAND\"}'\n    DONKEY: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_DONKEY\"}'\n    MULE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_MULE\"}'\n    EVOKER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_EVOKER\"}'\n    VEX: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_VEX\"}'\n    VINDICATOR: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_VINDICATOR\"}'\n    ILLUSIONER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ILLUSIONER\"}'\n    CREEPER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_CREEPER\"}'\n    SKELETON: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SKELETON\"}'\n    SPIDER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SPIDER\"}'\n    GIANT: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_GIANT\"}'\n    ZOMBIE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ZOMBIE\"}'\n    SLIME: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SLIME\"}'\n    GHAST: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_GHAST\"}'\n    PIG_ZOMBIE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_PIG_ZOMBIE\"}'\n    ENDERMAN: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ENDERMAN\"}'\n    CAVE_SPIDER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_CAVE_SPIDER\"}'\n    SILVERFISH: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SILVERFISH\"}'\n    BLAZE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_BLAZE\"}'\n    MAGMA_CUBE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_MAGMA_CUBE\"}'\n    ENDER_DRAGON: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ENDER_DRAGON\"}'\n    WITHER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_WITHER\"}'\n    BAT: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_BAT\"}'\n    WITCH: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_WITCH\"}'\n    ENDERMITE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_ENDERMITE\"}'\n    GUARDIAN: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_GUARDIAN\"}'\n    SHULKER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SHULKER\"}'\n    PIG: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_PIG\"}'\n    SHEEP: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SHEEP\"}'\n    COW: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_COW\"}'\n    CHICKEN: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_CHICKEN\"}'\n    SQUID: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SQUID\"}'\n    WOLF: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_WOLF\"}'\n    MUSHROOM_COW: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_MUSHROOM_COW\"}'\n    SNOWMAN: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_SNOWMAN\"}'\n    OCELOT: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_OCELOT\"}'\n    IRON_GOLEM: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_IRON_GOLEM\"}'\n    HORSE: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_HORSE\"}'\n    RABBIT: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_RABBIT\"}'\n    POLAR_BEAR: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_POLAR_BEAR\"}'\n    LLAMA: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_LLAMA\"}'\n    PARROT: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_PARROT\"}'\n    VILLAGER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_VILLAGER\"}'\n    PLAYER: '{\"MaxLevel\":10,\"MinLevel\":10,\"TRMobID\":\"TR_PLAYER\"}'\n复制代码使所有在world世界自然刷新的僵尸为 com.relatev.minecraft.TRMExample.TestZombie 类的僵尸，等级为5-10级：\n注意，TRMobSpawn插件不支持模糊匹配，你只能写怪物的全ID，写testzombie是不行的\nCustomSpawn:\n  world:\n    ZOMBIE: '{\"MaxLevel\":10,\"MinLevel\":5,\"TRMobID\":\"com.relatev.minecraft.TRMExample.TestZombie\"}'\n复制代码\n\n刷新点刷新指定怪物：\nTRMobSpawn 自带一个怪物点刷新系统，跟MM有点类似，\n/trms spawnpoint 查阅刷新点命令\n/trms spawnpoint addpoint <ID> <间隔秒> (最低级) (最高级) 在你所站位置创建一个刷新点\n/trms spawnpoint removepoint <半径> 删除周围多少米内的所有刷怪点\n/trms listpoint (距离) 列表附近多少米内所有刷怪点，不填半径为全部刷怪点\n让站着的位置每5秒刷一只1-3级的 com.relatev.minecraft.TRMExample.TestZombie 怪物：\n/trms spawnpoint addpoint testzombie 5 1 3\n\n\n删除旁边的一个刷怪点：\n/trms spawnpoint removepoint 5\n查阅旁边的刷怪点们的名字：\n/trms spawnpoint listpoint 5\n第四章 —— 对怪物进行常见的配置讲解TRJsonConfigurable\n如果你有看过开发者教程，你应该知道TRMobAPI自带了一套非常简单好用的配置生成和读取器，\n使用的是Json搭配Yaml格式，使用极其方便，编辑起来还是比较人性化的。\n不同的附属插件其怪物配置文件也不尽相同，但这里讲解了常见的几个参数：\nTRJsonConfig: |-\n  {\n    \"DisplayName\": \"&a小绿 &bLv.%Level%\", #怪物的名字，%Level%代表等级替换符\n    \"BukkitEntityType\": \"ZOMBIE\", #怪物类型，有些附属插件可能不支持修改类型，或会报错\n    \"ID\": \"com.relatev.minecraft.TRMExample.TestZombie\", #怪物ID，不建议乱改，ID重合会导致插件冲突\n    \"Mobs\": [], #不要动\n    \"Tasks\": [] #不要动\n  }复制代码\n\nTRMobAPI —— 自定义怪物API\n\nTRMobAPI 是什么？\nTRMobAPI是一套开发者API\n极其简单易用，但拓展性十分强大，可以设计各种怪物\n这套API提供了完整的怪物框架来设计自定义怪物\n另外，本插件官方含有Javadoc\n\n\n\nJavaDoc.zip\n(241 Bytes, 下载次数: 6)\n\n\n\n2019-9-14 14:29 上传\n点击文件名下载附件\n\n\n\n\n\n\n\n建议：如非有特殊需求，建议任何附属插件名字以TR开头\n方便用户在搜索附属插件时容易找到他们想要的附属插件\n\n目录：\n 第一章序言 Description 第二章 创建一只简单的僵尸 TRMob 第三章 设置僵尸的各项属性 TRLevelMob、spawn、Listener 第四章 雷暴僵尸、爆炸弓箭小白BukkitTask 第五章 多重形态、多层血条的怪物 CustomMetadata 第六章 Boss！Boss血条、召唤小怪 TRBossBar、TRMobAPI 第七章设计可配置的怪物TRConfigManager、TRJsonConfigurable 第八章调控另一个附属插件的怪物TRMobSpawnEvent、TRMobManager、TRMobAPI 第⑨章实战训练：凋零风暴\n第二章 —— 创建一只简单的僵尸TRMob\n\nplugin.yml：\n\n然后导入TRMobAPI.jar，这没什么好说的对吧{:4_106:}\n\n然后新建一个类，extends TRMob\n接下来你有两种方式传回TRMob的参数：\n1.public TRMob(String id,String displayname,EntityType entitytype)\n2.public TRMob(String displayname,EntityType entitytype)\n两个你用哪个都一样，更推荐下面的，比较省事\n如果你选择下面的ID会自动生成，ID为类的全名\n\nTestZombie.java:\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRMob;\nimport org.bukkit.entity.EntityType;\n\npublic class TestZombie extends TRMob{\n\n    public TestZombie() {\n        super(\"&a小绿\", EntityType.ZOMBIE);\n    }\n\n}复制代码\n然后你需要叫TRMobAPI去加载这个怪物，使用TRMobManager的loadMob方法去加载它\n主类：\npublic class TRMExample extends JavaPlugin {\n\n    public TestZombie TRTestZombie;\n\n    @Override\n    public void onEnable() {\n        TRTestZombie = new TestZombie();\n        TRMobAPI.getAPI().getTRMobManager().loadMob(TRTestZombie);\n    }\n}复制代码\n把它丢入服务器看看效果吧！{:4_98:}输入/trm list来查看怪物列表，你应该可以看到多了一个自己写的怪物\n\n很好，我们的怪物已经工作了，生成一个试试{:4_115:}\n/trm spawn TestZombie 就可以生成一只你的怪物了\n值得一提的是，trm spawn命令是模糊识别的，输入/trm spawn com.relatev.minecraft.TRExample.TestZombie\n或者/trm spawn testzombie 都会生成这只怪物\n\n\n\n第三章 —— 设置僵尸的各项属性\nTRLevelMob、spawn\nTRMob类从你激活的那一刻起，就自动被注册了监听器\n不需要你自己去注册{:4_119:}\n\nTRLevelMob 是 TRMob 的一个子类，TRMob是没有等级系统的\n但如果你的类继承的是TRLevelMob，那么怪物就有等级了{:4_119:}\n因此把你的\npublic class TestZombie extends TRMob 复制代码改为\npublic class TestZombie extends TRLevelMob复制代码\n\n那么你需要覆写spawn(Location loc,int level)方法\nloc 指的是刷新位置，level 指的是刷新等级\n\n这里以修改初始生命值为例\n    @Override\n    public LivingEntity spawn(Location loc, int level) {\n        Zombie zombie = (Zombie) super.spawn(loc, level);\n        zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(20 + level * 5); //设定怪物出生最大生命值为 20+等级x5\n        zombie.setHealth(zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //让怪物满血\n        return zombie;\n    }复制代码\n修改怪物的伤害也是很简单的：{:4_115:}\n    @EventHandler\n    public void onDamage(EntityDamageByEntityEvent event) {\n        if (super.isThisMob(event.getDamager())) { //如果攻击者是我们设计的怪物\n            Zombie zombie = (Zombie) event.getDamager();\n            event.setDamage(super.getLevel(zombie) * 2D); //设定怪物伤害为 等级x2\n        }\n    }复制代码\n加一点掉落物和经验修改：{:4_101:}\n    @EventHandler(priority = EventPriority.HIGH)\n    public void onDeathDrop(EntityDeathEvent event) {\n        if (super.isThisMob(event.getEntity())) {\n            LivingEntity lent = event.getEntity();\n            event.setDroppedExp(super.getLevel(lent) * 2); //设定怪物掉落经验为 等级x2\n            if (super.getLevel(lent) > 5) {\n                event.getDrops().add(new ItemStack(Material.DIAMOND)); //如果怪物等级超过5 掉一颗钻石\n            }\n        }\n    }复制代码\n\n最终成品如下：{:4_110:}\nTestZombie.java：\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRLevelMob;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.attribute.Attribute;\nimport org.bukkit.entity.EntityType;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.entity.Zombie;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.EventPriority;\nimport org.bukkit.event.entity.EntityDamageByEntityEvent;\nimport org.bukkit.event.entity.EntityDeathEvent;\nimport org.bukkit.inventory.ItemStack;\n\npublic class TestZombie extends TRLevelMob {\n    \n    public TestZombie() {\n        super(\"&a小绿 &bLv.%Level%\", EntityType.ZOMBIE); //%Level%代表着该怪物的等级\n    }\n    \n    @Override\n    public LivingEntity spawn(Location loc, int level) {\n        Zombie zombie = (Zombie) super.spawn(loc, level);\n        zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(20 + level * 5); //设定怪物出生最大生命值为 20+等级x5\n        zombie.setHealth(zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //让怪物满血\n        return zombie;\n    }\n    \n    @EventHandler\n    public void onDamage(EntityDamageByEntityEvent event) {\n        if (super.isThisMob(event.getDamager())) { //如果攻击者是我们设计的怪物\n            Zombie zombie = (Zombie) event.getDamager();\n            event.setDamage(super.getLevel(zombie) * 2D); //设定怪物伤害为 等级x2\n        }\n    }\n    \n    @EventHandler(priority = EventPriority.HIGH)\n    public void onDeathDrop(EntityDeathEvent event) {\n        if (super.isThisMob(event.getEntity())) {\n            LivingEntity lent = event.getEntity();\n            event.setDroppedExp(super.getLevel(lent) * 2); //设定怪物掉落经验为 等级x2\n            if (super.getLevel(lent) > 5) {\n                event.getDrops().add(new ItemStack(Material.DIAMOND)); //如果怪物等级超过5 掉一颗钻石\n            }\n        }\n    }\n}\n复制代码\n\n第四章 —— 雷暴僵尸、爆炸弓箭小白BukkitTask\n嗯，终于到了技能设计环节了~\n\n雷暴僵尸：若目标在5M内，每秒雷击它一次\n\n在创建Task之后，必须使用super.loginBukkitTask(BukkitTask task)传回它\n    public TestZombie() {\n        super(\"&a小绿 &bLv.%Level%\", EntityType.ZOMBIE); //%Level%代表着该怪物的等级\n        super.loginBukkitTask(Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new Runnable(){\n            @Override\n            public void run(){\n                \n            }\n        }, 20, 20));\n    }复制代码你可能问为什么要用loginBukkitTask方法把Task传回去\n这是为了热拔插，动态加载、卸载、重载怪物\n\nsuper.getLivingMobs()\n这个方**返回所有存活中的该类怪物，使用该方法遍历所有存活怪物并进行雷击即可\nTestZombie.java：\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRLevelMob;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.EntityType;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.entity.Zombie;\n\npublic class TestZombie extends TRLevelMob {\n\n    public TestZombie() {\n        super(\"&a雷暴小绿 &bLv.%Level%\", EntityType.ZOMBIE);\n        super.loginBukkitTask(Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new Runnable() {\n            @Override\n            public void run() {\n                for (LivingEntity lent : getLivingMobs()) { //super.getLivingMobs 会返回所有该怪物\n                    Zombie zombie = (Zombie) lent;\n                    LivingEntity target = zombie.getTarget();\n                    if (target != null) {\n                        if (target.getWorld() == zombie.getWorld() && target.getLocation().distance(zombie.getLocation()) < 5) {\n                            zombie.getWorld().strikeLightning(target.getLocation());\n                        }event\n                    }\n                }\n            }\n        }, 20, 20));\n    }\n}\n复制代码\n\n\n嗯，很好，我被雷劈死了{:4_137:}\n\n爆炸弓箭小白：射出的每一发弓箭都会引发一次1.5M的爆炸\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRMob;\nimport org.bukkit.entity.EntityType;\nimport org.bukkit.entity.Projectile;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.entity.ProjectileHitEvent;\nimport org.bukkit.metadata.Metadatable;\n\npublic class TestSkeleton extends TRMob {\n\n    public TestSkeleton() {\n        super(\"§c爆炸弓箭小白\", EntityType.SKELETON);\n    }\n\n    @EventHandler\n    public void onArrowHit(ProjectileHitEvent event) {\n        if (super.isThisMob((Metadatable) event.getEntity().getShooter())) {\n            Projectile proj = event.getEntity();\n            proj.getWorld().createExplosion(proj.getLocation(), 1.5F);\n        }\n    }\n}\n复制代码是不是超级简单，简单就对了，这才是API的意义\n\n\n\n第五章 —— 多重形态、多层血条的怪物CustomMetadata\n想过多重血条没有？几乎市面上所有插件都没这个功能\n但现在它要在你的手上实现了，而且非常简单\n\nTRMobAPI 提供了一套利用Metadata的数据存储系统\n由于封装设计早就做好了，所以不必担心出现冲突或者内存泄漏\nsuper.hasCustomMetadata(String path); #是否存在条目\nsuper.setCustomMetadata(String path,Object value); #设置指定条目的数据\nsuper.getCustomMetadata(String path); #获取指定条目的数据\n为了让效果可以看，我们根据等级给羊羊不同血量：\n    @Override\n    public LivingEntity spawn(Location loc, int level) {\n        Sheep sheep = (Sheep) super.spawn(loc, level);\n        sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(20 + level * 5); //设定怪物出生最大生命值为 20+等级x5\n        sheep.setHealth(sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //让怪物满血\n        return sheep;\n    }复制代码\n\n然后监听EntityDamageEvent，当羊羊受了致命伤的时候进行结算：\n    @EventHandler\n    public void onDamage(EntityDamageEvent event) {\n        if (super.isThisMob(event.getEntity())) {\n            Sheep sheep = (Sheep) event.getEntity();\n            if (sheep.getHealth() <= event.getDamage()) { //如果羊羊受的是致命伤\n\n            }\n        }\n    }复制代码\n\n记得对数据进行初始化：\n                if (super.hasCustomMetadata(sheep, \"DeathCount\") == false) {\n                    super.setCustomMetadata(sheep, \"DeathCount\", 0);\n                }复制代码\n\n计数器代码就可以写完了：\n                super.setCustomMetadata(sheep, \"DeathCount\", super.getCustomMetadata(sheep, \"DeathCount\").asInt() + 1); //计数器 +1\n                if (super.getCustomMetadata(sheep, \"DeathCount\").asInt() < 3) { //如果死亡次数低于3，满血这只羊羊\n                    sheep.getWorld().playEffect(sheep.getLocation(), Effect.POTION_BREAK, 0); //来个复活特效\n                    sheep.setHealth(sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //给羊羊满血\n                }复制代码\n\n\nFeiSheep.java：\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRLevelMob;\nimport org.bukkit.Effect;\nimport org.bukkit.Location;\nimport org.bukkit.attribute.Attribute;\nimport org.bukkit.entity.EntityType;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.entity.Sheep;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.entity.EntityDamageEvent;\n\npublic class FeiSheep extends TRLevelMob {\n\n    public FeiSheep() {\n        super(\"&r&l沸羊羊\", EntityType.SHEEP);\n    }\n    \n    @Override\n    public LivingEntity spawn(Location loc, int level) {\n        Sheep sheep = (Sheep) super.spawn(loc, level);\n        sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).setBaseValue(20 + level * 5); //设定怪物出生最大生命值为 20+等级x5\n        sheep.setHealth(sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //让怪物满血\n        return sheep;\n    }\n\n    @EventHandler\n    public void onDamage(EntityDamageEvent event) {\n        if (super.isThisMob(event.getEntity())) {\n            Sheep sheep = (Sheep) event.getEntity();\n            if (sheep.getHealth() <= event.getDamage()) { //如果羊羊受的是致命伤\n                if (super.hasCustomMetadata(sheep, \"DeathCount\") == false) {\n                    super.setCustomMetadata(sheep, \"DeathCount\", 0);\n                }\n                super.setCustomMetadata(sheep, \"DeathCount\", super.getCustomMetadata(sheep, \"DeathCount\").asInt() + 1); //计数器 +1\n                if (super.getCustomMetadata(sheep, \"DeathCount\").asInt() < 3) { //如果死亡次数低于3，满血这只羊羊\n                    sheep.getWorld().playEffect(sheep.getLocation(), Effect.POTION_BREAK, 0); //来个复活特效\n                    sheep.setHealth(sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue()); //给羊羊满血\n                }\n            }\n        }\n    }\n}\n复制代码\n\n嗯，这只羊本来已经死了，现在它复活了！\n\n\n第六章 —— 巨人僵尸？Boss！TRBossBar、TRMobAPI\n在自己写插件设计BOSS的时候最蛋疼的是什么呢？\n大概是BOSS血条和生成的小怪吧\n很好，TRMobAPI已经解决了这些问题\n你不需要关心这两个棘手的问题了\n\n要给一个怪物搞Boss血条，真的非常简单，\n只需要 implements TRBossBar\npublic class GiantBoss extends TRMob implements TRBossBar复制代码\n它会叫你实现抽象方法 getBossBar(LivingEntity mob)和 getVisableDistance()\n而这个方法返回的BossBar便是玩家看到的，\n你当然可以自己设计一个BossBar，如下    @Override\n    public BossBar getBossBar(Entity ent) {\n        Sheep sheep = (Sheep) ent;\n        BossBar bb = Bukkit.createBossBar(DisplayName + \" &c\" + sheep.getHealth() + \"&r/&a\" + sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue(), BarColor.BLUE, BarStyle.SOLID, new BarFlag[0]);\n        bb.setProgress(sheep.getHealth()/sheep.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue());\n        return bb;\n    }复制代码\n这样的话你也可以给BossBar写各种自己想写的奇奇怪怪的东西\n\n但如果你很懒，TRMobAPI也有现成的：\n    @Override\n    public BossBar getBossBar(Entity ent) {\n        return TRBossBar.getDefaultBossBar(this, (LivingEntity) ent);\n    }复制代码\n而getVisableDistance()指的是BossBar可见距离玩家距离怪物多少距离时显示BossBar，建议32\n    @Override\n    public int getVisableDistance() {\n        return 32;\n    }复制代码\n好了，BossBar就算做完了！\n\n\n召唤小怪：\n依然是先写一个TimerTask：\n    public GiantBoss() {\n        super(\"§a巨人Boss\", EntityType.GIANT);\n        super.loginBukkitTask(Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new Runnable(){\n            @Override\n            public void run(){\n                for(LivingEntity lent:GiantBoss.super.getLivingMobs()){\n                    \n                }\n            }\n        }, 5 * 20, 5 * 20));\n    }复制代码\n还记得主类里的那个TRTestZombie？\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRMobAPI;\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic class TRMExample extends JavaPlugin {\n\n    public static TRMExample MainPlugin;\n    public TestZombie TRTestZombie;\n    public GiantBoss TRGiantBoss;\n\n    @Override\n    public void onEnable() {\n        MainPlugin = this;\n        TRTestZombie = new TestZombie();\n        TRMobAPI.getAPI().getTRMobManager().loadMob(TRTestZombie);\n        \n        TRGiantBoss = new GiantBoss();\n        TRMobAPI.getAPI().getTRMobManager().loadMob(TRGiantBoss);\n    }\n}复制代码\n现在该用到它的时候了：    public GiantBoss() {\n        super(\"§a巨人Boss\", EntityType.GIANT);\n        super.loginBukkitTask(Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new Runnable() {\n            @Override\n            public void run() {\n                for (Entity lent : GiantBoss.super.getLivingMobs()) {\n                    TRMExample.MainPlugin.TRTestZombie.spawn(lent.getLocation(), 5);\n                }\n            }\n        }, 5 * 20, 5 * 20));\n    }复制代码\n\n\n\n这就算完成了，现在每过5秒巨人Boss脚下会刷一个小绿出来\n\n\n值得一提的是，你可能问，如果我要召唤的是隔壁附属插件的怪物怎么办？\n                    trmm.getTRMob(\"com.relatev.minecraft.TRMExample.TestZombie\"); //通过ID获得怪物\n                    trmm.fuzzyRecognizeTRMob(\"TestZombie\"); //模糊识别，不推荐，性能较差\n                    trmm.getTRMob(Entity entity); //通过实体获得TR怪物实例\nGiantBoss.java：\npackage com.relatev.minecraft.TRMExample;\n\nimport com.relatev.minecraft.TRMobAPI.TRBossBar;\nimport com.relatev.minecraft.TRMobAPI.TRMob;\nimport org.bukkit.Bukkit;\nimport org.bukkit.boss.BossBar;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.EntityType;\nimport org.bukkit.entity.LivingEntity;\n\npublic class GiantBoss extends TRMob implements TRBossBar {\n    \n    public GiantBoss() {\n        super(\"§a巨人Boss\", EntityType.GIANT);\n        super.loginBukkitTask(Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new Runnable() {\n            @Override\n            public void run() {\n                for (Entity lent : GiantBoss.super.getLivingMobs()) {\n                    TRMExample.MainPlugin.TRTestZombie.spawn(lent.getLocation(), 5);\n                }\n            }\n        }, 5 * 20, 5 * 20));\n    }\n    \n    @Override\n    public BossBar getBossBar(Entity ent) {\n        return TRBossBar.getDefaultBossBar(this, (LivingEntity) ent);\n    }\n}\n复制代码\n\n\n\n接下来你可以脑洞大开设计更多乱七八糟的技能和特效了\n\n\n第七章 —— 设计可配置的怪物\nTRMobConfig、TRJsonConfigurable\n\n如果你打算把你写的附属插件发布的话，\n那么提供配置文件是至关重要的一部分\n然而很开心的是，TRMob自带了一个超级简单的配置系统\n\n只需要给你的怪物类 implements TRJsonConfigurable\n顾名思义，这是一个由json组成的Config，\npublic class TestZombie extends TRLevelMob implements TRJsonConfigurable{\n\n    public TestZombie() {\n        super(\"&a雷暴小绿 &bLv.%Level%\", EntityType.ZOMBIE);\n    }\n}复制代码你的可配置性就算是完事了，\n配置文件生成在“plugins\\TRMobAPI\\MobConfig”里面\n\n里面大概是这样的\n\n\n比如如果你的怪物类是这样的：\n\npublic class TestZombie extends TRLevelMob implements TRJsonConfigurable{\n\n    private final String hahaha = \"test\";\n    private final Material testmaterial = Material.REDSTONE;\n    \n    public TestZombie() {\n        super(\"&a雷暴小绿 &bLv.%Level%\", EntityType.ZOMBIE);\n    }\n}\n复制代码那么配置文件就多了两行：\n\n很简单吧，任何可配置的部分直接新建一个变量就解决问题了\n\n当然了，如果你想去自己设计配置文件的话，也是可以的\nTRMobAPI.getAPI().getTRConfigManager() 获得TRConfigManager\n下面有一些方法，你可以获取怪物配置文件的位置等信息\n方便你直接操作配置文件...\n\n第八章 —— 调控另一个附属插件的怪物TRMobSpawnEvent、TRMobManager\nTRMobAPI 提供了监听器，\n比如TRMobSpawnOverEvent\n然而很遗憾的是，并不支持Cancelled，只能监听信息和获得实体\n原因在于这是一套API插件，天知道另一个插件的怪物生成的时候\n对怪物做了什么，如果撤销生成就要返回null，很可能会报错\n但你仍然给对其他插件生成的TR怪物进行操作\n不能Cancelled，你可以在生成监听器触发后立即remove掉它\n\n注意！\n原版自带的CreatureSpawnEvent 仍然对TRMobAPI生效\n若你对CreatureSpawnEvent 生成的怪物进行操作，有可能是不会生效的\n因为插件工作机理如下：\nCreatureSpawnEvent --> TRMobAPI --> 附属插件 --> TRMobSpawnOverEvent\n因此如果你用CreatureSpawnEvent 修改了TRMobAPI生成的怪物，\nTRMobAPI随后就会改回去....\nTRMobSpawnOverEvent 监听器会在TRMobAPI怪物生成完毕后才触发\n这样你对怪物的后续修改便会生效了\n\n需求：隔壁附属插件有个怪物ID为 com.relatev.minecraft.TRMExample.TestZombie\n我要对其后续修改，如果它的生成Y高度高于12，则让它只有一滴血\npackage com.relatev.minecraft.TRMExample.listener;\n\nimport com.relatev.minecraft.TRMobAPI.Event.TRMobSpawnOverEvent;\nimport org.bukkit.entity.Zombie;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\n\npublic class TRListener implements Listener {\n\n    @EventHandler\n    public void onTRMobSpawn(TRMobSpawnOverEvent event) {\n        if (event.getTRMob().ID.equals(\"com.relatev.minecraft.TRMExample.TestZombie\") && event.getSpawnLocation().getY() > 12) {\n            Zombie zombie = (Zombie) event.getEntity();\n            zombie.setHealth(1D);\n        }\n    }\n}\n复制代码\n\n\n如何获取隔壁插件的怪物？这没什么难的。。。\n\n需求：隔壁附属插件有个怪物ID为 com.relatev.minecraft.TRMExample.TestZombie\n每5秒为其恢复5点生命值。\npackage com.relatev.minecraft.TRMExample.listener;\n\nimport com.relatev.minecraft.TRMExample.TRMExample;\nimport com.relatev.minecraft.TRMobAPI.TRMobAPI;\nimport org.bukkit.Bukkit;\nimport org.bukkit.attribute.Attribute;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Zombie;\n\npublic class TRTask implements Runnable {\n    \n    public static void init() {\n        Bukkit.getScheduler().runTaskTimer(TRMExample.MainPlugin, new TRTask(), 5 * 20, 5 * 20);\n    }\n    \n    @Override\n    public void run() {\n        for (Entity ent : TRMobAPI.getAPI().getTRMobManager().getTRMob(\"com.relatev.minecraft.TRMExample.TestZombie\").getLivingMobs()) {\n            Zombie zombie = (Zombie) ent;\n            if (zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue() <= zombie.getHealth() + 5) {\n                zombie.setHealth(zombie.getAttribute(Attribute.GENERIC_MAX_HEALTH).getValue());\n            } else {\n                zombie.setHealth(zombie.getHealth() + 5);\n            }\n        }\n    }\n}\n复制代码\n利用这些API，你可以写附属插件来做到第三方技能\n比如你写一个EpicSkill，只需要在配置文件里填入技能开启的怪物名字\n这类怪物就可以拥有技能了，是十分方便的\n\n第八章 —— 实战训练：凋零风暴懒得写了，以后更新",
    "replies": [
        {
            "author": "向文",
            "timestamp": 1568436780,
            "txt_content": "在？ 你也开始搬“资源了”？ps：看我的搬运"
        },
        {
            "author": "玄月月",
            "timestamp": 1568440020,
            "txt_content": "向文 发表于 2019-9-14 12:53\n在？ 你也开始搬“资源了”？ps：看我的搬运\n你说什么呢？"
        },
        {
            "author": "玄月月",
            "timestamp": 1568440080,
            "txt_content": " 本帖最后由 寡姐 于 2019-9-14 13:52 编辑 \n\n不错的api，可以做末日了"
        },
        {
            "author": "拍卖官v",
            "timestamp": 1569220140,
            "txt_content": "不兼容1.7.10吗"
        },
        {
            "author": "贺兰兰",
            "timestamp": 1569608760,
            "txt_content": "这么快就转载了wwwwwww"
        },
        {
            "author": "豪桑丧",
            "timestamp": 1582029420,
            "txt_content": "666666666666666666"
        },
        {
            "author": "1569093281",
            "timestamp": 1582382280,
            "txt_content": "哇这也太强了吧，真的超满意的"
        },
        {
            "author": "蟹蒙老鸽",
            "timestamp": 1582382400,
            "txt_content": "ohhhhhhhhhh看来有点东西呀,先试试看"
        },
        {
            "author": "凉菀彡",
            "timestamp": 1585709400,
            "txt_content": "  这个插件很好~服务器刚好用得上"
        }
    ]
}