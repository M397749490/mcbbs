{
    "title": "[ CBL | 命令进阶 ]第二章 常用命令格式",
    "author": "pca006132",
    "replyCount": 31,
    "timestamp": 1502876580,
    "txt_content": " 本帖最后由 pca006132 于 2017-8-15 22:54 编辑 \n\n-------命令进阶-------\n第二章 常用格式\n\n本文首发于命令进阶教程全集\n使用CC BY-SA-NC 4.0协议，转载请注明本页面链接\n    虽然本文不会详细说明不同的命令，然而本文会详细解释命令常用的格式。\n\n    常用的格式分别有:\nJSON文本定义显示出来的文本，并且提供点击、悬浮等功能命令NBT定义、检测实体及方块实体的属性\n\n\n    其中JSON文本里所介绍的JSON格式在其他游戏文件里也经常使用。\n    至于NBT则是命令里一个相当重要（并且多Bug）的部分。\n作为移植页面，格式可能会有偏差，请到教程全集中获得完整体验。\n本页面可能随着版本推进而过期，内容以全集为准。\n\n\nJSON概观\n\n简介\n什么是JSON？引用术语来说\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript等）。 这些特性使JSON成为理想的数据交换语言\n简单来说\n\nJSON就是一种易于阅读以及交换信息的语言格式\n而Minecraft也看中了JSON这种便于阅读及读取的格式，以JSON格式来定义不同功能。\n这里我们将会介绍JSON文本，这是一个经常用于各种命令的格式。\n\n首先我们需要学习JSON的基本格式。\n\n\n格式\n首先，JSON标准的格式为：\n\n\"<名称>\": <值>复制代码值可以为一个数字（分为整数以及浮点数，浮点数即有小数），布尔值（只有 真(True)和假(False)的数值）等。\n例如：\n\n\"Number\":1\n\"Answer\":true复制代码对字符串（可以理解为普通文字）来说，值需要被双引号括起来，即：\n\n\"<名称>\":\"<值>\"复制代码例如：\n\n\"Name\":\"SYL\"复制代码\n\n如果是描述一个对象(Compound)的话，把内容（属性）书写在花括号 {} 中，以 , 分隔内容。\n例如:\n\n{\"Name\":\"SYL\",\"Gender\":\"Male\"}复制代码其中 Name 和 Gender 就是这个对象的属性。\n这对象表达了名为SYL，性别为男的意思。\n\n\n\n如果是一个集合/数组(Array/List)，那么用 [] 把对象括起来\n例如：\n\n{\"CBL\":[{\"Name\":\"SYL\",\"Gender\":\"Male\"},{\"Name\":\"Woody_Mo\",\"Gender\":\"Male\"}]}复制代码这里描述了名为CBL的对象集合，包含了SYL和Woody_Mo这两个对象。\n\n\n转义\n转义是JSON应用中十分重要的课题。在此我们只会大约说明转义的用法，详细例子将会在之后章节给出例子。\n\n当我们在字符串里使用某些特别的字符，如 \" 字符的时候，情况会变得稍微复杂。举个例子\n\n\"abc\":\"这个JSON的名称为\"abc\"\"复制代码就我们现在所学， \" 字符代表的是字串的开始和结尾啊！这样的话哪个 \" 字符是开始哪个才是结束？\n答案是：没人知道。我们不能这么写JSON的。\n\n如果我们要在字串里填写一些特殊符号，我们需要对它们进行转义(escape)。\n转义即在特殊字符前方加入一个名为转义字符的字符，表示这个字符和原来的意思不同。（当作普通字符处理）。\n在JSON里，转义字符为 \\ ，而需要转义的特殊字符为 \\ 及 \"  （为何转义字符也需要转义？因为它独自出现的时候代表的是转义，而不是一个普通字符。因此当我们需要在文本内使用此字符时需要将其转义。）。\n以上方的例子来说，我们希望abc的数值为 这个JSON的名称为\"abc\" ，因此我们会这么写:\n\n\"abc\":\"这个JSON的名称为\"abc\"\"复制代码如果我们要一个数值为上方这JSON字串的JSON呢？我们需要这么写：\n\n\"foo\":\"\"abc\":\"这个JSON的名称为\\\\\"abc\\\\\"\"\"复制代码注意:\n转义本来是没有\"多重转义\"的概念的。转义是一层一层，每次在 \\ 及 \" 符号前方加入 \\ 字符。\n记住这个最基本的原则可以避免出现错误。\n\nJSON除错\nJSON常见错误有几个：\n\n标签名称忘记加上引号。如 {test:1} 是错的， {\"test\":1} 才是对的。额外的逗号 , 。如 [1,2,3,] 或 {\"test\":1,\"test2\":2,} 。因为 , 代表之后还有东西，记得之后没东西的时候要删掉那个逗号。忘记转义。比如 \"tellraw @a [\"bla\"]\" 这可是错的，得转义成 \"tellraw @a [\\\"bla\\\"]\" 。括号不匹配。比如 {\"a\":{\"test\":\"testing\"} ，这个缺了最后的 } 符号。\n  这个最好的办法是一开始就别错，而输入 { 或 [ 符号时顺便输入 } 或 ] 符号是一个好习惯。错字，如 true 写成 ture 。这样你就没救了（误。\n\nJSON文本\n在MC里面，目前用到JSON文本(Text component)的地方有5个， tellraw 命令， title 命令， 告示牌 ， 成书 以及 advancement 命令，用于记录文字的样式和功能。\n\n比起传统的 say 命令，JSON可以自由编辑样式，甚至提供了交互功能，所以很适合作为信息输出/用户交互界面。\n\n其中最基本的概念是：\n每一段文字被视作为一个文本对象，由 {} 括起来。\n文本对象内可设置属性，决定了文字的内容，样式，功能等等（内容只能设置一种，但可以设置多个其他属性）。\n以下章节将一步步解释JSON文本的格式及在游戏内的应用。\n\n\n\nJSON文本类型\n最基础的JSON文本类型可被分为5类：\n\ntext-文本selector-目标选择器score-分数translate-翻译keybind-显示按钮\n值得注意的是，虽然这五个都是文本对象中的属性，这5类文本类型在单个对象（同一段文字）中只能设置一个。\n不然会互相覆盖，只有一个能生效。\n关于同时使用多个文本类型的情况，我们会在之后的章节进行讨论。\n\n\ntext-文本\ntext可谓是游戏内最基本的类型。\n功能十分简单，就是显示你指定的文字。\n\n最基本的格式为：\n\n\"text\":\"<文本内容>\"复制代码例如：\n\ntellraw @a {\"text\":\"Hello World\"}复制代码\n\n顺带一提，在内容中插入 \\n 可以让文字换行（只限于 成书 和 tellraw 命令）\n\n例如：\n\ntellraw @a {\"text\":\"Hello\\nWorld\"}复制代码\n\n\nselector-目标选择器\nselector的作用就是显示选择器选择到的实体名称，与命令中的选择器格式一致\n\n基本格式为\n\n\"selector\":\"<目标选择器>\"复制代码选择符就如平时使用一般输入就可以了\n例如：\n\ntellraw @a {\"selector\":\"@p\"}复制代码\n\n如果世界内只有我和一只名为GGG的猪：\n\ntellraw @a {\"selector\":\"@e\"}复制代码\n\n值得注意的是，选择器参数（即跟随在选择符后的[]部分）也可使用：\n\ntellraw @a {\"selector\":\"@e[type=Pig]\"}复制代码\n\n注意:\nJSON文本里的选择器，包括接下来的score中name使用的选择器，大部分都是以命令执行位置作为原点。\n如 tellraw 及 title 命令以命令执行点为原点，书本以打开的玩家的位置为原点，只有牌子是以牌子坐标为原点\n\nscore-分数\nscore用于显示特定目标的特定分数，需要对记分板的知识（详见之后的章节）。\n\n格式为：\n\n\"score\":{\"name\":\"<对象名>\",\"objective\":\"<变量名>\"}复制代码对象名 即为需要选中的对象，如指定玩家名称\n分数名 就是来自哪一个记分板变量\n\n例如我们创建了一个名为 test 的记分板变量，里面有两个玩家：\n\n\n输入：\n\ntellraw @a {\"score\":{\"name\":\"Tester\",\"objective\":\"test\"}}复制代码\n\nname 支持选择符（但不能为多选，如 @a ），我们放置了一个命令方块，并让SYL接近他\n\n输入：\n\ntellraw @a {\"score\":{\"name\":\"@p\",\"objective\":\"test\"}}复制代码\n\nscore 在 tellraw 命令中还有一个特殊功能， name 部分输入 * 的话\n那么观察者自己将会作为对象，显示观察者的分数（这在做地图的时候十分有用）\n\n例如：\n\ntellraw @a {\"score\":{\"name\":\"*\",\"objective\":\"test\"}}复制代码SYL的视角：\n\n\nTester的视角：\n\n\n\ntranslate-翻译文件\ntranslate其实就是在文本JSON里引用翻译文件的文字，格式为:\n\n\"translate\":\"翻译识别器\"复制代码如\n\n\"translate\":\"chat.link.warning\"复制代码然而翻译文件的文字可以有参数（那些 %s ），这个时候我们就可以用with来传入参数（顺序对应翻译文件内的 %s ），格式为:\n\n\"with\":[<参数字串列表>]复制代码注意with的参数可以为JSON文本。\n\n如\n\n假设翻译文件中有一行为\ncustom.a=第一个参数: %s，第二个参数: %s\n\nJSON文本为\n{\"translate\":\"custom.a\",\"with\":[\"a\",\"b\"]}\n\n输出则为\n第一个参数: a，第二个参数: b复制代码\n\ntranslate除了能够用作翻译以外，亦能用作检查资源包，如\n\n{\"translate\":\"custom.1\",\"with\":[{\"text\":\"请点击这里\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say 用了自定义的材质包\"}}]}复制代码原版很明显是没有 custom.1 这个翻译识别器的，故此没加载资源包的用户看到的就是 custom.1 ，也没法点击。而地图的自定义资源包则能够添加此翻译识别器，如\n\ncustom.1=%s复制代码然后玩家就能点击 请点击这里 并触发命令了。如果玩家没有使用该资源包，则只能看着 custom.1 在那里干瞪眼了。\n\n\nKeybind-显示按钮\nKeybind就是引用某些特殊按钮，如果玩家修改了的话就显示玩家修改为的按钮。对地图制作十分有用，因为有时候需要让玩家按某个按钮然而玩家可能会修改默认键位。（比如 按F装填 ）\n\n格式:\n\n{\"keybind\":\"<按键>\"}复制代码按键比如是 key.drop ,  key.forward 等等。\n完整的按键列表在这：按键列表\n\n例子:\n\n{\"keybind\":\"key.drop\"}\n{\"keybind\":\"key.forward\"}复制代码注意: 如果没有设置该键位，则会显示为 None \n\n\n知道了如何定义内容后，我们就得为我们的内容搞点新意思了。\n接下来将会介绍如何为文本对象加入颜色、粗体等样式\n\n\n\n样式代码\n样式代码即为帮文字添加样式的代码。\n例如加粗，斜体，颜色等等。\n这些都是文本对象里的属性。\n\n同时，样式代码不像 text / selector / score 并不能重复。\n每个对象都可以使用多个样式代码，以达成多种效果叠加。\n\n\ncolor-颜色\ncolor代码，就是帮文字添加颜色的代码。\n基本格式为：\n\n\"color\":\"<颜色代码>\"复制代码实际使用时，添加在文本类型后方，使用 , 分隔即可。\n所有的样式代码都是如此使用的，可以添加多于一个样式代码。\n\n例如：\n\ntellraw @a {\"text\":\"Hello World\",\"color\":\"dark_blue\"}复制代码\n\n颜色表格\n\n\nbold-加粗\nbold，加粗文字。\n基本格式：\n\n\"bold\":true复制代码如果是后方的数值不为 true 而是 false 的话，文字就不会加粗。\n将样式代码设置为false的用途主要体现在 extra-分项/JSON array 中，后续将有说明。\n\n使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"bold\":true}复制代码\n\n如果是想搭配其他样式代码，如颜色使用的话：\n\ntellraw @a {\"text\":\"Hello World\",\"bold\":true,\"color\":\"dark_red\"}复制代码\n\n请注意，样式代码的先后顺序并无影响。\n其他样式代码同理，不再作示范。\n\n\nitalic-斜体\nitalic，斜体，与bold的使用方式类近\n基本格式：\n\n\"italic\":true复制代码使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"italic\":true}复制代码\n\n\nunderlined-下划线\nunderlined，下划线，与bold的使用方式类近\n基本格式：\n\n\"underlined\":true复制代码使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"underlined\":true}复制代码\n\n\nstrikethrough-删除线\nstrikethrough，删除线，与bold的使用方式类近\n基本格式：\n\n\"strikethrough\":true复制代码使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"strikethrough\":true}复制代码\n\n\nobfuscated-混淆文字\nobfuscated，混淆文字\n\n这个是一个特别的样式代码\n生效条件是文本内容必须为英文\n效果为不断跳动变换的乱码文字\n\n基本格式：\n\n\"obfuscated\":true复制代码使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"obfuscated\":true}复制代码\n\n如果不是英文的话不会起效，例如：\n\ntellraw @a {\"text\":\"世界你好\",\"obfuscated\":true}复制代码\n\n\n\n现在我们懂得为JSON文本加入不同的样式了，那么还有没有别的可以玩玩呢？\nJSON文本除了能看以外，还能与玩家互动，这也是JSON文本一个非常重要的特点。\n接下来的章节我们将会介绍点击及悬浮事件，让JSON文本变得更生动有趣！\n\n\n\n点击事件\nclickEvent 是JSON最重要的功能之一。\n其功能为：点击相关文字的时候执行某些操作。\n提供了一个对输入（点击）产生反馈（action）的功能。\n\n基本格式为：\n\n\"clickEvent\":{\"action\":\"<动作>\",\"value\":\"<值>\"}复制代码将其放置在对象内使用（和样式类似，都是文本对象的一个属性，只是这属性比较复杂而已）\n\n请注意， clickEvent 不适用于标题及 advancement 的description。\n在告示牌的话最多只能设置4个，之后告示牌部分会有讲解。\n\n而每个文本对象只能设置一个点击事件和悬浮事件，继承下来的事件会被覆盖。\n\n advancement 的title的clickEvent只能在聊天栏公告获得进度时点击，不能在进度面板点击\n\nrun_command-运行命令\nrun_command是一个十分常用的动作\n其功能为让点击者执行设定的命令\n基本格式为：\n\n\"clickEvent\":{\"action\":\"run_command\",\"value\":\"<需执行命令>\"}复制代码需执行命令前必须有 / ，就像是直接在聊天栏执行一样。\n\n并且CE（clickevent的简称）可以和样式代码一起使用\n例如：\n\ntellraw @a {\"text\":\"Hello World\",\"color\":\"dark_red\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say hi\"}}复制代码\n\n由于run_command是使点击者执行命令，所以同一个命令由不同人点击，结果也不同\n例如分别由SYL和Tester点击上面的命令：\n\n\n在多人游戏时，需要注意一点，在 tellraw 命令、书本内使用CE时，如果点击者没有OP权限\n那么是无法执行需要OP权限的命令的\n例如 say 无法被普通玩家执行，那么如果在没有OP权限的情况点击文字：\n\n\n如果是在告示牌内使用的话，则带有2级OP权限，所以普通玩家也可以右键告示牌执行命令\n\n\n另一点就是， value 里面的命令长度不能太长\n因为命令是视作在聊天栏输入之后按enter执行的\n所以不能超越聊天栏的输入上限：256个字符\n\n例如我使用以下 /summon 命令：\n（本例子为旧版本例子，当时输入上限为100个字符，所以此命令在新版本中可用，但若超出256个字符的话依旧会出现问题）\n\ntellraw @a {\"text\":\"Hello World\",\"color\":\"dark_red\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/summon minecraft:creeper ~ ~ ~ {powered:1,ExplosionRadius:5,Attributes:[{Name:generic.movementSpeed,Base:0}],ActiveEffects:[{Ambient:1,Amplifier:0,Duration:999999999,Id:11}]}\"}}复制代码\n\n由于超过了长度上限，实际输入部分到逗号就终结了，命令并未完整，自然无法成功执行\n\n如果是在告示牌内使用的话，则没有这个长度限制\n\nsuggest_command-建议命令\nsuggest_command ，建议命令\n其功能为点击时，将点击者输入栏中的内容替换为 value 中设定的内容\n\n格式\n\n\"clickEvent\":{\"action\":\"suggest_command\",\"value\":\"<值>\"}复制代码例如：\n\ntellraw @a {\"text\":\"Hello World\",\"clickEvent\":{\"action\":\"suggest_command\",\"value\":\"hi\"}}复制代码\n\n\nopen_url-打开链接\nopen_url，打开链接（一般是叫浏览器打开的，然而打开前会有一段警告询问玩家是否要打开未知链接）\n\n基本格式为：\n\n\"clickEvent\":{\"action\":\"open_url\",\"value\":\"<值>\"}复制代码值的部分必须填一个以 http:// 或 https:// 开头的网址\n按下去，系统就会询问是否打开网页，同意以后就会打开浏览器跳转至页面\n例子:\n\ntellraw @a {\"text\":\"Hello World\",\"clickEvent\":{\"action\":\"open_url\",\"value\":\"http://www.google.com\"}}复制代码\n\n\n\n\n\n\nchange_page-换页\n此CE为成书专用的CE\n成书的格式容后讲解\n\n基本格式为：\n\n\"clickEvent\":{\"action\":\"change_page\",\"value\":\"<值>\"}复制代码值 就是要跳到的页数\n例如：（成书的格式请参阅后面相关篇章）\n\ngive @a minecraft:written_book 1 0 {title:\"\",author:\"\",pages:[\"{\"text\":\"Page 2\",\"clickEvent\":{\"action\":\"change_page\",\"value\":\"2\"}}\",\"{\"text\":\"The second page.\"}\"]}复制代码\n\n按下以后：\n\n\n\n悬浮事件\nhoverevent 是JSON的另一个实用功能\n类似CE，HE也是一个反馈机制，不过这次是对鼠标移上文字时，这个动作进行反馈\n简单来说就是鼠标移上去文字，会有个悬浮框显示一些信息\n\n基本格式为：\n\n\"hoverEvent\":{\"action\":\"<动作>\",\"value\":\"<值>\"}复制代码 hoverevent 不适用于标题、 advancement 和告示牌\n\nshow_text-显示文本\nshow_text，显示文本\n功能自然为显示文字\n\n基本格式为：\n\n\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"<值>\"}复制代码或\n\n\"hoverEvent\":{\"action\":\"show_text\",\"value\":{JSON文本}}复制代码前者使用上比较方便简单，但不支持如样式等设定\n使用例子：\n\ntellraw @a {\"text\":\"Hello World\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"hello again\"}}复制代码\n\n后者需求完整的JSON文本，但支援如样式代码等功能\n例子：\n\ntellraw @a {\"text\":\"Hello World\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":{\"text\":\"hello again\",\"color\":\"gold\"}}}复制代码\n\n甚至是其他的JSON结构，例如：\n\ntellraw @a {\"text\":\"Hello World\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":{\"score\":{\"name\":\"SYL_qiuyifeng\",\"objective\":\"test\"},\"color\":\"gold\"}}}复制代码\n\n\n\n\nshow_item-显示物品\n显示物品，可以显示一个物品的信息\n其效果与在背包内查看物品信息一致\n\n格式为：\n\n\"hoverEvent\":{\"action\":\"show_item\",\"value\":\"<物品NBT标签>\"}复制代码物品标签请参考之后的NBT教程\n例子：（关于\\\"，即转义的内容，请参阅相应章节）\n\ntellraw @a {\"text\":\"Hello World\",\"hoverEvent\":{\"action\":\"show_item\",\"value\":\"{id:\"minecraft:iron_pickaxe\"}\"}}复制代码\n\n 例子二：\n\ntellraw @a {\"text\":\"Hello World\",\"hoverEvent\":{\"action\":\"show_item\",\"value\":\"{id:\"minecraft:iron_pickaxe\",tag:{display:{Lore:[\"keep digging\"]}}}\"}}复制代码\n\n\nshow_entity-显示实体\nshow_entity，显示生物\n此功能必须在玩家使用了F3+H打开了附加信息显示后才能运作\n\n这个功能提供的显示，和运行命令 /say @e 或其他类似命令后\n将鼠标移上去实体名称后显示的实体信息一致\n效果如下：\n\n\n基本格式为：\n\n\"hoverEvent\":{\"action\":\"show_entity\",\"value\":\"{name:\"<名称>\",type:\"<生物ID>\",id:\"<UUID/文本>\"}\"}复制代码其中 name 就是最上面显示的名字\ntype 就是生物id\nid 呢，原意是用于显示 UUID 的，但也可用作一般文本显示\n\n例如：\n\ntellraw @a {\"text\":\"Pig\",\"hoverEvent\":{\"action\":\"show_entity\",\"value\":{\"type\":\"Pig\",\"name\":\"Bacon\",\"id\":\"Walking Bacon\"}}}复制代码\n\n\ninsertion-插入\ninsertion是一个单独的属性\n其格式为：\n\n\"insertion\":\"<值>\"复制代码其功能为，shift+点击该JSON文本后，在聊天栏输入插入 值 的内容\n和 suggest_command 不同，此操作并不会覆盖已有输入\n而是在输入的最后添加\n\n例子：\n\ntellraw @a {\"text\":\"Hello World\",\"insertion\":\"|after click\"}复制代码\n\nbefore click 是已经输入的内容， |after click 是点击后插入的内容\n\n\n\n即使知道了那么多的功能，如果JSON文本只能做到单一颜色，单一功能，还是比较单调啊。\n不用怕！我们可以进行分项处理，一次过显示多个文本对象，显示不同的样式、类型以及事件。\n接下来将会讲解JSON分项处理。\n\n\n\n分项与数组\nextra-分项 以及 JSON array-JSON数组 提供了让多个不同的文本对象同时存在的可能性\n例如想让一条 tellraw 命令中使用多个不同样式的文本对象，或者是组合多个JSON结构时使用\n\n同时它们在告示牌和成书之中也有重要的角色\n并且继承的特性有时能让一些样式上的设定变得方便\n\n\n基础\nextra-分项是一个附加在JSON文本中的数组对象\n其格式为\n\nextra:[{<JSON文本1>},{<JSON文本2>},......]复制代码JSON文本1、JSON文本2...等等的文本对象会被放在当前对象之后。\n\n\n\n而JSON array则是由 [] 包围的JSON文本，在需求JSON文本的命令/NBT中，可以直接使用 [] 输入一个JSON数组，取代使用 {} 来输入单一对象\n\n使用一个简单的例子：\n\ntellraw @a {\"text\":\"Hello World\"}复制代码\n\n最基础的一条 tellraw 命令也可以分别以 extra 和 array 的形式重写\narray:\n\ntellraw @a [{\"text\":\"Hello\"},{\"text\":\" World\"}]复制代码或者\n\ntellraw @a [\"Hello\",\" World\"]复制代码（在array中，可以用双引号直接取代简单的 text 对象，可以和完整的JSON文本混合使用）\n\n\n\nextra:\n\ntellraw @a {\"text\":\"Hello\",\"extra\":[{\"text\":\" World\"}]}复制代码\n\n三者效果是完全一样的\n\n\n\nextra内也可以添加多个JSON文本\n\n例如：\n\ntellraw @a {\"text\":\"Hello\",\"extra\":[{\"text\":\" Minecraft\"},{\"text\":\" World\"}]}复制代码\n\n\n\n不过由于 extra 和 array 的效果和特性基本一致，出于 array 比 extra 使用上方便一点，以及格式上比较方便阅读和美观，个人推荐尽量使用 array 。\n\n然而在进度里，文件只能够使用Compound，因此只能使用extra。\n\n应用\nextra及array最大的应用，就是可以分别设置每一个JSON文本的属性\n例如：\narray:\n\ntellraw @a [{\"text\":\"Hello\",\"color\":\"red\"},{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"color\":\"blue\"}]复制代码extra:\n\ntellraw @a {\"text\":\"Hello\",\"color\":\"red\",\"extra\":[{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"color\":\"blue\"}]}复制代码\n\n不仅仅是颜色之类的样式代码，还可以是CE(clickEvent)和HE(hoverEvent)\n\n例如：\narray:\n\ntellraw @a [{\"text\":\"Hello\",\"color\":\"red\"},{\"text\":\" Minecraft\",\"color\":\"green\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say Minecraft\"}},{\"text\":\" World\",\"color\":\"blue\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"World\"}}]复制代码extra:\n\ntellraw @a {\"text\":\"Hello\",\"color\":\"red\",\"extra\":[{\"text\":\" Minecraft\",\"color\":\"green\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say Minecraft\"}},{\"text\":\" World\",\"color\":\"blue\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"World\"}}]}复制代码由于命令比较长，下面将会把命令分解出来说明\n\n这条 /tellraw 命令分别有3个JSON文本：\n\n第一个JSON文本（array内首个对象，或者是带有extra列表的那个对象），我们可称之为主项：\n\n{\"text\":\"Hello\",\"color\":red}复制代码其设定为红色的\"Hello\"第二个对象：\n\n{\"text\":\" Minecraft\",\"color\":\"green\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say Minecraft\"}}复制代码其设定为绿色的\" Minecraft\"，点击执行/say Minecraft第三个对象：\n\n{\"text\":\" World\",\"color\":\"blue\",\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"World\"}}复制代码其设定为蓝色的\" World\"，悬浮时显示\"World\"\n效果就会是：\n\n\n\n\n不仅如此，它们还可以设置不同结构的JSON（例如组合text,score和selector）\n\n例如：\narray:\n\ntellraw @a [{\"text\":\"Nearest Player:\"},{\"selector\":\"@p\"}]复制代码extra:\n\ntellraw @a {\"text\":\"Nearest Player:\",\"extra\":[{\"selector\":\"@p\"}]}复制代码这里有两个对象：\n\n主项的文本:\"Nearest Player:\"和第二项的 @p 选择符\n效果就是：\n\n\n\n继承\nextra 和 array 都拥有继承的特性\n所有 分项 （array里面首个之后的对象/extra列表里面的所有对象）都会继承到 主项 （array里面首个对象/带有extra列表的那个对象）的设定\n\n举个例子帮助理解：\narray:\n\ntellraw @a [{\"text\":\"Hello\",\"bold\":true},{\"text\":\" World\"}]复制代码extra:\n\ntellraw @a {\"text\":\"Hello\",\"bold\":true,\"extra\":[{\"text\":\" World\"}]}复制代码\n\n在本例中，只有主项设置了 bold 属性，但是由于继承的特性，分项也同时拥有了粗体的样式\n\n但是反之，分项的设定并不会影响主项，例如：\narray:\n\ntellraw @a [{\"text\":\"Hello\"},{\"text\":\" World\",\"bold\":true}]复制代码extra:\n\ntellraw @a {\"text\":\"Hello\",\"bold\":true,\"extra\":[{\"text\":\" World\",\"bold\":true}]}复制代码\n\n同时，分项之间并不会互相影响，并且继承而来的属性可以被覆盖\n例如:\narray:\n\ntellraw @a [{\"text\":\"Hello\",\"bold\":true},{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"bold\":false}]复制代码extra:\n\ntellraw @a {\"text\":\"Hello\",\"bold\":true,\"extra\":[{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"bold\":false}]}复制代码\n\n详细分析一下以上的命令，以上的 /tellraw 拥有三个对象\n\n主项为\"Hello\"，拥有 bold 属性第二项\" Minecraft\"，继承了 bold 属性，并且设定了颜色为绿色第三项\" World\"，虽然应该继承主项的 bold 属性，但是 bold:false 设定覆盖了继承而来的属性，同时也不受第二项的颜色属性影响\n虽然本节没有使用CE/HE作为例子，但它们也是可以如同 样式代码 一样被继承的，规则相同。但如果子对象也有设置CE/HE，继承下来的事件会被取代。\n\n\n\n如果有时需要设定一段格式差异较大的JSON文本，例如只想将第一段文字设定为粗体，其他都不要，那么后面的文本是不是都要设定 bold:false 这么麻烦？\n\n一个方便的做法为，将主项设置为空项，例如：\narray:\n\ntellraw @a [\"\",{\"text\":\"Hello\",\"bold\":true},{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"italic\":true}]复制代码extra:\n\ntellraw @a {\"text\":\"\",\"extra\":[{\"text\":\"Hello\",\"bold\":true},{\"text\":\" Minecraft\",\"color\":\"green\"},{\"text\":\" World\",\"italic\":true}]}复制代码\n\n这样即可确保每一个JSON文本的独立性，减少互相干扰\n\n\n\n告示牌\n告示牌 支持使用JSON文本定义上面的文字，并且有三种指令可以自定义告示牌，分别为 give 命令（获得物品形式的 告示牌 ）, setblock 命令（直接放置）,和 blockdata 命令（修改已有 告示牌 ）\n\n格式分别为：\n\ngive @p sign 1 0 {BlockEntityTag:{NBT}}复制代码setblock [x] [y] [z] minecraft:standing_sign/minecraft:wall_sign [数据值] [旧方块处理方式] {NBT}复制代码blockdata [x] [y] [z] {NBT}复制代码其中 告示牌 的 NBT 格式如下：\n\n{Text1:\"{JSON文本}\",Text2:\"{JSON文本}\",Text3:\"{JSON文本}\",Text4:\"{JSON文本}\"}复制代码Text1/2/3/4 分别代表牌子的每一行的内容（在使用 entitydata 命令时，如果相关行内容不需编辑，可以不写相关行数的NBT）。\n\n请注意，由于 Text1/2/3/4 本身不是文本对象，而是 NBT ，所以无需使用双引号包围，并且由于JSON文本被双引号包围，请注意里面引号需要转义。\n\n例子：\n\nblockdata ~ ~1 ~ {Text1:\"{\"text\":\"Hello World\",\"bold\":true,\"color\":\"dark_green\"}\",Text2:\"{\"selector\":\"@p\"}\"}复制代码\n\n如需在同一行内使用多于一个文本对象，请使用 JSON array 或 extra \n例子：\n\nblockdata ~ ~1 ~ {Text1:\"[\"\",{\"text\":\"Hello\",\"color\":\"green\"},{\"text\":\" World\",\"color\":\"red\"}]\"}复制代码\n\n\n\n最后是CE在牌子的应用\n牌子的每一行都可以设置一个CE，即一个牌子最多可设置4个CE\n但每一行的CE只能设置在主项，设置在分项的CE是无效的\n\n例如：\n\nblockdata ~ ~1 ~ {Text1:\"{\"text\":\"say 1\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say 1\"}}\",Text2:\"{\"text\":\"say 2\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say 2\"}}\"}复制代码\n\n\n\n值得注意的事项是\n玩家右键点击牌子时执行命令，命令的执行坐标以牌子所处位置为起始点 （情况类似与 /execute <点击者> <告示牌坐标> <命令> ）\n\n所以当涉及到选择符的命令，例如/say @e[c=2] ，这个命令将会以牌子为选择实体的起始点，这个情况下会选中距离牌子最近的两个实体而同样的，使用了相对坐标，例如/setblock ~ ~ ~ minecraft:stone，则会以牌子作为相对坐标的起始点，这个情况下会将牌子替换为石头特别注意， c=1 这个选择器参数有特别处理，该参数无论如何都会选中点击者，如/say @e[c=1] 必定会选中点击者，不管中间有多少实体距离 告示牌 比点击者更近\n亦请注意，于1.12以后的版本，由于NBT语法分析器的改动，若需要在牌子中使用 unicode-万国码 ，即 \\u ，需要对其反斜杠进行转义，即写成 \\\\u 的形式\n\n如果是Setblock的话，需要指明Text1-Text4的JSON。\n不过，如果那行是空的话，可以写 null 。\n例子:  Text4:null \n\n成书\n成书亦支持使用JSON文本定义书本的内容，获得方式只有一个，使用 /give 命令\n\n格式为：\n\ngive @p written_book <数量> 0 {pages:[\"{JSON文本}\",\"{JSON文本}\",......],title:\"<成书名称>\",author:\"<作者>\"}复制代码数量 ， 成书名称 和 作者 不多作解释，而!(list)\npages 这个NBT 里面的每一个JSON文本都代表一页的内容\n例如：\n\ngive @p written_book 1 0 {pages:[\"{\"text\":\"page 1\"}\",\"{\"text\":\"page 2\"}\"],title:\"Book\",author:\"SYL\"}复制代码\n\n\n\n\n\n如需在一页内使用多个文本对象，自然需要使用 JSON array \n并且 成书 也支援CE和HE\n例如：\n\ngive @p written_book 1 0 {pages:[\"[\"\",{\"text\":\"say hi\",\"underlined\":true,\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say hi\"}},{\"text\":\"\\nhello\",\"bold\":true,\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"world\"}}]\"],title:\"Book\",author:\"SYL\"}复制代码分解以上命令说明\n\n主项为 \\\"\\\" ，即空白的主项第二项为\"say hi\"，点击后让玩家执行 /say hi第三项为\"\\nhello\"，悬浮在文字上显示 world需要注意的是，第三项内容前有 \\n 换行符，所以它将在第二行显示\n最终效果为：\n\n\n点击say hi\n\n\n请注意，于1.12以后的版本，由于NBT语法分析器的改动，若需要在牌子中使用 unicode-万国码 或 换行符 ，即 \\u 和 \\n ，需要对其反斜杠进行转义，即写成 \\\\u 以及 \\\\n 的形式\n\n以上命令若需在1.12后使用，请使用以下版本：\n\ngive @p written_book 1 0 {pages:[\"[\"\",{\"text\":\"say hi\",\"underlined\":true,\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/say hi\"}},{\"text\":\"\\\\nhello\",\"bold\":true,\"hoverEvent\":{\"action\":\"show_text\",\"value\":\"world\"}}]\"],title:\"Book\",author:\"SYL\"}复制代码\n\n\n杂项\n本部分将收纳应用方面的补充说明，他们可能是难以归纳进以上架构或者是平日甚少使用，所以收纳于此部分\n\n\nunicode-万国码\nJSON支援显示Unicode，格式为：\n\\u#### \n\n#### 就是4个位的Unicode代码，具体请参考Unicode代码的网页\n不过MC字库并不保证所有的Unicode都能正常显示\n\n使用例子：\n\ntellraw @a {\"text\":\"\\u2622\"}复制代码\n\ntellraw @a {\"text\":\"\\u2622\\u269B\"}复制代码\n\n\n转义\n这里是接着首章的例子。\n\n比如需要输出 \"Hello World\" ，我使用了以下命令：\n\ntellraw @a {\"text\":\"\"Hello World\"\"}复制代码但由于配对的问题，标识 值 部分的引号和内容所需的引号配对了，系统无法正确识别命令，导致无法执行\nJSON规定的转义方式为，将 \" 转为 \\\" ,将 \\ 转为 \\\\ \n正确的命令为：\n\ntellraw @a {\"text\":\"\"Hello World\"\"}复制代码\n\n这样我们便能告知系统， \"Hello World\" 的引号和包围 值 的引号如何正确配对\n\n\n\n然后是需要更多转义的例子\n例如我们需要修改以下命令：\n\ntellraw @a {\"text\":\"Hello World\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/tellraw @a {\"text\":\"Hello World\"}\"}}复制代码这是一个包含了CE的 /tellraw ，点击会再次输出 Hello World \n如果我们需要修改成输出 \"Hello World\" ，我们便需要在已经转义一次的引号内再加入一对引号\n按照正确的转义方式，命令将修改为：\n\ntellraw @a {\"text\":\"Hello World\",\"clickEvent\":{\"action\":\"run_command\",\"value\":\"/tellraw @a {\"text\":\"\\\\\"Hello World\\\\\"\"}\"}}复制代码\n\n需要注意，因为第二次转义， \\ 也需要被转义，所以正确的写法为 \\\\\\\" 而非 \\\\\" ，三次转义为 \\\\\\\\\\\\\\\" ，如此类推\n\n\n\n最后需要提醒的一点是，并非一见到引号内的引号就需要额外转义多一次\n而是需要小心分辨他们是否处于同一层次\n例如我要输出 \"\"Hello World\"\" \n使用：\n\ntellraw @a {\"text\":\"\"\\\\\"Hello World\\\\\"\"\"}复制代码\n\n将会造成错误的输出\n\n正确的写法应为：\n\ntellraw @a {\"text\":\"\"\"Hello World\"\"\"}复制代码\n\n\n与资源包的配合\n有些地图把部分不常用的文字改为图片（没错，Minecraft里的文字是图片来的），然后用JSON来做到在聊天栏打印合成配方的特技。\n当然，这需要牺牲，就是玩家如果输入那些字符就会变为物品。不过只要用生僻字的话一般还是没有问题的。\n\n\n\nkey.forward: 移动按钮(向前）key.left: 移动按钮(向左）key.right: 移动按钮(向右)key.back: 移动按钮(向后）key.sneak: 潜行按钮key.sprint: 疾行按钮key.inventory: 打开背包key.swapHands: 交换手（把物品在主手及副手之间交换）key.drop: 掉落物品key.use: 使用物品（一般为右键）key.attack: 使用物品（攻击）key.pickItem: 选择物品（滚轮）key.chat: 打开聊天栏(t)key.playerlist: 列出玩家(Tab)key.command: 输入命令(/)key.screenshot: 截图(F2)key.togglePerspective: 调换镜头位置(f5)key.smoothCamera: 平滑镜头（f8）key.fullscreen: 全屏key.spectatorOutlines: 旁观者高亮，旁观者模式时点击此按键就会高亮所有玩家（默认没有按键）key.hotbar.[1-9]: 选择热键（1-9）key.saveToolbarActivator: 储存工具栏key.loadToolbarActivator: 加载工具栏\n\n\n\n\nNBT\n\n前言（？）\nNBT（二进制命名标签）格式为Minecraft中用于向文件中存储数据的一种存储格式。\nNBT格式以树形结构并配以许多标签的形式存储数据。所有的标签都有一个独立的ID和名称。\n...\n等等！ 我们不是在说命令么？怎么跑了去编程了？教练我不要学这个！\n\n其实NBT有两个意思：NBT文件格式以及命令中的NBT格式，两者表达方式是不同的，然而内里的数据是相同的。\n本文只会介绍命令中的NBT的表达方式，对NBT文件格式（二进制的）有兴趣的朋友可以参考 http://wiki.vg/NBT\n\n同时，部分标签的修改不能通过游戏内命令达成，需要使用外置修改器修改存档中的部分NBT文件，在此推荐 NBTExplorer 这个外置修改器\n\n下载地址:\nhttp://www.mcbbs.net/thread-306895-1-1.html\n\nNBT文件储存了很多重要资料，如存档资料、实体资料、方块资料等。\n通过命令中的NBT，我们能够修改并检查实体（玩家除外）、物品、方块实体的属性，也能检查玩家的部分属性。\n看完本章，你不会知道NBT的完整格式，然而你会知道最好的写法，最不容易出现错误的写法。\n\nNBT简介\nNBT和JSON类似，是由标签(Tag)组成的。而每个标签都有它们的数值。\n\n标签有不同的种类，我们可以大致分为四大类（前三类可以当作基本数值类(simple)）：\n\n数值类（详细分类会包括整数和浮点数，里面又可以根据不同的大小、精度再分类）字串类（没错，字串是自成一类的）数组类（虽然数组也能包括多个数值，然而其特性和List有明显不同，之后将会详细解释，但并不常用）集合类（包括compound及list，将会在下方详述）\n  集合类的数值为一个集合，也就是说能够储存另外的一些标签在里面\n  故此，NBT的结构是一个树结构\nTag_End算不算一个Tag....我觉得那比较算是Tag_Compound的格式之一（二进制的时候）,\n而且那只会在NBT文件里使用，因此就不需要理会了。\n接下来我们会看看NBT的大致结构，基本数值类的标签将会在之后的章节逐一说明。\n\n\n集合\nNBT前三者只是简单的数值类，不能储存更多标签，因此对整体结构没啥影响。\n这里就统一把它们的类型写作simple，方便阅读。\n集合类的NBT有两种，分别为Compound以及List，它们在资料储存方式和实际应用也有很大分别。\n我们首先来看看Compound\n\n\nCompound\nCompound，其实和JSON的物件非常类似。\nCompound里的每个标签都有一个名字(key)，里面的标签类型不必一样。\nCompound里的标签名字非常重要，因为游戏依靠标签名字查找资料。\n故此，一个Compound内的标签不能重名。\n\n技术说明到此为止，我们来看看一个例子。\n\n说例子前先说说这章例子的格式\n标签:  种类 名称: 数值 \n种类有: simple, compound, list\n格式为\"某\"的就是字串，和数值不同\ncompound和list的子标签会缩排（对齐缩进），以与其他标签分开\ncompound a:\n    simple aa: 123\n    simple ab: 456\n    simple ac: \"23333\"\n\n    compound ad:\n        simple aa: 123\n        simple ab: 456\n        simple ac: \"23333\"复制代码可以看到，a这个compound里同时有数字、字串及另一个compound。\n\n然而在ad里，出现了和compound a里重名的标签！这不是违反了我们上面说的“一个Compound内的标签不能重名”？\n其实这不算重名，因为在a里叫aa的只有1个，另一个在a的ad里，分属于不同的compound。\n\n\n\n那么我们来看看下一个例子\n\ncompound a:\n    simple aa: 123456\n    simple aa: 1234复制代码这个例子就有错误了！\na里有两个aa，所以我们指定a的aa是要数值为123456的呢，还是1234那个？没人知道。\n\n所以重复名称是不允许的。\n\n此外，Compound是不注重次序的（同一Compound内的子标签是没有前后次序之分的）\n对Compound来说最重要的是结构，也就是谁是谁的子标签\n故此，在命令里不需要理会Compound的子标签次序，只需要理会结构就好。\n\n格式\n现在来让我们看看命令里是怎么写Compound的。\n\nCompound的数值格式为：\n\n{ 子标签 }复制代码子标签需要名字，并且以 , 分隔。\n\n而子标签需要名字，名字是这么写的：\n\n名字:数值\n或\n\"名字\":数值复制代码当名字包含不是 a-z A-Z 0-9 _ . 的字符时就需要用 \"\" 了（出现空格的话也需要），如果出现 \\ 或 \" 字符则需要转义，详见之后的字串章节（正常人也不会在名字里加入这奇奇怪怪的东西吧233333）。\n\n注：数值前后及名字前后（如果名字需要 \"\" 则 \"名字\" ）的空格都会被忽略\n\n\n例子（把例子1的格式转为命令里的NBT写法）:\n\na:{aa:123,ab:456,ac:\"23333\",ad:{aa:123,ab:456,ac:\"23333\"}}复制代码假设把第一个 ab 的名称改为 a b ，我们就得这么写了:\n\na:{aa:123,\"a b\":456,ac:\"23333\",ad:{aa:123,ab:456,ac:\"23333\"}}复制代码记得开了 { 就得关掉 } 。\n修改NBT时只会修改指定了的NBT，不会清空整个Compound。\n检测亦如是，只会检测指定NBT。比如检查 {} 只能检查此compound是否存在，不能检查是否一个空的compound。\n更多的例子将会在之后的NBT命令实战一章介绍。\n\nList\nList就是一个列表，和Compound类似，也能储存多个tag，然而也有很大的分别。\n\n一旦被命令修改，之前的List就会被清空。（特例会在实战部分讲解）子标签没有名字，并且重视次序。每个List只能储存一种标签。比如储存List，储存字串，储存Compound等等。（但里面的List可以储存不同种类的子标签，只要确保同一个List内的标签全部类型一致即可）\n一般提及List的时候，我们也会提及这List储存的类型，说法是 List of <类型> （中文就是 <类型>的列表 ）\n\n例子:\n\ncompound a:\n    <List of simple> b:\n        simple : 123\n        simple : 456\n        simple : 123复制代码\n\n错误例子:\n\ncompound a:\n    <List of simple> b:\n        simple a: 123\n        compound b:\n            simple a: 123复制代码错误的原因有两个:\n\nList里的子标签应该是没有名字的。List里的子标签应该是同一类型的。（甚至即使它们都是基本类型也不行，需要类型完全一样，之后将会介绍基本类型的分类）\n\n格式\n现在来让我们看看命令里是怎么写List的。\n\n数值格式:\n\n[ 子标签 ]复制代码子标签没有名字，之间以 , 分隔。\n\n例子1\n\na:{b:[123,456,123]}复制代码例子2\n\n{a:[{a:123},{a:456},{a:789}]}复制代码例子2外面那个无名的Compound在实际命令非常常见。\n检测的时候不会循序检测，只会看看目标列表里有没有这几个标签，不论次序。\n简单来说就是你无法控制次序\n\n设置为 [] 会直接清空列表。\n直接检查 [] 会检查该列表是否一个空的列表。\n\n之后的NBT命令实战一章将会有更多例子。\n\n\n下一个章节将会仔细将基本数值里面的数值类型。\n数值类型在MC里大量使用，NBT里最多的也是数值类型。\n数值类型有一些比较方便的写法，然而某些情况会失效，因此我们不会介绍那写法，而是介绍标准写法。如果需要学习便捷写法的话请自行寻找相关教程。\n\n\n\n基本类型\n\n数字类型\nNBT把数字分为两大种，分别为整数及浮点数，然后再细分为不同储存大小、精度的种类。\n\n整数\nByte （数值范围为 -128 到 127 ）Short （数值范围为 -32,768 到 32,767 )Int （数值范围为 -2,147,483,648 到 2,147,483,647）Long (数值范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807)\n浮点数（类似科学计数法，能储存小数及很大的数值，然而精度有限，数值越小精度越高，反之亦然）\nFloat （精度较低）Double （精度较高）\n\n\n整数格式\n<数值><后缀>复制代码数值部分必须为纯数字或纯数字且前方有个 + / - 号。\n纯数字不能以0开头，也就是不能有前导零(Leading zeros)，除非那个数字就是0。\n\n类型后缀（大小写皆可）BytebShortsInt无后缀Longl例子: (前方为+的就是正确，-的就是错误)\n\n+ 123b\n+ 123B\n+ 123\n+ -123b\n+ 0\n+ +0\n+ -0\n\n- 0123b\n（前导零）\n- 00\n（前导零）\n- +-123\n（只能出现一个`+`/`-`号）\n- 1e3\n（不支持科学记数法）\n- 133b\n（超出范围）复制代码命令NBT更改NBT时能够做自动类型变换，只要数值没有超出范围就可以\n然而建议全部都写上类型后缀，因为类型变换有时候可能会出问题，而且检测的时候也必须加上类型后缀\n\n布尔值\n布尔值是整数格式的一个特殊情况，只储存1 (True)及 0 (False)值。\n布尔值使用 Byte储存，比如是  NoAI:1b 、 IsBaby:0b 这类。\n由于其实根本就是byte，所以一般也不会特别介绍。\n\n\n浮点数格式\n<数值><后缀>复制代码数值部分可以是\n\n整数，可以有前导零小数，可以有前导零科学记数法，如 1.23e123 或 1.23e-123 \n格式就是 <数值1>e<数值2> ，数值就是 <数值1>*10^<数值2>\n类型后缀（大小写皆可）FloatfDoubled例子\n\n123f\n123d\n1.23e2f\n1.23e2d\n-1.23e-2d\n1.23e-2d复制代码注意，浮点数的数值不太准确，一般到4个位就差不多了\n别试图检查浮点数的NBT了...检查不了 的\n\n字串类型\n字串(String)类型，顾名思义就是储存字串（文字）的类型。\n\n数据并不总全是数字，比如物品的名称。为了方便使用，NBT里有字符类型可以储存字符。\n\n格式：\n\n字符\n或\n\"字符\"复制代码当字符出现了不属于 a-z A-Z 0-9 _ . （空格、中文字符也是不属于这些字符）里的字符，就需要使用第二个格式，也就是以 \"\" 括住，表示这是一个完整的字串。\n或者当该字符可能被当作是其他类型的时候（如纯数字或数字结尾为 bsldf 等字符（大小写皆可）），也需要使用第二个格式。\n\n如同Compound子标签的名字一样（Compound子标签的名字其实就是一个字串类型），当字串里出现了 \\ 或 \" 字符时就需要将这两个字符进行转义，方式为在字符前方加上 \\ 号。转义方式可以参见之前JSON的介绍，大致一样。\n\n例子:\n\nNBT表示实际显示 abcd abcd \"abcd\" abcd \"123\" 123 123 这个不是字符串 \"ab cd\" ab cd \"say \\\"hi\\\"\" say \"hi\" \"中文\" 中文 minecraft:stone 这会出错 \"minecraft:stone\" minecraft:stone \"{\\\"abcd\\\":\\\"{\\\\\\\"abc\\\\\\\":\\\\\\\"第一行\\\\\\\\\\\\\\\\n第二行\\\\\\\"}\\\"}\" {\"abcd\":\"{\\\"abc\\\":\\\"第一行\\\\n\\\"}\"} \\n 及 \\uxxxx 的 \\ 字符都需要转义，因为这两个格式是JSON的而不是NBT的。\n\n注意，部分NBT，如实体ID，在生成时容许使用 id:实体id 的方式写，比如是 id:armor_stand \n然而，检测的时候是必须全写，也就是实体id前方得加上 minecraft: ，如 id:\"minecraft:armor_stand\" \n\n数组类型\n数组(Array)类型能储存多个数字，那些数字就是该数组的类型。\n和List类似，我们会叫特定类型的数组为 <类型>数组(array of <类型>)。\n数组和List最大的分别在于，List是查看子标签里是否存在那些检测的标签，而数组则是检查整个数组看看是否符合指定要求，检查包括该标签所在位置、顺序等等。\n\n目前支持的类型包括：\n\nByteIntLong\n格式:\n\n[类型前缀;子标签]复制代码子标签和List类似，都是只有数值的标签，之间以 , 分隔\n\n类型字符（必须大写）Byte B Int I Long L 例子:\n\n[I;]\n空的Int array\n\n[I;123,456]\n\n[B;12b,13b,14b]\n\n[L;123l,456l,789l]复制代码只有很少的地方需要用到数组...\n\n\n\n\nNBT实战\n这部分会涉及不少英语...\n而且玩NBT必须会点英语...因为都是英语词语\n英语不好的读者...请自行找个命令群问吧，并且得学好点英语啊23333\n\n阅读树视图(Treeview)\nWiki 主要NBT页面：\n实体、方块NBT\n玩家、物品NBT\n\nWiki中以树视图来表达NBT的继承关系（父compound/list与子标签）。\n标签左边的图标会标识每个标签的类型（看不清楚的话可以把鼠标放在那图标上面）。\n那格式相信已经非常清楚了，然而还是有点需要解释的。\n\n\n阅读子Compound\n首先，大家需要明白一个很重要的事实: Compound是分种类的。\nCompound根据子标签的不同，是有不同的\"种类\"的。我们一般会把常用的compound分类。类别如下（子类别为在父类别加上一些别的标签）:\n\nEntity （实体）\nMob （生，实体的子类别）Projectile （弹射物，实体的子类别）Block Entity （动态方块，实体的子类别）...\nItem （物品）Block （方块）Tag （物品内的Tag）Attribute...\n我们会在之后的部分简述其中一些标签。\n\n其实命令里的 Data tag （数据标签）也是有分\"种类\"的，实体相关的大部分为Entity，物品相关的为Tag，方块相关的为Block\n\n\n\n\n有时候会看到这种 See this format (recursive) （中文为 参见这个格式（递归） ）。\n这代表里面这个Compound，就是这个部分最\"大\"的标签（在这个例子中，最大的标签就是Entity data，中文为实体数据）。\n\n那个部分在wiki里其实是这样的\n\nEntity data\n    id: string ...\n    Pos: list of 3 TAG_Doubles ...\n    ...\n    Passengers: list of the data of the entity riding...\n        see this format (recursive)复制代码我们看最\"大\"的tag，就是看没有父标签的那个，在这情况就是 Entity data 。\n\n\n\n\n\n有时候也会看见这种：The list of items .... （中文：....物品的列表）\n这说明下面的compound为item。\n\n\n阅读List元素\nList元素有两种，分别为有限（且顺序敏感）元素数量及不限制元素数量的。\n\n有限元素的分别有两种写法。第一种就如同上方的HandItems一样，就是List下面有多于一个标签，那些标签必须放在相应的位置。\n\n以HandItems作例子\n\nHandItems:[{id:\"minecraft:stone\",Count:1b},{id:\"minecraft:glass\",Count:1b}]复制代码石头就是放在主手，而玻璃就是放在副手。\n\n\n\n对于非Compound的有限元素，有时候就会这么写：数字 TAG_<类型>....，说明了元素数量及类型，如：\n\nMotion: 3 TAG_Doubles describing the current dX,dY,dZ velocity of the entity in meters per tick.\n这句讲解了List里的元素类型以及用途。而粗体的那三个字就是你要写的元素了。以下是一个例子：\n\nMotion:[1d,2d,3d]复制代码x轴上的速度为1m/s，y轴为2m/s，z轴为3m/s。\n\n\n\n不限制元素数量的写法有两种：第一种为在List下面有一个标签，第二种为只写着 List of ... 而之后的部分不是种类而是子标签用途。\n\n例子:\n\n1: \n\n2:  Tags: List of custom string data. \n这代表了子标签数量不设限制，而子标签次序一般并无影响。\n\n例子：\n\nPassengers:[{id:\"minecraft:pig\"},{id:\"minecraft:armor_stand\"}]\n\nTags:[abc,def,ghjdfs,sfdsfsdf,sadasdsad]复制代码注: 是一般并无影响而不是绝对没有影响。\n在Passengers的例子里，如果根实体（被Passengers骑着的实体）为船，那么第一个及第二个实体的位置会有分别。只有一个实体和有两个甚至更多实体的位置也不同。\n\nList是无法直接修改指定索引值的标签的。赋值时也无法不覆盖掉原先的所有标签。\n\n阅读数组\n其实数组方面和List的不限制元素数量写法也十分相近，就是 Array of ... 。\n\n例子：\n\nColors: Array of integer values corresponding to the primary colors of this firework's explosion...\n简单来说就是一堆数字，代表了那烟花的颜色。所以NBT的例子为：\n\nColors:[I;123,456,789,123,456,789]复制代码1.12后数组有类型分别，分号前的值即代表其类别。\n\n例子1——给予物品\ngive 命令的功能为给予物品，其格式为\n\ngive <玩家> <物品id> [数量] [伤害值] [NBT]复制代码NBT（有时亦作数据标签，其实就是NBT）部分，其base tag为tag。\n\n什么是Base tag呢？其实这是一个概念，说的是这段NBT最外层的Compound是什么。\n\n上面我们说到，Compound也有分为不同种类的。有一些是Entity，一些是Item，一些是Tag。而不同命令使用的NBT也有所不同。\n\n比如是物品类的命令，如 give 命令，它们的NBT那里就是物品的额外NBT，其Base tag就是 tag ，意思就是最外层的compound类型为 tag 。\n\n而tag的（部分）子标签为\n\n tag: compound\n └── display：compound\n      ├── Name: 物品名称，string\n      └── Lore: 物品描述，string的list，每个string代表一行复制代码故此我们命令里的NBT就能这么写：\n\n{display:{Name:\"物品名称\",Lore:[\"第一行\",\"第二行\"]}}复制代码例子命令：\n\ngive @p nether_star 1 0 {display:{Name:\"原谅之星\",Lore:[\"爱是一道光\",\"如此美妙\"]}}复制代码这命令给予玩家一个下界之星，名称为 原谅之星，描述为 爱是一道光 （下一行）如此美妙。\n\n\n例子2——物品自定义NBT\n只有物品的tag能有这个操作\n物品的tag里能够自定义NBT，通过自定义NBT，玩家能够方便的把物品分类并且选择物品的实体/持有物品的实体等。\n\ntag: compound\n├── 自定义NBT1: 种类自定\n├── 自定义NBT2: 种类自定\n├── ...\n└── 自定义NBTn: 种类自定复制代码假设我们要给予玩家一些特别的物品，我们需要统一进行检查。（检测有没有持有那类的物品，给予buff或者避免重复给予玩家那类型物品）\n如果我们不使用自定义NBT，就需要逐个物品来检查，那就会十分麻烦，故此我们可以使用自定义NBT。\n\n#这是第一类，编程的别问我为啥从1开始数\ngive @p diamond_axe 1 0 {CustomNBT:1b}\ngive @p diamond_sword 1 0 {CustomNBT:1b}\n\n#这是第二类\ngive @p iron_axe 1 0 {CustomNBT:2b}\ngive @p iron_sword 1 0 {CustomNBT:2b}复制代码这样，比如我们要检查拿着第一类物品的玩家，我们可以通过以下命令：\n\ntestfor @p {SelectedItem:{tag:{CustomNBT:1b}}}复制代码相比两条命令（分别检测 {SelectedItem:{id:\"minecraft:diamond_axe\"}} 和 {SelectedItem:{id:\"minecraft:diamond_sword\"}} ）明显方便了许多，而且这只是因为一个种类里的物品比较少：比较多物品的时候能更方便。\n\n提示：NBT里检测id的时候，无论是实体名称、方块id或者是物品id都得写 minecraft: 。\n\n检查NBT时，如果是同样精准度的话，我们会使用较少NBT的那个，因为效率会更高。而就物品来说，我们就可以使用自定义NBT，简单方便的进行检查。\n\n高级用法\n我们可以用大类小类的方式更有系统的分类，对小游戏地图特别有用。\n然而我们不必写很多特殊标签，我们只需要：Compound。\n\n比如说，以上两类都属于工具类别，那么我们就命名这个大类为 tools \nNBT改为 {tools:{CustomNBT:1b}} 及 {tools:{CustomNBT:2b}} \n假设我们要检测小类，则正常方式也行。如果要检测大类，则可以只写 {SelectedItem:{tags:{tools:{}}}} \n是不是方便很多呢？2333\n\n\n例子3——天降补给\n生成一个掉落中的方块(Falling block)，类型为箱子，里面装着一把剑。\n\n首先我们看看 falling_block 的NBT。\n\nfalling_block\n├──Block: 方块ID。字串。\n├──TileEntityData: 方块实体的NBT。\n├──Data: 方块的元数据。Byte。\n└──Time: 这掉落中的方块的存在时间（单位为游戏刻）。如果设置为0，过了1游戏刻后如果方块发现所处位置的方块id和此实体的方块id不同，就会消失。...（省却了和这部分无关系的描述）。当数值超过600或y坐标=0，这个实体就会消失。Int。复制代码至于箱子（一种方块实体）的NBT就是这样的\n\nchest\n└──Items: 箱子内的物品列表。复制代码而物品的格式就是\n\nItem\n├──Count: 物品数量。byte。\n├──Slot: 物品所处格子编号。byte。\n├──Damage: 物品数据值。short。\n├──id: 物品id。字串。\n└──tag: 物品的其他tag。复制代码首先我们写出这剑的NBT，假设我们希望是一把钻石剑，在箱子的第一格（编号从0开始）。\n\n{Count:1b,Slot:0b,Damage:0s,id:\"minecraft:diamond_sword\"}复制代码然后编写箱子的NBT（物品列表内的物品就是剑的NBT）\n\n{Items:[{Count:1b,Slot:0b,Damage:0s,id:\"minecraft:diamond_sword\"}]}复制代码最后编写掉落方块的NBT（ TileEntityData 里的就是箱子的NBT）\n\n{Block:\"minecraft:chest\",Data:0b,Time:1,TileEntityData:{Items:[{Count:1b,Slot:0b,Damage:0s,id:\"minecraft:diamond_sword\"}]}}复制代码这例子显示了NBT格式是怎么引用别的NBT的。\n\n例子4——小僵尸Boss\n首先我们希望Boss的名字叫Boss。这和实体格式有关：\n\n然后如何定义一只小僵尸呢？我们就得看僵尸的NBT。\n\nzombie\n└──IsBaby: 僵尸是否婴儿。Byte。复制代码那么僵尸有没有定义名称的NBT呢？看起来是没有的。？？？\n\n其实僵尸(zombie)是实体(entity)的一个子类，因此僵尸里会继承所有属于实体的tag，比如是 CustomName 。\n\nEntity\n├──CustomName: 实体的名称。字串。\n└──CustomNameVisible: 实体名称是否可见。Byte。复制代码可以这么想，僵尸有的NBT为：\n\nzombie\n├── 一切实体的NBT\n└── 僵尸独有的NBT复制代码也就是\n\nzombie\n├──CustomName\n├──CustomNameVisible\n├──IsBaby\n└──...复制代码\n\n好了我们怎么弄一只boss呢？我们可以修改属性，也就是Attribute。然而在僵尸的NBT里看不到Attribute啊！是不是代表没有呢？\n\n不是的，其实僵尸也属于生物(Mob)，而Mob就有我们需要的Attribute了。\n僵尸的继承体系是：\n\nentity\nmob\n怪物monster, 不死类生物 Undead （这里不影响NBT，但影响其行为）\n\n\nMob的格式是这样的：\n\nMob\n├──Attributes: Attributes列表。\n│   └┬─ 一个Attribute\n│    ├──Name: attribute的名称（我们改血量，写generic.maxHealth）\n│    ├──Base: attribute的数值（写30），类型为byte。\n│    ├──...\n├──Health: 血量（只改maxHealth只会修改最大血量，实际血量还是20）。float。\n└──...复制代码所以NBT可以这么写：\n\n{CustomName:Boss,CustomNameVisible:1b,IsBaby:1b,Attributes:[{Name:\"generic.maxHealth\",Base:30b}],Health:30.0f}复制代码注意: 使用 summon 命令生成实体时我们不是在指定实体的所有标签，我们只是修改特定的标签，其他标签还是会自动赋予的，其中一些会被随机生成。有一些NBT只能在实体生成时设置，生成后就会消失。\n\n样式代码\n有时候我们会希望在NBT加入样式代码，来为比如是物品名称或描述加上颜色等样式。\n\n样式代码其实就是 §<符号> ，之后的字符根据会加上特定样式。样式决定于 § 后的符号，和JSON那些样式类似。也能够混合使用（效果会叠加直至 §r 的出现）。\n\n颜色：\n\n\n特殊样式：\n\n样式代码效果§k混淆(obfuscated)§l粗体(bold)§m删除线(strikethrough)§n下划线(underline)§o斜体(italic)§r重置(reset)，即前方样式不会对后方有作用例子:\n\n{CustomName:\"§a123456§r\"}\n\n{display:{Lore:[\"§a§l粗体原谅\"]}}复制代码然而是无法以正常方式向游戏内输入 § 字符的。\n最方便的方式为通过命令函数输入，如果不能使用命令函数的话可以使用牌子点击黑科技，链接：http://www.mcbbs.net/thread-443181-1-1.html\n除了NBT以外，其他地方也会使用 § 字符代表颜色，比如存档名称、advancement、记分板假名等等。\n\n\n例子\n\n命令:\n\ngive @p nether_star 1 0 {display:{Name:\"§a§l爱是一道光\",Lore:[\"如此美妙\"]}}复制代码效果：\n\n\n你们是不是以为如此美妙的部分也是绿色和粗体？不是说好的 之后的字符根据会加上特定样式 么？\n\n其实是这样的，那句 之后的字符根据会加上特定样式 其实说的是同一个NBT内，比如是Name里面，或者是Lore里面的一个子标签里面。\n故此，Lore部分是独立于Name部分的，也不会获得那原谅Buff。\n\n\n其他\n这里会说一些NBT的额外资料。\n部分NBT是生成后就会消失的，如UUID，别想着要改了。\n部分NBT是只读(Read only)不能修改的，如OnGround这些，而且你修改了也没用。\n\n有时候会看见别人写错类型的，如Item:  {id:\"minecraft:stone\",Count:1} 。\n然而其实这并不是错的，这是利用了NBT的型别转换(Type casting)，也就是说修改NBT时能自动把类型转为正确类型。（当然，超出了正确类型范围的时候就不会自动转换了）\n不过我们并不建议这种写法，因为有很大几率会出现错误，并且在检测NBT的时候不允许使用这种写法。\n\n生物的ActiveEffects不建议直接修改。部分和attribute有关的状态效果需要attribute modifier。故此只声明ActiveEffects是无效的。\n\n生物的Attribute很坑（包括AttributeModifier，比如史莱姆的maxHealth改了也没用...）...建议使用前多测试。\n\n检测生物有没有受到攻击可以检测生物 HurtTime 。（function的话可以考虑检测 9s ，命令方块的话得+1s，检测 10s 。这是由于gameLoopFunction在生物更新后执行。原则上 10s 到 1s 都可以用于检测，但一般我们都需要即时获取状态。）\n\n别试图检测Float/Double，你往往不要指望恰好能达到你所检测的值...例如检查实体视角时更常见的是使用选择器参数而不是相应NBT。\n\n处理火球的时候记着设置direction。motion对它是没用的，并且不设置direction根本生成不了。\n\n重要！！！\n村民的 Inventory 设置的时候只会增加物品，不会覆盖。\n比如原先有 [{id:\"minecraft:stone\",Count:1b,Damage:0s}] ，我们设置 Inventory:[{id:\"minecraft:stone\",Count:1b,Damage:0s}] ，村民的Inventory NBT会变为 [{id:\"minecraft:stone\",Count:2b,Damage:0s}] 。\n假如我们在以上的基础上设置 [{id:\"minecraft:stone\",Count:1b,Damage:1s}] ，村民的Inventory会变为 [{id:\"minecraft:stone\",Count:2b,Damage:0s},{id:\"minecraft:stone\",Count:1b,Damage:1s}] 。\n而且村民的 replaceitem 命令中的 slot.villager.数字 是基于这个列表里的物品位置的，第一个的数字就是 0 ，第二个就是 1 ，如此类推。但实际上在村民的Inventory里是不会有 Slot 这个NBT的。我们需要移除物品就只能靠 replaceitem 为 air 了。 replaceitem 为 air 之后物品会向前补充那空缺。\n幸好这奇奇怪怪的特性不常见...\n\n此特性由Yaossg发现\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "TNT嘉音",
            "timestamp": 1502878920,
            "txt_content": "真搞不懂，到底别人看得懂吗？"
        },
        {
            "author": "pca006132",
            "timestamp": 1502879460,
            "txt_content": "爆博狙击 发表于 2017-8-16 18:22\n真搞不懂，到底别人看得懂吗？\n哪儿不懂或写的不清晰？欢迎询问"
        },
        {
            "author": "rooke_zb",
            "timestamp": 1502883840,
            "txt_content": "每次看到logo图还是想笑"
        },
        {
            "author": "2538078192",
            "timestamp": 1502932020,
            "txt_content": "............."
        },
        {
            "author": "5dongdnng5",
            "timestamp": 1502980500,
            "txt_content": "666666666666666666666666666666666666"
        },
        {
            "author": "5dongdnng5",
            "timestamp": 1502980680,
            "txt_content": "66666666666666666666666666666666666666666666666"
        },
        {
            "author": "1028874439",
            "timestamp": 1503413940,
            "txt_content": "转义还是没搞懂。。。。"
        },
        {
            "author": "1028874439",
            "timestamp": 1503415020,
            "txt_content": "LZ顺便问一下，怎么改村民交易物品的颜色~~用不来颜色代码"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503417960,
            "txt_content": "1028874439 发表于 2017-8-22 22:59\n转义还是没搞懂。。。。\n转义简单地说就是:利用斜杠，让系统明白你的引号不是用来结束字符串的，而是作为字符串的一部分的；多层的转义还需要让系统明白，你的一些斜杠不是用来转义的，而是要用来作为下一层字符串转义时用的斜杠。"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503418080,
            "txt_content": "1028874439 发表于 2017-8-22 23:17\nLZ顺便问一下，怎么改村民交易物品的颜色~~用不来颜色代码\n如果用function来生成村民，就可以直接在nbt里用样式代码（那个弯弯曲曲的符号）；如果要在游戏内要用unicode，也就是\\u....那个来代替样式代码。如果你需要例子请回复一下:)"
        },
        {
            "author": "1028874439",
            "timestamp": 1503418320,
            "txt_content": "kakagou12 发表于 2017-8-23 00:08\n如果用function来生成村民，就可以直接在nbt里用样式代码（那个弯弯曲曲的符号）；如果要在游戏内要用uni ...\n需要需要谢谢了~~话说这么晚了"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503420060,
            "txt_content": "1028874439 发表于 2017-8-23 00:12\n需要需要谢谢了~~话说这么晚了\n那我明天再给你好了（笑"
        },
        {
            "author": "1028874439",
            "timestamp": 1503420720,
            "txt_content": "kakagou12 发表于 2017-8-23 00:41\n那我明天再给你好了（笑\n谢谢了。。"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503458700,
            "txt_content": "1028874439 发表于 2017-8-23 00:52\n谢谢了。。summon Villager ~ ~ ~ {Offers:{Recipes:[{maxUses:9999999,buy:{id:stone,Count:1},sell:{id:wool,Damage:3,Count:1,tag:{display:{Name:\"§2AB\"}}}}]}}复制代码\n刚才测试了一下，这个命令现在只能用function来执行，不然样式代码打不出来"
        },
        {
            "author": "1028874439",
            "timestamp": 1503462120,
            "txt_content": "kakagou12 发表于 2017-8-23 11:25\n刚才测试了一下，这个命令现在只能用function来执行，不然样式代码打不出来 ...\n喔，谢谢了。"
        },
        {
            "author": "1028874439",
            "timestamp": 1503464520,
            "txt_content": "kakagou12 发表于 2017-8-23 11:25\n刚才测试了一下，这个命令现在只能用function来执行，不然样式代码打不出来 ...\n没用啊~~在里面的的§在游戏中直接以一个平行四边形显示。。"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503473520,
            "txt_content": "1028874439 发表于 2017-8-23 13:02\n没用啊~~在里面的的§在游戏中直接以一个平行四边形显示。。\n你用了function了吗？还是直接输入到cb？"
        },
        {
            "author": "2759159258",
            "timestamp": 1503484140,
            "txt_content": "JSON全部看不懂的说。。。。香菇"
        },
        {
            "author": "madtom",
            "timestamp": 1503491760,
            "txt_content": "一脸懵逼"
        },
        {
            "author": "神幻魔刑",
            "timestamp": 1503493860,
            "txt_content": "多谢楼主"
        },
        {
            "author": "1028874439",
            "timestamp": 1503539640,
            "txt_content": "kakagou12 发表于 2017-8-23 15:32\n你用了function了吗？还是直接输入到cb？\n用了function，CB里输不了。。"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503584460,
            "txt_content": "1028874439 发表于 2017-8-24 09:54\n用了function，CB里输不了。。\n这就奇怪了，我这边是可以的，你修改过命令吗？"
        },
        {
            "author": "1028874439",
            "timestamp": 1503646920,
            "txt_content": "kakagou12 发表于 2017-8-24 22:21\n这就奇怪了，我这边是可以的，你修改过命令吗？\n并没有。。。"
        },
        {
            "author": ":spgbigfan:",
            "timestamp": 1503765000,
            "txt_content": "1028874439 发表于 2017-8-25 15:42\n并没有。。。\n这就非常尴尬了（；￣д￣）"
        },
        {
            "author": "pca006132",
            "timestamp": 1503801540,
            "txt_content": "1028874439 发表于 2017-8-25 15:42\n并没有。。。\n把游戏内的输出截图一下，顺便你的命令函数文件是啥编码的"
        },
        {
            "author": "chyx",
            "timestamp": 1503813420,
            "txt_content": "1028874439 发表于 2017-8-23 13:02\n没用啊~~在里面的的§在游戏中直接以一个平行四边形显示。。\n也许是你保存文件时使用的编码不正确\n\n应当使用UTF-8无BOM格式\n\n记事本不使用这个 请使用其他的软件"
        },
        {
            "author": "1028874439",
            "timestamp": 1503898740,
            "txt_content": "chyx 发表于 2017-8-27 13:57\n也许是你保存文件时使用的编码不正确\n\n应当使用UTF-8无BOM格式\n我用的N++..."
        },
        {
            "author": "1028874439",
            "timestamp": 1503899340,
            "txt_content": " 本帖最后由 1028874439 于 2017-8-28 13:52 编辑 \n\n卧槽。。。好像又好了，之前不是这样的。。。你听我解释。"
        },
        {
            "author": "1028874439",
            "timestamp": 1503899340,
            "txt_content": "pca006132 发表于 2017-8-27 10:39\n把游戏内的输出截图一下，顺便你的命令函数文件是啥编码的\n谢谢了，这次不知道为啥，已经成功了。。。"
        },
        {
            "author": "是谁",
            "timestamp": 1564124580,
            "txt_content": "样式代码怎么打出来哈"
        },
        {
            "author": "YLM20041125",
            "timestamp": 1600508940,
            "txt_content": "这是属于代码了吧"
        }
    ]
}