{
    "title": "如何让某功能休息一下",
    "author": "qq1196963797",
    "replyCount": 4,
    "timestamp": 1456063560,
    "txt_content": "比如我写了一个掉钻石的方法\nplayer.getWorld().dropItemNaturally(player.getPlayer().getLocation(),new ItemStack(Material.DIAMOND));\n那么如何让他在一个计时器里\n每隔3秒掉一个呢？\n谢谢！",
    "replies": [
        {
            "author": "ader",
            "timestamp": 1456120620,
            "txt_content": "sleep吧。。我不太懂[无视]"
        },
        {
            "author": "qq1196963797",
            "timestamp": 1456137000,
            "txt_content": "bader 发表于 2016-2-22 13:57\nsleep吧。。我不太懂[无视]\nsleep可能会让整个服务器都sleep"
        },
        {
            "author": "tdiant",
            "timestamp": 1456139460,
            "txt_content": "sleep是停止一个线程的，服务器就一个线程停止了就卡了。建议考虑Timer，或者你自己再造一个线程"
        },
        {
            "author": "a254969696",
            "timestamp": 1456222080,
            "txt_content": "可以使用Runnable或BukkitRunnable。\n如果使用Runnable可以用匿名内部类，示例如下：\n在主类中写：this.getServer().getScheduler().scheduleAsyncRepeatingTask(this,new Runnable(){\n    public void run(){\n        //some codes\n    }\n}, 0L,3*20L);\n这样run()方法内的代码就会在执行这条代码起每3秒重复执行一次（在一个新线程中，所以注意线程安全）\nBukkitRunnable可以调用自身的方法来重复执行，示例如下：\n在主类中写new BukkitRunnable(){\n    public void run(){\n        //some codes\n    }\n}.runTaskTimerAsynchronously(this,0L,3*20L);\n也可以达到一样的效果，同上注意线程安全"
        }
    ]
}