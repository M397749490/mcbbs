{
    "title": "[CBL|2b]数组还原二进制运算操作（源指令|存档|演示|原理）",
    "author": "⭐✔️",
    "replyCount": 3,
    "timestamp": 1471951080,
    "txt_content": " 本帖最后由 贰逼 于 2017-4-4 10:45 编辑 \n\n目录\nP1 介绍预览\nP2 操作方式\nP3 进制转换原理\nP4 加法原理\nP5 减法原理/补码\nP6 乘法原理\nP7 除法原理\nP8 存档下载\n\n二进制操作包括了：\n十进制转二进制、二进制转十进制、加法、减法、乘法、除法、求余、补码；\n\n方法：模块数组（教程链接）\n位数限制：在保证区块加载的范围内（理论上无限）\n运算速度：和位数有关，最慢是((位数+1)?+位数)刻（实体较多的情况下1刻≥0.05s）\n\n注：本作是原理展示向，存档未制作封装的按键操作，所以操作方法也许复杂.\n\n模块一览：\n\n十进制数字输入（单次执行） （你可以靠右击按钮输入十进制数字）\n\n数字显示模块（Update） （显示数组中元素的值）\n\n\n进制转换模块：\n2convert1() （Update void） （数字1十进制转二进制）\n2convert3() （Update void） （数字2十进制转二进制）\n2convert2() （Update void） （运算结果二进制转十进制）\n\n数字确认（单次执行） （确认输入的数字，标记为数字1和数字2，具体操作方法看后面）\n\n二进制数字修改模块（Update） （通过标签直接修改二进制值）\n\n\n运算模块：\nplus()（Update void） （二进制加法）\nreduc()（Update void） （二进制减法）\nproduc()（Update void） （二进制乘法）\ndivid()（Update void） （二进制除法/求余）\n\n补码模块（单次执行） （二进制补码）\n\n二进制结果确认模块（单次执行） （确认二进制运算结果，具体操作看后面）\n\n调用2convert2()\n\n操作方式：\n基本流程（乘法为例）\n\n输入数字模块按按钮输入数字（135790864223457801）\n\n按下这个按钮确认第一个数字\n\n按下这个按钮重置输入指针（如果不重置，那么再次输入数字会在刚才输入的数字末尾继续移位）\n\n输入第二个数字（67891）\n\n按下这个按钮确认第二个数字\n\n分别按下这两个按钮，将数字1，数字2都转为二进制\n\n\n等待二进制转换完成\n\n按下这个按钮删掉输入的十进制数字1，数字2\n\n找到运算模块，按下调用produc()模块的按钮\n\n等待运算完成\n\n按下这个确认结果的按钮\n\n按下这个调用2convert2()的按钮，将运算结果二进制转十进制\n\n结果=9218977562994773567691\n\n最后重置所有模块（如果操作中失误，造成什么系统问题，也可以按下这个按钮重置）\n除法的求余求商\n\n首先两个数字转为二进制（123456789/12为例）\n\n按下这个按钮调用divid()模块\n\n等待完成\n\n按下告示牌写有求余的确认运算结果模块的按钮，然后再按下调用2convert2()的按钮转化值\n余数为9\n\n按下告示牌写有求商的确认运算结果模块的按钮，然后再按下调用2convert2()的按钮转化值\n商为10288065\n补码\n首先减法前面操作不说了\n1-1234为例\n\n按下这个按钮调用reduc()\n然后我们知道这是一个负数，但是如果就此结果直接转化是不正确的\n\n激活这个补码模块（激活一次即可）\n\n补码运行后再确认结果，转化\n\n补码结果是负数的绝对值\n\n十进制转二进制\n就是一个十进制数%2后的余数，然后(该数-余数)再/2，反复进行直到为0\n举个例子：123\n\n123%2 = 1 (123-1)/2 = 61\n61%2 = 1 (61-1)/2 = 30\n30%2 = 0 (30-0)/2 = 15\n15%2 = 1 (15-1)/2 = 7\n7%2 = 1 (7-1)/2 = 3\n3%2 = 1 (3-1)/2 = 1\n1%2 = 1 (1-1)/2 = 0\n复制代码然后全部余数从下往上顺序排列就是1111011，也就是二进制的123\n\n2convert1()（2convert3就不演示了，只是转换对象不同，这里对象是数组num(代表数字1)，而2convert3是数字num0(代表数字2)）\n\n/execute @p[tag=2convert1] ~ ~ ~ execute @e[tag=num] ~ ~ ~ scoreboard players operation all str += @e[tag=num,c=1] str\n/scoreboard players test all str 0 0\ncond:/scoreboard players tag @p remove 2convert1\n*检测数组中全部元素之和是否为0，为0结束模块\n/execute @p[tag=2convert1] ~ ~ ~ /execute @p[tag=2convert1] ~ ~ ~ /scoreboard players set @e[tag=num] sum2 0\n/execute @p[tag=2convert1] ~ ~ ~ /scoreboard players set @e[tag=num] mod2 0\n*sum2是商，mod2是余数\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num] ~ ~ ~ /scoreboard players operation @e[tag=num,c=1] mod2 = @e[tag=num,c=1] str\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num] ~ ~ ~ /scoreboard players operation @e[tag=num,c=1] sum2 = @e[tag=num,c=1] str\n*赋值\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num] ~ ~ ~ /scoreboard players operation @e[tag=num,c=1] mod2 %= 2 str\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num] ~ ~ ~ /scoreboard players operation @e[tag=num,c=1] sum2 /= 2 str\n*操作\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num] ~ ~ ~ /scoreboard players operation @e[tag=num,c=1] str = @e[tag=num,c=1] sum2\n*迭代\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num,score_mod2_min=1] ~ ~ ~ /scoreboard players add @e[tag=num,rm=0,c=1,dx=1] str 5\n*如果余数为1，第二位进5\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[num0s,bit,number1],CustomName:0,CustomNameVisible:1}\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num,score_mod2_min=1,score_numl=1,score_numl_min=1] ~ ~ ~ execute @e[tag=num1] ~ ~ ~ entitydata @e[c=1,tag=num0s] {Tags:[num1s,bit,number1],CustomName:1}\n*在二进制操作栏生成二进制数组number1\n/execute @p[tag=2convert1] ~ ~ ~ /execute @e[tag=num1] ~ ~ ~ tp @e[tag=num1] ~1 ~ ~\n*移位二进制操作栏的转换指针\n/execute @p[tag=2convert1] ~ ~ ~ /scoreboard players set all str 0\n*重置\n*注：num1 num2是二进制转十进制中二进制操作栏的指针\n复制代码二进制转十进制\n就是一个逆过程，第一个二进制值*2+第二个二进制值\n举个例子：1111011\n\n0*2+1=1\n1*2+1=3\n3*2+1=7\n7*2+1=15\n15*2+0=30\n30*2+1=61\n61*2+1=123\n复制代码1111011，也就是十进制的123\n\n2convert2()\n\n/execute @p[tag=2convert2] ~ ~ ~ /execute @e[tag=Tper] ~ ~ ~ scoreboard players tag @e[c=1,tag=results] add resulting\n*标记正在操作的二进制数字（Tper为二进制操作的指针）\n/execute @p[tag=2convert2] ~ ~ ~ /execute @e[tag=2result] ~ ~ ~ /scoreboard players operation @e[tag=2result,c=1] str *= 2 str\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players operation @e[tag=2resultStart] str += @e[tag=resulting] str\n*算法操作\n/execute @p[tag=2convert2] ~ ~ ~ /execute @e[tag=2result,score_str_min=10] ~ ~ ~ summon ArmorStand ~-1 ~ ~ {Tags:[adding],CustomNameVisible:1}\n/execute @p[tag=2convert2] ~ ~ ~ /execute @e[tag=2result,score_str_min=10] ~ ~ ~ scoreboard players set @e[rm=0,c=1,dx=-1,tag=adding] str 1\n/execute @p[tag=2convert2] ~ ~ ~ execute @e[tag=2result] ~ ~ ~ execute @e[tag=adding,r=0] ~ ~ ~ scoreboard players operation @e[tag=2result,c=1] str += @e[tag=adding,c=1] str\n/execute @p[tag=2convert2] ~ ~ ~ execute @e[tag=2result] ~ ~ ~ kill @e[tag=adding,r=0]\n*添加一个补位，补位和重合的元素相加，最后销毁\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players tag @e[tag=adding] add 2result\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players tag @e[tag=adding] remove adding\n*如果补位没有重合，使补位成为一个结果\n/execute @p[tag=2convert2] ~ ~ ~ scoreboard players remove @e[tag=2result,score_str_min=10] str 10\n*退一位\n/execute @p[tag=2convert2] ~ ~ ~ /kill @e[tag=resulting]\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players set all str 0\n*销毁正在操作的数字，重置\n/execute @p[tag=2convert2] ~ ~ ~ /execute @e[tag=results] ~ ~ ~ scoreboard players add all str 1\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players test all str 0 0\ncond:/scoreboard players tag @p[tag=2convert2] remove 2convert2\ncond:/execute @e[tag=2result] ~ ~ ~ tp @e[tag=2result] ~1 ~ ~\ncond:tp @e[tag=2result] ~-1 ~ ~\n*检测后结束模块\n/execute @p[tag=2convert2] ~ ~ ~ /scoreboard players reset all str\n*重置检测复制代码\n加法原理\n这个和竖式计算是一样的\n例如1100+110（也就是12+6）\n\n加数    1  1  0  0\n加数        1  1  0\n补数   1  1\n结果1  0  0  1  0\n复制代码结果10010，也就是十进制下的18\n\nplus()\n\n/execute @p[tag=plus] ~ ~ ~ /scoreboard players set @e[tag=number1] numl 0\n/execute @p[tag=plus] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ /scoreboard players operation @e[tag=number1,r=0] numl += @e[tag=number1,r=0] str\n*预设分配计分板\n/execute @p[tag=plus] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ /scoreboard players operation @e[tag=number1,r=0] str = @e[tag=number1,r=0] numl\n/execute @p[tag=plus] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ /scoreboard players operation @e[tag=number1,c=1] str += @e[tag=number2,r=0] str\n*数字相加\n/execute @p[tag=plus] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ kill @e[tag=number2,r=0]\n/execute @p[tag=plus] ~ ~ ~ /scoreboard players tag @e[tag=number2] add number1\n/execute @p[tag=plus] ~ ~ ~ /scoreboard players tag @e[tag=number2] remove number2\n*保留不重合的number2，销毁重合的number2\n/execute @e[tag=bit,score_str_min=2] ~ ~ ~ summon ArmorStand ~1 ~ ~ {Tags:[num1s,number2,bit],CustomNameVisible:1}\n*进位\n/execute @p[tag=plus] ~ ~ ~ execute @e[tag=2resultStart] ~ ~ ~ /tp @e[tag=Tper] @e[tag=bit,c=-1]\n/execute @p[tag=plus] ~ ~ ~ /tp @e[tag=Tper] ~1 ~ ~\n*将指针移至最末位\n/execute @p[tag=plus] ~ ~ ~ /scoreboard players set @e[tag=bit,score_str_min=2] str 0\n*退位\n/execute @p[tag=plus] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ scoreboard players tag @p[tag=plus] add plusa\n/execute @p[tag=plus] ~ ~ ~ /scoreboard players tag @a remove plus\n/execute @a[tag=plusa] ~ ~ ~ scoreboard players tag @a[tag=plusa] add plus\ncond:/scoreboard players tag @a[tag=plusa] remove plusa\n*检测结束或继续复制代码\n减法原理\n一样的竖式计算，例如1100-110（12-6）\n\n减数    1  1  0  0\n减数        1  1  0\n补数       1  1\n结果    0  1  1  0\n复制代码也就是十进制6\n（计算机中是靠补码相加，这里因为能直接使用减法就套用加法直接用减法了）\n补码原理\n面对负数，例如110-1100（6-12）\n那么会有一个无限创建的问题\n\n减数        1  1  0\n减数    1  1  0  0\n补数 \n差    ∞1  0  1  0\n复制代码但是如果取反后加1，就是该数绝对值：\n\n补码 ∞0  1  0  1\n复制代码也就是十进制6\n\nreduc()\n\n/execute @p[tag=reduc] ~ ~ ~ /scoreboard players set @e[tag=number2] numl 0\n/execute @p[tag=reduc] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ /scoreboard players operation @e[tag=number2,r=0] numl -= @e[tag=number2,r=0] str\n*预设分配计分板\n/execute @p[tag=reduc] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ /scoreboard players operation @e[tag=number2,r=0] str = @e[tag=number2,r=0] numl\n/execute @p[tag=reduc] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ /scoreboard players operation @e[tag=number1,c=1] str += @e[tag=number2,r=0] str\n*预减后的两数相加\n/execute @p[tag=reduc] ~ ~ ~ /execute @e[tag=number1] ~ ~ ~ kill @e[tag=number2,r=0]\n/execute @p[tag=reduc] ~ ~ ~ /scoreboard players tag @e[tag=number2] add number1\n/execute @p[tag=reduc] ~ ~ ~ /scoreboard players tag @e[tag=number2] remove number2\n/execute @e[tag=bit,score_str=-1] ~ ~ ~ summon ArmorStand ~1 ~ ~ {Tags:[num1s,number2,bit,bu],CustomNameVisible:1}\n/execute @p[tag=reduc] ~ ~ ~ execute @e[tag=2resultStart] ~ ~ ~ /tp @e[tag=Tper] @e[tag=number1,c=-1]\n/execute @p[tag=reduc] ~ ~ ~ /tp @e[tag=Tper] ~1 ~ ~\n/execute @p[tag=reduc] ~ ~ ~ /scoreboard players set @e[tag=bit,score_str=-1] str 1\n/execute @p[tag=reduc] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ scoreboard players tag @p[tag=reduc] add reduca\n/execute @p[tag=reduc] ~ ~ ~ /scoreboard players tag @a remove reduc\n/execute @a[tag=reduca] ~ ~ ~ scoreboard players tag @a[tag=reduca] add reduc\ncond:/scoreboard players tag @a[tag=reduca] remove reduca\n*和加法一样的过程，只是加变成减，补位1变成-1\n/execute @e[tag=2resultStart] ~ ~ ~ scoreboard players tag @e[tag=number1,c=-1] add reducend\n/execute @e[tag=reduc] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ /scoreboard players add allred str 1\n/scoreboard players test allred str 1 1\ncond:/scoreboard players tag @e[tag=number2] add thelast\n*给仅剩的最后的number2添加一个tag\n/execute @e[tag=thelast] ~ ~ ~ execute @e[tag=reducend,rm=0,dx=-1] ~ ~ ~ scoreboard players tag @e[tag=thelast] add dex\ncond:/scoreboard players tag @p remove reduc\n*如果仅剩的number2在所有操作数字左侧，那么代表跳入无限循环阶段，添加dex标签，并且结束模块\n/scoreboard players tag @e remove reducend\n/scoreboard players set allred str 0\n*重置\n复制代码com()\n\n/scoreboard players tag @e[tag=number1] add number2\n/execute @e[tag=number2,score_str=0] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[number1,bit,num1s],CustomNameVisible:1}\n/execute @e[tag=number2,score_str_min=1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[number1,bit,num0s],CustomNameVisible:1}\n/kill @e[tag=number2]\n*将所有数字取反，然后设成number1\n/execute @e[tag=2resultStart] ~ ~ ~ execute @e[tag=number1,c=1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[num1s,number2,bit],CustomNameVisible:1}\n*生成一个number2，值为1，和number1相加\n/scoreboard players tag @p add plus\n*调用plus()复制代码\n乘法原理\n此时需要向左移位，如果遇到数字1中遇到1就加上数字2\n110*1100（12*6）\n\n第一位为1，积为1100，左移：11000\n第二位为1，积为11000+1100=100100，左移：1001000\n第三位为0，最终结果：1001000\n复制代码也就是十进制72\n\n调用produc的准备模块\n\n/scoreboard players tag @p add produc\n*调用\n/scoreboard players tag @e[tag=number1] add number3\n/scoreboard players tag @e[tag=number2] add number4\n/scoreboard players tag @e[tag=number2] remove number2\n/scoreboard players tag @e[tag=number1] remove number1\n*将number1变更为number3，number2变更为number4\n/scoreboard players tag @p add producta\n*标记为正在调用\n复制代码produc()\n\n/execute @a[tag=producta] ~ ~ ~ /execute @e[tag=2resultStart] ~ ~ ~ tp @e[tag=Tper] @e[tag=number4,c=1]\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ execute @e[tag=Tper] ~ ~ ~ tp @e[tag=Tper] @e[tag=number4,c=-1]\n*将指针移至末位\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /tp @e[tag=number1] ~1 ~ ~\n*左移一位\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /execute @e[type=ArmorStand,name=res1] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[number1,bit,num0s],CustomNameVisible:1}\n*注 res1为商位的指针.默认生成一个0\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /execute @e[tag=Tper] ~ ~ ~ execute @e[tag=number4,r=0,score_str_min=1] ~ ~ ~ scoreboard players tag @p add productab\n*检测到遇到number2的1\n/execute @p[tag=productab] ~ ~ ~ /execute @e[tag=number3,score_str=0] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num0s,number2,bit],CustomNameVisible:1}\n/execute @p[tag=productab] ~ ~ ~ /execute @e[tag=number3,score_str_min=1] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num1s,number2,bit],CustomNameVisible:1}\n*遇到number2的1生成一个number1\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /execute @e[tag=Tper] ~ ~ ~ execute @e[tag=number4,r=0,score_str_min=1] ~ ~ ~ /scoreboard players tag @p add product\ncond:/scoreboard players tag @p add plus\ncond:/scoreboard players tag @p remove produc\n*调用plus()\n/execute @a[tag=producta] ~ ~ ~ /testfor @p[tag=!plus] {Tags:[product]}\ncond:/scoreboard players tag @p add produc\ncond:/scoreboard players tag @p remove product\n*检测到plus()模块执行结束后，重置，标记为正在调用\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /execute @e[tag=2resultStart] ~ ~ ~ tp @e[tag=Tper] @e[tag=number4,c=1]\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ execute @e[tag=Tper] ~ ~ ~ tp @e[tag=Tper] @e[tag=number4,c=-1]\n/execute @a[tag=producta] ~ ~ ~ /execute @p[tag=produc] ~ ~ ~ /execute @e[tag=Tper] ~ ~ ~ kill @e[tag=number4,r=0]\n*指针移到末位，并销毁刚才检测的数字\n/scoreboard players tag @p remove producta\n/execute @e[tag=number4] ~ ~ ~ /scoreboard players tag @p add producta\n/scoreboard players tag @p remove productab\n*结束或继续模块复制代码\n除法原理\n同样是向左移位和减法，将被除数从右到左移入余数，并且商跟着移位，如果余数-除数≥0，那么余数等于差，商此时增加一个为1的元素\n1100/110（12/6）\n\n左移，余数为1，1<110，商为0\n左移，余数为11，11<110，商为0\n左移，余数为110，110=110，商为1\n左移，余数为0，0<110，商为10\n复制代码余数就是十进制0，商就是十进制2\n\n调用divid()的准备模块\n\n/scoreboard players tag @p add divid\n*调用\n/scoreboard players tag @e[tag=number1] add number3\n/scoreboard players tag @e[tag=number2] add number4\n/scoreboard players tag @e[tag=number2] remove number2\n/scoreboard players tag @e[tag=number1] remove number1\n*将number1改为number3 number2改为number4\n/execute @e[tag=number3,score_str=0] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num0s,number1,bit],CustomNameVisible:1}\n/execute @e[tag=number3,score_str_min=1] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num1s,number1,bit],CustomNameVisible:1}\n/execute @e[tag=number4,score_str=0] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num0s,number2,bit],CustomNameVisible:1}\n/execute @e[tag=number4,score_str_min=1] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num1s,number2,bit],CustomNameVisible:1}\n*生成number1=number3 nmber2=number4\n/execute @e[tag=2resultStart] ~ ~ ~ scoreboard players tag @e[tag=number1,c=1] add end1d\n*标记number1的初位\n/execute @e[tag=number1] ~ ~ ~ tp @e[tag=number1] ~-1 ~ ~\n*移位number1到操作位外，方便一会左移\n/scoreboard players tag @p add divide\n*标记divid()正在调用\n/execute @e[tag=2resultStart] ~ ~ ~ scoreboard players tag @e[tag=number2,c=-1] add end2d\n*标记number2的末位\n复制代码divid()\n\n/execute @a[tag=divid] ~ ~ ~ scoreboard players tag @p[tag=!reduc] add reduccb {Tags:[dividea]}\n/execute @a[tag=reduccb] ~ ~ ~ scoreboard players tag @p remove dividea\n/execute @a[tag=reduccb] ~ ~～ scoreboard players tag @p add divide\n*检测reduc调用完毕，重新归为执行状态\n/execute @a[tag=reduccb] ~ ~ ~ /execute @e[tag=number4,score_str_min=1] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num1s,number2,bit],CustomNameVisible:1}\n/execute @a[tag=reduccb] ~ ~ ~ /execute @e[tag=number4,score_str=0] ~ ~ ~ summon ArmorStand ~ ~ ~-2 {Tags:[num0s,number2,bit],CustomNameVisible:1}\n*复制number2\n/execute @a[tag=reduccb] ~ ~ ~ /execute @e[tag=dex] ~ ~ ~ /scoreboard players tag @p add reducecb\n/execute @a[tag=reducecb] ~ ~ ~ /scoreboard players tag @p remove reduccb\n/execute @a[tag=reducecb] ~ ~ ~ execute @e[tag=number5] ~ ~ ~ kill @e[tag=number1,dx=100000]\n/execute @a[tag=reducecb] ~ ~ ~ /scoreboard players tag @e[tag=number5] add number1\n/execute @a[tag=reducecb] ~ ~ ~ /scoreboard players tag @e[tag=number1] remove number5\n/execute @a[tag=reducecb] ~ ~ ~ /kill @e[tag=dex]\n/scoreboard players tag @p remove reducecb\n*检测到dex，也就是差＜0，重置，还原备份\n/execute @a[tag=reduccb] ~ ~ ~ kill @e[tag=number5]\n/execute @a[tag=reduccb] ~ ~ ~ /execute @e[name=res2] ~ ~ ~ summon ArmorStand ~ ~ ~ {CustomNameVisible:1,Tags:[divida,num1s]}\n/execute @e[name=res2] ~ ~ ~ /execute @e[tag=num1s,r=0] ~ ~ ~ scoreboard players set @e[tag=divida,score_str=0,r=0] str 1\ncond:/execute @e[name=res2] ~ ~ ~ /kill @e[tag=num1s,r=0]\n/scoreboard players tag @p remove reduccb\n*未检测到dex，也就是差≥0，商新增1.注 res2为商位的指针、res1为余数位的指针\n/execute @e[tag=divid] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ execute @e[tag=end1d,r=0] ~ ~ ~ /scoreboard players tag @p remove dividea\n/execute @e[tag=divid] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ execute @e[tag=end1d,r=0] ~ ~ ~ /scoreboard players tag @p remove divide\n/execute @e[tag=divid] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ execute @e[tag=end1d,r=0] ~ ~ ~ /scoreboard players tag @p remove divid\n/execute @e[tag=2resultStart] ~ ~ ~ scoreboard players tag @e[tag=number2,c=-1] add end2d\n*如果number1的初位碰到了number2就结束\n/execute @p[tag=divid] ~ ~ ~ /execute @a[tag=divide] ~ ~ ~ /tp @e[tag=divida] ~1 ~ ~\ncond:/execute @e[name=res2] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[num0s,divida],CustomNameVisible:1}\n*默认将商移位并创建新的0\n/execute @p[tag=divid] ~ ~ ~ /execute @a[tag=divide] ~ ~ ~ /tp @e[tag=number1] ~1 ~ ~\n*将number1移位\n/execute @p[tag=divid] ~ ~ ~ /execute @a[tag=divide] ~ ~ ~ execute @e[tag=end2d] ~ ~ ~ /execute @e[tag=number1,score_str_min=1,dx=1] ~ ~ ~ scoreboard players tag @p add divideab\n/execute @p[tag=divideab] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ /execute @e[tag=number1,score_str=0,r=0] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[num0s,number5,bit],CustomNameVisible:1}\n/execute @p[tag=divideab] ~ ~ ~ /execute @e[tag=number2] ~ ~ ~ /execute @e[tag=number1,score_str_min=1,r=0] ~ ~ ~ summon ArmorStand ~ ~ ~ {Tags:[num1s,number5,bit],CustomNameVisible:1}\n*如果number2末位碰到了number1末位，备份\n/execute @p[tag=divideab] ~ ~ ~ /scoreboard players tag @p add dividea\n/execute @p[tag=divideab] ~ ~ ~ /scoreboard players tag @p add reduc\n/execute @p[tag=divideab] ~ ~ ~ /scoreboard players tag @p remove divide\n/execute @p[tag=divideab] ~ ~ ~ /scoreboard players tag @p remove divideab\n*然后移除正在调用的标记，调用reduc()复制代码\n当然未封装完成，将会持续更新：\nhttp://pan.baidu.com/s/1dFyp0Ed\n同时未来会进一步完善二进制运算操作.[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "MojeDes",
            "timestamp": 1471955460,
            "txt_content": "很厉害哦！"
        },
        {
            "author": "langyo",
            "timestamp": 1474040760,
            "txt_content": "虽然这可以用在模拟数字信号计算上，综合讲这的确是挺不错的模块，但你能否把移位补码什么的讲清楚一点。讲的太迷糊了，之前没学过的就根本看不懂了。\nhttp://wk.baidu.com/view/9a49c2a6dd3383c4bb4cd236.html这是移位的\nhttp://m.baike.so.com/doc/6337171-6550784.html这是补码的\n\n另外，弄个OCB怎么样？大家实际上都懒得下存档←_←\n\n（实际上就是看这帖子都一个月了没啥人回复所以就强行水233333但也算是支持下）"
        },
        {
            "author": "彪悍的新手",
            "timestamp": 1486171980,
            "txt_content": "卧槽。。。\n萌新仰望dalao"
        }
    ]
}