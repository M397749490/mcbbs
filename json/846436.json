{
    "title": "[NPC]浅析NPC脚本·上",
    "author": "Hueihuea",
    "replyCount": 5,
    "timestamp": 1550588100,
    "txt_content": " 本帖最后由 Hueihuea 于 2020-3-31 15:10 编辑 \n\n图床炸了\n推荐图片版\n嘛 讲的也不是很好 感兴趣可以参考下\n\n\n\n\nfile_1585638611000.jpg (278.13 KB, 下载次数: 3)\n\n下载附件\n\n2020-3-31 15:10 上传\n\n\n\n\n\n\n声明:\n1.如果本帖出示的源代码对noppes造成利益损失,愿意承担相关责任并删帖。\n2.本帖仅为学术交流,并非有意损害任何人的利益。\n3.我也不知道这个还能不能发mod教程版 毕竟还是讲NPC脚本的 应该没问题。\n注:本帖以1.7.10为准,1.12.2思维上类似,本帖内容根据本人理解，不能保证全部准确。\n\n首先,这不是教怎么写NPC脚本的,这是分析NPC脚本的原理，和如何用代码去修改NPC的脚本的。\n本帖主要三点:\n①NPC脚本是如何运行的？\n②NPC脚本储存在哪里？\n③如何读写NPC脚本？\n我们先说说NPC是怎么运行的。\nNPC运行原理非常简单。\n大概是这样:\n\n嘛,我们就不管MC事件发生的过程和他的处理内容了,我们知道,MC会在发生对应事件时把对应事件方法调用并传入参数就行了。\n好,我们举个例子,互动（也就是你右键NPC）事件。\n我们看看他的事件方法。\npublic boolean interact(final EntityPlayer player) {\n                //.......................\n        if (this.script.callScript(EnumScriptType.INTERACT, \"player\", player) || this.isAttacking() || this.isKilled() || this.faction.isAggressiveToPlayer(player)) {\n            return false;\n        }\n                //.......................\n        return true;\n    }复制代码好,我们关键看\nthis.script.callScript(EnumScriptType.INTERACT, \"player\", player)复制代码这一代码,\n好,我们现在要知道两个问题\n1.script是什么?\n2.callScript是怎样的方法?\n3.你应该不会问我this是什么吧\n好,我们一一解答。\n我们先看script这个属性是如何声明的。\npublic DataScript script;复制代码好,我们现在知道,他的数据类型是DataScript。\n好,到此为止,我们不继续了解script属性,而是了解DataScript。\n我们这次,主要看DataScript的callScript方法。\n  public boolean callScript(EnumScriptType type, Object... obs)\n  {\n        //.......................\n    ScriptContainer script = (ScriptContainer)this.scripts.get(Integer.valueOf(type.ordinal()));//获取对应事件脚本容器\n        //.......................\n    script.setEngine(this.scriptLanguage);//为脚本容器设置环境\n        //.......................\n    for (int i = 0; i + 1 < obs.length; i += 2)\n    {\n      Object ob = obs[(i + 1)];\n      if ((ob instanceof Entity)) {\n        ob = ScriptController.Instance.getScriptForEntity((Entity)ob);//若参数为实体则转为脚本实体类型\n      }\n      script.engine.put(obs[i].toString(), ob);//为环境写入参数\n    }\n    return callScript(script);//转交至callScript处理并返回其返回值\n  }\n    private boolean callScript(ScriptContainer script)\n  {\n    ScriptEngine engine = script.engine;//获取容器的环境\n    engine.put(\"npc\", this.dummyNpc);//写入参数npc\n    engine.put(\"world\", this.dummyWorld);//写入参数world\n    ScriptEvent result = (ScriptEvent)engine.get(\"event\");//获取事件\n    if (result == null) {\n      engine.put(\"event\", result = new ScriptEvent());//若没有事件则写入新事件\n    }\n    engine.put(\"EntityType\", entities);//写入参数EntityType\n    engine.put(\"RoleType\", roles);//写入参数RoleType\n    engine.put(\"JobType\", jobs);//写入参数JobType\n    script.run(engine);//运行脚本\n        //.......................\n    return result.isCancelled();//返回结果\n  }复制代码好,我们现在来说,callScript是一个怎样的方法。\n听仔细了！\ncallScript是一个获取对应事件的脚本容器,且给予容器环境,并为其环境写入事件参数与默认参数,最后在环境中执行脚本的一个方法！\n没听清？再来一遍！\ncallScript是一个获取对应事件的脚本容器,且给予容器环境,并为其环境写入事件参数与默认参数,最后在环境中执行脚本的一个方法！\n好,我们总结一下:\nscript是什么?\n-script是NPC的属性,他指向他的DataScript对象。\ncallScript是怎样的方法?\n-callScript是一个获取对应事件的脚本容器,且给予容器环境,并为其环境写入事件参数与默认参数,最后在环境中执行脚本的一个方法！\n问题总结完了,我们最后再来解释下名词。\nDataScript:这是存储脚本容器与脚本基础信息的地方\nScriptContainer:这是储存这脚本源代码和Engine的地方\nEngine:脚本的运行环境或者叫做虚拟机？脚本就是在Engine上运行的。\n嘛,讲的不是很好,但是代码列出来了,应该可以理解吧。\n\n图片版:\n",
    "replies": [
        {
            "author": "思望文宣",
            "timestamp": 1550588280,
            "txt_content": "前排围观qwq"
        },
        {
            "author": "思望文宣",
            "timestamp": 1550588340,
            "txt_content": "大佬很强，但看不懂，慢慢学吧"
        },
        {
            "author": "princess01",
            "timestamp": 1550595900,
            "txt_content": "我也是，学习ing"
        },
        {
            "author": "a1016746326",
            "timestamp": 1550799780,
            "txt_content": "至今还是只能浅浅的运用npc脚本..."
        },
        {
            "author": "1370698539",
            "timestamp": 1566556500,
            "txt_content": "tql,灰佬nb！"
        }
    ]
}