{
    "title": "Java世界的Lisp实现——Clojure与Minecraft 【0",
    "author": "Debug.Twilight",
    "replyCount": 8,
    "timestamp": 1465044060,
    "txt_content": " 本帖最后由 Debug.Twilight 于 2016-8-1 20:24 编辑 \n\n大家好！欢迎来到Twilight的编程讲堂，在听课之前，先介绍一下基础知识。\nJVM——全称Java Vitrual Machine，顾名思义，就是Java虚拟机，他可是整个Java世界的基础，负责的是解释Java字节码。\nJava——史上最好（垃）用（圾）的编程语言，以其出（垃）色（圾）的面对对象思想和普及度出名。\nJRE——全称Java Running Environment，Java运行环境。\n看到上面的简介，你就肯定明白，我对Java没有多少好感，是的没错，Java在我眼中就是垃圾。\n听了我这一席话，某同学可能愤然起坐，是谁占了世界排行榜第一的位置？Minecraft是神魔写的？\n这位同学，稍安勿躁，最流行的不一定是最好的，Minecraft还有22%是用Scala和C++写的呢。\nJava的面对对象机制是由C++的机制改进而来，当然正因为此，两哥们没少互掐，Java去除了C++的不足，\n多态，多继承，goto，指针等，所以Java之父称Java是“没刀枪棍棒的C++”，但他还是没有解决C++中的一些问题，\n所以它花了10年也未能干掉C++，而这时，一门古老的语言流派在竞争中露出了水面———函数式语言\n\n\n函数在某些人眼中看来（尤其是Java众）只不过是在过程上浅浅的概括一层，是低级的封装，完全不能与对象相提并论。\n这是因为我们大脑中对函数的映像都是来自于像C,C++,Python,Ruby这样不完全是函数的语言，而函数式语言中的函数与它们的函数\n有着显著不同，尤其是最古老的Lisp家族，更是大相庭径。\n\n\nLisp起源于计算机的括荒时代，上世纪五十年代末，Lisp语言首次在IBM704机上跑了起来，它与COBOL，Fortran并称编程语言三大始祖\nLISP为函数式程序设计语言，所有运算都能以函数作用于参数的方式来实LISP机器原型收藏于MIT人工智能实验室\n现。\n　　LISP没有命令式语言程序中常见赋值语句和变量，重复的过程可以使用递归的函数调用来表示，并不需要使用循环模式。\n　　LISP是古老的函数语言、弱类型、动态推断，其代码本身就是各种列表。每一个表项均可以储存任何类型的数据如数字、函数、符号或一个子表等，在编码时，可以随时操作以更新列表。\n　　LISP核心的操作符只有7个操作符：quote、atom、eq、car、cdr、cons、cond。前三者quote、atom、eq用于符号的推断；car、cdr、cons操纵表格；cond负责分支判断。这种简洁定义，非常接近图灵机原型的纯函数式语言，是现代语言完全无法比拟的。\n　　LISP作为弱类型这优点相对缺点则是运行效率的低下。原始定义简洁的缺点使到大型开发工程变得困难，自底层到高层，自二维表查询到面向对象，使用者需要嵌入更多的函数来实现，致使LISP众多方言的衍生。[6] [1] [7]\n\n语言组成[url=]编辑[/url]\n\n数据类型\nLISP只有两种数据结构，原子（atom）和表（list）。原子为标识符形式的符号或数字的字面值，表则是由零个或多个表达式组成的序列。基本上，LISP程序，并不需要使用一般表处理所必需的任意插入及删除操作。\n\n语句结构\nLISP的语法是简洁的典型，程序代码与数据的形式完全相同，以圆括号为边界的表。例如，表：\n　　(A B C D) \n　　按数据来解释时，它是一个有4个元素的表，按代码来解释时，它是将名为A的函数作用于3个参数B、C和D。\n　　在指定表结构时将表的元素放在圆括号中，简单表的元素仅限原子而成的方式是：\n　　(A B C D) \n　　嵌套表结构亦是以圆括号来表示，例如，表：\n　　(A (B C) D (E (F G))) \n　　由4个元素组成。\n　　第1个元素是原子A，第2个是子表(B C)，第3个是原子D，第4个是子表(E(F G))，它的第2个元素是子表(F G)。\n\n\n如上可见，表在Lisp语言中是最重要的数据结构。\nClojure身为Lisp的一个方言也继承了这一体系，这被称为S表达式。\n\n不不不，括号真的不会让你瞎了眼。。。\n使用括号来标注语句虽然意味着你要打一大堆的括号，而不是以更为的大括号或begin,end，\n但带来的补偿可是大大弥补了它在感官上的不足。想想看，在写表达式时完全不用管二义性\n和优先级的感觉是有多爽。\n\n\nLisp的营销\n相对于其他语言，Lisp给大众的感觉一直是难以亲近的·，但它实际上就在你的身边一直工作着\n著名的编辑器Emacs就是用Emacs Lisp写出来的，这门语言给了Emacs无敌的扩展性，AutoCAD\n的Visual LISP开发环境众人皆知，在《黑客与画家》中，作者更是以Common Lisp写出了Yahoo！Store的原型。\nLisp众很少在公共场所露过面，他们可没有心思去发展自己的狂热信徒。\nClojure中的公理\nClojure身为Lisp的一门分支，自然是少不了Lisp的公理啦：D让我们来简单的介绍一下：\n1) list\nlist函数主要的作用是创建一个列表，如下\n(list ())\n=>()\n(list a b 1)\n=>(a b 1)\n可以用list？函数检查表达式是否是列表\n(list? ())\n=>true\n(list? a)\n=>false\n2) quote 【阻止求值】\n这是Lisp最容易让人迷糊的概念了，通过以下几个实例可以让你更理解些\n(quote a)\n=>a\n\n\n(+ 1 1)\n=>2\n(quote (+ 1 1))\n=>(+ 1 1)\n看到没有，所有传给quote函数的东西，无论是表达式还是变量，都原封不动的给吐了回来。\n在Clojure中，相对于它的语法糖是'(单引号).\n'(+ 1 1)\n=>(+ 1 1)\n\n条件判断\n'clojure中的条件判断用的也是if，但结构却又有所不同，如下\n\n(if 判断条件\n  表达式A;;如果成立就执行它\n  表达式B;;否就是它)\n注意：表达式如果不止一个，就必须要用do括在一起。do函数会对各个表达式依次求值，最后一个函数的值就是返回值。\n(if true\n  (do\n    (a)\n    (b))\n  (do\n    (c)\n    (b)))\n=>b\n如果要多次判断，可以用类似else if的cond\n或类似switch的when。\n(when a\n  1 b\n  2 c)\n=>b或c\n(cond \n  ((= a 1) c)\n  ((= b 1) d))\n循环：\nClojure提供了两种循环，函数式的for和命令式的doseq，两者有着很大的不同\ndoseq的用法类似Java中的for(type let-val：value),是把value的内容逐个抽出来，对其进行操作。\n(doseq [绑定的变量 列表]\n           操作1\n           操作2\n           ...\n           操作n)   \nfor的用法类似，但是如果有多于一个的操作就要用do把它们括起来，\nfor会把每次对值的操作汇集到一个列表里面，然后返回这个列表。\n举个例子：\n(for [x [1 2 3 4 5]]\n       (+ x 1))\n;=>(2 3 4 5 6)\n当然，还有更为底层的循环函数：loop和recur\n看看一个例子：\n(loop [x 1]\n         (println x)\n         (recur (+ x 1)))\nloop把1绑定到x上，中途打印了x\n而recur把(+ x 1)作为新的绑定返回loop头。recur不只能在loop中使用，如果没找到loop，他就会把函数头作为loop头\n这里有个问题，一旦碰到了recur，就会跳过剩下的代码，直接返回loop，所以这是一个死循环，最好还是拿一个if来限制住它。\nloop函数中如果没有recur来跳转，就只回执行一次。\n通常你不会遇到使用recur的场景，除非必要，不要使用它。\n\n\nClojure的数据类型\nclojure的数据类型大多数重用了Java的数据类型。\nClojure的数字对应Java的各种数字\n  2.  Clojure的复合数据结构（散列，列表，vector，set）对应java.util中的类型\nClojure的高效数据操作使得它在JVM语言中排名前列（Github排名20），下面让我们分别讨论它们。\n\n[url=]s[/url]\n[url=]t[/url]\n\n",
    "replies": [
        {
            "author": "Debug.Twilight",
            "timestamp": 1465044600,
            "txt_content": "Clojure的语言特性明天再补上，有兴趣的朋友可以看这里Clojure官网"
        },
        {
            "author": "andylizi",
            "timestamp": 1465050900,
            "txt_content": " 本帖最后由 andylizi 于 2016-6-4 22:58 编辑 \n看到上面的简介，你就肯定明白，我对Java没有多少好感，是的没错，Java在我眼中就是垃圾。如果我这个渣渣的感觉没错的话帖内似乎在说函数式语言有多么好，但是似乎并没有提到Java有多么差耶。有那么一霎那我还以为LZ的意思是”Java和函数式语言是完全相对的”呢，当然，我理解错了。\n\nJava去除了C++的不足，多态，多继承，goto，指针等啥？Java去除了多态？\n\n所以它花了10年也未能干掉C++，啥？一种新编程语言的发明就是为了干掉其他语言？\n\n所以Java之父称Java是“没刀枪棍棒的C++”啥？他说过这句话么？还真没听说过，肯定是我火星了。不过怎么百度也没找到耶，真奇怪，肯定是百度有问题。\n\n但他还是没有解决C++中的一些问题，\n而这时，一门古老的语言流派在竞争中露出了水面———函数式语言C++中的……哪些问题？\n\nMinecraft还有22%是用Scala和C++写的呢。啥？MC里有Scala？还真没听说过，肯定是我又火星了\nC++的部分我只找到了mc运行所需的动态链接库，这也是没办法的，lwjgl之类的必须得用，但为啥我感觉“MC有一部分用C++写”这个表达方式有点不对劲呢。哎肯定是我语言没学好。\n\n于是这个帖子的目的到底是什么？LZ先说Java与面向对象都是垃圾，一会拿面向对象的Java与同样是面向对象的C++比，说Java仍然有不足没能把C++干掉，然后又开始说起了函数式语言，最后感觉全篇的意思都是在说 函数式语言比面向对象好，觉得有一点很奇怪，既然函数式语言这么牛逼而且出现的比面向对象早多了还被赞誉为“编程语言三大始祖”为何人们用的最多的还是面向对象呢？既然LZ这么看不起java为何想要在一个主题为一个java编写的游戏的大型论坛里介绍运行在Java平台上的似乎在这个论坛并没有多少人知道Clojure？\n\n望您能抽出宝贵的时间回答一下我的问题，感激不尽。"
        },
        {
            "author": "aa957189313",
            "timestamp": 1465051260,
            "txt_content": "啥，我怎么这么火星呢"
        },
        {
            "author": "0x3B800001",
            "timestamp": 1465052520,
            "txt_content": "看完lz的帖子，真是“长见识了”"
        },
        {
            "author": "jkaa13579",
            "timestamp": 1465120680,
            "txt_content": "孩子，你没写过程序？每个编程语言有每个的偏向特点这个都不懂？？喜欢弱语言干嘛不去写C？或者直接汇编、机器码？"
        },
        {
            "author": "Debug.Twilight",
            "timestamp": 1465401420,
            "txt_content": "好了，接着扯淡。\n楼上那几位叫嚣的也说了，Java所采用的面对对象貌似来看是目前最好的解决方法，\n（还有，高斯林是说过这句话的，不知道就显得你图样图森破了）\n我在此介绍Clojure，是为了给大家带来一种截然不同的思考方法。\n啥？你说Lisp不流行，说它几十年来默默无闻？大哥，那你可真不是一名标准的极客。\nMacintosh之父在《黑客与画家》里面都把Lisp捧上天啦，史蒂夫.雅各在《程序员的呐喊》里把Lisp更是\n把Lisp誉为神的语言，哪个程序员没读过《黑客与画家》就该狠狠地抽自己一巴掌。：D\n虽然《黑客与画家》里确实有推销的成分，但Lisp从来可不是为了占领全世界而想的呀，\nJava的营销是靠Sun公司用钱主打，Oracle用口碑堆出来的，Perl的营销是靠拉里出色的推销手段，\nPython和Ruby靠的是其口碑相传。而Lisp众从来不把营销当回事（说实在Python众也是）\n为什么我们要抢占市场呀。\n函数式编程是以其简单粗暴的手段而有效的，Lisp又把它和自己高效的数据操作能力结合在一起，\n组成的高效数据结构这才是Lisp的精髓——列表"
        },
        {
            "author": "aa957189313",
            "timestamp": 1465998000,
            "txt_content": "我读书少，我只知道0和1就够用了，还用啥语言"
        },
        {
            "author": "Debug.Twilight",
            "timestamp": 1466312640,
            "txt_content": "aa957189313 发表于 2016-6-15 21:40\n我读书少，我只知道0和1就够用了，还用啥语言\n好啊，那你用1和0在x86机器上的windows写一个扫雷，然后移植到arm上的linux上"
        }
    ]
}