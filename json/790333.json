{
    "title": "[C++&Java]MC反作弊开发日记-第一章-纯Java编写Mod校验[PCD]",
    "author": "萝娜娜",
    "replyCount": 3,
    "timestamp": 1532810640,
    "txt_content": " 本帖最后由 lona 于 2018-7-31 02:04 编辑 \n\n【MC反作弊开发日记-第一章-纯Java编写Mod校验】第一节-需求分析在本节我们将要分析如何设计一个使用BukkitAPI以及ForgeAPI的Mod校验应用。一.通信模型    我们采用C-S模型即client-server（客户端-服务器模型）。    在这个模型中需要注意5点。        1.请求由客户端发起        2.客户端任何信息都不可信任        3.服务器需要能同时响应多个请求         4.设计服务器时安全性排在第一位        5.通信过程需要加密（解决第二点客户端不可信）\n二.客户端设计    1.分析        1).文件校验            (1).需要校验的文件存在多个            (2).需要校验的文件可能存在因为某些问题而读取失败\n            (3).读取文件时可能被hook（例如hook住ReadFile函数）\n            (4).读取到的数据在内存中可能被篡改\n                  ①.客户端被修改\n                  ②.直接在文件读取完成后修改内存区域（基本没人用这种办法吧）\n            (5).采用何种Hash算法\n        2).数据传给服务器            (1).传输可能加密            (2).传输可能中断            (3).传输可能被拦截    2.实现        1).文件校验            (1).对目录进行遍历            (2).读取失败时停止校验并且发送读取失败消息给服务器            (3).现阶段无法防止Hook            (4).现阶段无法防止修改            (5).javaAPI(SE)自带的API中已经有SHA MD5 CRC等实现        2).数据传输            (1).加密过程以服务器为主导            (2).中断即失败，此时需要退出在线游戏或者客户端            (3).现阶段无法判断拦截            (3).使用MC通信协议的plugin channel进行数据传输（单个包不大于64千字节）            (4).使用PCD_ANTICHEAT_MOD作为plugin channel的name        3).Forge Mod三.服务器设计    1.分析        1).接收客户端数据            (1).同时可能存在多个客户端连接            (2).客户端数据可能有假            (3).客户端客户端可能利用协议进行攻击        2).对数据进行处理            (1).校验失败            (2).校验成功    2.实现        1).数据传输            (1).bukkit服务端已经为我们很好的管理了这个情况，所以不需要处理            (2).通信加密来防止伪造的客户端            (3).限制客户端连接次数和流量        2).数据处理            (1).将玩家踢出并记录相关信息            (2).记录相关信息第二节-源代码可以说是非常精简的一个反作弊，全部只有286行代码一.git    1.请使用git下载最新源码,二.服务端源码package lona.java.minecraft.bukkit.pcdtac;\n\nimport com.google.common.io.ByteArrayDataInput;\nimport com.google.common.io.ByteArrayDataOutput;\nimport com.google.common.io.ByteStreams;\nimport org.apache.commons.io.FileUtils;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.event.player.PlayerQuitEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class PCDTAC extends JavaPlugin implements Listener {\n\n    public static final String PLUGIN_CHANNEL_NAME = \"PCDTAC\";\n    private Map<String, Integer> uncheckPlayerMap;\n    private List<String> acceptableFileList;\n    private byte[] requestHashPacketData;\n\n    public enum PacketType {\n        RequestClientModFileHash(0),\n        ReplyClientModFileHash(1);\n\n        PacketType(int packet_id) {\n            this.packet_id = (byte) packet_id;\n        }\n\n        private byte packet_id;\n\n        public byte getPacket_id() {\n            return packet_id;\n        }\n\n        public static byte getLastPacketID() {\n            return ReplyClientModFileHash.packet_id;\n        }\n    }\n\n    public enum KickReason {\n        BadPacket(\"通信错误\"),\n        UnacceptableMod(\"存在不允许安装的Mod\"),\n        Timeout(\"超时\"),\n        Unknow(\"出现未知错误\");\n\n        KickReason(String reason) {\n            this.reason = reason;\n        }\n\n        private String reason;\n\n        public String getReason() {\n            return reason;\n        }\n    }\n\n    public PCDTAC() {\n        uncheckPlayerMap = new ConcurrentHashMap<>();\n\n        ByteArrayDataOutput dataOutput = ByteStreams.newDataOutput();\n        dataOutput.writeByte(PacketType.RequestClientModFileHash.getPacket_id());\n        requestHashPacketData = dataOutput.toByteArray();\n    }\n\n    @Override\n    public void onEnable() {\n        try {\n            acceptableFileList = FileUtils.readLines(new File(\".\" + File.separator + \"plugins\" + File.separator + \"PCDTAC\" + File.separator + \"fileList.txt\"), \"UTF-8\");\n        } catch (IOException e) {\n            acceptableFileList = new ArrayList<>();\n            getLogger().info(\"读取fileList.txt失败\");\n        }\n        getServer().getPluginManager().registerEvents(this, this);\n        getServer().getMessenger().registerOutgoingPluginChannel(this, PLUGIN_CHANNEL_NAME);\n        getServer().getMessenger().registerIncomingPluginChannel(this, PLUGIN_CHANNEL_NAME, (String channel_name, Player player, byte[] payload) -> {\n            ByteArrayDataInput dataInput = ByteStreams.newDataInput(payload);\n            try {\n                //读取包ID\n                final byte packet_id = dataInput.readByte();\n                //检查包ID是否正常\n                if (packet_id > PacketType.getLastPacketID()) {\n                    kickPlayer(player, KickReason.BadPacket);\n                } else {\n                    //分包\n                    if (packet_id == PacketType.ReplyClientModFileHash.getPacket_id()) {\n                        final short numOfFile = dataInput.readShort();\n                        List<Map.Entry<String, String>> hashList = new ArrayList<>();//Map.Entry<fileName,hashValue>\n                        for (short i = 0; i < numOfFile; i++) {\n                            hashList.add(new AbstractMap.SimpleEntry<>(dataInput.readUTF(), dataInput.readUTF()));\n                        }\n                        if (isFileListAcceptable(hashList)) {\n                            uncheckPlayerMap.remove(player.getName());\n                        } else {\n                            kickPlayer(player, KickReason.UnacceptableMod);\n                        }\n                    } else//不可解析的包\n                    {\n                        kickPlayer(player, KickReason.BadPacket);\n                    }\n                }\n\n            } catch (Exception e) {\n                kickPlayer(player, KickReason.Unknow);\n            }\n        });\n\n        getServer().getScheduler().runTaskTimer(this, () -> {\n            final Set<String> players = uncheckPlayerMap.keySet();\n            for (String playerName : players) {\n                int timeout = uncheckPlayerMap.get(playerName);\n                if (timeout > 0) {\n                    uncheckPlayerMap.put(playerName, timeout - 1);\n                } else {\n                    kickPlayer(playerName, KickReason.Timeout);\n                }\n            }\n        }, 20, 20);\n        getLogger().info(\"反作弊插件载入成功\");\n    }\n\n    @Override\n    public void onDisable() {\n\n    }\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent event) {\n        final String playerName = event.getPlayer().getName();\n        getServer().getScheduler().runTaskLater(this, () -> {\n            final Player player = getServer().getPlayer(playerName);\n            player.sendPluginMessage(this, PLUGIN_CHANNEL_NAME, requestHashPacketData);\n            uncheckPlayerMap.put(playerName, 5);\n        }, 20 * 1);\n    }\n\n    @EventHandler\n    public void onPlayerExit(PlayerQuitEvent event) {\n        uncheckPlayerMap.remove(event.getPlayer().getName());\n    }\n\n    private void kickPlayer(Player player, KickReason reason) {\n        player.kickPlayer(reason.getReason());\n        uncheckPlayerMap.remove(player.getName());\n    }\n\n    private void kickPlayer(String playerName, KickReason reason) {\n        kickPlayer(getServer().getPlayer(playerName), reason);\n    }\n\n    public boolean isFileListAcceptable(List<Map.Entry<String, String>> hashList) {\n        for (Map.Entry<String, String> pair : hashList) {\n            if (!isFileAcceptable(pair.getKey(), pair.getValue())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean isFileAcceptable(String fileName, String hashValue) {\n        return acceptableFileList.contains(hashValue);\n    }\n}\n\n\n三.客户端代码package lona.java.minecraft.forge.pcdtac;\n\nimport com.google.common.io.ByteArrayDataInput;\nimport com.google.common.io.ByteArrayDataOutput;\nimport com.google.common.io.ByteStreams;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport net.minecraft.network.PacketBuffer;\nimport net.minecraftforge.common.MinecraftForge;\nimport net.minecraftforge.fml.common.FMLCommonHandler;\nimport net.minecraftforge.fml.common.Mod;\nimport net.minecraftforge.fml.common.Mod.EventHandler;\nimport net.minecraftforge.fml.common.event.FMLInitializationEvent;\nimport net.minecraftforge.fml.common.event.FMLPreInitializationEvent;\nimport net.minecraftforge.fml.common.eventhandler.EventPriority;\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\nimport net.minecraftforge.fml.common.network.FMLEventChannel;\nimport net.minecraftforge.fml.common.network.FMLNetworkEvent;\nimport net.minecraftforge.fml.common.network.NetworkRegistry;\nimport net.minecraftforge.fml.common.network.internal.FMLProxyPacket;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport static lona.java.minecraft.bukkit.pcdtac.PCDTAC.PLUGIN_CHANNEL_NAME;\n\nimport lona.java.minecraft.bukkit.pcdtac.PCDTAC.PacketType;\n\n@Mod(modid = PCDTAC.MODID, name = PCDTAC.NAME, version = PCDTAC.VERSION, acceptedMinecraftVersions = \"[1.8,1.12.2]\")\npublic class PCDTAC {\n    public static final String MODID = \"pcdtac\";\n    public static final String NAME = \"PCDTAC\";\n    public static final String VERSION = \"1.0.0\";\n    private FMLEventChannel channel;\n    private static final String modsDirPath = System.getProperty(\"user.dir\") + File.separator + \"mods\";\n\n    @EventHandler\n    public void preInit(FMLPreInitializationEvent event) {\n    }\n\n    @EventHandler\n    public void init(FMLInitializationEvent event) throws IOException, NoSuchAlgorithmException {\n        List<Map.Entry<String, String>> modFileHashList = getModFileHashList();\n        File file = new File(\".\" + File.separator + \"mods\" + File.separator + \"PCDTAC\" + File.separator + \"fileList.txt\");\n        if (!file.getParentFile().exists()) {\n            file.getParentFile().mkdirs();\n        }\n        for (Map.Entry<String, String> fileHash : modFileHashList) {\n            FileUtils.write(file, fileHash.getValue() + '\\n', \"UTF-8\", true);\n        }\n        FMLCommonHandler.instance().bus().register(this);\n        MinecraftForge.EVENT_BUS.register(this);\n        (channel = NetworkRegistry.INSTANCE.newEventDrivenChannel(PLUGIN_CHANNEL_NAME)).register(this);\n    }\n\n    @SubscribeEvent(priority = EventPriority.LOWEST)\n    @SideOnly(Side.CLIENT)\n    public void onServerCustomPacket(FMLNetworkEvent.ClientCustomPacketEvent event) {\n        try {\n            final Field packetField = event.getClass().getSuperclass().getDeclaredField(\"packet\");\n            final FMLNetworkEvent.CustomPacketEvent customPacketEvent = event;\n            packetField.setAccessible(true);\n            final FMLProxyPacket packet = (FMLProxyPacket) packetField.get(customPacketEvent);\n            ByteBuf buffer = packet.payload();\n            byte[] data = new byte[buffer.readableBytes()];\n            buffer.readBytes(data);\n            ByteArrayDataInput dataInput = ByteStreams.newDataInput(data);\n            byte packet_id = dataInput.readByte();\n            if (packet_id == PacketType.RequestClientModFileHash.getPacket_id()) {\n                ByteArrayDataOutput dataOutput = ByteStreams.newDataOutput();\n                List<Map.Entry<String, String>> modFileHashList = getModFileHashList();\n                dataOutput.writeByte(PacketType.ReplyClientModFileHash.getPacket_id());\n                dataOutput.writeShort(modFileHashList.size());\n                for (Map.Entry<String, String> pair : modFileHashList) {\n                    dataOutput.writeUTF(pair.getKey());\n                    dataOutput.writeUTF(pair.getValue());\n                }\n                channel.sendToServer(new FMLProxyPacket(new PacketBuffer(Unpooled.wrappedBuffer(dataOutput.toByteArray())), PLUGIN_CHANNEL_NAME));\n            }\n        } catch (NoSuchFieldException | IllegalAccessException | IOException | NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getFileHash(File file) throws IOException, NoSuchAlgorithmException {\n        byte[] fileData = FileUtils.readFileToByteArray(file);\n        MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n        messageDigest.update(fileData);\n        byte[] hashBytes = messageDigest.digest();\n        StringBuilder hash = new StringBuilder();\n        for (byte b : hashBytes) {\n            hash.append(String.format(\"%02X\", b));\n        }\n        return hash.toString();\n    }\n\n    public List<Map.Entry<String, String>> getModFileHashList() throws IOException, NoSuchAlgorithmException {\n        File[] files = new File(modsDirPath).listFiles((File file) -> file.getName().toLowerCase().endsWith(\"jar\") || file.getName().toLowerCase().endsWith(\"zip\"));\n        List<Map.Entry<String, String>> modFileHashList = new ArrayList<>();\n        assert files != null;\n        for (File file : files) {\n            String hash = getFileHash(file);\n            modFileHashList.add(new AbstractMap.SimpleEntry<>(file.getPath(), hash));\n        }\n        return modFileHashList;\n    }\n\n}\n\n\n[groupid=1330]PluginsCDTribe[/groupid]",
    "replies": [
        {
            "author": "117779284",
            "timestamp": 1532815500,
            "txt_content": "\n\n给我个成品就可以了··"
        },
        {
            "author": "erry64",
            "timestamp": 1532831760,
            "txt_content": "我一直在想有没有可能动态编译混淆反作弊mod"
        },
        {
            "author": "萝娜娜",
            "timestamp": 1532851680,
            "txt_content": "berry64 发表于 2018-7-29 10:36\n我一直在想有没有可能动态编译混淆反作弊mod\n没意义，纯java写的反作弊mod实际上并没有什么卵用"
        }
    ]
}