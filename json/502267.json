{
    "title": "【万年坑】【本章完结】Java高手训练营第六章：String和StringBuffer",
    "author": "ufof",
    "replyCount": 11,
    "timestamp": 1442325960,
    "txt_content": " 本帖最后由 ufof 于 2016-5-5 00:25 编辑 \n\n\n6.1 声明并创建字符串\n\n\n6.1.1 字符串概述\n\n基本数据类型的字符只能够存储一个字符。例如'a'、'5'、'哦'等。但是在生活中，文字是由若干个字符组成的。例如\"I like Java\"，由11个字符组成。在程序当中文字也是十分可见。可以得出结论，光有字符远远不够。\n\n字符串顾名思义，就是“多个字符串起来”。可以存储多个字符就是了。在程序当中字符串的应用十分之多，必须要掌握字符串才可以真正投入到开发当中。\n\n6.1.2 字符串的声明和创建\n\n字符串是一个类，类名叫做String。我们在讲面向对象的时候讲过实例化。String类也一模一样。\nString myString;复制代码创建myString实例。\n\nString类提供了大量的构造方法。先讲这个两个：\nString()  用于创建0个字符的空字符串\nString(String original)  用于创建一个字符串的副本\n其他的一些构造方法涉及到字符的数组。我们还没有学到。\n\nString myString = new String();                                //空字符串\nString myString2 = new String(\"hello, string\");             //内容为hello, string的字符串复制代码其实也可以赋给一个字面量：\n\nString myString = \"hello, string\";复制代码\n\n我们再来打印一下：\n\nclass StringDemo{\n    public static void main(String[] args){\n        String myString = \"hello, string\";\n        System.out.println(myString);\n    }\n}复制代码结果：\n\n\n\n\n注：字符串类还有一个小特点：其永远无法被改变。但是可以被重新赋值。\n\n本章小结\n字符串是一个类。其用于存储若干个字符字符串有两种构造方法：String()、String(String origin)\n\n\n\n6.2 字符串的连接以及获取字符串信息\n\n\n6.2.1 字符串的连接\n\n字符串的连接不仅仅可以对字符串，还可以连接基本数据类型。其实我们之前在打印输出语句中早就有过这样的操作。\n通过加号+进行字符串的连接。\n\nclass StringConnection {\n    public static void main(String[] args) {\n        String str;\n        String str1 = \"hello \";\n        String str2 = \"world\";\n        \n        str = str1+str2;\n        System.out.println(str);\n    }\n}复制代码结果：\n\n\n\n\n在这个实例中，String类引用str1和str2连接之后，赋给了未初始化的引用str。打印之后即为hello world。\n基本数据类型照样可以连接，但是这样的写法是不对的：\n\nclass StringConnection {\n    public static void main(String[] args) {\n        String str;\n        int a = 2;\n        int b = 33;\n        \n        str = a+b;\n        System.out.println(str);\n    }\n}复制代码结果：\n\n\n\n这是为什么？这是因为a和b是两个整数类型。运用加号“+”，系统会认为你是在做加法运算，而非字符串的连接。加法运算返回的必定是一个数值类，然而数值类不能赋给str。\n\n那么我们如何解决这个问题呢？\n\nclass StringConnection {\n    public static void main(String[] args) {\n        String str;\n        int a = 2;\n        int b = 33;\n        \n        str = a+\"\"+b;\n        System.out.println(str);\n    }\n}复制代码结果：\n\n\n\n在这个字符串的连接中，我加了一点手脚。在a+\"\"+b中，中间我加了一个没有字符的字符串。这样系统就知道了我们是在做字符串连接，而非加法运算。\n\n6.2.2 获取字符串信息：length()方法\n\n这个方法返回int类型，不接收参数。\n用途是其可以返回改字符串的长度，即有几个字符。\n\nclass StringLengthDemo {\n    public static void main(String[] args) {\n        String str = \"233\";\n        System.out.println(str);\n        \n        System.out.println(str.length());\n    }\n}复制代码结果：\n\n\n\n在这个程序中，字面量\"233\"赋给了str引用。在打印输出str后，调用其的length()方法并输出其返回值。由于233共有三个字符，打印出来的便为3。\n\n6.2.3 获取字符串信息：startsWith()和endsWith()方法\n\n这两个方法返回布尔类型，接受的参数为字符串类型。\n方法的用途适用于检测字符串是否已指定的另一个字符串（即传进去的参数）开头/结尾。如果是返回true，反之亦然。\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"Java我要学会你\";\n        System.out.println(\"str是否以'Java'开头？\"+str.startsWith(\"Java\"));\n        System.out.println(\"str是否以句号结尾？\"+str.endsWith(\"。\"));\n    }\n}复制代码结果：\n\n\n\n简单的来说，因为str的确以Java开头，所以为true；其没有用句号结尾，所以为false。\n\n6.2.4 获取字符串信息：equals()和equalsIgnoreCase()方法\n\n这两个方法是十分常见的。由于字符串是引用数据类型，其不能用“==”来比较两个字符串内容是否相同。因此java为我们听过了比较两个字符串内容的方法。\n\nequals()和equalsIgnoreCase()两个方法的返回值都是boolean，接受的参数为另一个字符串。如果两个字符串内容一致，返回true，反之亦然。（其实equals()方法接受的是Object类，但是没有学到）\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"hello\";\n        System.out.println(\"在考虑大小写的情况下，str内容是否为Hello？\"+str.equals(\"Hello\"));\n        System.out.println(\"在不考虑大小写的情况下，str内容是否为Hello？\"+str.equalsIgnoreCase(\"hello\"));\n    }\n}复制代码结果：\n\n\n\nstr的值为\"hello\"，全部为小写。在调用equals方法时，传进去的参数为\"Hello\"，第一个字母是大写，所以返回false。但是调用equalsIgnoreCase()方法时，由于其不考虑大小写的问题，返回true。\n\n本章小结\n字符串可以通过加号+来连接。基本数据类型也可以互相连接成字符串字符串的length()方法返回字符串的字符数量字符串的startsWith()和endsWith()方法用于探测字符串是否以特定的字符串开头/结尾字符串的equals()和equalsIgnoreCase()用于比较两个字符串的内容。后者不考虑大小写\n\n\n\n6.3 字符串的操作\n\n\n这个章节我就粗略的把String类中的方法过一遍，不会对每一个方法都讲得十分详细了。\n\n6.3.1 subString()方法\n\nsubString()方法用于截取字符串的一部分来返回一个子字符串。其有两个方法被重载：\nsubString(int beginIndex)\nsubString(int beginIndex, int endIndex)复制代码第一种方法返回从指定的下标直到字符串结尾的子字符串，第二种即可以指定结束的位置。\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"123456789\";\n        String sub = str.substring(3);\n        System.out.println(sub);\n    }\n}复制代码结果：\n\n\n\n由于下标是从0开始算起的，第三个下标其实是第四个字符。所以说从4~9的字符串就被截取了。\n\n\n\n第二种方法本质来讲也一样，只是可以控制子字符串的结束位置：\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"123456789\";\n        String sub = str.substring(3,7);\n        System.out.println(sub);\n    }\n}复制代码结果：\n\n\n\n\n\n6.3.2 trim()方法\n\ntrim()很容易理解。就是返回删除掉字符串前端的空格以及后端的空格的副本字符串。\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"     hello, world      \";\n        String str2 = str.trim();\n        System.out.println(str2);\n    }\n}复制代码结果：\n\n\n\n6.3.3 replace()方法\n\nreplace方法是将字符串中指定的字符替换成另外一个指定的字符并返回副本。接收的参数如下：\nreplace(char oldChar, char newChar)复制代码其在字符串中的oldChar替换成newChar。\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"hello, world\";\n        String str2 = str.replace('l', 'r');\n        System.out.println(str2);\n    }\n}复制代码结果：\n\n\n\n6.3.4 toLowerCase()和toUpperCase()方法\n\ntoLowerCase()方法用于将字符串中的所有大写字母改成小写字母并返回副本；toUpperCase()用于将字符串中的所有小写字符改成大写字母并返回副本。\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"hello, world\";\n        String str2 = str.toUpperCase();\n        System.out.println(str2);\n    }\n}复制代码结果：\n\n\n\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"HELLO, WORLD\";\n        String str2 = str.toLowerCase();\n        System.out.println(str2);\n    }\n}复制代码结果：\n\n\n\n6.3.5 concat()方法\n\nconcat方法用于在原有字符串后追加另一个字符串并返回其副本。\nclass StringMethodsDemo {\n    public static void main(String[] args) {\n        String str = \"hello\";\n        str = str.concat(\", world\");\n        System.out.println(str);\n    }\n}复制代码结果：\n\n\n\n从某种角度来讲这和连接字符串没有多少区别。\n\n\n本章小结\nsubString()方法用于截取字符串返回指定范围的子字符串trim()用于将前端和后端的空格消掉并返回副本\nreplace()用于将字符串中指定的字符替换成另外一个字符并返回副本toLowerCase()以及toUpperCase()用于将字符串的所有小写字母替换到大写字母/大写字母替换到小写字母并返回副本concat()方法用于对字符串进行追加并返回副本\n\n\n\n6.4  认识StringBuffer\n\n\n6.4.1 StringBuffer类概述\n\nJava中的String类是不可变的。所以说如果我们想要对字符串进行编辑（例如追加、替换、删除）操作，需要产生过多的String实例。这样做十分耗费内存。所以说Java为我们提供StringBuffer类。StringBuffer字面意义为“字符串缓冲区”，其可以在不创建多个实例的情况下对字符串进行编辑。\n\n学生提问：StringBuffer和StringBuilder有区别吗？\n\n答：从功能上来讲，两者没有区别。但是StringBuffer是线程同步的，StringBuilder是异步的。简单的来说StringBuffer更加安全。但是StringBuilder的速度和效率更高。关于线程方面以后在讲多线程的时候回有进一步的了解。由于现在我们的程序都是单线程的，推荐StringBuilder。\n\n6.4.2 StringBuffer的构造方法\n\nStringBuffer常用的构造方法有以下三种：\nStringBuffer()                        //空StringBuffer\nStringBuffer(int capacity)        //用于在声明时定义长度\nStringBuffer(String str)           //用于在声明时将内容设置为该字符串复制代码\n\n6.4.3 StringBuffer的特点\n\nStringBuffer有以下特点\nStringBuffer是一个容器StringBuffer长度可变许多方法与String相同\n\n下一章开始我们就开始讲StringBuffer的应用了。\n\n本章小结\nStringBuffer用于对字符串进行更方便的编辑StringBuffer和StringBuilder从功能上没有多大区别，但是安全性和效率有出入StringBuffer是一个容器\n\n\n\n6.5 StringBuffer的增删改查\n\n\n6.5.1  增：append()\n\nappend()方法是StringBuffer中最常用之一的一个方法。其的作用是在已有字符串的末尾处添加数据。而这个方法有许多的参数重载。API给出的方法详情如下：\n\n\n可以看出来，append()方法可以接受所有的基本数据类型，以及引用数据类型，还有字符串。\n\n我们来写一个小实例：\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer();\n        sb = sb.append(\"abc\");\n        sb = sb.append(89);\n        sb = sb.append(true);\n        System.out.println(sb);\n    }\n}复制代码结果：\n\n\n\n在第四、五、六行，通过StringBuffer的append方法在其末尾处添加一些数据。第一次添加的是字符串\"abc\"，第二次是int类型89，第三次是布尔型true。将其打印输出之后为“abc89true”，可以得出结论，append()方法是在末尾处添加的。\n\n我们已经讲过了，StringBuffer是一个容器。所以说最最赞的地方就是在append()之后根本不需要把值赋给自己。\n所以说上述代码可以简化为：\n\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"abc\");\n        sb.append(89);\n        sb.append(true);\n        System.out.println(sb);\n    }\n}复制代码因为append()返回值是其本身，也可以一连串的添加：\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"abc\").append(89).append(true);\n        System.out.println(sb);\n    }\n}复制代码这样写结果不变。\n\n6.5.2 改：insert()\n\n我们刚才讲的append()方法是在其末尾处添加数据的。但是有的时候我们想要在其中间插入，可以用到insert()方法。\n同样，insert()有多个方法重载：\n\n\n\n第一个参数int offset是要替换的下标，换句话说就是字符的位置，从0开始。第二个参数就是要插入的数据了，其支持所有基本数据类型，引用类型，以及字符串。\n\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer(\"abcdefghijk\");\n        sb.insert(2, '哈');\n        System.out.println(sb);\n    }\n}复制代码结果：\n\n\n\n在程序的第四行，通过insert()方法将第二个下标，也就是第三个字符的位置插入了字符'哈'。\n\n6.5.3 删：delete()\n\ndelete()方法所接受的参数为两个int类型。这个方法会将其所指定的范围内的字符删除。第一个参数定义的是删除范围的开始的下标（包括），第二个参数定义的是删除范围的结束下标（不包括）。\n\n如果两个参数相同，不会有改变；如果第二个参数小于第一个参数，报错。\n\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer(\"0123456789\");\n        sb.delete(4, 7);\n        System.out.println(sb);\n    }\n}复制代码结果：\n\n\n\n在这个程序中，通过delete()方法将下标为4（包括）知道下标为7（不包括）范围内的所有字符删除。在这个例子当中'4'、'5'和'6'被删除。\n\n6.5.4 删：deleteCharAt()\n\n这个方法的功能也是用于删除。不过delete()方法是删除一个范围内的字符；deleteCharAt()是删除特定的下标的字符。其接收的参数为一个int。\n\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer(\"0123456789\");\n        sb.deleteCharAt(6);\n        System.out.println(sb);\n    }\n}复制代码结果：\n\n\n\n这个程序当中，第6个下标的字符被删除，也就是字符'6'。\n\n6.5.5  查：charAt()\n\ncharAt()接收的参数是一个int类型。其将会返回所对应下标的字符。\npublic class StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer(\"0123456789\");\n        System.out.println(sb.charAt(8));\n    }\n}复制代码结果：\n\n\n\n在这个程序当中，通过charAt()方法返回第8个下标字符，也就是'8'。\n\n6.5.6  查：toString()\n\n我们通过StringBuffer将字符串编辑完了，现在我想要让他把其所容纳的所有字符转换成字符串，可以通过toString()方法实现。该方法不接受任何参数，只返回一个字符串类型。\n\nclass StringBufferDemo {\n    public static void main(String[] args) {\n        StringBuffer sb = new StringBuffer(\"0123456789\");\n        String result = sb.toString();\n        System.out.println(result);\n    }\n}复制代码结果：\n\n\n\n声明字符串类型result，将sb通过toString()方法转换成字符串并赋给result。然后输出result，即的出来了StringBuffer中容纳的所有字符。\n\n本章小结：\nappend()用于在末尾添加数据类型insert()用于替换特定下标的值delete()用于删除特定范围的字符deleteCharAt()用于删除特定下标的字符charAt()用于返回特定的下标的字符toString()用于将StringBuffer中所容纳的字符转换成字符串\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "DarcJC",
            "timestamp": 1453816680,
            "txt_content": "哎= =发现这也是重新赋值了= =\n\n\n可以被改变吧= =\n就比如这样\n\nString QwQ = \"Hello\";\nQwQ = QwQ.substring(0, 3) + \"p!\";\nprint (QwQ);复制代码\n然后输出结果就变成Help!了。。。"
        },
        {
            "author": "Innovators",
            "timestamp": 1453819620,
            "txt_content": "z25096708 发表于 2016-1-26 21:58\n哎= =发现这也是重新赋值了= =\n666，但是help！是怎么出来的"
        },
        {
            "author": "ufof",
            "timestamp": 1453821300,
            "txt_content": "z25096708 发表于 2016-1-26 05:58\n哎= =发现这也是重新赋值了= =\n这是一个很常见的误区。\n“不可改变”的意思是一个对象一经创建就不可改变。字符串\"abc\"就是\"abc\"，这是不可改变的。层主做的只是把一个字符串实例重新赋值了一遍罢了。要知道对象和实例是有区别的。"
        },
        {
            "author": "cesium_fluoride",
            "timestamp": 1462389720,
            "txt_content": " 本帖最后由 cesium_fluoride 于 2016-5-5 14:43 编辑 \n\n6.5.2，StringBuffer的方法insert是插入而非替换吧..."
        },
        {
            "author": "Modic",
            "timestamp": 1469199180,
            "txt_content": "Innovators 发表于 2016-1-26 22:47\n666，但是help！是怎么出来的\n虽然已经隔了好几个月了.....是这样的，字符串相当于指向内存中一个对象的指针（不过java里面没有指针），当你对这个字符串重新赋值的时候，是在内存里面新建了一个对象，内容是<help!>，但并不是之前那个对象了，也就是说，这个时候内存里面同时存在<help>和<help!>，然后垃圾回收机制发现这个<help>没人用了，就把它删了。所以说，string1 = new string(\"help\"), string2 = new string(\"help\")时，string1 == string2为false"
        },
        {
            "author": "IDE_helloender",
            "timestamp": 1495892100,
            "txt_content": "Innovators 发表于 2016-1-26 22:47\n666，但是help！是怎么出来的\nhello的hel接上p!"
        },
        {
            "author": "oyjs",
            "timestamp": 1496126880,
            "txt_content": "6.3部分开头所有的substring中第二个s都变成了大写。"
        },
        {
            "author": "oyjs",
            "timestamp": 1498993980,
            "txt_content": "oyjs 发表于 2017-5-30 14:48\n6.3部分开头所有的substring中第二个s都变成了大写。\n但是在接下来的代码中第二个s就没有大写了，而且实际上它是不需要大写的，或者说这是什么我不清楚的格式？求教"
        },
        {
            "author": "IDE_helloender",
            "timestamp": 1500346320,
            "txt_content": "oyjs 发表于 2017-7-2 19:13\n但是在接下来的代码中第二个s就没有大写了，而且实际上它是不需要大写的，或者说这是什么我不清楚的格式 ...\n我查过了，不用大写，大写没这个方法"
        },
        {
            "author": "Lucky777777",
            "timestamp": 1500475260,
            "txt_content": "推荐StringBuilder然后写了StringBuffer→_→虽然方法差不多"
        },
        {
            "author": "XiaoBingBy",
            "timestamp": 1501634880,
            "txt_content": "555555555555555"
        }
    ]
}