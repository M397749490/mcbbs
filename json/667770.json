{
    "title": "MCmod制作 1.11(12.新的粒子特效)",
    "author": "zkm00323",
    "replyCount": 7,
    "timestamp": 1485494100,
    "txt_content": "之前说要完善呢个冰弹,但是我们的\n基本元件还没配齐,我们要给冰弹加特效\nmc原版的粒子特效显然是不能满足我的\n要做就做个自定义的粒子特效\n我想让冰弹在飞的时候周围有液氮烟雾的感觉\n呢么就开始吧!\n\n\n\n\n\n1.新建particle文件\n一个包里面创建一个class\n\n\n\n\nQQ截图20170127111518.png (7.69 KB, 下载次数: 6)\n\n下载附件\n\n2017-1-27 11:03 上传\n\n\n\n\n\n\n\n在ParticleIcesmoke里要写的东西比较多,我们一点点写\npublic class ParticleIcesmoke extends Particle{\n        //两种写法都可以\n        //public static final ResourceLocation icon = new ResourceLocation(Name.MOD_ID,\"textures/particle/icesmoke.png\");\n        public static final ResourceLocation icon = new ResourceLocation(\"soa:particle/icesmoke\");\n\n\n        public ParticleIcesmoke(World worldIn, double posXIn, double posYIn, double posZIn, double velocityX, double velocityY, double velocityZ) {\n                super(worldIn, posXIn, posYIn, posZIn);\n                motionX = velocityX;             //x轴向量\n                motionY = velocityY;             //y轴向量\n                motionZ = velocityZ;             //z轴向量\n                particleMaxAge = 10;             //存活时间\n                particleAlpha = 1f;                  //透明度1为完全不透明,0为完全透明,可输入中间值\n                particleScale = 1f;                  //显示大小\n                particleGravity = -0.001f;       //重力影响,等一下在更新位置的时候y轴坐标可以用到这个参数来实现重力效果\n                TextureAtlasSprite sprite = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(icon.toString());\n                setParticleTexture(sprite);      //绑定贴图\n        }\n\n}\n\n上面的看注解就知道是什么意思了\n但是setParticleTexture()我要重点讲一下\n他的传入参数为一个TextureAtlasSprite\n而我们点进去看这个类会发现\n\n\n\n\nQQ截图20170127112343.png (2.13 KB, 下载次数: 6)\n\n下载附件\n\n2017-1-27 11:26 上传\n\n\n\n\n\n\n他是protected,所以我们没办法通过new一个TextureAtlasSprite来传入值.\nMinecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(icon.toString());\n的意思是去mc的贴图素材库里寻找一个贴图而这个回传值就是一个 TextureAtlasSprit\n但是我们的路径并不是指向mc的贴图素材库,而是自己mod的贴图,呢则么办呢\n所以现在我们就要把自己的这个贴图路径注册的mc贴图库内\n\n\n\n\n\n2.注册贴图路径\n在init里面创建一个class\n\n\n\n\nQQ截图20170127112849.png (9.2 KB, 下载次数: 3)\n\n下载附件\n\n2017-1-27 11:31 上传\n\n\n\n\n\n\n\n在里面输入\npublic class ModParticle {\n        \n        public static void init(){        \n                new ModParticle();\n        }\n        \n        public ModParticle() {\n                MinecraftForge.EVENT_BUS.register(this);\n        }\n        \n         @SubscribeEvent\n         public void TexturestitcherEventPre(TextureStitchEvent.Pre event) {\n            ResourceLocation icon = new ResourceLocation(\"soa:particle/icesmoke\");\n            event.getMap().registerSprite(icon);\n         }\n}\n\n\n这个架构是不是非常类似,没错就和\n之前potion里面的event注册一样\n当然你也可以直接把MinecraftForge.EVENT_BUS.register(new ModParticle());\n写在Main的preinit方法里,我这样只是为了美观\n\n然后我们到Main里把这个init写进去\n        @EventHandler\n        public void preInit(FMLPreInitializationEvent event){\n                ModParticle.init();\n                ModPotion.init();\n                ModItems.init();\n                ModBlocks.init();\n                ModEntity.init();\n                ModAchivenent.init();\n                proxy.init();\n        }\n\n\n\n\n\n\n3.完善ParticleIcesmoke\n呢么接下来回到ParticleIcesmoke并在里面复写一个方法\n    public int getFXLayer(){\n        return 1;\n    }\n\n\n到他的父类Particle里看\n\n\n\n\nQQ截图20170127113638.png (6.54 KB, 下载次数: 5)\n\n下载附件\n\n2017-1-27 11:39 上传\n\n\n\n\n\n\n他默认回传为0,但如果是0的话\n就会抛出一个RuntimeException\n并且没有绑定到贴图路径\n呢可能有小伙伴问了,为什么不直接\n particleTexture = Minecraft.getMinecraft().getTextureMapBlocks().getAtlasSprite(icon.toString());\n呢?恩....这样子似乎并不可行,贴图不会被找到,这也许和mc代码的调用机制有关\n\n再来\n    @Override\n    public int getBrightnessForRender(float partialTick){\n          BlockPos blockpos = new BlockPos(this.posX, this.posY, this.posZ);\n          return this.worldObj.isBlockLoaded(blockpos) ? this.worldObj.getCombinedLight(blockpos, 0) : 0;\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n          //return 0xf000f0 ;//自定義亮度,或者上面的獲取坐標位置亮度\n          //15728640白天\n          //15728640黑夜?\n          //15 黑的        \n          //0 黑的\n          //0xFFFFFF 灰色的\n          //0xf000f0 純白\n          //0xf0f0f0 灰色\n          //0x100010 黑灰\n    }\n\n\n这个方法是设置粒子的亮度的\n这里我们通过获取当前坐标的环境亮度决定他的亮度\n当然你可以自己输入值\n不过对于黑白量我还是摸不着头绪\n下面的测试的结果\n但如果你不想要自定义亮度这个方法可以不写\n因为我是完全照抄他的父类方法的\n\n然后是 onUpdate()\n    @Override\n    public void onUpdate(){\n      prevPosX = posX;\n      prevPosY = posY;\n      prevPosZ = posZ;\n      particleScale -= particleScale/particleMaxAge; //让粒子大小随着时间慢慢缩小(不可取的逻辑写法)\n      particleAlpha -= particleAlpha/particleMaxAge;//让粒子透明度随着时间慢慢增加(不可取的逻辑写法)\n      motionY -= particleGravity;//通过设置的重力参数让y向量不断向下增加\n      moveEntity(motionX, motionY, motionZ); \n\n\n      if (isCollided) {//碰撞了就消失\n        this.setExpired();\n      }\n\n\n      if (this.particleMaxAge-- <= 0) {//年寿到了就消失\n        this.setExpired();\n      }\n    }\n\n\n这是一个客户端单边方法\n至于则么测试的其实只要在方法里写一句\nsystem.out.println(\"yoooooooooooo\")\n然后看是Client呼出的还是Server呼出的还是两个都呼出了\n这也是个每tick执行的方法(或者是每帧,懒得测试了...反正就是不断刷新的方法)\n这样写算式稍微简化了父类的方法,把重力加速度去掉了\n并且加了2行新代码\n让粒子随着时间而改变自己的属性\n然而这是一个不可取的写法,那时我脑抽写出来的\n如果要让让粒子大小随着时间慢慢缩小\n应该这样的写\nint scale;\nscale =  particleScale*(particleAge/particleMaxAge)\n这样scale才会随着时间慢慢变小直到为0,而且时间和大小是等比例缩放的\n不过由于刚刚好我设定的参数用这个垃圾逻辑不会出错,而且能\n出现非常好的效果,所以我就没改了\n\n接下来最后一个是重点\n        @Override\n        public void renderParticle(VertexBuffer vertexBuffer, Entity entity, float partialTick,float edgeLRdirectionX, float edgeUDdirectionY, float edgeLRdirectionZ,float edgeUDdirectionX, float edgeUDdirectionZ){\n            //client only\n            //下面4句通过获取绑定贴图的大小,定义贴图最左上角的点和最右下角的点\n            double minU = particleTexture.getMinU();         \n            double maxU = particleTexture.getMaxU();\n            double minV = particleTexture.getMinV();\n            double maxV = particleTexture.getMaxV();\n\n\n           //和父类方法一样,通过partialTick和interpPos补足在两tick内的多帧显示坐标变化量\n            double scale = 0.1F * particleScale;\n            final double scaleLR = scale;\n            final double scaleUD = scale;\n            double x = prevPosX + (posX - prevPosX) * partialTick - interpPosX;\n            double y = prevPosY + (posY - prevPosY) * partialTick - interpPosY;\n            double z = prevPosZ + (posZ - prevPosZ) * partialTick - interpPosZ;\n\n\n           //和父类方法一样,关于亮度的一些设定\n            int combinedBrightness = getBrightnessForRender(partialTick);\n            int skyLightTimes16 = combinedBrightness >> 16 & 65535;\n            int blockLightTimes16 = combinedBrightness & 65535;\n\n\n            //绑定4个点(在之前的冰弹render里就出现过这个方法了)\n            //pos的三个参数,通过输入的参数来让渲染粒子图片永远面对玩家\n            //tex的两个参数,绑定贴图点位\n            //color的前3个参数,可以设置贴图颜色的RBG偏移,最后一个为设置透明度\n            //lightmap用来设置亮度\n            vertexBuffer.pos(\n                        x - edgeLRdirectionX * scaleLR - edgeUDdirectionX * scaleUD,\n                    y - edgeUDdirectionY * scaleUD,\n                    z - edgeLRdirectionZ * scaleLR - edgeUDdirectionZ * scaleUD)\n                    .tex(maxU, maxV)\n                    .color(particleRed, particleGreen, particleBlue, particleAlpha)\n                    .lightmap(skyLightTimes16, blockLightTimes16)\n                    .endVertex();\n            vertexBuffer.pos(\n                        x - edgeLRdirectionX * scaleLR + edgeUDdirectionX * scaleUD,\n                    y + edgeUDdirectionY * scaleUD,\n                    z - edgeLRdirectionZ * scaleLR + edgeUDdirectionZ * scaleUD)\n                    .tex(maxU, minV)\n                    .color(particleRed, particleGreen, particleBlue, particleAlpha)\n                    .lightmap(skyLightTimes16, blockLightTimes16)\n                    .endVertex();\n            vertexBuffer.pos(\n                    x + edgeLRdirectionX * scaleLR + edgeUDdirectionX * scaleUD,\n                    y + edgeUDdirectionY * scaleUD,\n                    z + edgeLRdirectionZ * scaleLR + edgeUDdirectionZ * scaleUD)\n                    .tex(minU, minV)\n                    .color(particleRed, particleGreen, particleBlue, particleAlpha)\n                    .lightmap(skyLightTimes16, blockLightTimes16)\n                    .endVertex();\n            vertexBuffer.pos(\n                        x + edgeLRdirectionX * scaleLR - edgeUDdirectionX * scaleUD,\n                    y - edgeUDdirectionY * scaleUD,\n                    z + edgeLRdirectionZ * scaleLR - edgeUDdirectionZ * scaleUD)\n                    .tex(minU, maxV)\n                    .color(particleRed, particleGreen, particleBlue, particleAlpha)\n                    .lightmap(skyLightTimes16, blockLightTimes16)\n                    .endVertex();\n        }\n\n\n呢么最后一步,把贴图丢到设定的路径下就算完成了\n\n\n\n\nQQ截图20170127122255.png (8.67 KB, 下载次数: 2)\n\n下载附件\n\n2017-1-27 12:25 上传\n\n\n\n\n\n\n\n附赠贴图→\n\n\n\n\nicesmoke.png (203 Bytes, 下载次数: 16)\n\n下载附件\n\n2017-1-27 12:26 上传\n\n\n\n\n\n\n\n\n\n\n\n喂喂喂还没完呢,还没说要如何生成粒子特效呢!\n嘿呀对=w=\n不过直接把粒子特效附到冰弹上可能又要讲半天所\n以我可以先告诉你们原版粒子和mod粒子的生成方法\n\n原版\nworld.spawnParticle(\n          EnumParticleTypes.BLOCK_CRACK, //粒子特效类型\n          posX, //坐标x\n          posY, //坐标y\n          posZ,//坐标z\n          (new Random().nextDouble - 0.5D) * 0.08D,//x向量(//可不加随机值)\n          (new Random().nextDouble - 0.5D) * 0.08D,//y向量\n          (new Random().nextDouble - 0.5D) * 0.08D,//z向量\n           Block.getIdFromBlock(Blocks.ICE)//特效类型的参数(可能有的特效不需要)\n           );\n\nMod\nMinecraft.getMinecraft().effectRenderer.addEffect(new ParticleIcesmoke(world, posX, posY, PosZ, velX, velY, velZ));\n\n\n好这章就到这里了\n我这一次写的比较详细\n之前我觉得只要提供给新手一个能够用的\n方法,至于为什么我没有解释很多\n毕竟当初我看教程也都不看解释\n只想知道则么做,不过也许这并不好...\n\n这次源码我就不发了因为我已经做到下一章的量了\n想看的可以到下一章拿\n\n\n\n\n\n",
    "replies": [
        {
            "author": "zkm00323",
            "timestamp": 1485574980,
            "txt_content": "我看了一些国外的帖子\n觉得对于客户端和服务端的代码区分要做的更深入一点\n\n\n\n\nQQ截图20170128113712.png (2.47 KB, 下载次数: 3)\n\n下载附件\n\n2017-1-28 11:40 上传\n\n\n\n\n\n\n在ModParticle的init加一条限制为只有客户端可以执行的显示\n虽然不加限制和加限制测试都可以用\n但是没有人知道最后mod完成后汇出让别人使用会不会有问题\n"
        },
        {
            "author": "caizhong3",
            "timestamp": 1509426540,
            "txt_content": " 本帖最后由 caizhong3 于 2017-10-31 13:13 编辑 \n\n求助一下  我是用1.10.2写的 \n如果我写在服务端世界生成一个粒子(if(!world.isRemote))\nworld.spawnParticle(......)\n粒子并不会自动同步在客户端\n 但是客户端世界生成粒子正常显示\n  是需要手动同步吗？\nworld.playSound(......)也是这样\n\n主要是要在服务器让附近所有玩家可以看见粒子\n"
        },
        {
            "author": "一头奶牛",
            "timestamp": 1509528360,
            "txt_content": "66666666666"
        },
        {
            "author": "魂蛋呃",
            "timestamp": 1565141280,
            "txt_content": "非常感谢您的分享"
        },
        {
            "author": "qq2362975089",
            "timestamp": 1565657280,
            "txt_content": "1.14版本的forge要怎么构建，我构建成功但是没有mc的源代码，，"
        },
        {
            "author": "1518560526",
            "timestamp": 1580187900,
            "txt_content": "我的天哪，这也太复杂了吧。。我连一个方块都制作不出来=。="
        },
        {
            "author": "fqy92",
            "timestamp": 1583638140,
            "txt_content": "感谢分享，让我有了思路"
        }
    ]
}