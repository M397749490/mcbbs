{
    "title": "[综合][PCD]Denizen——不用定制，自己动手写插件！[1.8-1.13]",
    "author": "秋风残叶",
    "replyCount": 55,
    "timestamp": 1529807820,
    "txt_content": " 本帖最后由 秋风残叶 于 2019-2-17 19:27 编辑 \n\n这个帖子还没有编辑完，随心更新吧\n\n\n\n\n★Denizen★现在你可以自己写插件了\n\n 插件介绍 写在前面：本帖适合代码阅读能力，英语能力，逻辑思维能力有一定基础的服主阅读，阅读本帖需要一些耐心\n危险警告：\n本插件大部分可用脚本是安全的，但是本插件也提供了一些相当危险的脚本（比如async异步执行指令）脚本危险度已在帖内标出，除非你知道自己在做什么，否则请不要擅自使用这些危险脚本，请不要在不了解内容的前提下擅自将不明脚本放入运行中的服务器，Denizen不承担因误用危险脚本造成的一切后果\n\n版权提示：\n本帖教程中展示的部分脚本非搬运者原创，仅供效果展示与学习参考\n\n\n插件介绍\n这是一款和Skript类似的，可以通过编写脚本达到不同效果的脚本引擎插件，通过这些脚本，可以做到指令触发事件，权限限制，读取配置等Bukkit插件能做到的事情，只要愿意研究，用它编写一些满足服务器需要的脚本，完全不逊色于Bukkit插件\n本插件的脚本即一个一个的yml文件，你可以自己编写，或者从网上下载一些已经编写好的脚本放入plugins/Denizen/scripts文件夹，并重载插件/denizen reload scripts 便可加载此脚本\n你可能需要借助外力才能制作出一个完美的脚本，本插件有一个附带的论坛， 你可以在那里查阅编写脚本需要使用到的各种要素大全，也可以观看文字教程，视频教程等\n下文给出了一些简单的脚本编写方法，可供初学者参考\n\n 脚本编写教程 1. 基础 - 入门与常用脚本教程目标：以触发型脚本为例子理解脚本结构，学会查阅帮助内容理解变量的概念并学会在合适的地方调用变量了解各数据类型含义，掌握常用脚本用法，能完成简单的一两层判断的小脚本\n\n1.1 触发型脚本\n热身 - 先从触发型脚本开始讲起\n\n脚本有很多种种类，我们先从最常用的“触发型脚本”开始介绍\n\n不同种类的脚本格式也不一样，触发型脚本的基本格式是这样的\n脚本名称: \n  type: world \n  debug: false\n  events: \n    什么时候触发: \n    - 触发以后执行1\n    - 触发以后执行2复制代码\n\n触发型脚本的两个核心元素为“什么导致触发？”和“触发以后执行什么？”\n让我们先从一个最简单的指令脚本开始讲起\n# 该脚本的功能是：玩家执行指令/test，显示一条提示语后获得金钱\n# “获得金钱”的脚本需安装Vault\ntest:\n    type: world\n    debug: false\n    events: \n        on test command: \n        - determine passively fulfilled\n        - narrate '<&e>你刚刚执行了指令/test！你获得了 50 金币！' \n        - give money quantity:50复制代码我们可以看到，这个脚本的触发条件是“on test command”，即“执行了指令/test后会触发”\n当玩家满足触发条件后，便会执行下面几个脚本“显示提示语”和“给予金钱”\n脚本中的“determine fulfilled”代表告诉Bukkit：“/test”这个指令已经处理过了，如果不包含这个脚本则Bukkit会输出不存在这个指令（尽管如此但是余下的脚本还是会运行）\n\n可用于触发脚本的事件和脚本的内容有很多，就算记不住也不要紧，本帖中每一个内容都附了至少一个脚本实例，可供参考，建议将实例复制粘贴进插件文件夹的脚本里，更直观地阅读，测试脚本\n\n\n1.2 查阅帮助\n学会阅读帮助内容\n\n这才第一个例子就把你看晕了？不要急，Denizenscript论坛提供了很多有帮助的内容\n就算你的记性再好，想把所有的事件/脚本类别/可用变量等等全部记住也是不可能的\n想要成功地编写一个Denizen脚本，你应该学会去网站上看帮助内容\n★触发事件\n你可以在Event Search看到所有可用触发事件，比方说我们在上一个例子里用的“on command”事件\n\n\n\n\n\non_command.png (28.9 KB, 下载次数: 1)\n\n下载附件\n\n2018-6-24 10:48 上传\n\n\n\n\n\nNames: 该事件的名称Triggers: 该事件的触发原因Context: 这个事件相关的一些变量，你可以在很多情况下调用，也可以通过if等脚本对变量进行判断Determine: 当该事件下面有以“- determine”打头的脚本时，代表对该事件本身进行处理，比如上一个例子里给的“- determine fulfilled”\n关于Context变量，以下是一个调用变量的例子\ntest:\n    type: world\n    debug: false\n    events: \n        on test command: \n        - determine passively fulfilled\n        - narrate '<&e>亲爱的玩家<player>，你刚刚执行了指令<context.command>！'  复制代码\n\n★触发/执行脚本\n你可以在Command Search看到所有可用触发脚本，比方说我们在上一个例子里用的“narrate”脚本\n\n\n\n\n\nmoney.png (44.13 KB, 下载次数: 10)\n\n下载附件\n\n2018-6-24 11:15 上传\n\n\n\n\n\nName: 该脚本的名称Syntax: 该脚本的正确写法Description: 该脚本的介绍Stable: 该脚本是否稳定，请注意某些“不稳定”的脚本可能弄坏你的服务器！Related Tags: 相关的变量，可以在很多情况下调用或者判断Usages: 用法示例（这作者懒的要死，很多脚本并没有给示例）Warning: 危险警告，有此标记的脚本十分危险，请不要随意使用Note: 备注，可能会提示你要安装前置啥的\n关于Related Tags变量，以下是一个调用变量的例子\ntest:\n    type: world\n    debug: false\n    events: \n        on test command: \n        - determine passively fulfilled\n        - narrate '<&e>你刚刚执行了指令<context.command>！' \n        - give money quantity:50\n        - narrate '<&e>你获得了50金币！你现在有<player.money>金币！' 复制代码\n\n\n\n\ntest_output.png (18.33 KB, 下载次数: 8)\n\n下载附件\n\n2018-6-24 11:18 上传\n\n\n\n\n\n\n★变量\n你可以在Tag Search看到所有可用变量，你可以在很多场合调用这些变量，你需要注意变量的数据类型\n\n\n\n\n\ntag.png (14.05 KB, 下载次数: 1)\n\n下载附件\n\n2018-6-24 11:22 上传\n\n\n\n\n\nName: 变量名称Returns: 返回数据类型Description: 变量描述\n可以通过给变量加一些“尾缀”来代表对该变量进行补充，我们称之为“附加变量”\n比方说布尔值变量<aaa>，其返回值是true，给他加个not尾缀<aaa.not>，则其返回值是false\n请看下面这个例子，附加变量<xxx.to_lowercase>代表把变量<xxx>返回值里所有大写字母改为小写\ntest:\n    type: world\n    debug: false\n    events: \n        on test command: \n        - determine passively fulfilled\n        - narrate '<&e>亲爱的玩家<player>，你刚刚执行了指令<context.command>！'\n        - narrate '<&e>这个指令如果转换成小写的话是<context.command.to_lowercase>！'复制代码值得一提的是，附加变量可以附加到很长，还可以添加附加的数据值，比如：\n<player.location> 返回的是玩家当前坐标(dLocation)<player.location.find.entities.within[15]> 返回的是以该玩家坐标为中心周围15格内所有实体的UUID(dList)<player.location.find.entities.within[15].entity_type> 返回的是上述实体的实体名(dEntity)<player.location.find.entities.within[15].entity_type.to_lowercase> 返回的是上述实体的小写实体名(dEntity)\n鉴于太长的变量可能会让脚本变得很难看，可以在使用define脚本来给变量取个短名字，请参阅下文\n\n★数据类型\n一个变量究竟是什么？是一种物品？一个坐标？一串数字？还是一只生物？\n为了防止混乱，Denizen让每个变量都拥有了数据类型，你可以在Mech Search查看所有数据类型\n数据类型的名称是一个小写字母d后面跟一个单词，例如dEntity代表“实体数据类型”\n在某些脚本中调用变量时，必须关注其数据类型，用错数据类型的脚本通常会导致bug产生\n比如使用take脚本取走玩家手中一个物品时，正确写法是：\n- take <player.item_in_hand> quantity:1\n错误写法是：\n- take <player.item_in_hand.material.name> quantity:1\n虽然上面两个脚本中使用的变量，返回值从文字上看并无区别，但是其数据类型不同，前者是dItem，后者是文字，物品可以取走，文字怎么取得走？\n\n可以通过附加变量，直接对某类型数据进行更改：\n<player.location> - 返回的是玩家当前坐标（dLocation）<player.location.add[0,2,0]> - 返回的是玩家当前坐标Y轴向上偏移2格的坐标（dLocation）\n\n也可以通过附加变量让变量在不同的数据类型之间转换，比如上面引用的例子\n\n如果你给某变量指定了名字，为了防止混乱，可以在脚本调用这个变量时在前面加一个标识来指代其变量类型，例如，你创建了一个物品，名叫custom，但是这个名字没有标注变量类型（一本书可以叫custom，一只怪物也能叫custom）因此在调用此变量时可以使用i@custom来告诉Denizen：这是一个物品类型的变量（dItem）\n同理：\ne@custom代表这是一个实体类变量b@custom代表这是一个生物群系类变量w@custom代表这是一个世界类变量\n……更多请参Mech Search\n在使用与这些变量相关的附加变量时也很方便，比如<e@custom.item_in_offhand>代表“名为custom的实体副手上的物品”\n\n\n\n\n1.3 脚本if\n通过if来讲权限限制\n\nif脚本只是众多脚本之中的一种，其功能是：若玩家符合条件，则执行子脚本，若不符合条件则跳过\n那么我就用这个脚本来做出“给指令添加权限限制”的效果\n# 该脚本的功能是：有权限和无权限server.vip的玩家进服，显示不同的消息\ntest:\n    type: world\n    debug: false\n    events: \n        on player joins: \n        - wait 1t \n        - if <player.has_permission[server.vip]> { \n          - narrate '<&a>亲爱的VIP玩家欢迎回到服务器！' \n          }\n        - if !<player.has_permission[server.vip]> {   \n          - narrate '<&a>欢迎您来到本服务器' \n          - queue clear\n          }复制代码该脚本被触发后执行脚本if，首先会判断其后变量是不是true（该变量可以是布尔值变量）\n若变量条件符合，则执行下面的子脚本，若不符合，则跳过子脚本，继续进行下一步\n在变量的前面加一个感叹号!或者加一个附加变量<[element].not>代表反向含义\n\n当然，if脚本不一定判断的只能是布尔值变量，也可以判断两个相同数据类型变量是否相等或者谁大谁小，即 if A = B \n请看例子，这里我们判断的是玩家主手的物品\n# 该脚本的功能是：手持石头输入/sellhand可以卖出1个石头并获得10金币\ntest:\n    type: world\n    debug: false\n    events: \n        on sellhand command: \n        - determine passively fulfilled\n        # 如果玩家主手上是空气，即“什么都没有”，输出信息，同时终止序列，脚本不再往下运行\n        - if <player.item_in_hand.material.name||null> == air { \n          - narrate '<&a>你手上什么都没有，你必须把要出售的物品拿在手上！' \n          - queue clear\n          }\n        # 如果玩家手上不是石头（当然也不是空气）\n        # 输出信息，同时终止序列，脚本不再往下运行\n        - if <player.item_in_hand.material.name||null> != stone {\n          - narrate '<&a>目前本服务器只允许出售石头，请把石头拿在手上！' \n          - queue clear\n          }  \n        # 如果玩家主手上有石头，扣除主手上的一个物品，输出信息，给予玩家10金币  \n        - if <player.item_in_hand.material.name||null> == stone {   \n          - take iteminhand\n          - narrate '<&a>你出售了1个石头，获得10金币' \n          - give money quantity:10\n          } 复制代码\n\n\n1.4 脚本flag\n标记 | 我已经做过这件事了？\n\n当你给玩家加了某些效果以后，什么时候该把效果去掉？本插件该用什么来确认“这效果还在不在玩家身上？”\n这时就应该使用flag标记，给玩家加上效果以后顺手给玩家加个标记，当插件想去掉效果时\n首先会检测有没有标记：“哦~这家伙身上有标记，说明效果还在，移除掉！”\n这种脚本大大减少了bug的发生率，很多bug产生的原因是因为：加了效果忘了移除\nBUG高发提示：加了flag以后，什么时候该移除flag要考虑的非常周全，比较容易犯错误的地方有：玩家下线flag没移除，玩家死亡flag没移除，玩家转换世界flag没移除……等等\n\n先看例子：\n# 该脚本的功能是：主手或者副手手持火把，可以作为光源照亮周围，并跟随玩家移动\ntest:\n    type: world\n    debug: false\n    events:\n        on player steps on block:\n        # 若玩家有标记，则移除光照同时移除标记\n        # 因为生成的光照本身是无法“移动”的，必须消灭旧光照产生新光照来达到“移动”\n        - if <player.has_flag[torch_light_prev]> {\n          - light <context.previous_location> reset\n          - flag player torch_light_prev:!\n          }\n        # 若玩家主手/副手之一拿了火把，则给玩家所在位置Y轴+1的位置加上14亮度，同时给玩家加上标记  \n        - if <player.item_in_hand.material.name||null> == torch || <player.item_in_offhand.material.name||null> == torch {\n          - light <context.location.add[0,1,0]> 14\n          - flag player torch_light_prev\n          }\n        # 当玩家下线时，若玩家身上有标记，则移除光照并移除标记\n        # 这是一个好发bug的地方：玩家都下线了，效果还在        \n        on player quits:\n        - if <player.has_flag[torch_light_prev]> {\n          - light <context.previous_location> reset\n          - flag player torch_light_prev:!\n          }复制代码脚本flag的格式是\n- flag <player> <标记名>\n可在该脚本末尾加上冒号感叹号代表移除标记\n\n\n1.5 脚本adjust\n对变量进行“调整”\n\nadjust字面意思翻译过来就是“调整”，其意义是对变量本身进行调整，或者对变量某一属性进行调整\n该脚本的标准格式为\n- adjust <变量> <属性:调整后的值> [save:临时的保存名]\n同时该脚本有两个相关的变量，可调用已经调整过的保存的变量：\n<entry[临时的保存名].result> 返回的是已经保存的单个变量<entry[临时的保存名.result_list]> 返回的是已经保存的一组数据变量（dList）\n\n需要注意的是adjust脚本并不能调整变量本身的数据类型，举个例子：你可以把“猪”调整为“幼年猪”“有鞍的猪”，而不能调整为“钻石”，因为数据类型不同\n来看个例子\n\n\n\n\nadjustsword.png (4.82 KB, 下载次数: 2)\n\n下载附件\n\n2018-6-29 22:02 上传\n\n\n\n\n\n# 该脚本的功能是：玩家手持钻石剑执行指令/addlore，给钻石剑加一行lore\n# 原理是：把手中的物品调整了lore以后保存，拿走手中的物品，再把保存的物品给玩家\ntest:\n    type: world\n    debug: true\n    events: \n        on addlore command: \n        - determine passively fulfilled\n        # 如果玩家手里拿的是钻石剑\n        - if <player.item_in_hand.material.name||null> == diamond_sword {\n            # 将玩家手里的钻石剑的lore改掉，并将调整后的结果保存为myitem，数据类型为dItem\n            - adjust <player.item_in_hand> \"lore:<&e>很棒的剑\" save:myitem \n            - take iteminhand \n            # 直接将调整后的结果作为物品给玩家，数据类型dItem\n            - give <entry[myitem].result> \n            - narrate '<&a>已给手中钻石剑添加lore'  \n            } else {\n            - narrate '<&c>请把钻石剑拿在手上'  \n            }复制代码\n\n\n\n\n1.6 脚本foreach\n遍历 | 挨个接受检查\n\n想要把你周围所有怪物扫描一遍，并移除里面全部的敌对生物？你需要使用脚本foreach\nforeach后面应该跟的是“组数据”（dList）可以是一堆符合要求的玩家，一堆符合要求的生物等\n先看一个简单的例子\n# 该脚本的功能是：玩家执行指令/onlinereward，遍历全服所有在线玩家，每人都能看到输出消息，并获得金钱\ntest:\n    type: world\n    debug: false\n    events: \n        on onlinereward command: \n        - determine passively fulfilled\n        - foreach <server.list_online_players> {\n          - narrate \"感谢您在本服务器游玩，您收到了在线奖励 $50.00!\" \n          - give %value% money qty:50 \n          }复制代码再看一个例子，把foreach和if连用，遍历全部项目并筛选出符合要求的项目\n# 该脚本的功能是：玩家执行指令/removemobs，移除玩家周围15格范围内所有敌对生物\n# 同时输出不予清理的实体种类（包括执行玩家自己）\ntest:\n    type: world\n    debug: false\n    events: \n        on removemobs command: \n        - determine passively fulfilled\n        # 遍历 玩家坐标 周围全部实体 15格内\n        - foreach <player.location.find.entities.within[15]> {  \n            # 若遍历到的实体是敌对生物，清除掉实体\n            - if <%value%.is_monster> {\n                - remove %value% \n                }\n            # 若遍历到的实体不是敌对生物，输出相关信息    \n            - if <%value%.is_monster.not> {\n                - narrate '<&a>扫描到一只实体<%value%.entity_type>，不符合清理条件，不予清理' \n                }    \n          } \n        - narrate '<&a>15格内所有敌对生物已清理'  复制代码\n\n\n1.7 脚本choose-case | 脚本define\n不止一种的选择 | 临时的自定义变量\n\n有的时候，当你使用if脚本时可能要套不少if，这个if判断完了再判断下一个if，烦不胜烦\n可以直接使用脚本choose-case，直接通过不同的判断输出不同的结果\n\n很多时候，你可能需要调用一个很长的、附加很多的脚本，你可以使用脚本define来给这个长脚本起个“短名字”\n这样接下来脚本中调用这个变量就很方便\n请先看例子：\n# 该脚本的功能是：玩家击杀僵尸/骷髅/苦力怕三种生物，会有特殊提示语，击杀其它生物会有普通提示语\ntest:\n    type: world\n    debug: false\n    events: \n        on player kills entity: \n        # 下面的脚本将会调用一个很长的变量<context.entity.entity_type.to_lowercase> \n        # 为了代码简洁，给它临时取个“短名字”：aaa\n        # 下面的脚本就可以使用<def[aaa]>来代表那个长变量\n        - define aaa <context.entity.entity_type.to_lowercase> \n        # 检测玩家击杀的实体的种类\n        - choose \"<def[aaa]>\": \n          - case \"zombie\": \n            - narrate \"你干掉了一只僵尸！\" \n          - case \"skeleton\": \n            - narrate \"你把骷髅弓箭手击杀了！\" \n          - case \"creeper\": \n            - narrate \"成功阻止了苦力怕的爆炸！\" \n          # 每个choose脚本可以在最后添加一条default，当前面的选项一个都不满足时，执行default\n          - default: \n            - narrate \"你击杀了一只 <def[aaa]>!\" 复制代码\n\n\n1.8 脚本determine\n对触发事件本身进行处理\n\n前面展示的脚本例子里，不知你注意到没有，我每用一个指令触发就在后面加一个“- determine passively fulfilled”\ndetermine脚本代表对触发的事件本身进行处理，“determine fulfilled”代表告诉Bukkit这个指令已经处理，不会再有该指令附带的其它触发内容出现\n在脚本中加上passively代表该行脚本处理完后接着进行下一行\n\n除此之外，determine脚本其实更常用的是“determine [passively] cancelled”，指“取消该事件”\n这个特性可以用作对一些原版特性的限制，比如“让苦力怕不爆炸”等等，请看例子\n# 该脚本的功能是：当苦力怕被激活，会维持在激活的那一瞬间，而不爆炸\ntest:\n    type: world\n    debug: false\n    events: \n        on creeper explosion primes: \n        - determine passively cancelled      复制代码如图，右边的苦力怕显然胖一些，是已经被激活的苦力怕，但是没有爆炸，因为它的爆炸事件已经被我用determine脚本取消掉了\n\n\n\n\ncreeper.png (89.55 KB, 下载次数: 11)\n\n下载附件\n\n2018-6-24 11:32 上传\n\n\n\n\n\n\n\n1.9 脚本inject\n注入脚本 | 多次调用\n\n是不是觉得把所有的判断，所有的处理写进同一个脚本太冗杂太混乱？\n有的时候一个小小的判断会在很多地方被用到？那么可以试试inject注入脚本\n我们这次用“判断玩家是否是OP”作为注入脚本来介绍\n# 该脚本的功能是：若玩家是OP且执行了指令/getmoney，那么获得1000金币\ntest:\n    type: world\n    debug: false\n    # 这是可以注入的脚本，判断玩家不是OP，若玩家不是OP，输出信息，终止序列\n    op_check: \n    - determine passively fulfilled \n    - if !<player.is_op> {     \n      - narrate '只有管理员可以这么做' \n      - queue clear   \n      } \n    events: \n        on getmoney command:\n        # 第一步先注入这个op_check小脚本，判断玩家是否是OP\n        - inject locally op_check  \n        # 玩家通过了注入脚本的检测，说明玩家是OP，继续执行后面的脚本\n        - give money quantity:1000 \n        - narrate '<&a>你是本服OP，你获得了1000金币'复制代码\n\n\n1.10 脚本random\n随机脚本多选一\n\n谁说触发脚本只能得到一种结果？可以使用随机脚本random来在预设的结果里随机抽一个\n下面这个例子里提供了三种random脚本的用法\ntest:\n    type: world\n    debug: false\n    events: \n        on test1 command:\n        - determine passively fulfilled \n        # 子脚本式random用法，会从下面三个子脚本中抽一条\n        - random:\n          - narrate '<&a>欢迎加入PCD小组'\n          - narrate '<&a>PCD小组致力于优质插件开发与搬运'\n          - narrate '<&a>加入小组立刻变身大佬'\n        on test2 command:\n        - determine passively fulfilled \n        # 指定范围式random用法，会从下面三条脚本中抽一条\n        - random 3\n        - narrate '<&a>请加入PCD小组'\n        - narrate '<&a>PCD小组最棒'\n        - narrate '<&a>现在就加入PCD小组'\n        - narrate '<&c>这条信息一定会显示，因为这已经是第四条了'\n        on test3 command:\n        - determine passively fulfilled \n        # 多条脚本的random用法，repeat 1代表“重复一次”，其本身没有什么意义\n        - random:\n          - repeat 1: \n            - give xp quantity:10\n            - narrate \"你获得了10经验\" \n          - repeat 1: \n            - give xp quantity:20\n            - narrate \"你获得了20经验\" \n          - repeat 1: \n            - give xp quantity:30\n            - narrate \"你获得了30经验\" 复制代码\n\n\n1.11 脚本goto-mark\n在按部就班的脚本序列中来回横跳\n\n在前面的例子里，你看到的脚本大多只能按部就班，一行一行运行，但是，使用了脚本goto和脚本mark，便可以实现跳序运行，mark脚本可以用来“标记书签”，goto脚本则用来跳转到对应的“书签”，继续往下运行\n你可以把goto和mark脚本写在不同的脚本中，来完成跨脚本运行\n\nBUG高发提示：正因为goto-mark脚本可以跳序运行脚本，所以使用不当有造成死循环的危险，请务必注意\n\ntest:\n  type: world\n  debug: false\n  events:\n    on test command:\n    - determine passively fulfilled\n    - narrate '<&a>接下来你可能会看到一些关于Denizen的评价'\n    - goto pcd\n    - narrate '<&c>[已屏蔽]这插件真垃圾'\n    - narrate '<&c>[已屏蔽]晦涩难懂又没人用'\n    - mark pcd\n    - narrate '<&a>这插件真棒！！'复制代码\n\n\n家庭作业：\n1，请改写2.1 物品型脚本中的“夜视帽”实例，功能不变，至少用到一处flag脚本\n（参考答案见2楼置顶）\n\n2. 进阶 - 各类型脚本 理论联系实际教程目标：熟练运用触发型脚本，了解其它种类脚本的用法能够把两个以上序列联系起来做出比较复杂的脚本锻炼逻辑思维能力，尽量避免逻辑性bug出现\n2.1 物品型脚本创建物品并调用物品“物品”是插件中不可或缺的一个元素之一，很多插件效果都要通过物品来触发（比如WorldEdit要用小木斧来选区）\n那么我就在这里教大家如何使用Denizen创建一些特殊物品，并在脚本中调用物品，物品型脚本的type是item我们以一个“夜视帽”的小脚本做例子来介绍\n\n\n\n\nyeshimao.png (4.47 KB, 下载次数: 5)\n\n下载附件\n\n2018-6-24 14:32 上传\n\n\n\n\n# 该脚本的功能是：创建一个名叫yeshimao的物品（锁链头盔）玩家把它戴在头上可获得夜视效果\n# 玩家把帽子脱掉则夜视效果消失，该物品可以合成\n# \n# 先创建一个名叫yeshimao的物品，后面的脚本可以使用i@yeshimao来调用此物品\n# 也可在游戏中执行/ex give yeshimao来直接获得此物品  \nyeshimao: \n  type: item \n  # 物品的种类，通常用i@<物品英文名>来表示\n  material: i@chainmail_helmet \n  # 物品的名称\n  display name: '<&a>夜视帽' \n  # 物品的lore\n  lore:  \n  - '<&e>把它戴在头上'  \n  - '<&e>获得夜视效果' \n  # 玩家不能丢弃此物品，也不能通过第三方插件途径扣除此物品\n  bound: true \n  # 物品合成配方，合成配方里也可以调用别的物品，来使用自定义物品合成\n  # 引申开来，只要是可以调用物品的地方，都可以使用自己创建的自定义物品\n  recipe:  \n  - i@ink_sack,15|i@redstone_block|i@ink_sack,1 \n  - i@glass|i@chainmail_helmet|i@glass \n  - i@ink_sack,2|i@quartz|i@ink_sack,4 \n  # 附魔\n  # enchantments:\n  # - SHARPNESS:5\n  # 熔炉原料\n  # furnace_recipe: i@stone\n  # 下面这项设置为true，则该物品ID不可被调用，除非有特殊需求否则不推荐\n  # no_id: true/false\n  # 设置某些物品的颜色，如皮革衣服，数据类型为dColor\n  # color: co[url=home.php?mod=space&uid=296831]@color[/url] \n  # 如果该物品是成书（i@written_book）那么可以给这本书指定一个成书型脚本\n  # book: book_script_name \n   \nYESHIMAO_ON: \n  type: world \n  debug: false \n  events: \n    # 当玩家戴上头盔时，检测玩家的头盔是不是yeshimao\n    # 如果是，显示消息，执行cast脚本，玩家获得夜视效果\n    on player equips helmet: \n    - if <context.armor.simple> == i@yeshimao { \n      - narrate '你刚刚戴上了夜视帽！现在你能在黑暗中看清楚了' \n      - cast night_vision <player> duration:23h hide_particles \n      } \nYESHIMAO_OFF: \n  type: world \n  debug: false \n  events: \n    # 当玩家取下头盔时，检测玩家的头盔是不是yeshimao\n    # 如果是，执行adjust脚本，移除玩家自带效果\n    on player unequips helmet: \n    - if <context.armor.simple> == i@yeshimao { \n      - adjust <player> remove_effects \n      } \n       \nYESHIMAO_CRAFT: \n  type: world \n  debug: false\n  events: \n    # 可以在触发事件中直接调用物品名\n    # 当夜视帽被合成时，检测玩家是否有权限yeshimao.craft\n    # 如果否，显示消息，取消合成\n    on i@yeshimao crafted: \n    - if !<player.has_permission[yeshimao.craft]> { \n      - narrate '<red>你没有权限合成这个，你必须拥有权限yeshimao.craft' \n      - determine cancelled \n      }          复制代码\n\n\n\n2.2 指令型脚本在服务器里执行指令我们前面用了这么多“on command”触发型脚本举例子，这一次我们直接来讲指令型脚本，指令型脚本的type是command\n可以直接给指令设置权限限制或者OP限制，很方便，不需要再套一层层if判断了，指令型脚本还能使用Tab补全看例子test_command: \n  type: command \n  debug: false \n  # 这个指令的根指令名称，会显示在/help指令列表里\n  name: test\n  # 这个指令的别称，会显示在/help指令列表里\n  aliases: \n  - testcmd\n  # 这个指令的用法，会显示在/help指令列表里\n  usage: /testcmd  \n  # 这个指令的描述，可以通过<&nl>变量换行，会显示在/help指令列表里\n  description: 这是一个测试用的指令\n  # 执行这个指令所需的权限\n  permission: warps.setwarp \n  # 当玩家没有权限执行，显示的消息\n  permission message: '对不起， <player.name>，你没有权限<permission>' \n  # 前面提到该指令可以在/help列表里看到，那么什么样的人可以看到？\n  # 这里只能填写determine脚本+布尔值变量\n  # 常用的变量有：\n  # <player.has_permission[权限]> - 检测玩家是否有权限\n  # <player.is_op> - 检测玩家是否是OP\n  # <context.server> - 检测指令是不是由控制台执行\n  allowed help: \n  - determine <player.has_permission[warps.setwarp]||<player.is_op>> \n  # 一级指令tab补全，前面的if脚本只是判断玩家是不是OP/是不是控制台执行\n  # determine后面必须跟上dList组数据，比如<server.list_online_players.parse[name]>返回的是全服在线玩家名列表\n  tab complete: \n  - if !<player.is_op||<context.server>> queue clear \n  - determine help|list|info|reload\n  script:  \n  # 当该指令是从控制台执行，会触发的内容\n  # 如果该指令只能由玩家执行，应该加上这部分脚本，以避免bug产生\n  - if <context.server> { \n    - announce to_console \"<&c>只有玩家可以使用此指令\" \n    - queue clear \n    }  \n  - narrate \"你输入了参数 '<context.raw_args>'!\" 复制代码\n\n\n2.2-1 实战 | “加血指令”调用指令中的参数你可以在指令中指定参数，在脚本中使用变量<context.args.get[参数序号]>即可获得此参数让我们以一个例子来说明，下面这个是一个加血的脚本，玩家输入/jx <血量值> 即可给自己加血可能有些人会嗤之以鼻：不就是个触发事件+执行脚本么？多简单！错了！这是好发bug的地方！因为你无法知晓这个指令会以什么方式输入，指令的使用者说不定并不会按照指令的标准用法进行使用，而是胡乱添加参数，修改阈值，这些东西如果不加以注意，可能会造成严重bug\n★需要注意的地方过多参数和过少参数\n指令的使用者执行指令时可能会给指令添加/减少参数，比如把/jx 8写成/jx 或者/jx 8 8，这个需要加个if来判断\n参数的阈值\n你真的以为指令使用者会按部就班的指定参数阈值？他会不会指定一个负数的值？会不会让阈值溢出？阈值上出现问题的指令经常会造成严重bug（比如：加负数金钱）需要对指令参数进行阈值的判断，来避免问题\n参数的格式，范围\n有的时候，除了要给参数指定数字上的阈值，还要确认参数的范围，比如检查该参数的文字是否是合法字符，等等，进一步让这个参数运行在可控范围内这个检测需要用到一个Java方法：match，一般的格式为：  - if <变量> matches <合法范围> {\n    - 下一步指令\n    - 在matches前面加感叹号!则含义相反\n    }复制代码常用的一些<合法范围>如下判断变量是否是纯数字：if <变量> matches number\n是不是通过控制台执行？\n有的时候指令并非通过玩家执行，而是通过控制台执行，这种情况会导致脚本中获得玩家相关变量时总是null也需要加个if判断，来让控制台执行不了玩家指令\n请看这个加血指令脚本，仅仅一个参数的脚本就加了6个判断test_command: \n  type: command \n  debug: false \n  name: jx\n  aliases: \n  - jiaxue\n  usage: /jx \n  description: 输入/jx <血量> 可以给自己加血\n  script:  \n  # 当该指令是从控制台执行，触发消息，终止序列\n  - if <context.server> { \n    - announce to_console \"<&c>只有玩家可以使用此指令\" \n    - queue clear \n    }  \n  # 当该指令参数过多，比如/jx 3 233  ，触发消息，终止序列\n  - if <context.args.get[2]||null> != null {\n    - narrate '<&c>指令参数过多'\n    - queue clear\n    }\n  # 当该指令参数过少，比如/jx ，触发消息，终止序列  \n  - if <context.args.get[1]||null> == null {\n    - narrate '<&c>请输入要加的血量'\n    - queue clear\n    }  \n  # 当第一个参数不是合法数字，比如/jx 1q5u，触发消息，终止序列\n  - if <context.args.get[1]||null> !matches number {\n    - narrate '<&c>请输入一个合法数字'\n    - queue clear\n    }    \n  # 当第一个参数是负数或者零，比如/jx -1 ，触发消息，终止序列  \n  - if <context.args.get[1]||null> <= 0 {\n    - narrate '<&c>不可以设置为零或者负数血量'\n    - queue clear\n    }    \n  # 当玩家加了血量以后血量会超过最大血量，比如玩家当前血量18/20，又输入了/jx 3 ,触发消息，终止序列  \n  - if <context.args.get[1].add[<player.health>]||null> > <player.health.max> {\n    - narrate '<&c>玩家即将达到最大血量，加血失败'\n    - queue clear\n    }      \n  # 将以上可能性都排除后，再加血量  \n  - heal <player> <context.args.get[1]>\n  - narrate '<&a>已为您加了<context.args.get[1]>血量'复制代码\n\n\n2.3 成书型脚本创建自定义内容成书成书型脚本可以创建自定义标题，作者，内容的成书，其本身可在游戏中直接通过指令获得也可以和物品型脚本挂钩，在其它场合作为物品被调用\n看例子\n\n\n\n\nnewbook.png (13.34 KB, 下载次数: 6)\n\n下载附件\n\n2018-6-24 14:55 上传\n\n\n\n\n# 可直接通过/ex give i@newbook来获得此成书\nnewbook: \n  type: book \n  # 成书的标题\n  title: 欢迎加入PCD小组\n  # 成书的作者\n  author: mcmonkey\n  # 设置为true则物品为成书，false则为书与笔，缺省默认为true\n  signed: true/false \n  # 每一个横杠代表一整页，想另起一行可使用变量<n>，想开新段落可使用变量<p>\n  text: \n  - '<&1>欢迎您加入PCD小组<n><&4>今天也要努力招新哦！'复制代码\n\n\n\n2.4 实体型脚本创建自定义实体生物可以通过实体型脚本（type: entity）来创建一些实体，用于生成或者在脚本中被调用先来看一个简单的生成生物的例子# 该脚本的功能是：玩家执行指令/spawnwolf 在玩家鼠标指着的位置召唤一只狼\nentityspawn: \n  type: entity\n  # 实体种类，必须是dEntity数据 (比如 e@zombie 或者 e@pig[age=baby]) \n  entity_type: e@wolf \n  # 该生物有没有默认AI，有AI的生物行为和原版MC一样，没有AI的生物不会移动，不会和其它实体交互\n  has_ai: true\n  # 该生物的年龄\n  age: adult \n  \nspawncommand: \n  type: world \n  debug: false\n  events: \n    on spawnwolf command:\n    - determine passively fulfilled  \n    # 在玩家鼠标所指的位置召唤实体e@entityspawn\n    - spawn e@entityspawn <player.location.cursor_on> \n    - narrate '已在<player.location.cursor_on>生成一只狼' 复制代码与实体生成相关的设置项远远要比示例中多，你可以通过查阅这里来获得大量实体设置项，来进一步描述生成的实体（比如盔甲架的手臂是否可见，船的材质，僵尸的穿戴等等）\n\n\n\n\ntestzombie.png (87.03 KB, 下载次数: 37)\n\n下载附件\n\n2018-6-24 17:00 上传\n\n\n\n\n# 该脚本的功能是：玩家执行指令/spawnzombie 在玩家鼠标指着的位置召唤一只僵尸\nentityzombie: \n  type: entity\n  # 实体种类，必须是dEntity数据 (比如 e@zombie 或者 e@pig[age=baby]) \n  entity_type: e@zombie \n  # 该生物有没有默认AI，有AI的生物行为和原版MC一样，没有AI的生物不会移动，不会和其它实体交互\n  has_ai: true\n  # 该生物的年龄\n  age: adult \n  # 该生物的自定义名称\n  custom_name: '<&a>测试僵尸'\n  # 该生物的四件装备，请注意顺序：从下到上\n  equipment: i@diamond_boots|i@diamond_leggings|i@diamond_chestplate|i@diamond_helmet\n  # 该生物自带的药水效果\n  potion_effects: SPEED,0,120\n  \nspawncommand: \n  type: world \n  debug: false\n  events: \n    on spawnzombie command:\n    - determine passively fulfilled  \n    # 在玩家鼠标所指的位置召唤实体e@entityzombie\n    # 由于僵尸是两格的生物，直接指定坐标可能会让僵尸卡进地下，因此要加个附加变量，让坐标在Y轴上移1格\n    - spawn e@entityzombie <player.location.cursor_on.add[0,1,0]> \n    - narrate '已在<player.location.cursor_on>生成一只僵尸' 复制代码\n\n\n2.5 容器型脚本 | 脚本inventory创建和打开自定义GUI菜单GUI菜单是各种插件常有的元素之一，相信大家一定用过ChestCommands等一些著名的GUI菜单插件Denizen提供了容器型脚本（type: inventory）来创建完全自定义的GUI，你可以自定义其GUI类型，标题，内含的各物品也可以调用已经存在的自定义物品GUI该怎么打开？这里我们要用到脚本inventory简略的inventory脚本标准格式如下（更多附加变量请参这里）容器名的变量数据类型是dInventory，通常使用in@<容器名>来指代该容器- inventory <open/close> destination:<容器名> \n\nBUG高发提示：如果想通过容器型脚本做出“菜单”效果的GUI，需要注意其内容物是可以拿出来的，必须再加一条触发型脚本，当玩家点击GUI时取消事件，方可避免bug\n来看一个简单的例子，这是一个输入指令以后能打开一个显示全服玩家在线列表的脚本\n\n\n\n\ninventory.png (15.9 KB, 下载次数: 1)\n\n下载附件\n\n2018-6-29 23:34 上传\n\n\n\n\n# 该脚本的功能是：玩家执行指令/openinv 打开一个GUI，显示在线玩家列表\n# GUI的排版自定义，且里面的物品不可拿出\ntest:  \n  type: inventory \n  # GUI的种类\n  # 可选种类: BREWING, CHEST, DISPENSER, ENCHANTING, ENDER_CHEST, HOPPER, PLAYER, WORKBENCH \n  inventory: chest\n  # GUI的标题\n  # 只有 CHEST, DISPENSER, FURNACE, ENCHANTING, HOPPER 这几个GUI支持标题 \n  title: '<&4>测试GUI标题'\n  # GUI的大小，必须是 9 的倍数. 最好不要超过 54 否则GUI可能显示不正常\n  # 这个地方可以调用数字型变量来作为GUI大小\n  size: 27 \n  # 用于填充GUI格子的各项物品，可以直接填入物品种类（比如i@diamond）也可以调用已经存在的自定义物品\n  definitions: \n    test1: i@iron_fence\n    test2: i@diamond\n  \n  # Procedural items 这个部分会生成一组物品数据 dItems，并填入下面slots的空格里\n  # 每个组内的物品都会按照顺序被填充进下面GUI的空格内\n  # 如果GUI里已经没有空格了，那么不会再有新物品填充进去 \n  # 请注意i@air空气并不代表空格！如果下面的格子里填入了空气，该格子将一直不会有物品填充进去\n  procedural items: \n    # 定义一个物品组li@为list，这个物品组现在为空\n    - define list li@ \n    # 遍历全服在线玩家（输出值为<def[value]>）\n    - foreach <server.list_online_players>: \n      - define item i@human_skull[display_name=<def[value].name>] \n      # 输出包含所有在线玩头颅的def[list]\n      - define list <def[list].include[<def[item]>]> \n    - determine <def[list]> \n  # 这里你可以指定GUI内各物品位置\n  # 可以填入之前在definitions那里自定义的名称，也可以直接写上i@<物品种类>，也可以调用物品\n  # 可以留空[]代表空格子\n  slots: \n    - \"[test2] [test1] [test1] [test1] [i@iron_fence] [test1] [test1] [test1] [test2]\" \n    - \"[test1] [] [] [] [i@apple] [] [] [] [test1]\" \n    - \"[test2] [test1] [test1] [test1] [test1] [test1] [test1] [test1] [test2]\" \n    \ncmds:\n  type: world \n  debug: false\n  events: \n    # 执行指令/openinv 打开GUI：in@test\n    on openinv command: \n    - determine passively fulfilled \n    - inventory open destination:in@test           \n\nanticlick:       \n  type: world \n  debug: false\n  events: \n    # 阻止玩家把物品从GUI中拿出来\n    # 这是一个bug的好发之处：从GUI里拿出物品\n    on player clicks in in@test: \n    - determine passively cancelled 复制代码\n\n\n2.5-1 实战 | “服务器菜单”用Denizen制作服务器菜单\n\n\n\n\nstore.gif (166.67 KB, 下载次数: 6)\n\n下载附件\n\n2018-6-30 11:06 上传\n\n\n\n\n\n看到这个动图是不是感觉和一些市面上流行的菜单插件差不多？那么这次就用这个例子来讲一讲在实战中创建GUI菜单的要素阅读此部分前请确保自己已经认真阅读了2.5 容器型脚本 部分内容\n★触发事件中的要素玩家点击菜单中某物品时触发（任意点击/左键点击/右键点击/Shift+左键/Shift+右键/中键）on player clicks in <容器变量名>on player left clicks in <容器变量名>on player right clicks in <容器变量名>on player shift_left clicks in <容器变量名>on player shift_right clicks in <容器变量名>on player middle clicks in <容器变量名>\n\n★点击后执行脚本中的要素可以使用if脚本判断一下是否有权限/是否是OP等等可以打开其它GUI可以执行一些常用的脚本，比如修改金钱/经验，执行指令等等\n\n★容易产生BUG的地方老生常谈：把物品从GUI里拿出来的bug，所以无论是什么GUI，只要涉及到点击事件，必须加个触发型脚本取消事件，以防止拿出物品bug产生\n上面那个动图里的菜单，脚本如下：# 该脚本的功能是：玩家执行指令/openinv 打开一个GUI，显示有两个按钮的“服务器菜单”\n# 一个按钮左键点击可传送，右键点击显示消息，另一个按钮点击可打开另一个GUI\n# 首先创建两个GUI里的按钮物品：i@lobby和i@storeopen\nlobby: \n  type: item \n  material: i@redstone\n  display name: '<&a><&l>点击' \n  lore:  \n  - '<&e>左键点击: <&f>回到主城'  \n  - '<&e>右键点击: <&a>打开充值链接' \n  - '<&7>祝大家在服务器游玩愉快' \n  \nstoreopen: \n  type: item \n  material: i@diamond\n  display name: '<&a><&l>服务器商店' \n  lore:  \n  - '<&e>点击打开服务器商店'    \n  \n# 这是玩家输入指令后首先打开的GUI，里面包含两个按钮\ntest:  \n  type: inventory \n  inventory: dispenser\n  title: '<&1>PCD服务器菜单'\n  definitions: \n    test1: i@iron_fence\n    test2: i@diamond\n  slots: \n    - \"[] [] []\" \n    - \"[] [i@lobby] [i@storeopen]\" \n    - \"[] [] []\" \n# 这是第二个GUI\"服务器商店\"    \nstore:  \n  type: inventory \n  inventory: chest\n  title: '<&1><&l>PCD服务器商店'\n  size: 27\n  definitions: \n    test1: i@iron_fence\n    test2: i@diamond\n  slots: \n    - \"[test2] [test1] [test1] [test1] [test1] [test1] [test1] [test1] [test2]\" \n    - \"[test1] [i@cooked_beef] [i@melon] [i@potato_item] [i@apple] [i@carrot_item] [i@bread] [i@cake] [test1]\" \n    - \"[test2] [test1] [test1] [test1] [test1] [test1] [test1] [test1] [test2]\"    \n# 玩家执行指令，打开in@test GUI菜单，即“服务器菜单”    \ncmds:\n  type: world \n  debug: false\n  events: \n    on openinv command: \n    - determine passively fulfilled \n    - inventory open destination:in@test           \n# 玩家左键点击“服务器菜单”里的i@lobby物品时，显示消息\n# 除此之外，点击GUI内任何物品均取消动作，以防止拿物品出来\nrclick:       \n  type: world \n  debug: false\n  events: \n    on player right clicks in in@test: \n    - if <context.item.simple> = i@lobby {\n      - determine passively cancelled \n      - narrate '<&a>充值链接 www.mcbbs.net'\n      } else {\n      - determine passively cancelled \n      }\n# 玩家右键点击“服务器菜单”里的i@lobby物品时，传送玩家\n# 除此之外，点击GUI内任何物品均取消动作，以防止拿物品出来  \nlclick:       \n  type: world \n  debug: false\n  events: \n    on player left clicks in in@test: \n    - if <context.item.simple> = i@lobby {\n      - determine passively cancelled \n      - teleport <player> l@102,78,102,0,0,world\n      - wait 1t\n      - narrate '<&a>已将您传送至主城'\n      } else {\n      - determine passively cancelled \n      }\n# 玩家点击“服务器菜单”里的i@storeopen物品时，打开另一个GUI in@store,即“服务器商店”      \ncmdclick:       \n  type: world \n  debug: false\n  events: \n    on player clicks in in@test: \n    - if <context.item.simple> = i@storeopen {\n      - determine passively cancelled \n      - inventory open d:in@store\n      } else {\n      - determine passively cancelled \n      }      \n# 玩家在in@store菜单里点击时，取消事件，防止物品被拿出      \nstoreclick:       \n  type: world \n  debug: false\n  events: \n    on player clicks in in@store: \n    - determine passively cancelled 复制代码\n\n\n家庭作业：\n1，请给2.2-1实战中的“加血指令”新增功能，玩家输入/jx <玩家名> <血量值> 可给指定在线玩家加血\n（参考答案见2楼置顶）\n3. 配置 - 生成和读取配置文件教程目标：了解配置文件的生成和读取\n\n3.1 什么是配置文件？必须先把基础概念搞清楚配置文件的基础格式，不用我多解释吧：路径:\n  子路径:\n    子子路径1: 值\n    子子路径2: 值复制代码\n\n为了理解后面的内容，首先要厘清一个重要区别：\n磁盘里的配置文件和内存里的已加载配置\n你在文件夹里看到的一个一个的config.yml，是磁盘里的配置文件磁盘里的配置文件必须先加载进服务器内存，才能被读取/修改Denizen只能对内存里的配置文件进行修改，然后把已经修改好的配置一股脑地保存进磁盘里的配置文件为了内部方便，Denizen给每个内存里的已加载配置都赋予了一个id，这个id可以和配置文件本来的名字不同厘清这两者的区别以后，后面的内容就很好理解了\n\n你写的脚本到底有没有必要搞配置文件？以下是一些建议：\n★如果你写脚本是为了给自己的服务器用只是给自己用的话，添加配置文件只是徒增麻烦，我建议你不要弄配置文件，直接在脚本里修改就好\n★如果你写脚本是为了发布给别人用这种情况我建议还是添加配置文件比较好，用户可以一目了然地编辑，同时更有逼格，在MCBBS申请发布奖励时也可以更被版主看重\n\n\n3.2 生成与加载配置文件 | 脚本yaml一般插件的惯用步骤，一步一步来首先需要介绍一个新脚本：脚本yaml这个脚本可以用于生成配置，加载配置，卸载配置，读取并调用配置文件里的东西，保存修改到配置文件等等前文里已经讲了内存和磁盘配置文件两种形态的区别，接下来只要不涉及保存的，我们一律以内存里的已加载配置作为介绍中心，所谓的“配置id”也都是针对内存里的配置而言的\n常用的关于yaml的脚本：\n★生成配置（不是直接生成配置文件，搞清楚区别！）- yaml create id:<配置id>\n\n★编辑配置（如果路径不存在则会自动创建）- yaml id:<配置id> set 路径.子路径.子子路径:<值>\n\n★保存配置至文件/从文件加载配置至内存所谓的文件夹路径，其根目录都是你插件文件夹里的Denizen文件夹- yaml savefile:/<文件夹名字>/<配置文件名>.yml id:<配置id>- yaml load:/<文件夹名字>/<配置文件名>.yml id:<配置id>\n\n★常用变量<yaml[<配置id>].read[<路径>]> —— 最常用的变量：读取配置中某个设置项的值<yaml[<配置id>].read[<路径>].as_list> —— 若路径下包含多个子路径以及多个值，则以dList组数据的方式输出<yaml[<配置id>].contains[<路径>]> —— 布尔值变量，某配置文件中是否包含某路径\n\n让我们一边看例子一边讲，以下是一个生成并加载配置文件的脚本，常见的套路都在里面qi_dong:\n  debug: false\n  type: world\n  events:\n    # 当服务器启动时，注入脚本，加载配置文件（这一步必做）\n    on server start:\n    - inject locally path:jia_zai_pei_zhi\n    # 当整个Denizen重载时，注入脚本，加载配置文件（也可以不做这一步，单独使用指令重载也行）\n    on reload scripts:\n    - inject locally path:jia_zai_pei_zhi\n    # 你也可以自己指定一个\"重载指令\"，用来生成/重载配置文件（要加权限/OP限制）\n    on pluginreload command:\n    - determine passively fulfilled\n    - if <player.is_op.not> queue clear\n    - inject locally path:jia_zai_pei_zhi\n  jia_zai_pei_zhi:\n  # 加载配置之前先注入脚本，检查配置文件是否已经存在了\n  - inject locally path:check_config\n  - narrate '<&a>测试配置文件已加载/重载完毕！'\n  check_config:\n  # 先检查以下路径配置文件是否存在，如果存在，加载这个配置文件，并赋予其一个ID\n  # 某些偏执的插件作者可以在这一步里，一项一项检查配置项有没有拼写错误，缺漏什么的，这样也行\n  - if <server.has_file[/chajian/config.yml]> {\n    - yaml load:/chajian/config.yml id:config\n    # 如果配置文件不存在，先在内存里创建一个（仅ID），然后一项一项生成配置项，最后将其保存成磁盘里的配置文件\n    } else {\n    - yaml create id:config\n    - yaml id:config set PCD小组概况.年作品量.秋风残叶:16\n    - yaml id:config set PCD小组概况.年作品量.组长夜幕:12\n    - yaml id:config set PCD小组概况.年作品量.背锅坏黑:10\n    - yaml id:config set PCD小组概况.圈内贡献.秋风残叶:14\n    - yaml id:config set PCD小组概况.圈内贡献.女装海螺:90\n    - yaml id:config set PCD小组概况.PCD最棒:true\n    - yaml savefile:/chajian/config.yml id:config\n    }复制代码OK，只要运行这个脚本，在开服后/手动重载后，配置文件即可自动生成在Denizen文件夹中\n\n\n\n\n\nconfigpic.png (10.84 KB, 下载次数: 1)\n\n下载附件\n\n2018-12-25 23:33 上传\n\n\n\n\n\n这个配置文件里都写了些啥呀？\n\n\n\n\n\nconfignote.png (11.64 KB, 下载次数: 1)\n\n下载附件\n\n2018-12-25 23:34 上传\n\n\n\n\n\n\n3.3 读取和修改配置文件在游戏中对配置文件进行操作我们之所以添加配置文件，不是拿来干瞪眼看的，是要把他用进服务器中只要学会用相关变量，读取配置文件并不难# 该脚本的功能是：玩家输入指令/testc，从配置文件读取某一设置项的值，再输出出来\n# 首先你得确保你读取的配置文件已经加载进内存，否则你还要先加载才行\nxun:\n  debug: false\n  type: world\n  events:\n    on test command:\n    - determine passively fulfilled\n    - define zuoping <yaml[config].read[PCD小组概况.年作品量.秋风残叶]>\n    - narrate '<&e>秋风残叶的年作品量是<def[zuoping]> '复制代码\n\n\n\n\nzuoping.png (13.01 KB, 下载次数: 1)\n\n下载附件\n\n2018-12-25 23:40 上传\n\n\n\n\n\n修改配置文件也很简单，看例子（这是一个指令型脚本）\n# 该脚本的功能是：玩家输入指令/baocun <值>，可以修改某配置项的值\n# 首先你得确保你读取的配置文件已经加载进内存，否则你还要先加载才行\nbaocun:\n  debug: false\n  type: command\n  name: baocun\n  usage: /baocun\n  description: 这个指令可以让你保存输入的值到配置文件\n  script:\n  - if <context.args.get[2]||null> != null {\n    - narrate '<&c>指令参数过多'\n    - queue clear\n    }\n  - if <context.args.get[1]||null> == null {\n    - narrate '<&c>请输入要指定的值'\n    - queue clear\n    }    \n  - if <context.args.get[1]||null> !matches number {\n    - narrate '<&c>无效数值，请输入一个合法数字'\n    - queue clear\n    }    \n  - yaml id:config set PCD小组概况.年作品量.秋风残叶:<context.args.get[1]> \n  - yaml savefile:/chajian/config.yml id:config\n  - narrate '<&a>已将秋风残叶的年作品量设置为<context.args.get[1]>'复制代码\n\n\n\n\narticles.png (15.81 KB, 下载次数: 1)\n\n下载附件\n\n2018-12-26 00:04 上传\n\n\n\n\n\n本教程还没有写完待完成：inject脚本增加非本地注入示例，地图型脚本\n\n 指令与权限 /denizen help - 插件帮助/denizen scripts - 列出当前加载的脚本/denizen reload scripts - 重载脚本/denizen debug - 切换debug模式/denizen save - 将当前插件状态保存至saves.yml/denizen version - 查看denizen版本/ex <单行脚本> - 直接运行单行脚本\n\n本插件没有任何权限需要给玩家\n\n 配置文件 \n暂无\n\n\n 下载地址 \n本插件大小约5MB，请不要在Spigot帖子里下载，请至这里下载最新构建不知何故下载经常中断，可能需要多试几次（如果你下载下来的文件只有1MB说明中断了）\n\n更新记录\n#1649 搬运本插件（2018.06.24）\n\n\n\n\n[groupid=1330]PluginsCDTribe[/groupid]",
    "replies": [
        {
            "author": "xmdhs",
            "timestamp": 1529813580,
            "txt_content": "然而还是审核通过了  \n\n\n以后还是用记事本里保存草稿吧"
        },
        {
            "author": "贺兰兰",
            "timestamp": 1529826000,
            "txt_content": "还是审核通过了，，，，审核组的人压根不看的吗。。"
        },
        {
            "author": "huangzhidong",
            "timestamp": 1530003300,
            "txt_content": "类似script的插件？？"
        },
        {
            "author": "3222577979",
            "timestamp": 1530015600,
            "txt_content": "有了这个插件我再也不用面向对象。面向IDE编程了"
        },
        {
            "author": "INKDRRAK",
            "timestamp": 1530021720,
            "txt_content": "Denizen我吹爆"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1530337020,
            "txt_content": " 本帖最后由 秋风残叶 于 2018-6-30 14:28 编辑 \n\n家庭作业答案：\n请改写2.1 物品型脚本中的“夜视帽”实例，功能不变，至少用到一处flag脚本\n参考答案与解析（并非唯一实现方法，行之有理即可）\n\n# 该脚本的功能是：创建一个名叫yeshimao的物品（锁链头盔）玩家把它戴在头上可获得夜视效果\n# 玩家把帽子脱掉则夜视效果消失\n# \n# 先创建一个名叫yeshimao的物品，后面的脚本可以使用i@yeshimao来调用此物品\n# 也可在游戏中执行/ex give yeshimao来直接获得此物品  \nyeshimao: \n  type: item \n  material: i@chainmail_helmet \n  display name: '<&a>夜视帽' \n  lore:  \n  - '<&e>把它戴在头上'  \n  - '<&e>获得夜视效果' \n  bound: true \n  recipe:  \n  - i@ink_sack,15|i@redstone_block|i@ink_sack,1 \n  - i@glass|i@chainmail_helmet|i@glass \n  - i@ink_sack,2|i@quartz|i@ink_sack,4 \n   \nYESHIMAO_ON: \n  type: world \n  debug: false \n  events: \n    on player equips helmet: \n    # 当玩家戴上头盔时，检测玩家戴上的是不是i@yeshimao\n    # 如果是，给玩家加flag，加夜视效果，显示消息\n    - if <context.armor.simple> == i@yeshimao { \n      - flag <player> yeshimao_on_head\n      - narrate '你刚刚戴上了夜视帽！现在你能在黑暗中看清楚了' \n      - cast night_vision <player> duration:23h hide_particles \n      } \nYESHIMAO_OFF: \n  type: world \n  debug: false \n  events: \n    # 当玩家取下头盔时，检测玩家有没有flag标签yeshimao_on_head\n    # 如果有，执行adjust脚本，移除玩家自带效果，同时移除flag\n    on player unequips helmet: \n    - if <player.has_flag[yeshimao_on_head]> == true { \n      - adjust <player> remove_effects \n      - flag <player> yeshimao_on_head:!\n      } \n# 当玩家下线，移除flag\nYESHIMAO_QUIT: \n  type: world \n  debug: false \n  events:       \n    on player quits:\n    - if <player.has_flag[yeshimao_on_head]> {\n      - flag player torch_light_prev:!\n      }\n# 当玩家上线，移除全部已存在效果，以避免bug产生\nYESHIMAO_JOIN: \n  type: world \n  debug: false \n  events:       \n    on player joins:\n    - adjust <player> remove_effects 复制代码\n\n\n\n\n请给2.2-1实战中的“加血指令”新增功能，玩家输入/jx <玩家名> <血量值> 可给指定在线玩家加血\n参考答案与解析（并非唯一实现方法，行之有理即可）\n\ntest_command: \n  type: command \n  debug: false \n  name: jx\n  aliases: \n  - jiaxue\n  usage: /jx \n  description: 这是一个测试用的指令\n  script:  \n  - if <context.server> { \n    - announce to_console \"<&c>只有玩家可以使用此指令\" \n    - queue clear \n    }  \n  - if <context.args.get[3]||null> != null {\n    - narrate '<&c>指令参数过多'\n    - queue clear\n    }\n  - if <context.args.get[2]||null> == null {\n    - narrate '<&c>指令参数过少'\n    - queue clear\n    }  \n  # 检测第1个参数是否在全服玩家列表里，如果否，输出消息\n  - foreach <server.list_online_players> {\n    - if !<def[value].name.contains[<context.args.get[1]>]>  {\n      - narrate '<&c><context.args.get[1]>该玩家不存在或者不在线'\n      - queue clear\n      }    \n    }      \n  # 将以上可能性都排除后，再加血量  \n  - heal <context.args.get[1]> <context.args.get[2]>\n  - narrate '<&a>已为玩家<context.args.get[1]>加了<context.args.get[2]>血量'复制代码\n\n"
        },
        {
            "author": "我爱侬",
            "timestamp": 1530429420,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "星球冥王星",
            "timestamp": 1532528820,
            "txt_content": "表示看不懂，完全不知道这是甚么"
        },
        {
            "author": "JarKue",
            "timestamp": 1538385120,
            "txt_content": "重载的时候会这样是什么情况？"
        },
        {
            "author": "a3095272833",
            "timestamp": 1538386740,
            "txt_content": "要学好久的"
        },
        {
            "author": "1632131200",
            "timestamp": 1538394660,
            "txt_content": "可算是有人认真搬运了这个插件了,上个搬运者的描述堪称模糊不清"
        },
        {
            "author": "q_miao",
            "timestamp": 1538397300,
            "txt_content": "感谢楼主分享～"
        },
        {
            "author": "Ray_Hughes",
            "timestamp": 1539407580,
            "txt_content": "whf1152768145 发表于 2018-10-1 17:12\n重载的时候会这样是什么情况？\n这是你有地方写错了"
        },
        {
            "author": "JarKue",
            "timestamp": 1539419400,
            "txt_content": "bliblibli23333 发表于 2018-10-13 13:13\n这是你有地方写错了\nemm直接复制例子来着的。。"
        },
        {
            "author": "TheRam_",
            "timestamp": 1539477360,
            "txt_content": "感觉直接敲代码更好一点"
        },
        {
            "author": "2609848420",
            "timestamp": 1539483900,
            "txt_content": "实际上楼主不觉得如此形式的脚本过于复杂了么 我以前是打算用List<String>来一行一行判断的 还有就是各个脚本的互相跳转 希望能反馈给原作者"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1539484980,
            "txt_content": "2609848420 发表于 2018-10-14 10:25\n实际上楼主不觉得如此形式的脚本过于复杂了么 我以前是打算用List来一行一行判断的 还有就是各个脚本的互相 ...\n脚本的存在意义在于给那些没有Java基础的人一个写“插件”的机会，其宗旨是通俗易懂，而非高效\n不满足于脚本的话，完全可以尝试去写Bukkit插件了"
        },
        {
            "author": "q2635700450",
            "timestamp": 1539486960,
            "txt_content": "不错的插件在此支持一下"
        },
        {
            "author": "2609848420",
            "timestamp": 1539495360,
            "txt_content": "秋风残叶 发表于 2018-10-14 10:43\n脚本的存在意义在于给那些没有Java基础的人一个写“插件”的机会，其宗旨是通俗易懂，而非高效\n不满足于 ...\n我只是想说这个脚本的撰写方式还是有点复杂 或许是我太过理想化了 但是对于没有基础的人给他们解释一些脚本语句也不一定懂"
        },
        {
            "author": "486461",
            "timestamp": 1539607500,
            "txt_content": "神乎其技，不服不行"
        },
        {
            "author": "486461",
            "timestamp": 1539607500,
            "txt_content": "神乎其技，不服不行"
        },
        {
            "author": "JarKue",
            "timestamp": 1539953520,
            "txt_content": "请问有人知道配置里面那个mid音乐的原曲吗，急需！"
        },
        {
            "author": "青木-[RUST-MC]",
            "timestamp": 1549324020,
            "txt_content": "我想弄个\"检测玩家输入/tpa %player% 然后给被TP的玩家发送一条json消息，可以点击接受tp\"的脚本,这个插件能做到吗"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1549327920,
            "txt_content": "2869949486 发表于 2019-2-5 07:47\n我想弄个\"检测玩家输入/tpa %player% 然后给被TP的玩家发送一条json消息，可以点击接受tp\"的脚本,这个插件 ...\n思路：指令型脚本/tpa\n获取第二个变量，若变量不为空，输出消息“指令参数过多！”，终止序列\n获取第一个变量，若变量为空，输出消息“请输入要传送至的玩家名称！”，终止序列\n判断  第一个变量  不包含在  全服玩家在线列表  中，如果yes，输出消息“该玩家不存在或者不在线！”，终止序列\n将以上可能性排除，给<第一个变量>玩家发送tellraw指令（即json消息），<第一个变量>玩家点击指令执行/tpaccept\n传送过程可以使用第三方插件，也可以直接用teleport脚本"
        },
        {
            "author": "青木-[RUST-MC]",
            "timestamp": 1549338360,
            "txt_content": "秋风残叶 发表于 2019-2-5 08:52\n思路：指令型脚本/tpa\n获取第二个变量，若变量不为空，输出消息“指令参数过多！”，终止序列\n获取第一个 ...\n我有个MiaoChat，可以点击发起TP，很方便，但是没有便捷的接受TP的方式，我用的是\"我的世界联机侠\"联机平台，平台上提供的插件没有这一类，比如EasyTP，如今知道Denizen可以做到，实在是太好了。\n\n不过，你说的太复杂了，我是个初学者，他既然能发起tpa %player% 何必还要判断玩家是否在线什么的，能不能简单点，只要检测到有tpa %player%指令被发送，就给%player%发送一条JSON ？"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1549339260,
            "txt_content": "2869949486 发表于 2019-2-5 11:46\n我有个MiaoChat，可以点击发起TP，很方便，但是没有便捷的接受TP的方式，我用的是\"我的世界联机侠\"联机平 ...\nDenizen和其他tp插件属于两套系统，指令的触发也是两套系统\n你不想加那些判定也可以，但是如果玩家尝试tp到“不存在的玩家”身边，Denizen也会判定为合法（哪怕第三方传送插件不允许）"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1549339560,
            "txt_content": "2869949486 发表于 2019-2-5 11:46\n我有个MiaoChat，可以点击发起TP，很方便，但是没有便捷的接受TP的方式，我用的是\"我的世界联机侠\"联机平 ...\n比较简便的写法是直接使用触发型脚本“on tpa command”，然后同样要获取第一个参数（即“即将传送到的玩家名”）后面的步骤还是一样的，只不过这种写法我没试过，可行性未知"
        },
        {
            "author": "青木-[RUST-MC]",
            "timestamp": 1549340880,
            "txt_content": "秋风残叶 发表于 2019-2-5 12:06\n比较简便的写法是直接使用触发型脚本“on tpa command”，然后同样要获取第一个参数（即“即将传送到的玩 ...\n嗯 ， 谢谢 ， 我还有两个问题 ：\n1.我如果仔细的阅读了你的教程贴后 实现我那个想法 难度算不算大 ？\n2.GrScriptBlock 可以和本插件一起使用吗 ？"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1549341900,
            "txt_content": " 本帖最后由 秋风残叶 于 2019-2-5 12:47 编辑 \n2869949486 发表于 2019-2-5 12:28\n嗯 ， 谢谢 ， 我还有两个问题 ：\n1.我如果仔细的阅读了你的教程贴后 实现我那个想法 难度算不算大 ？\n2. ...\n1，难度非常小，实际上本插件的拓展性很大，我有朋友已经用这个脚本插件做出了RPG副本房间啥的（但是我的中文教程帖还不太全，很多东西你可能要去Denizenscript论坛啃生肉）\n2，可以兼容"
        },
        {
            "author": "青木-[RUST-MC]",
            "timestamp": 1549350960,
            "txt_content": "秋风残叶 发表于 2019-2-5 12:45\n1，难度非常小，实际上本插件的拓展性很大，我有朋友已经用这个脚本插件做出了RPG副本房间啥的（但是我的 ...\n好的，谢谢 ， 我以前没接触过这类东西，你说过的那些判断什么的，我只能从字面意思理解，我会自己先研究的，如果有不会的，还希望你能不吝赐教啊"
        },
        {
            "author": "1477959465",
            "timestamp": 1550301720,
            "txt_content": "不错支持一下！"
        },
        {
            "author": "蓝京",
            "timestamp": 1550311680,
            "txt_content": "请问,如果我想要输入一个指令,然后输入这个指令就等于输入我想要的那个指令,应该怎么做？"
        },
        {
            "author": "秋风残叶",
            "timestamp": 1550312220,
            "txt_content": "觲龗洃 发表于 2019-2-16 18:08\n请问,如果我想要输入一个指令,然后输入这个指令就等于输入我想要的那个指令,应该怎么做？ ...\n这个是最简单的啊，可以用on xxx command触发型脚本来写，也可以直接用指令型脚本来写\n我的教程写的够详细了"
        },
        {
            "author": "百万中出娘",
            "timestamp": 1562993100,
            "txt_content": "在插件里写插件 绝了"
        },
        {
            "author": "xystudio",
            "timestamp": 1566228840,
            "txt_content": "大佬牛逼！收藏了慢慢看qwq"
        },
        {
            "author": "Newfield",
            "timestamp": 1570516500,
            "txt_content": "这么强力的插件确实很不错"
        },
        {
            "author": "龙猫酱~",
            "timestamp": 1570532040,
            "txt_content": "小白不太懂，这种插件会不会占用很大的资源？"
        },
        {
            "author": "qwe1664828807",
            "timestamp": 1581897600,
            "txt_content": "问题来了这插件和SKRIPT那个强？（个人认为denizen结构比较清晰 但是SKRIPT我会用啊a.a）"
        },
        {
            "author": "轮回233",
            "timestamp": 1582622700,
            "txt_content": "很不错的插件，支持！"
        },
        {
            "author": "qq780520800",
            "timestamp": 1583054580,
            "txt_content": "怎么么有delay的延时命令，我都找遍了，没找到，脚本一下子就触发完了"
        },
        {
            "author": "1430704465",
            "timestamp": 1584068340,
            "txt_content": "我觉得有必要翻译一下官网，不然这个插件也没几个人知道怎么用，另外楼主你是咕咕咕了吗"
        },
        {
            "author": "1430704465",
            "timestamp": 1584083580,
            "txt_content": "因为我发现bound现在用不了，教程里面好多脚本也没法用（话说...我这边做自定义物品什么都行，就是不让做钟是什么鬼.....）"
        },
        {
            "author": "坠落流星",
            "timestamp": 1584084120,
            "txt_content": "很方便的，推荐使用"
        },
        {
            "author": "1430704465",
            "timestamp": 1584094740,
            "txt_content": "1430704465 发表于 2020-3-13 10:59\n我觉得有必要翻译一下官网，不然这个插件也没几个人知道怎么用，另外楼主你是咕咕咕了吗 ...\n和作者聊了聊发现是个屑作者因为我的服务器是离线模式就不理会我提的bug了"
        },
        {
            "author": "基努",
            "timestamp": 1587352860,
            "txt_content": "我的天看着好复杂"
        },
        {
            "author": "Jeven",
            "timestamp": 1587368640,
            "txt_content": "很好的插件"
        },
        {
            "author": "し不懂丶装懂つ",
            "timestamp": 1587368820,
            "txt_content": "mcbbs有你更精彩"
        },
        {
            "author": "qq1831723028",
            "timestamp": 1587375540,
            "txt_content": "有点牛逼这个插件"
        },
        {
            "author": "Match丶",
            "timestamp": 1587706680,
            "txt_content": "自定义很高"
        },
        {
            "author": "1736838308",
            "timestamp": 1597848180,
            "txt_content": "蓝京 发表于 2019-2-16 18:08\n请问,如果我想要输入一个指令,然后输入这个指令就等于输入我想要的那个指令,应该怎么做？ ...mycommand:\n  type: world\n  events:\n    on 改成你想要输入的指令 command:\n      - determine passively cancelled\n      - execute as_op \"你想要执行的指令\"复制代码\n以下是一个例子 当使用指令 /666 时 以管理权限执行 /warp sc\nmycommand:\n  type: world\n  events:\n    on 666 command:\n      - determine passively cancelled\n      - execute as_op \"/warp sc\"复制代码"
        },
        {
            "author": "1736838308",
            "timestamp": 1597848720,
            "txt_content": "2869949486 发表于 2019-2-5 07:47\n我想弄个\"检测玩家输入/tpa %player% 然后给被TP的玩家发送一条json消息，可以点击接受tp\"的脚本,这个插件 ...\n如果你的服务器有装基础插件的话，这个功能就很容易被实现\nmyscrpt:\n  type: world\n  events:\n    on tpa command:\n          - if <context.args.get[1].as_player.is_online> narrate \"<element[§c玩家 <player.name> 请求传送到你的位置,点击这条消息来同意!].on_click[tpaccept]>\" targets:<context.args.get[1].as_player>复制代码\n稍稍解释一下，当玩家使用tpa指令时，如果参数1的玩家在线，给参数1的玩家发送一个消息，当被发送消息的玩家点击消息时，执行指令/tpaccept\n如果没有基础插件的话，就只能/tp到玩家位置了"
        },
        {
            "author": "1736838308",
            "timestamp": 1597849440,
            "txt_content": "Denizen真的强，实现市面上99%的插件的功能不是问题"
        },
        {
            "author": "落落哟",
            "timestamp": 1597991700,
            "txt_content": "提示: 作者被禁止或删除 内容自动屏蔽"
        },
        {
            "author": "aipaicongge",
            "timestamp": 1598057700,
            "txt_content": "emmmmmmm 看不懂 但还要支持"
        },
        {
            "author": "Blauer",
            "timestamp": 1598060340,
            "txt_content": "感谢楼主分享"
        }
    ]
}