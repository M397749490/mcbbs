{
    "title": "【万年坑】【该章完结】Java高手训练营第四章：方法",
    "author": "ufof",
    "replyCount": 16,
    "timestamp": 1441341540,
    "txt_content": " 本帖最后由 ufof 于 2015-12-26 18:21 编辑 \n\n\n4.1 认识方法\n\n\n4.1.1 方法概述\n\n方法是程序当中必不可少的组成部分。我们之前在讲hello, world的时候就已经粗略的讲过了主方法。\n简单的来说，方法是一个用于封装代码的区。我们之前写程序的时候都是把所有代码放在主方法里面，这也做可行，但是有两个问题：\n代码复用性极差程序分类不明确\n\n为什么会复用性差？如果一段代码我需要在不同的地方执行若干次，需要把整段代码都得赋值粘贴一遍。这样做十分麻烦。\n\n分类不明确的原因：一个程序当中，不同的代码负责不同的事情。有一些代码干这件事；有一些代码干另外一件事。那么我怎么知道这段代码是干什么的？虽然可以加上注释，但是分类明确无法提现出来。\n\n有了方法，这两个问题可以得到解决：\n\n复用性的提高：如果一段代码我要用很多次，我就把它封装在一个方法里面。我要用的时候调用这个方法就可以了。不需要再把整段代码复制粘贴。\n\n分类明确：一段代码如果是干这件事的，我把他封装在方法中；干另一件事的，我把他封装在另一个方法中。这样一来，程序的分类性就慢慢地体现出来了。\n\n综上所述，可见方法的重要性。下一章我们学习如何定义方法。\n\n学生提问：为什么有一些人把方法说成函数？两者有区别吗？\n\n答：两者有区别。简单的来说，定义在类中的叫做方法；独立定义的叫做函数。Java是面向对象的编程语言，所有东西都定义在类当中，所以叫做方法。像C这类的面向过程语言，没有类这个概念，所以叫做函数。\n\n本章小结：\n把所有代码放在主方法中是有问题的方法用于封装代码，主方法可以调用其他方法\n\n\n\n4.2  方法的定义和调用方法\n\n\n4.2.1  方法的定义\n\n方法的定义语法如下：\n\n若干个修饰符 返回值类型 方法名(参数类型1 参数名称1,参数类型n 参数名称n){ \n    //方法中的代码\n}复制代码注1：修饰符是可选的\n注2：参数数量完全可变，也可以没有\n注3：方法名建议使用小驼峰命名法\n\n就拿我们之间接触过的主方法来讲：\npublic static void main(String[] args){}复制代码\npublic是权限修饰符static是静态修饰符void是返回值类型，表示没有返回值main是方法名String[]是字符串数组，是主方法的参数\n\n然而，我们这节当中先固定的把方法声明为“static void”。static具体会在面向对象（上）去讲；void讲返回值（也就是下一节）的时候会说明。static void前面还可以加上一个public，不过加不加都可以。\n那么，我们先来定义一下我们自己的方法吧！\n\nclass MethodDemo{\n    public static void main(String[] args){\n        \n    }\n    \n    static void printString(){                            //定义方法\n        System.out.println(\"hello, method\");\n    }\n}复制代码大家先不用管主方法。我们就先看printString()方法。\n这个方法很简单，就是一个无返回值无参数的小方法。但是现在如果我们运行这个程序的话，什么都不会发生。因为主方法里什么都没有。我们想要让主方法调用printString方法，怎么做呢？请看下一小节：\n\n\n4.2.2 方法的调用\n\n方法的调用语法如下：\n方法名(方法要求的参数);复制代码\n注：即使方法没有参数要求，括号也得要写。\n注2：如果被调用的方法和调用者在不同的类当中，需要实例化对象，这个我们先不管。\n\n接着用我们上面的例子：\n\nclass MethodDemo{\n    public static void main(String[] args){\n        printString(); //调用方法\n    }\n    \n    static void printString(){\n        System.out.println(\"hello, method\");\n    }\n}复制代码结果：\n\n\n\n在这个程序的第三行，主方法调用了printString()方法。现在再编译和运行一次，hello, method字符串将会被打印。\n\n本章小结：\n方法的定义语法是“修饰符 返回值 方法名(参数列表) {  }”\n方法先暂时声明为static void方法的调用语法是“方法名(需求的参数)”\n\n\n\n\n4.3 方法的参数以及返回值\n\n\n4.3.1 参数以及返回值概述\n\n如果方法中要使用到的量是未知的，是要被上一级调用者定义的，可以使用参数。例如，我写一个方法，这个方法可以计算加法。加哪两个数我这个方法知道吗？这个时候，可以在方法上定义两个参数。当上一级调用者调用我这个方法的时候，必须给我传进来两个数。这样就可以由上一级调用者指定未知的量。\n\n返回值相当于整个方法的结果。再用一下刚才加法的例子，两个数是参数，那么两个数的和即是这个方法的返回值。有返回值的方法可以被上一级调用者用作一个量，这个量就是方法的返回值。\n\n4.3.2 如何定义有参数的方法\n\n参数是在定义方法时定义的。例如：\nclass MethodDemo{\n    public static void main(String[] args){\n    \n    }\n   \n    static void printNumber(int num){\n        System.out.println(\"我的上级调用者输入的数字是：\"+num);\n    }\n}复制代码\n这个方法需求的参数是一个int类型。在方法体当中会使用到这个int。\n\n我们在调用这个方法时也得要传入一个int：\n\nclass MethodDemo{\n    public static void main(String[] args){\n        printNumber(5271);        //给printNumber()方法传入int类型：5271\n    }\n   \n    static void printNumber(int num){\n        System.out.println(\"我的上级调用者输入的数字是：\"+num);\n    }\n}复制代码结果：\n\n\n\n一个方法也可以要求多个参数。通过逗号隔开。例如：\n\nclass MethodDemo{\n    public static void main(String[] args){\n        printNumber(5271,3.14);        //给printNumber()方法传入int类型：5271，double类型3.14\n    }\n   \n    static void printNumber(int num, double num2){\n        System.out.println(\"我的上级调用者输入的第一个数字是：\"+num);\n        System.out.println(\"我的上级调用者输入的第二个数字是：\"+num2);\n    }\n}复制代码结果：\n\n\n\n在方法上定义的参数叫做“形式参数”，简称为形参；实际传入的数叫做“实际参数”，简称为“实参”。在上一个程序当中，printNumber()方法的num和num2就是形参；main()传入的5271和3.14叫做实参。\n\n现在，我们学习了参数的使用之后，来写这样的一个方法。这个方法可以接收两个数字，并打印出这两个数字的和。\n\nclass MethodDemo {\n    public static void main(String[] agrs) {\n        add(10,4);                                   //调用add()方法。传入10和4作为实参\n    }\n    static void add(int num, int num2) {   //add()方法，需求两个int\n         System.out.println(num+num2);   //将两个数字的和打印    \n    }\n}复制代码结果：\n\n\n\n\n4.3.3 定义有返回值的方法\n\n返回值是一个方法的最终值。当方法返回一个值时，该方法结束。上一级调用者可以使用有返回值的方法作为一个值来使用。如果一个方法不需要返回值，将返回值定义为void。\n\n如果方法要返回一个值，语法如下：\n\nreturn 值;复制代码\n当然，如果是void的方法，可以通过return结束方法。但是没有任何值被返回。\n\nreturn;复制代码\n例如，我们有一个方法，这个方法可以给你返回一个0。\n\nclass MethodDemo {\n    public static void main(String[] agrs) {\n        System.out.println(myMethod());    //由于myMethod()有返回值，可以把它作为一个值来使用。\n    }\n    \n    static int myMethod() {                //返回一个int类型的方法\n        return 0;                        //返回0\n    }\n}复制代码结果：\n\n\n\n在这个程序当中，myMethod()方法被定义为返回int类型的方法。方法体中将0返回。因此，main()中可以将myMethod()作为一个值来使用，就可以直接将其打印输出。\n\n定义方法，参数是两个int，返回他们的和：\n\nclass MethodDemo{\n    static int add(int num, int num2){\n        return num+num2;\n    }\n    public static void main(String[] args){\n        int sum = add(5,1);\n        System.out.println(sum);\n    }\n}复制代码结果：\n\n\n\n在这个方法当中，返回值类型为int。return是表示返回的关键字，后面紧跟的就是要返回的值。\n有返回值的方法可以被上一级调用者用作一个值。在主方法当中，add(5,1)返回的值赋值给了sum这个变量，然后打印输出。\n\n一个方法可以有多个返回值，但是一般使用判断语句区分开，例如定义减法方法：\n\nclass MethodDemo{\n    static int subtract(int num, int num2){\n        if(num>num2){                //如果num>num2\n            return num-num2;        //返回num-num2\n        }\n        else{\n            return num2-num;        //不然，返回num2-num\n        }\n    }\n    public static void main(String[] args){\n        System.out.println(subtract(4,7));\n    }\n}复制代码结果：\n\n\n\n4.3.4 参数可变方法\n\n参数可变方法是Java 1.5中新加入的一个功能之一。如果一个方法的某个参数的数量不确定，可以使用参数可变方法。\n\n语法如下：\n\n若干个修饰符 返回值类型 方法名(参数类型... 参数名){\n    //代码\n}复制代码\n可见，如果一个参数的数量不确定，在参数列表中的参数类型后面加上“...”即可。如果一个参数类型是这样的，其会变成一个数组类型。由于数组类型我们没有学到，请参数第六章。\n\n本章小结：\n被上一级调用者指定的量叫做参数方法的最终值叫做返回值，可以被上一级调用者用作一个量\n方法的参数和返回值在整个方法定义时被定义如果没有返回值声明为voidreturn用于返回其后面的值当方法返回了一个值之后，方法结束Java 1.5新功能之一是可变数量参数，在参数类型后面加上“...”即可当一个参数类型是可变的，其变成一个数组类型\n\n\n\n4.4 方法的重载\n\n\n4.4.1  重载概述\n\nJava允许出现多个方法方法名一样但是参数不同的情况，这种情况被称为方法重载。这样大大方便了程序的编写。比如说定义一个加法方法，两个int可以相加、两个double可以相加、两个long也可以相加.....因为重载的存在，我们不需要定义不同名称的方法了。\n\n虚拟机负责判断使用哪个方法。\n\n满足下列情况之一，构成重载\n\n参数数量不同参数顺序不同（不同类型）参数类型不同\n\n\n4.4.2  三种重载形式\n\n一、参数数量不同：\n\nstatic int add(int x, int y){\n    return x+y;\n}\nstatic int add(int x, int y, int z){\n    return x+y+z;\n}\n复制代码\n二、参数顺序不同：\n\nstatic double add(int x, double y){\n    return x+y;\n}\nstatic double add(double y, int x){\n    return x+y;\n}复制代码\n注意：两者类型也得要不同。不然无法构成重载\n\n三、参数类型不同static int add(int x, int y){\n    return x+y;\n}\nstatic double add(double x, double y){\n    return x+y;\n}复制代码\n4.4.3 测试\n\n我们先定义两个方法。其中一个方法需要两个int参数；另一个需要两个double参数。打印两个数的乘积。\n\nclass MethodDemo {\n    public static void main(String[] agrs) {\n        getProduct(2,5);                                //使用int, int\n        getProduct(0.5,0.5);                            //使用double, double\n    }\n\n    static void getProduct(int num, int num2) {            //重载1：int, int\n        System.out.println(num * num2);\n    }\n\n    static void getProduct(double num, double num2) {    //重载2：double, double\n        System.out.println(num * num2);\n    }\n}复制代码结果：\n\n\n\n在这个程序当中，getProduct()方法有两个重载形式：int, int 和 double, double。因此，调用时可以选择使用哪个重载形式。\n\n\n本章小结\n方法重载是指多个同名称的方法拥有不同的参数的情况由虚拟机判断选用哪个方法\n方法重载在三个情况下发生：数量、顺序、类型\n\n\n\n4.5 方法的递归\n\n\n4.5.1 递归概述\n\n递归是一种算法。指在方法中调用自己。这样的算法可以逐步逼近结果。但是要保证两点：\n\n的确是可以趋近结果必须是要有条件的递归，不然是死循环\n\n递归的缺点在于如果递归次数过多，有栈内存溢出的风险。\n\n4.5.2 阶乘例子\n\n先简单介绍一下阶乘：\n\nn!=n*(n-1)*(n-2)*(n-3).....*3*2*1\n\n例如7!=7*6*5*4*3*2*1=5040\n\n我们现在通过Java实现：\n\nstatic long getFactorial(long num){\n    long sum = 0;\n    if(num==0){\n        return 1;\n    }\n    else{\n        sum = num*getFactorial(num-1);\n        return sum;\n    }\n}\n复制代码\n定义getFactorial方法，返回值和参数都是long类型。\n在第七行中完成了递归。getFactorial(num-1)相当于重新调用了方法本身，传进去的参数是num-1。一直重复调用本身直到num==0为止。这个算法就实现了：\n\nclass RecursionDemo{\n    public static void main(String[] args){\n        System.out.println(getFactorial(5));\n    }\n    \n    static long getFactorial(long num){\n        long sum = 0;\n        if(num==0){\n            return 1;\n        }\n        else{\n            sum = num*getFactorial(num-1);\n            return sum;\n        }\n    }\n}复制代码结果：\n\n\n\n本章小结：\n递归是指方法调用本身递归必须要有一个条件控制，不然会是死循环递归的缺点是如果递归次数过多有栈内存溢出风险\n\n\n\n4.6 栈内存\n\n\n4.6.1  栈内存概述\n\n这一章我们不讲Java，我们就了解一下在程序运行时具体发生了什么。\nJava把栈内存去分成栈内存和堆内存。虽然这两个词只有一字之差，但是区别还是蛮大的。\n\n当一个方法被调用时，其就会被分配一个栈区。方法中的变量/常量在方法中的栈区内存放。\n栈内存中的栈区都是有序排放的，遵循后进先出的原则。\n\n\n\n当声明一个变量/常量时，其在其方法的栈区中被存放：\n\npublic static void main(String[] args){\n    int num = 5;\n    double d = 3.1;\n    aMethod()\n}\n\nvoid aMethod(){\n    int num = 3;\n    double d = 4.1;\n}复制代码\n\n\n我想现在大家可以明白为什么递归过多会栈内存溢出了。每一次递归都会分配一个栈区，所以会越来越卡。\n这个概念就先讲到这里。\n\n本章小结：\nJava把内存规划成栈内存和堆内存当一个方法被调用时，栈内存会给方法分配一个栈区变量/常量都在其方法的栈区中存放栈内存是有序的\n\n\n[groupid=546]Command Block Logic[/groupid]",
    "replies": [
        {
            "author": "simon3000",
            "timestamp": 1441426200,
            "txt_content": "感觉把目录最底下放一个会跟好?"
        },
        {
            "author": "ufof",
            "timestamp": 1441426560,
            "txt_content": "simon3000 发表于 2015-9-4 20:10\n感觉把目录最底下放一个会跟好?\n貌似不行。。"
        },
        {
            "author": "小尐蓝猫",
            "timestamp": 1441429920,
            "txt_content": "这个坑。。。"
        },
        {
            "author": "yuxuanchiadm",
            "timestamp": 1442070180,
            "txt_content": "讨论某些东西的叫法总会有一大堆异议是不争的事实。在Java当中有实例方法和静态函数的说法。也就是一般把属于实例的叫做方法，把属于类的叫做函数。而且方法的本质也是第一个参数被隐藏为调用这个方法的对象，也就是this。说到底实例(instance)本身也可以叫做对象(object)。并且大多数时候也是把方法(method)和函数(function)混着叫。只有实际需要区分时才会有区分的意义。简而言之就是方法和函数一般情况下就是一个东西。"
        },
        {
            "author": "ufof",
            "timestamp": 1442145840,
            "txt_content": "yuxuanchiadm 发表于 2015-9-12 07:03\n讨论某些东西的叫法总会有一大堆异议是不争的事实。在Java当中有实例方法和静态函数的说法。也就是一般把属 ...\n如果说属于类的叫做函数，那我可以说只要是static的就叫函数了吗？"
        },
        {
            "author": "2478003816",
            "timestamp": 1454293440,
            "txt_content": "看到这里我就想，学习这个英语水平要怎么样，数学基础是不是要好..呢{:10_527:}"
        },
        {
            "author": "HackerXuanxu",
            "timestamp": 1463823300,
            "txt_content": "额，那个......C++里也有类的概念，可是它的也叫函数......\n有错误请指出"
        },
        {
            "author": "ufof",
            "timestamp": 1463833740,
            "txt_content": "HackerXuanxu 发表于 2016-5-21 01:35\n额，那个......C++里也有类的概念，可是它的也叫函数......\n有错误请指出\n我在教程中说明了“方法”和“函数”严格意义上的区别，不过大多数情况下还是根据习惯说的。没必要钻牛角尖。\n关于挂图的事情我也了解到了，我争取放假的时候改正过来。"
        },
        {
            "author": "Innovators",
            "timestamp": 1465416600,
            "txt_content": "那个这个方法必须要有参数的吗?如果没有参数可以运行吗"
        },
        {
            "author": "ufof",
            "timestamp": 1465433940,
            "txt_content": "Innovators 发表于 2016-6-8 12:10\n那个这个方法必须要有参数的吗?如果没有参数可以运行吗\n不知层主说的“这个方法”指的是哪个方法。\n如果是主方法，必须是String[]参数；如果是自己定义的方法，参数随意，按需求定义。"
        },
        {
            "author": "Innovators",
            "timestamp": 1465450380,
            "txt_content": "ufof 发表于 2016-6-9 08:59\n不知层主说的“这个方法”指的是哪个方法。\n如果是主方法，必须是String[]参数；如果是自己定义的方法， ...\n抱歉,没注意到这个是目录点击的,在4.5方法的递归中getFactorial(long num)方法必须要参数吗？"
        },
        {
            "author": "ufof",
            "timestamp": 1465455360,
            "txt_content": "Innovators 发表于 2016-6-8 21:33\n抱歉,没注意到这个是目录点击的,在4.5方法的递归中getFactorial(long num)方法必须要参数吗？ ...\ngetFactorial()是求阶乘的方法，必然必须传入一个数字，这个方法才能计算这个数字的阶乘。这是逻辑问题，而非语法问题。"
        },
        {
            "author": "IDE_helloender",
            "timestamp": 1497618180,
            "txt_content": "2478003816 发表于 2016-2-1 10:24\n看到这里我就想，学习这个英语水平要怎么样，数学基础是不是要好..呢{:10_527:} ...\n恕我直言，我估计你没读完初中。"
        },
        {
            "author": "3328763831a",
            "timestamp": 1551176220,
            "txt_content": "ssssssssssssssssssssssssssssssssssssssssssssssss"
        },
        {
            "author": "名为123的貘",
            "timestamp": 1565878800,
            "txt_content": "其实说白了就是参数可分辨地不同"
        },
        {
            "author": "QWQ史蒂夫QWQ",
            "timestamp": 1565932200,
            "txt_content": "simon3000 发表于 2015-9-5 12:10\n感觉把目录最底下放一个会跟好?\n大佬活跃之地"
        }
    ]
}