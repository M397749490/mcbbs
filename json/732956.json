{
    "title": "使用猜的办法使NMS支持多版本服务端",
    "author": "鸭蛋只吃黄",
    "replyCount": 1,
    "timestamp": 1508149020,
    "txt_content": " 本帖最后由 凋灵兔子 于 2017-10-16 18:33 编辑 \n\n\n\n版主先不要通过，谢谢，我过几天在写，现在脑阔疼\n\n首先照顾一下伸手党，一行代码实现发送ActionBar并且支持多版本，参数什么的等你看完这篇文章就知道了~\n            Class.forName(version_nms+\"PlayerConnection\").getDeclaredMethod(\"sendPacket\", Class.forName(version_nms+\"Packet\")).invoke(Class.forName(version_nms+\"EntityPlayer\").getDeclaredField(\"playerConnection\").get(Class.forName(version_obc +\"entity.CraftPlayer\").getDeclaredMethod(\"getHandle\").invoke(player)), Class.forName(version_nms +\"PacketPlayOutChat\").getDeclaredConstructor(Class.forName(version_nms +\"IChatBaseComponent\"), Class.forName(version_nms +\"ChatMessageType\")).newInstance(Class.forName(version_nms +\"IChatBaseComponent$ChatSerializer\").getMethod(\"a\", String.class).invoke(null, \"{\"text\":\"\" + message + \"\"}\"), Class.forName(version_nms +\"ChatMessageType\").getMethod(\"a\", byte.class).invoke(null, (byte)2)));\n复制代码\n\n\n关于使用nms的时候如何兼顾多版本论坛中已经有很多帖子了，基本分为两种：1. 使用多个版本的服务端构建，将需要支持的版本全部情况写出来，然后在启动的时候根据实际版本加载对应的子类来实现多版本。但是这种方式明显有2个缺陷：\n①.无法支持更高版本。比方说我用1.8和1.9构建的插件，放在1.12的端上肯定就废了，因为我在写的时候并没考虑1.12的情况，必须要让作者重新构建。\n②.如果子类代码量多，会造成大量代码冗余（虽然这样可以让插件看起来大一些，要不3K5K的总感觉有点掉渣...）。\n2. 第二种方式是我一位朋友使用的，我至今没明白具体的工作原理，总之有很多switch case，我看了一下源码，感觉这种方式可以支持部分常用功能，但是对于冷门的就有点力不从心，需要重新写很多case才能支持新功能\n\n\n本老爷今天介绍一种比较懒人化的方式，通过规律来猜测下一个版本并且反射使用。这里举一个比较经典的例子：发送位置在经验条上面的信息.\n当你要写一个自己感觉无从下手的功能之前，建议你永远不要拿起键盘开干，我们先要看看网上有没有类似的功能，看看大神是怎么写的，要是没缺陷，那就没必要写了，直接当成前置调用就行了，如果没有，那就要修补大神的缺陷。由于知道这个信息学名叫ActionBar，所以本老爷受累去spigotmc下载了一个同名插件（选了一个几个KB的，那些几十KB的看着就发愁），得到以下代码：\nnet.minecraft.server.v1_8_R3.IChatBaseComponent;复制代码好吧，老外并没有给我们支持多版本。但是好在他给了我发送信息的思路以及我们需要的类，这里本老爷受累把如何确定这些类位置的方式也写出来，授人以渔。\n首先我们需要获取我们当前服务端的版本并且得到nms和obc的包名，由于太简单我就不讲解了。\n第二，反射我们需要的类\n关于反射，特别是反射查找相应的方法，本老爷有一个经验：参数严格，“类”型宽松，即当我们需要使用参数查找方法时，要用人家确定的类型，千万不要用多态，用了准炸。当反射产生了对象时，要用宽松的Object类型，不要使用确定的类型，否则反射就失去了意义（都有确定类型了还反射个P）。哇塞这都被你发现了......膜拜dalao...\n我们马上反编译服务端，什么？不想看反编译？写nms不反编译你在逗我？找到IChatBaseComponent，至于该去哪儿找这个当然是去nms包了，但是我们发现我们需要的ChatSerializer是一个内部类，所以直接反射内部类（反正反射又没有限制）\n<font face=\"微软雅黑\">这个version_nms就是nms所在的包名</font>复制代码\n\n\n\n",
    "replies": [
        {
            "author": "耗子",
            "timestamp": 1508306160,
            "txt_content": "为啥不用ProtocolLib和ReflectionUtils呢？"
        }
    ]
}