{
    "title": "[搬运+翻译][从零学编程]C++Ⅲ：数据类型，数组，指针",
    "author": "45gfg9",
    "replyCount": 9,
    "timestamp": 1564387860,
    "txt_content": " 本帖最后由 45gfg9 于 2020-3-21 19:45 编辑 \n\n\n索引贴\n答案帖\nPrev: C++Ⅱ：条件与循环\nNext: C++Ⅳ：函数\n\n\n1 介绍数据类型\n\n1.1 数据类型\n操作系统根据变量的[ruby=data type]数据类型[/ruby]为其分配内存并决定存储什么样的数据。\n数据类型规定了如何正确使用标识符、能存储什么样的数据、能进行什么操作。\n\nC++内置许多数据类型。\nPart题：\n数据类型旨在？\nA. 定义头文件名\nB. 定义标识符的合理使用\nC. 定义循环或if语句\n\n\n1.2 表达式\n下面的例子演示了C++中合法和非法的表达式。\n\n55+15 // 合法C++表达式\n// + 操作符的两个操作数都是整型\n\n55 + \"John\" // 非法\n// + 操作符没有对整型和字符串操作的定义\n你可以通过重载操作符来实现原本非法的表达式。关于这个我们之后会学。\nPart题：\n下面哪个表达式在C++中是合法的？\nA. \"hello\" + 11\nB. \"hello\" * 3.14\nC. 12 + 4\nD. 12 + \"Mike\"\n\n\n1.3 数值型数据\n数值型数据包括：\n[ruby=Integers]整型[/ruby]（整数），例如-7，42。\n[ruby=Floating point]浮点[/ruby]数，例如3.14，-42.67。\n\n接下来的课程中，我们会多解释一点。\nPart题：\n下面哪几个是数值型数据？\nA. 3.14\nB. 1000\nC. \"hello\"\nD. 'abc'\n\n\n1.4 字符串 & 字符\n[ruby=string]字符串[/ruby]是由数字、字符、符号组成的。字符串的内容放在双引号中，例如\"Hello\"，\"我叫David\"等。\n[ruby=Characters]字符[/ruby]是单个的字母或符号，必须放在单引号中，例如'a'、'b'等。\n\nC++中，单引号标记字符，双引号标记字符串。'a'是一个字符，但\"a\"是一个字符串。\nPart题：\n下面哪个是合法的字符，不是字符串？\nA. \"this\"\nB. 'this'\nC. 't'\nD. \"or this\"\n\n\n1.5 布尔值\n[ruby=Boolean]布尔[/ruby]数据类型只返回两个可能的值：[ruby=真]true[/ruby]（1）或[ruby=假]false[/ruby]（0）。\n\n条件表达式是布尔值的一个例子。\nPart题：\n10 == 10的结果是true还是false？\n\n\n\n2 int，float，double\n\n2.1 整型（一）\n整型类型存储整数，可以是正数或负数。举例，42，-42等。\n\n整型的大小取决于程序运行的系统架构，在现代系统上应该是4字节。\nPart题：\n3.14是整型吗？\n\n\n2.2 整型（二）\n用int关键字定义整型数据。\n\nint a = 42;\n包括整型在内的几种基础数据类型都可以使用下面的一个或多个属性[ruby=modifiers]修饰符[/ruby]：\n[ruby=有符号]signed[/ruby]：一个有符号整型可以存储非负数或负数。\n[ruby=无符号]unsigned[/ruby]：一个无符号整型只能存储非负数。\n[ruby=短]short[/ruby]：默认大小的一半。\n[ruby=长]long[/ruby]：默认大小的两倍。\n举例：\n\nunsigned long int a;\n根据操作系统不同，整型会保留4-8个字节。\nPart题：\n填空声明一个只能存储非负整数的变量var。\n\n________ int var;\n\n\n2.3 浮点数\n浮点类型可以存储实数，例如420.0，-3.33，0.03325。\n“浮点”一词表示在小数点前后都可以出现数字。你可以说小数点有“飘浮”的能力。\n\n有三种不同的浮点数据类型：[ruby=单精度浮点]float[/ruby]，[ruby=双精度浮点]double[/ruby]，和[ruby=长双精度浮点]long double[/ruby]。\n\n在绝大多数现代计算机架构中，float占4字节，double占8字节，long double可能是double（8字节），也可能是16字节。\n举例：\n\ndouble temp = 4.21;\n浮点数都是有符号的，意味着它们能存储非负数和负数。\nPart题：\n浮点数据类型能存储负数吗？\n\n\n\n3 string，char，bool\n\n3.1 字符串\n字符串是字符的序列，被双引号包围。\n字符串是标准资源的一部分。\n如果要使用字符串，必须先包含<string>库。或者，你也可以使用包含string库的库。\n\n#include <string>\nusing namespace std;\n\nint main() {\n  string a = \"我在学C++\";\n  return 0;\n}\n<string>库包含在<iostream>库中，所以如果你已经使用了<iostream>，就不再需要单独包含<string>。\nPart题：\n填空使程序能使用字符串数据类型。\n\n#include <______>\n\n\n3.2 字符\n一个字符型变量存储一个1字节的整数，但字符型变量的值通常被解释为一个ASCII字符，而不是整型。\n\n字符数据类型被单引号包围。\n举例：\n\nchar test = 'S';\n[ruby=American Standard Code for Information Interchange]美国信息交换标准代码[/ruby]（ASCII）是一套用于表示计算机文本的字符编码标准。\nPart题：\n填空声明一个char型变量称为var，值为'z'。\n\n____ ___ = 'z';\n\n\n3.3 布尔值\n布尔数据类型只返回两个可能的值：[ruby=真]true[/ruby]（1）或[ruby=假]false[/ruby]（0）。\n用关键字bool声明一个布尔变量。\n\nbool online = false;\nbool logged_in = true;\n如果将布尔值赋给整型，则true变为1，false变为0。\n如果将整数赋给布尔类型，则0变为false，其他所有不为0的数变为true。\nPart题：\n填空声明两个布尔变量a和b，用true作为b的初值。\n\n____ a = false;\nbool b = ____;\n\n\n\n4 变量命名规则\n\n4.1 变量命名规则（一）\n当给变量命名的时候，要遵循下面的规则：\n\n变量名必须以字母或下划线（ _ ）开头开头的字母后可以包含其他字母或数字。空格和特殊字符不允许作为变量名。\n\n（Ps. 可以使用汉字作为变量名，但不可使用全角标点符号）\n\n有两种约定俗成的命名方法：\n[ruby=Pascal Case]帕斯卡拼写法[/ruby]：组成标识符的单词首字母全部大写，例如BackColor。\n[ruby=Camel Case]骆驼拼写法[/ruby]：标识符首字母小写，组成标识符的其他单词首字母大写，例如backColor。\nPart题：\n下面哪条是命名变量的正确规则？\nA. 不能以字母开头\nB. 不能以数字开头\nC. 不能包含下划线\n\n\n4.2 大小写敏感性\nC++是[ruby=case-sensitive]大小写敏感[/ruby]的，意味着大写的标识符与同名的小写标识符不等同。\n举例，myvariable，MYVARIABLE和MyVariable都不相同，它们是三个不同的变量。\n\n起名时应该使其用途明了，例如firstName，lastName。\nPart题：\n下面哪条是C++中合法的变量名？\nA. salary\nB. 14var\nC. &*^var\nD. name3_var\n\n\n4.3 变量命名规则（二）\nC++关键字（保留字）不能用作标识符。\n举例，int、float、double、cout不能用作变量名。\n\n事实上对变量名的长度没有限制（视不同系统而言），但是尽量确保变量名有实际意义。\nPart题：\n填空声明一个名为var3的int变量，一个名为salary的double变量，一个名为ab_c14的bool变量。\n\n___ var3;\n______ salary;\n____ ab_c14;\n\n\n\n5 数组\n\n5.1 数组\n[ruby=array]数组[/ruby]用来存储一系列数据，也可以将数组想象成相同类型的变量集合。\n相比声明多个单独的变量存储单独的值，你同样可以可以用一个数组存储所有值。\n当声明数组时，要规定其元素类型，还有其存储的元素数量。\n举例：\n\nint a[5];\n上面的例子中，变量a被声明为能存储5个整型值的数组 [在方括号中规定] 。\n可以在声明时给数组赋初值。\n\nint b[5] = {11, 45, 62, 70, 88};\n初值包含在{花括号}中，是一个由逗号分隔的列表。\n\n花括号 { } 中值的个数必须不能超过方括号 [ ] 中定义的数组长度。\nPart题：\n填空创建一个名为myArr的整型数组，大小为5，包含值1、2、3、4、5。\n\n___ myArr[5] = { 1, 2, 3, 4, 5 _ ;\n\n\n5.2 初始化数组\n如果省略数组大小，那么会创建一个大小刚好能容纳全部初值的数组。\n举例：\n\nint b[] = {11, 45, 62, 70, 88};\n这创建一个与之前例子中相同的数组。\n\n数组中的每个元素，或成员，都有其[ruby=index]索引[/ruby]，标注了元素的特定位置。\n数组的第一个成员索引为0，第二个成员索引为1。\n所以，这是我们之前定义的数组b：\n\n\n1145627088[0][1][2][3][4]\n\n要访问数组元素，用方括号中元素位置对数组进行索引。\n举例：\n\nint b[] = {11, 45, 62, 70, 88};\n\ncout << b[0] << endl;\n// 输出11\n\ncout << b[3] << endl;\n// 输出 70\nPart题：\n填空输出一个大小为5的数组的第一个值和最后一个值。\n\ncout << arr[ _ ] << endl;\ncout << arr[ _ ] << endl;\n\n\n5.3 访问数组元素\n索引也可以用来给元素赋新值。\n\nint b[] = {11, 45, 62, 70, 88};\nb[2] = 42;\n这给数组的第三个元素赋值42。\n\n牢记数组索引以0开始。\nPart题：\nC++中数组从几开始计数？\nA. 0\nB. 1\nC. 2\n\n\n\n6 在循环中使用数组\n\n6.1 循环中的数组（一）\n有时需要对列表中的元素进行迭代，根据特定的计算给元素重新赋值。\n\n通常这需要用[ruby=loop]循环[/ruby]完成。\nPart题：\n填空声明一个整型数组，大小为9。\n___ anArray[ _ ];\n\n\n6.2 循环中的数组（二）\n让我们声明一个数组，它会存储5个整型，而且用for循环为每个元素赋值：\n\nint myArr[5];\n\nfor(int x=0; x<5; x++) {\n  myArr[x] = 42;\n}\n数组中的每个元素都被赋予了42的值。\nfor循环中的x变量用作了数组的索引。\n\n数组最后一个元素的索引是4，所以for循环的条件是x<5。\nPart题：\n填空声明一个包含9个整型的数组。用for循环给每个元素赋值45。\n\nint anArray[ _ ];\nfor (int x = 0; x <= _; x++)\n{\n anArray[ _ ] = 45;\n}\n\n\n6.3 循环中的数组（三）\n让我们输出数组中对应的索引和值。\n\nint myArr[5];\n\nfor(int x=0; x<5; x++) {\n  myArr[x] = 42;\n\n  cout << x << \": \" << myArr[x] << endl;\n}\n\n/* 输出\n0: 42\n1: 42\n2: 42\n3: 42\n4: 42\n*/\nPart题：\n填空输出有3个元素的数组arr中的所有元素：\n\nfor (int x = 0; x < _; x++) {\n ____ << ___ [x] << endl;\n}\n\n\n\n7 计算中的数组\n\n7.1 计算中的数组\n下面的代码演示了用for循环计算一个数组中所有元素之和的程序。\nint arr[] = {11, 35, 62, 555, 989};\nint sum = 0; \n\nfor (int x = 0; x < 5; x++) {\n  sum += arr[x];\n}\n\ncout << sum << endl;\n//输出 1652\n让我们回顾一下：我们声明了一个数组，变量sum用于存储元素之和。\n接着，我们利用一个for循环迭代数组中的每个元素，并将对应的元素值加到sum变量中。\n数组中，第一个元素的索引是0，所以for循环将变量x初始化为0。\nPart题：\n填空用for循环计算myArray中各元素的和并输出到屏幕上。myArray是一个包含4个double元素的数组。\ndouble sum = 0.0;\nfor (int x = 0; x < _ ; x++) {\n  sum += myArray[x];\n}\n____ << sum << endl;\n\n\n\n8 多维数组\n\n8.1 多维数组（一）\n一个[ruby=multi-dimensional]多维[/ruby]数组存放着一个以上数组。用下面的方式声明多维数组。\n类型 名称[大小1][大小2]...[大小N];\n下面，我们创建一个3x4的二维int数组：\nint x[3][4];\n将这个数组以3行4列表格的方式呈现：\n\n\n\n列1列2列3列4行1x[0][0]x[0][1]x[0][2]x[0][3]行2x[1][0]x[1][1]x[1][2]x[1][3]行3x[2][0]x[2][1]x[2][2]x[2][3]\n\n\n记住，元素计数永远以0开始。\nPart题：\n填空声明一个2行4列的二维数组multiArr：\nint multiArr[ _ ][ _ ];\n\n\n8.2 二维数组\n多维数组可以用花括号包围的值初始化。下面是一个有2行3列的数组：\nint x[2][3] = {\n  {2, 3, 4}, // 第一行\n  {8, 9, 10} // 第二行\n};\n元素要使用数组的行索引与列索引访问。举例：\nint x[2][3] = {{2, 3, 4}, {8, 9, 10}};\ncout << x[0][2] << endl;\n\n//输出 4\n第一个索引0指第一行。第二个索引2指第一行中的第三个元素4。\nPart题：\n填空输出arr第1行第2列的值。\ncout << arr[ _ ][ _ ] << endl;\n\n\n8.3 多维数组（二）\n数组可以包含任意数量的维度。\nstring threeD[42][8][3];\n上面的例子声明了一个三维string数组。和我们前面做的一样，可以用索引访问和修改元素。\n多于三维的数组更难维护。\nPart题：\n填空声明一个2行3列的数组。用cin输入位于第2行第2列的元素。\nint arr[2][ _ ];\ncin >> arr[ _ ][ _ ];\n\n\n\n9 初识指针\n\n9.1 指针（一）\n每个变量都是一块内存位置，有自己的[ruby=address]地址[/ruby]。\n这个地址可以用[ruby=ampersand]and号[/ruby] (&)运算符（也叫[ruby=address-of]取地址[/ruby]运算符），它表示内存中的地址。\n举例：\nint score = 5;\ncout << &score << endl;\n\n//输出 \"0x29fee8\"\n这会输出存储着变量score的内存地址。\nPart题：\n填上缺失的运算符，使\"fish\"变量的地址输出到屏幕上。\nint fish = 5;\ncout << _fish << endl;\n\n\n9.2 指针（二）\n[ruby=Pointer]指针[/ruby]是以其他变量的地址为值的变量。\n在C++中，指针能使某些任务更容易执行。其他任务，例如动态内存分配，不能不用指针来完成。\n所有的指针都是一样的数据类型——一个十六进制long，表示内存地址。\n不同指针的区别只有指针所指向变量的数据类型。\nPart题：\n指针是什么？\nA. 函数\nB. 包含地址的数据类型\nC. 头文件\n\n\n9.3 指针（三）\n指针也是变量，与其他种类的变量一样，在使用前必须先声明。\n星号用来声明指针（和你用来做乘法的星号一样的星号），然而，在这种语句中信号用来将某个变量指定为指针。\n下面都是有效的指针声明：\nint *ip;  // 指向整型的指针\ndouble *dp;   // 指向双浮点的指针\nfloat *fp;  // 指向单浮点的指针\nchar *ch;  // 指向字符的指针\n与其他变量相同，我们给指针定义类型并起名。指针的声明类型表示指针指向元素的类型。\n星号可以和数据类型放一起，亦可以与变量名放一起，也可以单独放在中间。\nPart题：\n填上缺失的符号，使变量\"ptr\"成为指向int的指针。\nint _ptr;\n\n\n9.4 使用指针\n这里，我们将变量的地址赋给一个指针。\nint score = 5;\nint *scorePtr;\nscorePtr = &score;\n\ncout << scorePtr << endl;\n\n//输出 \"0x29fee8\"\n上面的代码声明了一个指向整型的指针scorePtr，并用and号（取地址）运算符将变量score的地址赋给它。\n现在，scorePtr的值是score的内存位置。\nPart题：\n填空声明一个指向int的指针，赋予它变量var的地址。\nint var = 5;\nint _ptr = _var;\n\n\n\n10 再谈指针\n\n10.1 指针运算\n\n对于指针，有两种运算符：\n[ruby=Address-of]取地址[/ruby]运算符 (&)：返回其操作数的地址。\n[ruby=Contents-of]取内容[/ruby]（或[ruby=dereference]间接引用/间接访问[/ruby]）运算符 (*)：返回其操作数包含的地址存储的值。\n举例：\nint var = 50;\nint  *p;\np = &var;\n\ncout << var << endl;\n// 输出 50（var的值）\n\ncout << p << endl;\n// 输出 0x29fee8 （var的内存地址）\n\ncout << *p << endl;\n// 输出 50 （指针p指向的变量的值）\n星号(*)在声明中只是简单地表示这个变量是个指针（星号是声明类型的一部分）。不要将它与间接引用运算符混淆了，后者是用来获取某个地址中所存放的值。它们只是两种同类型操作的不同运算。\nPart题：\n填空声明变量x=25，指针p=x的地址。向屏幕输出指针包含的地址。\nint x = 25;\nint * p = _x;\ncout << _ << endl;\n\n\n10.2 间接引用\n\n间接引用运算符(*) 基本就是指针所指值的别名。\n话不多说，上例子：\nint x = 5;\nint *p = &x;\n\nx = x + 4;\nx = *p + 4;\n*p = *p + 4;\n上面三条语句效果相同，结果相同。我们可以通过间接引用变量的指针来访问变量的值。\n由于p指向变量x，所以间接引用指针 (*p)与直接使用变量x完全一样。\nPart题：\n填空声明两个变量a，b；和两个指针pa，pb，分别指向a和b。通过指针pa改变a的值，通过指针pb将值加到b里。\nint a = 12; int b = 13;\nint * pa = &a;\nint * pb = _b;\n*pa += _pb; // 与a += b一样\n\n\n\n11 动态内存\n\n11.1 静态和动态内存\n\n要成为一个成功的C++程序员，就不能不充分了解[ruby=dynamic memory]动态内存[/ruby]的原理。\n在C++程序中，内存分两部分：\n[ruby=stack]栈[/ruby]：你所有的[ruby=local variable]局部变量[/ruby]占用栈内存。\n[ruby=heap]堆[/ruby]：未用到的内存，当程序运行时需要动态分配内存时使用这里的内存。\n很多时候，你都不会察觉在用变量存储信息时所用内存大小，有时需要的内存大小可以在运行时再决定。\n你可以用new运算符在堆中给变量分配一块内存，这个运算符返回所分配内存的地址。\nnew int;\n这会在堆中分配一块足以存储一个整型大小数据的内存，并返回这个地址。\nPart题：\n填空来分配一个int变量大小的内存（用\"new\"关键字）：\n_______;\n\n\n11.2 动态内存（一）\n\n分配的地址可以存在指针里，之后可以间接引用来访问其变量。\n例子：\nint *p = new int;\n*p = 5;\n我们给一个整型动态分配了内存，并给其赋值5。\n指针p作为局部变量存储在栈中，它自身存储了堆中分配的地址。值5存储在堆中那个地址的位置。\nPart题：\n填空声明一个指向int的指针ptr，包含用new int;表达式返回的地址。\nint _ ptr = new int;\n\n\n11.3 动态内存（二）\n对于栈中的局部变量，内存管理是自动进行的。\n在堆中，就必须手动管理分配的内存，当不再需要它的时候用delete运算符释放这块内存。\ndelete pointer;\n这条语句释放pointer指向的内存。\n举例：\nint *p = new int; // 申请内存\n*p = 5; // 存值\n\ncout << *p << endl; // 用值\n\ndelete p; // 释放内存\n忘记释放用new关键字分配的地址会导致内存泄漏，因为那块内存在程序结束运行前会一直存在。\nPart题：\nC++中哪个关键字用来释放分配的内存？\n\n\n11.4 悬垂指针\ndelete运算符释放给变量分配的内存，但并不删除指针本身，因为指针存储在栈上。\n指向不存在的内存地址的指针叫做[ruby=dangling pointers]悬垂指针[/ruby]。\n举例：\nint *p = new int; // 申请内存\n*p = 5; // 存值\n\ndelete p; // 释放内存\n// 现在p是悬垂指针了\n\np = new int; // 重新申请新地址\nNULL指针是有着值0的常量，在不少标准库中都有定义，包括iostream。\n在声明变量时给其赋NULL是很好的习惯，以防你没有能分配给它的合适的地址。有值NULL的指针叫做空指针，举例：int *ptr = NULL;\nPart题：\n填空在堆中分配一块int大小的地址，让\"ptr\"指向它，然后释放分配的内存。\nint * ptr = ___ int;\n______ ptr;\n\n\n11.5 动态内存（三）\n动态内存也可以分配给数组。\n举例：\nint *p = NULL; // 用空值初始化的指针\np = new int[20]; // 申请内存\ndelete [] p; // 删除p指向的数组\n注意语法中的方括号。\n动态内存分配在很多情况下都很有用，例如当你的程序要依靠输入的时候。举个例子，当你的程序需要读取一个图像文件，它无法提前知道图像的大小，和存储这个图像所需的内存为多少。\nPart题：\n多选题：下面正确的表述有：\nA. new在堆中动态分配内存\nB. delete释放堆中的内存\nC. new返回一个浮点数\nD. delete从你计算机中卸载程序\n\n\n\n12 sizeof() 运算符\n\n12.1 sizeof\n虽然对于不同的数据类型，所分配的内存大小由你的计算机架构决定，但C++对每种数据类型的大小都有一个最小限制：\n\n\n分类类型最小内存大小布尔bool1字节字符char1字节整数short2字节int2字节long4字节long long8字节浮点float4字节double8字节long double8字节\n\nsizeof运算符可以用来获取变量或数据类型占用内存的大小，以字节为单位。\n语法：\nsizeof(数据类型)\nsizeof运算符以字节为单位返回一个类型或一个变量的大小。\n举例：\ncout << \"char: \" << sizeof(char) << endl;\ncout << \"int: \" << sizeof(int) << endl;\ncout << \"float: \" << sizeof(float) << endl;\ncout << \"double: \" << sizeof(double) << endl;\nint var = 50;\ncout << \"var: \" << sizeof(var) << endl;\n\n/* 输出\nchar: 1\nint: 4\nfloat: 4\ndouble: 8\nvar: 4\n*/\n输出在不同计算机和不同编译器上可能不同。\nPart题：\n用sizeof()运算符向屏幕输出char类型变量的大小。\nchar c;\ncout << ______(c) << endl;\n\n\n12.2 数组大小\nC++ sizeof运算符也能用来计算数组的大小。\n还是举例：\ndouble myArr[10];\ncout << sizeof(myArr) << endl; \n\n//输出 80\n在我们的电脑上，double占8字节。由于数组存储10个double，所以整个数组占80 (8*10) 字节内存。\n另外，用整个数组占用的内存大小除以数组中单个元素的大小就能得到数组中元素个数。\n例例例：\nint numbers[100];\ncout << sizeof(numbers) / sizeof(numbers[0]);\n\n// 输出 100\nPart题：\n填空声明有10个double的数组，并用sizeof()运算符输出数组占用内存大小。\ndouble arr[ __ ];\ncout << sizeof( ___ ) << endl;\n\n\n\n章末检测\n\n1. 补全变量a，b，c，d的数据类型。a是整型，b是双精度浮点，c是字符，d是字符串。\n___ a;\n______ b;\n____ c;\n______ d;\n\n\n2. 下面哪些是合法的C++变量名？\nA. notLegal\nB. 13legal_name\nC. *!@is-legal\nD. think_is_LEGAL\n\n\n3. 填空声明一个包含12个double的数组darr。\ndouble darr ____;\n\n\n4. 补全代码，用for循环向屏幕输出myArray中的元素。\nint myArray[4] = { 1, 2, 3, 4 };\nfor (int x = 0; x < _; x++) {\n cout << myArray[ _ ] << endl;\n}\n\n\n5. 填空声明一个包含14个整型的数组myArray，并用cin运算符给每个元素赋值。\nint myArray[ __ ];\nfor (int x = 0; x < 14; x++) {\n ___ >> myArray[x];\n}\n\n\n6. new int;表达式的作用是？\nA. 删除堆中所有内存\nB. 在堆中分配内存\nC. 声明名为new int的函数\n\n\n7. 填空声明一指向int的指针\"ptr\"并将var的地址赋之。\nint var = 25;\nint _ ptr = _ var;\n\n\n8. 填空声明两个变量a，b；和两个指针pa，pb分别指向a，b。通过pa和pb向屏幕输出a除以b的值。\nint a = 12; int b = 14;\nint* pa = &a;\nint* pb = &b;\ncout << _ pa _ *pb << endl;\n",
    "replies": [
        {
            "author": "qKillerp",
            "timestamp": 1564395180,
            "txt_content": "让我来瞅瞅隐藏的啥"
        },
        {
            "author": "XYZ_sxk",
            "timestamp": 1569078060,
            "txt_content": "我想学，拜托了。"
        },
        {
            "author": "45gfg9",
            "timestamp": 1569211680,
            "txt_content": "XYZ_sxk 发表于 2019-9-21 23:01\n我想学，拜托了。\n…………\n你们的希望就是我的动力\n没想到我还没死！\n虽然漫长！但请相信一定会更新！"
        },
        {
            "author": "anan876",
            "timestamp": 1569420420,
            "txt_content": "666666666666666666"
        },
        {
            "author": "岩浆君WYH",
            "timestamp": 1569460860,
            "txt_content": "隐藏的啥[:hide:]"
        },
        {
            "author": "541572010q",
            "timestamp": 1572505860,
            "txt_content": "我也在慢慢学习c++，谢谢你的指导，收藏了"
        },
        {
            "author": "SKYhu",
            "timestamp": 1572680100,
            "txt_content": "感謝樓主分享"
        },
        {
            "author": "这里小雨.",
            "timestamp": 1579408080,
            "txt_content": "感谢楼主.加油"
        },
        {
            "author": "45gfg9",
            "timestamp": 1584453780,
            "txt_content": "更新：9.4中\n现在，*scorePtr的值是score的内存位置。\n应改为\n现在，scorePtr的值是score的内存位置。\n因为每次编辑都要进审核 开C++Ⅳ后再编辑"
        }
    ]
}