{
    "title": "强行构造实例 —— MethodHandle 的别样使用示例",
    "author": "Karlatemp",
    "replyCount": 2,
    "timestamp": 1579774440,
    "txt_content": "我在这里提供一种强制构造实例的方法. 通过MethodHandle\n\n首先，我们先看看Object的构造器有什么东西\n\n很简单，看不出什么，但是当我们把Debug模式打开后，就不一样了\nDirectMethodHandle.allocateInstance. 好, 让我们看看他做了什么\n\nUNSAFE.allocateInstance(dmh.instanceClass);\n\n这句就是MH构建对象实例的方法, 然后我们看看unreflect出来的MethodHandle是什么东东\n\n就是Constructor, 也就代表我们只需要修改instanceClass这个字段就可以修改实例化的目标类\n\n\n好，这就是我们目前实例化说需要做的，但是如果每次都要写这么长/运行这么多的话明显不划算，所以我们在将其封装一下\n\n有了这些，我们就可以做一些有趣的事情，比如\n\n但是，有些地方要注意，用这个方法构造出来的对象的字段都是没有值的\n\n\n好, 下面是这个实例的一部分用途:\n1. 忽略某些类的内置检查/逻辑, 比如 JarConnection\n2. 发包内容 (笑\n\n\n\n/*\n * Copyright (c) 2018-2020 Karlatemp. All rights reserved.\n * Reserved.FileName: MHAlloc.java@author: karlatemp@vip.qq.com: 2020/1/23 下午4:45@version: 2.0\n */\n\npackage cn.mcres.karlatemp.mxlib.tester.mh;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class MHAlloc {\n    public MHAlloc() {\n        throw new IllegalArgumentException(\"DENY\");\n    }\n\n    private static final Function<Class<?>, Object> allocateInstanceFunction;\n\n    static {\n        try {\n            MethodHandles.Lookup lk = MethodHandles.lookup();\n            final Constructor<Object> object_const = Object.class.getConstructor();\n\n            Field instanceClass = null;\n            for (Field f : Class.forName(\"java.lang.invoke.DirectMethodHandle$Constructor\").getDeclaredFields()) {\n                if (f.getType() == Class.class) {\n                    instanceClass = f;\n                    break;\n                }\n            }\n            assert instanceClass != null;\n            instanceClass.setAccessible(true);\n            Field instanceClass0 = instanceClass;\n\n            allocateInstanceFunction = clazz -> {\n                try {\n                    final MethodHandle constructor = lk.unreflectConstructor(object_const);\n                    instanceClass0.set(constructor, clazz);\n                    return constructor.invoke();\n                } catch (Error | RuntimeException re) {\n                    throw re;\n                } catch (Throwable thr) {\n                    throw new RuntimeException(thr);\n                }\n            };\n        } catch (Throwable any) {\n            throw new ExceptionInInitializerError(any);\n        }\n    }\n\n    interface AbstractConfiguration {\n        void init(Map<String, Object> data);\n\n        void store(Map<String, Object> output);\n    }\n\n    class BaseConfiguration implements AbstractConfiguration {\n        private String name;\n\n        @Override\n        public void init(Map<String, Object> data) {\n            name = String.valueOf(data.get(\"name\"));\n        }\n\n        @Override\n        public void store(Map<String, Object> output) {\n            output.put(\"name\", name);\n        }\n\n        @Override\n        public String toString() {\n            return \"BaseConfiguration{\" +\n                    \"name='\" + name + '\\'' +\n                    '}';\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Map<String, Object> data = new HashMap<>();\n        data.put(\"name\", \"MyName\");\n        AbstractConfiguration conf = (AbstractConfiguration) allocateInstanceFunction.apply(BaseConfiguration.class);\n        conf.init(data);\n        System.out.println(conf);\n    }\n}\n复制代码\n",
    "replies": [
        {
            "author": "海螺螺",
            "timestamp": 1579775400,
            "txt_content": "你直接unsafe.allocateInstance不就好了"
        },
        {
            "author": "Karlatemp",
            "timestamp": 1579782120,
            "txt_content": "海螺螺 发表于 2020-1-23 18:30\n你直接unsafe.allocateInstance不就好了\n对呀，但是java8和java13的不通哈哈，java9以上还得把模块访问限制艹了"
        }
    ]
}