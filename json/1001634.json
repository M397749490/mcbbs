{
    "title": "关于mod开发的问题",
    "author": "tempesteer666",
    "replyCount": 8,
    "timestamp": 1585527240,
    "txt_content": "我打算开发一个咸鱼模组，但我做到结尾时，想给最终武器加一些特性，但我实在不会要怎么写。\n1．更改剑的攻击半径\n2．把弓要消耗箭改成不消耗\n3．怎么才能使盔甲可以拥有像无尽之靴一样的加速移动效果",
    "replies": [
        {
            "author": "洞穴夜莺",
            "timestamp": 1585527900,
            "txt_content": "讲一下我的思路\n1，由于原版攻击事件攻击距离是写死了，所以放弃这个事件，当按下左键时，检查玩家的视线和哪些实体碰撞，攻击符合条件的实体\n2，参考无限附魔\n3，加AttributeModifier \"generic.attackDamage\""
        },
        {
            "author": "海螺螺",
            "timestamp": 1585531140,
            "txt_content": "攻击距离这个，forge 加了一个 AttributeModifier 叫 generic.reachDistance"
        },
        {
            "author": "tempesteer666",
            "timestamp": 1585533480,
            "txt_content": "Billy12345 发表于 2020-3-30 08:25\n讲一下我的思路\n1，由于原版攻击事件攻击距离是写死了，所以放弃这个事件，当按下左键时，检查玩家的视线和 ...\n但是我要的是类似砧板弓一样的不耗箭呀"
        },
        {
            "author": "洞穴夜莺",
            "timestamp": 1585533540,
            "txt_content": "tempesteer666 发表于 2020-3-30 09:58\n但是我要的是类似砧板弓一样的不耗箭呀\n像创造那样？"
        },
        {
            "author": "tempesteer666",
            "timestamp": 1585536720,
            "txt_content": "Billy12345 发表于 2020-3-30 09:59\n像创造那样？\n对，如你所言"
        },
        {
            "author": "洞穴夜莺",
            "timestamp": 1585538340,
            "txt_content": "tempesteer666 发表于 2020-3-30 10:52\n对，如你所言\n放代码(fabric)\nimport net.minecraft.entity.LivingEntity;\nimport net.minecraft.entity.player.PlayerEntity;\nimport net.minecraft.item.BowItem;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.Hand;\nimport net.minecraft.util.TypedActionResult;\nimport net.minecraft.world.World;\n\npublic class InfBowItem extends BowItem {\n        public InfBowItem(Settings settings) {\n                super(settings);\n        }\n\n        public TypedActionResult<ItemStack> use(World world, PlayerEntity user, Hand hand) {\n                ItemStack itemStack = user.getStackInHand(hand);\n                user.setCurrentHand(hand);\n                return TypedActionResult.consume(itemStack);\n        }\n\n        public void onStoppedUsing(ItemStack stack, World world, LivingEntity user, int remainingUseTicks) {\n                if (user instanceof PlayerEntity) {\n                        PlayerEntity playerEntity = (PlayerEntity)user;\n                        playerEntity.abilities.creativeMode=true;\n                        super.onStoppedUsing(stack,world,user,remainingUseTicks);\n                        playerEntity.abilities.creativeMode=false;\n                }\n        }\n}\n复制代码"
        },
        {
            "author": "MuMaple",
            "timestamp": 1586578680,
            "txt_content": "我有个第一个问题思路，修改是不可能修改的，但是你可以在攻击一个实体的时候，获取大范围内的所有生物实体然后给他们造成伤害(记得不要算进玩家)"
        },
        {
            "author": "zjx475",
            "timestamp": 1586677440,
            "txt_content": "（我的版本是1.15.2，可能和你的代码有些区别，但大致应该是相同的）\"更改剑的攻击半径\"\n这个有些棘手，你当然可以通过监听PlayerInteractEvent.LeftClickEmpty事件，来控制拿着剑左键时的事件，但这样很难做到与原版的攻击一致，这里提供一个比较底层的方法供参考：我们看到Minecraft类中，当你左键鼠标时触发的效果：private void clickMouse() {...            switch(this.objectMouseOver.getType()) {            case ENTITY:               this.playerController.attackEntity(this.player, ((EntityRayTraceResult)this.objectMouseOver).getEntity());               break;            ...   }这个objectMouseOver代表着你鼠标指向的东西，当它是entity时，左键就可以攻击。它在哪里设置呢？public void runTick() {... this.gameRenderer.getMouseOver(1.0F);...}游戏每次tick时都会调用getMouseOver更新objectmouseover. 注意到getMouseOver方法中 double d0 = (double)this.mc.playerController.getBlockReachDistance();d0就是玩家的reachdistance.我们怎么做呢？clickMouse()中有一行 net.minecraftforge.client.event.InputEvent.ClickInputEvent inputEvent = net.minecraftforge.client.ForgeHooksClient.onClickInput(0, this.gameSettings.keyBindAttack, Hand.MAIN_HAND);也就是说clickmouse时会触发事件。监听这个ClickInputEvent事件，并判断它是否就是clickmouse这儿触发的（而不是什么右键之类的），再判断玩家手上的物品是不是你的剑，如果是，你把getmouseover中的代码复制过来，（可以通过Minecraft.getInstance()获取mc实例），在getmouseover中的代码double d0 = (double)this.mc.playerController.getBlockReachDistance();中把d0改为固定值，就是你的剑的攻击范围。（你可能还需要修改其它一些地方的硬编码）这样，objectmouseover，你所指的东西，就可以变得很远，而不是原来的miss。然后判断objectmouseover是不是entity（它仍然可能是miss，或是block）如果不是，最好调用原来的getmouseover，而不是你改过的，来重置objectmouseover；如果是，手动调用 mc.playerController.attackEntity(this.player, ((EntityRayTraceResult)this.objectMouseOver).getEntity());并把事件取消。\n当你clickmouse时，如果是你在挥剑且你与实体的距离小于你所指定的d0，这段代码就会触发，修改objectmouseover，然后mc再执行 this.playerController.attackEntity，objectmouseover，也许是很远的你的剑所指的一只可怜的小猪，就会被攻击。享受长臂猿外挂一样的感觉吧~~~\n\n\n\n\nfile_1586677107000.jpg (147.28 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-12 15:38 上传\n\n\n\n\n...然而事实上你会发现这样仍然不能攻击过远的生物，为什么呢？ this.playerController.attackEntity确实被调用了，但！是！attackEntity中有一行this.connection.sendPacket(new CUseEntityPacket(targetEntity));众所周知鼠标左键是在客户端执行的，而实体受到伤害等等逻辑是在服务端执行的，这段代码就是从客户端发送网络数据包到服务端，服务端执行实体受到伤害等等逻辑。客户端发包后服务端解包，进行一些操作，这个包的解包操作： public void processUseEntity(CUseEntityPacket packetIn) {    ...      if (entity != null) {         boolean flag = this.player.canEntityBeSeen(entity);         double d0 = 36.0D;         if (!flag) {            d0 = 9.0D;         }\n         if (this.player.getDistanceSq(entity) < d0) {...}What!在服务端还要检查距离，过了才能执行，否则还是什么事都干不了，关键这些距离检查还是硬编码的！怎么办呢...我们可以自定义一个网络数据包，在你调用mc.playerController.attackEntity(this.player, ((EntityRayTraceResult)this.objectMouseOver).getEntity());后再发送自己的网络数据包，这个自己的网络数据包和在attackEntity中发送的网络数据包一模一样，唯独将距离检查 if (this.player.getDistanceSq(entity) < d0) 中的小于改为大于等于，这样，你在客户端挥剑时一共发送两个网络数据包，一个处理this.player.getDistanceSq(entity) < d0，一个处理this.player.getDistanceSq(entity) >= d0，最后无论this.player.getDistanceSq(entity)是多少，都会处理且仅处理一次挥剑的服务端逻辑。 然而，mc原版的网络数据包和forge提供的网络数据包不尽相同，不能直接复制黏贴，自定义网络数据包这个事我就没法帮你了，你可以参考一些mod制作教程,比如这个（1.14版本的）。最后... \n\n\n\n\nfile_1586677127000.jpg (121.53 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-12 15:38 上传\n\n\n\n\n经过测试，reach拉到满，只要准心在实体上，就能打得到！OHHHHHHHHHHHHHHHHHHHHHH\n“把弓要消耗箭改成不消耗”这个超级简单，想实现创造一样的效果，把玩家设置为创造模式大可不必，注意到原版bow类中的public void onPlayerStoppedUsing(ItemStack stack, World worldIn, LivingEntity entityLiving, int timeLeft) {      if (entityLiving instanceof PlayerEntity) {        ...         boolean flag = playerentity.abilities.isCreativeMode || EnchantmentHelper.getEnchantmentLevel(Enchantments.INFINITY, stack) > 0;                        ...               boolean flag1 = playerentity.abilities.isCreativeMode || (itemstack.getItem() instanceof ArrowItem && ((ArrowItem)itemstack.getItem()).isInfinite(itemstack, stack, playerentity));                        ...                  if (flag1 || playerentity.abilities.isCreativeMode && (itemstack.getItem() == Items.SPECTRAL_ARROW || itemstack.getItem() == Items.TIPPED_ARROW)) {                     ...               if (!flag1 && !playerentity.abilities.isCreativeMode) {                 ...   }你只消把这些playerentity.abilities.isCreativeMode统统换为true，再化简一波，将这些代码复制过来用于重写public void onPlayerStoppedUsing(ItemStack stack, World worldIn, LivingEntity entityLiving, int timeLeft) {   }就好。\n“怎么才能使盔甲可以拥有像无尽之靴一样的加速移动效果”其实无尽贪婪是开源的，所以你可以在github上进行参考。注意到它的Armor类中\n@Override    public Multimap getAttributeModifiers(ItemStack stack)    {        Multimap multimap = super.getAttributeModifiers(stack);        //if(armorType == 3)//3指盔甲中的靴子        //    multimap.put(SharedMonsterAttributes.movementSpeed.getAttributeUnlocalizedName(), new AttributeModifier(field_111210_e, \"Armor modifier\", 0.7, 1));        return multimap;    }被注掉的两行设置了盔甲中的一个属性，就是你说的加速移动效果，把代码复制到你的盔甲类中，稍稍修改一下就成啦~~~（本人语言表达能力比较差，有问题还可以问我）\n\n"
        }
    ]
}