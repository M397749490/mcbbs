{
    "title": "关于修改主线程类加载器",
    "author": "William_Shi",
    "replyCount": 12,
    "timestamp": 1597056600,
    "txt_content": "众所周知，Bukkit插件所使用的类加载器，是PluginClassLoader\n这个类加载器，没有双亲委派，有利也有弊\n以往我都采用一种办法测试JS代码\n\n\n    ScriptEngineManager m;\n    ScriptEngine e;\n    m = new ScriptEngineManager(Thread.currentThread().getContextClassLoader());\n    e = m.getEngineByName(\"js\");\n\n\n为什么要给Nashorn指定类加载器呢？因为写脚本只要涉及到Java.type，取到另外Java插件的一些什么类\n在不指定类加载器的情况下都会报错\nCaused by: java.lang.ClassNotFoundException: xxxxxxx\n        at java.net.URLClassLoader.findClass(Unknown Source) ~[?:1.8.0_241]\n\n\n但是刚才，我即使是按照上述写法，仍然报了ClassNotFoundException\n于是我干了一件这样的事\n\nThread.currentThread().setContextClassLoader(getClassLoader());\n\n\n当我再次运行new ScriptEngineManager(Thread.currentThread().getContextClassLoader())\n并且尝试Java.type 访问另外Java插件的类的时候成功了\n\n然而，我以往测试的时候，似乎发现如果采用PluginClassLoader\n存在一个getEngineFactories为空的问题，而直接采用AppClassLoader则没有问题\n\n此次测试的结果是，采用PluginClassLoader没有问题\n但是采用AppClassLoader却出现了问题\n\n以往我是在1.15进行测试，现在则是1.12，是不是版本导致了什么问题？\n或者说1.12以上莫非对PluginClassLoader作出了什么改动？\nJavaScript脚本的加载插件是如何解决这一问题的？（别和我说PVPIN，那玩意倒闭前就最高支持到1.11.2，第二种办法就是那边看到的）\n把主线程AppClassLoader改成PluginClassLoader会不会有问题？\n希望知道的大佬能不吝分享下自己的经验\n",
    "replies": [
        {
            "author": "NekokeCore",
            "timestamp": 1597057740,
            "txt_content": "冒泡"
        },
        {
            "author": "阴阳师元素祭祀",
            "timestamp": 1597058880,
            "txt_content": " 本帖最后由 阴阳师元素祭祀 于 2020-8-10 19:30 编辑 \n\n首先我不会bukkit 然后我也不会JavaScript\n\nNashorn我记得弃用了\n本身就不推荐使用\n\n指定ScriptEngineManager加载器我懂\n为什么连线程context的loader都要改\nThread.currentThread().setContextClassLoader(getClassLoader());复制代码\n因为eval js的东西的时候需要相关context么？\n不可以给engine的ScriptContext自行设置相关东西么（？)\n\n\n然而，我以往测试的时候，似乎发现如果采用PluginClassLoader\n存在一个getEngineFactories为空的问题，而直接采用AppClassLoader则没有问题\n\n此次测试的结果是，采用PluginClassLoader没有问题\n但是采用AppClassLoader却出现了问题\n采用AppClassLoader出现了问题 指 getEngineFactories返回空？\n请原谅我理解能力 因为我觉得就离谱(?)\n\n改主线程的AppClassLoader成PluginClassLoader\n我觉得是野蛮的\n非常野蛮 而且绝对大概率行不通的\n希望不要有这种行为出现 不是希望 是呵斥 \n\nJavaScript脚本的加载插件是如何解决这一问题的？\n没用过 但是我觉得完全可以在脚本里面调用自己的java代码 然后用代码再去执行相关操作\n而不是纯js加载（？)"
        },
        {
            "author": "Karlatemp",
            "timestamp": 1597059660,
            "txt_content": "这是我对你的问题的相关回答\n\npublic static IService getService(ClassLoader classLoader) {\n    if (classLoader == null) {\n        classLoader = Thread.currentThread().getContextClassLoader();\n        // 当没有指定 classLoader 的时候, 大部分(不排除有部分弱智库不这样做) 库\n        // 都会使用 Thread.currentThread().getContextClassLoader() 作为目标 ClassLoader\n        //\n        // 由于 Java 的类加载本身并不依赖 Thread.currentThread().getContextClassLoader(),\n        // 而是依赖需要使用的类他自己的唯一类加载器, 所以, 线程上下文加载器你设置成什么, 对java本身并没有任何影响\n        // 换句话来说, 线程上下文类加载器无法影响类本身的加载机制\n        // 上下文类加载器只是各种类库的缺省设置\n        // 这个值影响的只有类库的加载\n        //\n        // 对于 Bukkit Plugin System\n        // Bukkit 加载插件的时候, 并不会去修改 Thread.currentThread().getContextClassLoader(),\n        // 也就是说, 默认情况下, contextClassLoader = ClassLoader.getSystemClassLoader()\n        //\n        // 此时, SystemCL 没法找到 PluginCL,\n        // 你需要临时把上下文加载器设置成 PluginCL\n        // 然后, 为了避免系统不稳定性, 我们在调用完毕后需要设置回去\n        //\n        // 就像下面这样\n        /*\n        ClassLoader old = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(Bootstrap.class.getClassLoader());\n            // Service loading.\n        } finally {\n            Thread.currentThread().setContextClassLoader(old);\n        }\n        */\n    }\n    return getServiceImpl( /* @NotNull */ classLoader)\n}\n复制代码\n"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597059900,
            "txt_content": "阴阳师元素祭祀 发表于 2020-8-10 19:28\n首先我不会bukkit 然后我也不会JavaScript\n\nNashorn我记得弃用了\nNashorn在javax包下没有弃用，至少针对Java8完全没有问题\n\n为什么连线程context的loader都要改\n这个是我有疑问的地方，只能说是一种解决方法\n\n因为eval js的东西的时候需要相关context么？\n准确的来说，PluginClassLoader没双亲委派导致的，逻辑太复杂\n总之以往1.15测试时，不指定ClassLoader，没有办法通过Java.type访问其他插件的类\n\n采用AppClassLoader出现了问题 指 getEngineFactories返回空？\n不是，没做这个测试\n我说的是使用AppClassLoader，js中调用Java.type会报错ClassNotFound\n\n在脚本里面调用自己的java代码\nJava.type就是获取Java中的类，调用Java的代码"
        },
        {
            "author": "阴阳师元素祭祀",
            "timestamp": 1597060200,
            "txt_content": " 本帖最后由 阴阳师元素祭祀 于 2020-8-10 19:51 编辑 \nWilliam_Shi 发表于 2020-8-10 19:45\nNashorn在javax包下没有弃用，至少针对Java8完全没有问题\n\n为什么连线程context的loader都要改\n不指定ClassLoader，没有办法通过Java.type访问其他插件的类\n这个不指定 包括ContextClassLoader (?)某个解决方法么 那没事莉\n\n\n\n总之以往1.15测试时，不指定ClassLoader，没有办法通过Java.type访问其他插件的类\n没法访问目标类的时候 目标类加载了么\n\nJava.type就是获取Java中的类，调用Java的代码\n你之前说的是无法访问 其他插件的类 那么自己插件的类 是能的（？）\n那么脚本里面调用自己代码操作就对了（确信）\n\n\n"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597060380,
            "txt_content": "阴阳师元素祭祀 发表于 2020-8-10 19:50\n\n\n这个不指定 包括ContextClassLoader (?)某个解决方法么 那没事莉\n\n你之前说的是无法访问 其他插件的类 那么自己插件的类 是能的（？）\n那么脚本里面调用自己代码操作就对了（确信）\n\n都不能。如果能的话我当然可以采用自己的类封装别的插件的类\n\n没法访问目标类的时候 目标类加载了么\n加载了。Class.forName强行加载\nClass.forName未报错，返回的Class<?>不为空。"
        },
        {
            "author": "洞穴夜莺",
            "timestamp": 1597060620,
            "txt_content": "个人觉得不要用Nashorn\n其一，Nashorn在高版本Java已经弃用\n其二，Nashorn仍然在执行ES5标准，而火狐谷歌之流都奔着ES7标准去了"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597060800,
            "txt_content": "Karlatemp 发表于 2020-8-10 19:41\n这是我对你的问题的相关回答\n最后的方法就类似PVPINJSRT（也是set回原来的CL\n但是关键在于1.15发生了什么使得指定PluginClassLoader加载Nashorn无法再获取到Engine了\n这与什么有关？\n（1.12可以getEngineByName(\"js\")，但是1.15getEngineFactories返回了空列表\n\n感谢提供完整操作，问题差不多解决了"
        },
        {
            "author": "Karlatemp",
            "timestamp": 1597061220,
            "txt_content": "针对 Nashorn, 我翻了 JDK 的源码， 希望能解决你的问题\n\nScriptEngineManager manager = new ScriptEngineManager(Thread.currentThread().getContextClassLoader());\nScriptEngine engine = manager.getEngineByName(\"js\");\n\n首先到 `new ScriptEngineManager` 查看 JDK 其源码, 可以发现,\n可以发现， 这个 ClassLoader 参数\npublic ScriptEngineManager(ClassLoader loader) {\n    init(loader);\n}\nprivate void init(final ClassLoader loader) {\n    globalScope = new SimpleBindings();\n    engineSpis = new HashSet<ScriptEngineFactory>();\n    nameAssociations = new HashMap<String, ScriptEngineFactory>();\n    extensionAssociations = new HashMap<String, ScriptEngineFactory>();\n    mimeTypeAssociations = new HashMap<String, ScriptEngineFactory>();\n    initEngines(loader);\n}\n\nprivate void initEngines(final ClassLoader loader) {\n    Iterator<ScriptEngineFactory> itr = null;\n    try {\n        ServiceLoader<ScriptEngineFactory> sl = AccessController.doPrivileged(\n            new PrivilegedAction<ServiceLoader<ScriptEngineFactory>>() {\n                @Override\n                public ServiceLoader<ScriptEngineFactory> run() {\n                    return getServiceLoader(loader);\n                }\n            });\n        itr = sl.iterator();\n    } catch (ServiceConfigurationError err) {\n        System.err.println(\"Can't find ScriptEngineFactory providers: \" +\n                      err.getMessage());\n        if (DEBUG) {\n            err.printStackTrace();\n        }\n        // do not throw any exception here. user may want to\n        // manage his/her own factories using this manager\n        // by explicit registratation (by registerXXX) methods.\n        return;\n    }\n    try {\n        while (itr.hasNext()) {\n            try {\n                ScriptEngineFactory fact = itr.next();\n                engineSpis.add(fact);\n            } catch (ServiceConfigurationError err) {\n                System.err.println(\"ScriptEngineManager providers.next(): \"\n                             + err.getMessage());\n                if (DEBUG) {\n                    err.printStackTrace();\n                }\n                // one factory failed, but check other factories...\n                continue;\n            }\n        }\n    } catch (ServiceConfigurationError err) {\n        System.err.println(\"ScriptEngineManager providers.hasNext(): \"\n                        + err.getMessage());\n        if (DEBUG) {\n            err.printStackTrace();\n        }\n        // do not throw any exception here. user may want to\n        // manage his/her own factories using this manager\n        // by explicit registratation (by registerXXX) methods.\n        return;\n    }\n}\n复制代码\n详细逻辑请自行前往 JDK 源码查看\n\n不难看出， 这个 Manager 会尝试加载全部他自己找得到的 `ScriptEngineFactory`\n\n然后已知 JDK8 中, Java的JavaScript的Engine为 Nashorn\n他的 ScriptEngineFactory 为 NashornScriptEngineFactory,\n\n@Exported\npublic final class NashornScriptEngineFactory implements ScriptEngineFactory {\n    private static final String[] DEFAULT_OPTIONS = new String[]{\"-doe\"};\n    private static final List<String> names = immutableList(\"nashorn\", \"Nashorn\", \"js\", \"JS\", \"JavaScript\", \"javascript\", \"ECMAScript\", \"ecmascript\");\n    private static final List<String> mimeTypes = immutableList(\"application/javascript\", \"application/ecmascript\", \"text/javascript\", \"text/ecmascript\");\n    private static final List<String> extensions = immutableList(\"js\");\n\n    public NashornScriptEngineFactory() {\n    }\n复制代码\n通过查看 NashornScriptEngineFactory 的源码可以看出, Nashorn的 Factory 和 Engine 之间的创建并没有任何关联\n\n来到 `manager.getEngineByName(\"js\")`, 我们查看其源码, 可以得出\n\npublic ScriptEngine getEngineByName(String shortName) {\n    if (shortName == null) throw new NullPointerException();\n    //look for registered name first\n    Object obj;\n    if (null != (obj = nameAssociations.get(shortName))) {\n        ScriptEngineFactory spi = (ScriptEngineFactory)obj;\n        try {\n            ScriptEngine engine = spi.getScriptEngine();\n            engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n            return engine;\n        } catch (Exception exp) {\n            if (DEBUG) exp.printStackTrace();\n        }\n    }\n    for (ScriptEngineFactory spi : engineSpis) {\n        List<String> names = null;\n        try {\n            names = spi.getNames();\n        } catch (Exception exp) {\n            if (DEBUG) exp.printStackTrace();\n        }\n        if (names != null) {\n            for (String name : names) {\n                if (shortName.equals(name)) {\n                    try {\n                        ScriptEngine engine = spi.getScriptEngine();\n                        engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n                        return engine;\n                    } catch (Exception exp) {\n                        if (DEBUG) exp.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\n复制代码\npublic ScriptEngine getEngineByName(String shortName) {\n    // ....\n        try {\n            ScriptEngine engine = spi.getScriptEngine();\n            engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n            return engine;\n    // ...\n    // ...\n                        ScriptEngine engine = spi.getScriptEngine();\n                        engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n    // ...\n}\n复制代码\n\n可以找到, 核心就是 getScriptEngine(), 接下来我们查看 NashornScriptEngineFactory#getScriptEngine\n\n\n    public ScriptEngine getScriptEngine() {\n        try {\n            return new NashornScriptEngine(this, DEFAULT_OPTIONS, getAppClassLoader(), (ClassFilter)null);\n        } catch (RuntimeException var2) {\n            if (Context.DEBUG) {\n                var2.printStackTrace();\n            }\n\n            throw var2;\n        }\n    }\n\n    private static ClassLoader getAppClassLoader() {\n        ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n        return ccl == null ? NashornScriptEngineFactory.class.getClassLoader() : ccl;\n    }\n复制代码\n\n让我们注意一下, getAppClassLoader, 他做了什么,\n他直接使用了 Thread.currentThread().getContextClassLoader(),\n这说明 NashornScriptEngine 的创建 本身 和 NashornScriptEngineFactory 没有任何关联!\n结合我之前发的解释, 这也完美的说明了\n\n为什么要给Nashorn指定类加载器呢？因为写脚本只要涉及到Java.type，取到另外Java插件的一些什么类\n在不指定类加载器的情况下都会报错\nCaused by: java.lang.ClassNotFoundException: xxxxxxx\n        at java.net.URLClassLoader.findClass(Unknown Source) ~[?:1.8.0_241]\n\n\n但是刚才，我即使是按照上述写法，仍然报了ClassNotFoundException\n于是我干了一件这样的事\n\nThread.currentThread().setContextClassLoader(getClassLoader());\n\n\n当我再次运行new ScriptEngineManager(Thread.currentThread().getContextClassLoader())\n并且尝试Java.type 访问另外Java插件的类的时候成功了\n\n没有 Thread.currentThread().setContextClassLoader(getClassLoader()); 的时候, \nNashorn 引擎使用的是 System.getClassLoader(), 自然无法找到位于 PluginClassLaoder 的任何类,\n\n此刻, 证毕."
        },
        {
            "author": "William_Shi",
            "timestamp": 1597061220,
            "txt_content": "洞穴夜莺 发表于 2020-8-10 19:57\n个人觉得不要用Nashorn\n其一，Nashorn在高版本Java已经弃用\n其二，Nashorn仍然在执行ES5标准，而火狐谷歌之 ...\n据说Nashorn将会被一个新的JS引擎所替代\n叫做Graal（GraalVM）\n并且是ECMAScript 2020 compatible\n还支持JDK15\n可以说是非常非常新\n但是我还不会用。。。"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597062300,
            "txt_content": "Karlatemp 发表于 2020-8-10 20:07\n针对 Nashorn, 我翻了 JDK 的源码， 希望能解决你的问题\n\nScriptEngineManager manager = new ScriptEngine ...\n感谢大佬的回复\n也就是说在新建了Manager时传参只能确保加载到ScriptEngineFactory\n调整Engine相关还得靠改ContextClassLoader，除非它被强行设为空\n\n那么得出这样的结论\n创建Manager使用App Class Loader确保能加载到EngineFactory\n创建Engine调整ContextClassLoader为PluginClassLoader确保能访问到插件\n\n已经完全理清，再次感谢大佬的回复！"
        },
        {
            "author": "2280761425",
            "timestamp": 1598089560,
            "txt_content": " 本帖最后由 2280761425 于 2020-8-22 17:48 编辑 \n\n之前我在开发时直接设置ContextClassLoader也遇到过这问题\n但是不这样又不好调用其他插件的类\n所以我的做法是在必要时先获取到对应插件的ClassLoader再进行加载（如果觉得麻烦也可以获取到classloader后保存，之后直接使用）\n具体可以参考一下这里https://github.com/Miraclexc/Jav ... sources/lib/util.js"
        }
    ]
}