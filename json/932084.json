{
    "title": "在 Minecraft Mod 中使用 Coroutine",
    "author": "土球球",
    "replyCount": 2,
    "timestamp": 1576089120,
    "txt_content": " 本帖最后由 土球球 于 2020-2-22 01:09 编辑 \n\n在 Minecraft Mod 中使用 Coroutine\n\nCoroutine（协程）是编程语言的一种机制，该机制允许开发者编写出和过程式写法相同的代码，并在编译时得到一系列相互调用的子过程，从而使不同的子过程可以在不同的场合执行。\n\nCoroutine 的最常见用途是编写异步代码，而 Minecraft 中恰恰存在大量需要使用异步代码的场合：比方说我们有时需要将某段代码延迟到一个或多个 tick 后执行，有时需要将某段代码延迟到下一次事件触发时执行，等等。\n\n目前很多主流的编程语言都提供了相对官方的 Coroutine 支持，如 C#、Python、JavaScript，等等。虽然 Java 官方至今仍然没有支持 Coroutine，但 JVM 上流行的两大编程语言 Scala 和 Kotlin，已经对 Coroutine 提供了一定程度的支持。本文将分别使用 Scala 和 Kotlin 两门编程语言实现相应的机制：\n\n\n\n上图展示的是本文的核心代码，想必对于 Scala 和 Kotlin 有着一定程度了解的读者已经猜到这段代码实现的是什么需求了。上面的代码实现的特性是玩家在攻击怪物的时候给予 100 tick（约五秒）的攻击冷却，并在冷却结束后通知玩家。\n\n本文针对的是 Forge 平台的 1.12.2-14.23.5.2768 版本，不过对于插件等其他平台等，原理是通用的。\n\n概述\n\n回调函数是实现异步逻辑的常见手段，通常异步行为执行完后会调用回调函数从而执行下一步行为：\n\n// scala\ndef foo(value: Int, next: (Bar) => Unit) = {\n  next(new Bar(value))\n}\n// kotlin\nfun foo(value: Int, next: (Bar) -> Unit) {\n    next(Bar(value))\n}\n任何普通的方法通常都可以写成回调函数风格，例如下面的代码负责把两个数相加：\n\n// scala\ndef add(a: Int, b: Int, next: (Int) => Unit) = {\n  next(a + b)\n}\n// kotlin\nfun add(a: Int, b: Int, next: (Int) -> Unit) {\n    next(a + b)\n}\n我们通常使用 Continuation Passing Style（简称 CPS）描述这种风格，虽然调用 CPS 风格的方法通常写起来会很痛苦（也就是通常所说的回调地狱）：\n\n// scala\nadd(40, 2, { value =>\n  foo(value, { bar =>\n    doSomethingElse(bar)\n  })\n})\n// kotlin\nadd(40, 2, { value ->\n    foo(value, { bar ->\n        doSomethingElse(bar)\n    })\n})\n如果我们能直接写成 doSomethingElse(foo(add(40, 2))) 该多好啊。实际上，把这种可读性较强的写法转换成上面的回调地狱的行为被称为 CPS 变换，它是 Scala 及 Kotlin 等语言实现 Coroutine 的基础。\n\n在 Scala 中，我们可以声明返回值带有 @suspendable 注解的方法，而 Kotlin 则可以使用 suspend 关键字。具体的写法如下：\n\n// scala\ndef add2(a: Int, b: Int): Int@suspendable = shift { next => next(a + b) }\n// kotlin\nsuspend fun add2(a: Int, b: Int): Int = suspendCoroutine { next => next(a + b) }\n这样我们就可以在特定场合下使用它们了：\n\n// scala\nreset {\n  var i = 1\n  while (i < 100) {\n    val j = add2(i, 1)\n    println(f\"$i + 1 = $j\")\n    i = j\n  }\n}\n// kotlin\nlaunch {\n    var i = 1\n    while (i < 100) {\n        val j = add2(i, 1)\n        println(\"$i + 1 = $j\")\n        i = j\n    }\n}\n配置\n\n首先，因为配置环境时使用了 Gradle 新特性，而 Forge 使用的 Gradle 版本太过陈旧，因此读者需要使用 Gradle 4 或更高版本（本文使用的版本是 4.10.3），如果读者使用 Gradle Wrapper 的话，请打开 gradle/wrapper/ 目录并修改 gradle-wrapper.properties 文件（注意最后一行）：\n\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-4.10.3-all.zip\n然后我们需要配置 build.gradle。基于 Scala 的实现需要 scala-continuations 库，考虑到该库 Forge 已经自带，因此不必额外引入该库，仅需额外声明该库对应的 Scala 编译器插件：\n\n// scala\nsourceCompatibility = targetCompatibility = '1.7'\n\nconfigurations {\n    compilerPlugin\n}\n\ndependencies {\n    compilerPlugin 'org.scala-lang.plugins:scala-continuations-plugin_2.11.1:1.0.2'\n}\n\ncompileScala {\n    sourceCompatibility = targetCompatibility = '1.7'\n    scalaCompileOptions.additionalParameters = [\n        '-Xplugin:' + configurations.compilerPlugin.asPath,\n        '-P:continuations:enable'\n    ]\n}\n注意声明插件的同时还需要为编译器添加 -P:continuations:enable 参数。\n\n基于 Kotlin 的实现需要引入 Forge 并未自带的 Kotlin 环境，这通常可以通过依赖一个名为 ShadowFacts' Forgelin 的 Mod 解决：\n\n// kotlin\nsourceCompatibility = targetCompatibility = '1.8'\n\nrepositories {\n    jcenter()\n    maven {\n        name = 'shadowfacts'\n        url = 'http://maven.shadowfacts.net/'\n    }\n}\n\ndependencies {\n    deobfCompile 'net.shadowfacts:Forgelin:1.8.3'\n}\n最后别忘了把 apply plugin: scala 或 apply plugin: kotlin 添加到配置文件中。后者通常还需要引入 Kotlin 的 Gradle 插件，使用 Kotlin 配置过 Gradle 的应该都比较清楚，这里就不再赘述了。\n\n代码\n\n我们声明一个 Mod 主类，并在其中实现 nextTick 和 nextAttackEvent 两个方法：\n\n// scala\nobject EventListener {\n  val tickListeners: mutable.Queue[ServerTickEvent => Unit] = mutable.Queue()\n  val attackListeners: mutable.Queue[AttackEntityEvent => Unit] = mutable.Queue()\n\n  @SubscribeEvent\n  def onTick(event: ServerTickEvent): Unit = {\n    if (event.phase == Phase.END) {\n      tickListeners.dequeueAll(_ => true).foreach(listener => listener(event))\n    }\n  }\n\n  @SubscribeEvent\n  def onAttack(event: AttackEntityEvent): Unit = {\n    if (!event.getTarget.world.isRemote) {\n      attackListeners.dequeueAll(_ => true).foreach(listener => listener(event))\n    }\n  }\n}\n\nprivate def nextTick(): ServerTickEvent@suspendable = shift { continuation =>\n  EventListener.tickListeners.enqueue(continuation)\n}\n\nprivate def nextAttackEvent(): AttackEntityEvent@suspendable = shift { continuation =>\n  EventListener.attackListeners.enqueue(continuation)\n}\n\n@Mod.EventHandler\ndef preInit(e: FMLPreInitializationEvent): Unit = {\n  MinecraftForge.EVENT_BUS.register(EventListener)\n}\n// kotlin\nobject EventListener {\n    val tickListeners: Queue<(ServerTickEvent) -> Unit> = ArrayDeque()\n    val attackListeners: Queue<(AttackEntityEvent) -> Unit> = ArrayDeque()\n\n    @SubscribeEvent\n    fun onTick(event: ServerTickEvent): Unit {\n        if (event.phase == Phase.END) {\n            tickListeners.toList().also { tickListeners.clear() }.forEach { listener -> listener(event) }\n        }\n    }\n\n    @SubscribeEvent\n    fun onAttack(event: AttackEntityEvent): Unit {\n        if (!event.target.world.isRemote) {\n            attackListeners.toList().also { attackListeners.clear() }.forEach { listener -> listener(event) }\n        }\n    }\n}\n\nprivate suspend fun nextTick(): ServerTickEvent = suspendCoroutine { continuation ->\n    EventListener.tickListeners.add { event -> continuation.resume(event) }\n}\n\nprivate suspend fun nextAttackEvent(): AttackEntityEvent = suspendCoroutine { continuation ->\n    EventListener.attackListeners.add { event -> continuation.resume(event) }\n}\n\n@Mod.EventHandler\nfun preInit(e: FMLPreInitializationEvent): Unit {\n    MinecraftForge.EVENT_BUS.register(EventListener)\n}\n我们声明了两个事件监听器，并缓存了一串回调函数的列表。nextTick 和 nextAttackEvent 两个方法能够向相应的列表添加回调函数，并在事件触发的时候：\n\n获取所有的回调函数；清空缓存的回调函数列表；按顺序依次执行所有回调函数。\n\n注意上面三者必须依次进行，顺序不能有任何变动，读者可以想一想为什么有这样的要求。\n\n最后就是我们的核心代码了：\n\n// scala\n@Mod.EventHandler\ndef init(e: FMLInitializationEvent): Unit = {\n  reset {\n    val coolDownPlayers = mutable.HashSet[UUID]()\n    while (true) {\n      val event = nextAttackEvent()\n      val player = event.getEntityPlayer\n      val playerUUID = player.getUniqueID\n      if (coolDownPlayers.contains(playerUUID)) {\n        event.setCanceled(true)\n      } else {\n        event.getTarget match {\n          case _: IMob => reset {\n            coolDownPlayers.add(playerUUID)\n            var coolDownTickLeft = 100\n            while (coolDownTickLeft > 0) {\n              coolDownTickLeft -= 1\n              nextTick()\n            }\n            coolDownPlayers.remove(playerUUID)\n            val message = \"Cool down has expired\"\n            player.sendMessage(new TextComponentString(message))\n          }\n          case _ => ()\n        }\n      }\n    }\n  }\n}\n// kotlin\n@Mod.EventHandler\nfun init(e: FMLInitializationEvent): Unit {\n    GlobalScope.launch {\n        val coolDownPlayers = hashSetOf<UUID>()\n        while (true) {\n            val event = nextAttackEvent()\n            val player = event.entityPlayer\n            val playerUUID = player.uniqueID\n            if (coolDownPlayers.contains(playerUUID)) {\n                event.isCanceled = true\n            } else {\n                when (event.target) {\n                    is IMob -> launch {\n                        coolDownPlayers.add(playerUUID)\n                        var coolDownTickLeft = 100\n                        while (coolDownTickLeft > 0) {\n                            coolDownTickLeft -= 1\n                            nextTick()\n                        }\n                        coolDownPlayers.remove(playerUUID)\n                        val message = \"Cool down has expired\"\n                        player.sendMessage(TextComponentString(message))\n                    }\n                    else -> Unit\n                }\n            }\n        }\n    }\n}\n一方面，我们可以注意到所有和实现特性相关的代码和对象声明，都放在了同一个方法下，这很好地贯彻了高内聚低耦合的设计原则；另一方面，这样做可以使代码的可读性大大增加，例如跳过 100 tick 的实现声明了一个非常单纯的 while 循环，并重复调用 nextTick 方法 100 次，如果不使用 Coroutine，我难以想象类似的实现能有多复杂。\n\n说明\n\n这里有几点需要说明：\n\n我们是在 Mod 加载的时候调用的这段代码，我们可以注意到，所有代码都是被一个以 reset（Scala）或 launch（Kotlin） 开头的块括了起来，因此即使内部写成了死循环的形式，实际运行的时候也只会在第一次 nextAttackEvent 调用的时候暂停，因此根本不会阻塞加载过程。我们声明了一个全局性质的 coolDownPlayers，但在代码里是以临时变量的方式表示的。实际上，该对象会在不同的子过程之间辗转，因此虽然它看起来是一个临时变量，但它是会被一直引用着的。如果游戏世界关闭，代码在执行到 nextAttackEvent 或 nextTick 的时候便永远不会继续执行下去，因此不必担心这个看起来像是死循环的代码不会终止的问题。因为所有的回调函数都是在游戏内事件触发的时候执行的，因此尽管看起来代码本身不同的片段的执行时机并不完全相同，但它们都是在游戏世界的主线程执行的，不必担心任何线程安全的问题。\n\n总结\n\nCoroutine 虽然不是什么新的技术，但是在 Minecraft Mod 中使用 Coroutine，的确能够带来一些相对崭新的写法。这种写法粗看起来可能不那么容易让比较熟悉 Minecraft 的开发者接受（比方说我一开始也不太能接受在代码里写一个循环并在循环里直接等待下一个 tick 这种看起来像是把线程「阻塞」了的写法），但是一旦适应了这样的写法，本人相信开发效率一定能够得到显著的提升。\n\n由于作者本人并不熟悉 Kotlin，因此作者不太能保证本文中的 Kotlin 代码一定完全正确，望请读者谅解。\n\n以下是本文的所有相关代码：\n\n\n\n\nForgeCoroutine.zip\n(109.23 KB, 下载次数: 12)\n\n\n\n2019-12-12 02:32 上传\n点击文件名下载附件\n\n\n\n\n",
    "replies": [
        {
            "author": "liach",
            "timestamp": 1577324520,
            "txt_content": "// java\nvoid foo(int value, Consumer<Bar> next) {\n    next.accept(new Bar(value));\n}复制代码// java\nvoid add(int a, int b, IntConsumer next) {\n    next.accept(a + b);\n}\n复制代码add(40, 2, value -> foo(value, bar -> doSomethingElse(bar)));\n复制代码\n楼主能写java的话还是写java让大家清晰点，scala kotlin看得头晕了"
        },
        {
            "author": "Eldon",
            "timestamp": 1581840720,
            "txt_content": "liach 发表于 2019-12-26 09:42\n楼主能写java的话还是写java让大家清晰点，scala kotlin看得头晕了\n这里的 Coroutine 本来就是给 Kotlin, Scala 玩家看的，前面的 callback 只是个不是很重要的引子，看不懂的话，那么后面的内容对他们来说也就没有什么意义。"
        }
    ]
}