{
    "title": "红石粉真的比侦测器铁轨卡传输信号卡吗",
    "author": "MrRobot",
    "replyCount": 8,
    "timestamp": 1585732500,
    "txt_content": " 本帖最后由 MrRobot 于 2020-4-1 17:58 编辑 \n\n今天在看bbs的一篇帖子时和楼主争论红石粉是怎么更新的，红石粉传输信号是不是比侦测器铁轨卡。我的经验和看的资料、视频都告诉我红石粉更卡，他做了详细的测试（虽然有些地方没看懂，还有感觉有些地方不严谨），高频红石和高频侦测器铁轨占用的cpu相近。\n\n我真的搞不懂，bbs也没搜到相应关于红石粉更新的内容。\n\n我的问题是究竟红石粉的工作原理是怎么样的，侦测器铁轨传输信号又是怎样的，两者相比哪个造成的卡顿更严重？他的测试有没有问题？\n最好能提供一些系统点的文字资料说明。\n\n附上帖子，重点看看18楼。https://www.mcbbs.net/thread-990700-1-1.html\n\n谢谢大家了。\n",
    "replies": [
        {
            "author": "Salt_lovely",
            "timestamp": 1585732500,
            "txt_content": "MrRobot 发表于 2020-4-2 16:03\n老哥你让我挺尴尬啊，我再看看有没有大佬回答。\n第一、别想了，问答版没有顶贴机制，提问贴沉了就是沉了（上了我的贼船还想跑）\n\n第二、我来回答另一个问题：红石粉为什么不能多用，以及“从0递加至15”到底是什么\n\n阅读源码可以知道：红石粉确定自己的信号强度时算法是直接从周围方块获取信号强度，如果周围有个信号为5的红石粉同时没有别的充能方块，那么这个红石粉的信号强度变为4——这一点很好理解吧。\n但是有没有注意到一个文问题：红石粉不会判断信号到底来自何处——它不关心一整条线是否被充能，而只关心周围有没有可以充能它的方块。\n所以会有这个情况：假如现在有一条红石线\n0 0 0 0 0\n此时最左侧有个拉杆充能\n那么充能的时候红石线信号强度是这样传递的：\n 0  0  0  0  0\n15  0  0  0  0\n15 14  0  0  0\n15 14 13  0  0\n15 14 13 12  0\n15 14 13 12 11\n看起来一切正常对吧？\n那么如果我们将拉杆关闭呢？\n（假设方块更新是先向右更新的）\n（注意递归）\n15 14 13 12 11\n13 14 13 12 11\n13 12 13 12 11\n13 12 11 12 11\n13 12 11 10 11\n13 12 11 10  9\n13 12 11  8  9\n13 12 11  8  7\n13 12 11  6  7\n.\n.\n.\n（假设方块更新是先向左更新的）\n15 14 13 12 11\n13 14 13 12 11\n13 12 13 12 11\n11 12 13 12 11\n11 10 13 12 11\n9 10 13 12 11\n 9  8 13 12 11\n7  8 13 12 11\n.\n.\n.\n一直到0\n具体多少次更新我已经懒得算了XD \n虽然充能铁轨的算法类似，但是算一趟的时间比红石粉短，同时只向四周更新1次（红石粉要更新1+4次）\n另外充能铁轨不会接受侧面的充能铁轨的信号，而红石粉则会和四面八方的别的红石粉连到一起，此时计算过程远比我上面列举的那个过程复杂得多——因此大的红石机械理应避免使用连起来的红石线（特别是大规模红石线传输阵列），以防卡服，至于点状红石粉带来的性能损失，其实是可以忽略的\n\n卡顿的不是点状红石粉，而是连起来的线状红石粉\n"
        },
        {
            "author": "EmptyLava",
            "timestamp": 1585732680,
            "txt_content": " 本帖最后由 EmptyLava 于 2020-4-1 17:25 编辑 \n\n红石粉是这样更新的\n每个红石的脉冲等级改变1，红石就刷新一次，改变10就刷新十次\n而侦测器之类的，侦测了也仅仅是更新一次\n\n红石粉要比其他的更卡服吧\n我也是听说的，实际也没有见到哪里确切些了这个\n\nbaidu了一下找到了这个https://tieba.baidu.com/p/6529826600\n一个红石粉状态变化会对周围的六个面的方块产生更新（包括空气）\n一个红石粉从15的信号到0并不是直接变化，而是从15逐渐递减到0，从0到十五也是同理\n而每递减一次，就会对周围6个方块产生更新，因此一个红石粉从15的信号到0会产生15*6=90个方块更新。\n再比如：一条15格长的红石粉被激活，那么它产生的方块更新个数就是1*5+2*4+3*4+4*4+5*4+6*4+7*4+8*4+9*4+10*4+11*4+12*4+13*4+14*4+15*5=496个（应该没算错）\n这虽然一条不算什么，但红石粉越来越多，产生更新的方块也会快速增加，就会增加卡顿。\n但至于为什么在那个楼内占用差不多\n我觉得不是因为方块更新周围空气导致的占用增高\n而是渲染导致的\n更新空气几乎不渲染，所以这可能也是为什么两次占用差不多了\n\n建议无数个活塞和红石来比，我觉得活塞就会比红石占用高了\n\n最终哪个卡服，还要看tps"
        },
        {
            "author": "MrRobot",
            "timestamp": 1585733100,
            "txt_content": "EmptyLava 发表于 2020-4-1 17:18\n红石粉是这样更新的\n每个红石的脉冲等级改变1，红石就刷新一次，改变10就刷新十次\n而侦测器之类的，侦测了 ...\n激活铁轨呢？又是怎么更新的呢？我希望有更权威的文章最好有扒代码或是较详细的试验过程，还有如果与那帖子的楼主试验结果相违背，那他的试验哪里出错了？"
        },
        {
            "author": "EmptyLava",
            "timestamp": 1585734240,
            "txt_content": " 本帖最后由 EmptyLava 于 2020-4-1 18:01 编辑 \nMrRobot 发表于 2020-4-1 17:25\n激活铁轨呢？又是怎么更新的呢？我希望有更权威的文章最好有扒代码或是较详细的试验过程，还有如果与那帖 ...\n应该是一次更新\n等下发代码的图给你\n\n\n\n\nF74E18E3-3583-46AF-A2DA-1BCB8CCEB4FF.png (146.08 KB, 下载次数: 0)\n\n下载附件\n\n2020-4-1 18:01 上传\n\n\n\n\n\n可以给个最佳吗\n"
        },
        {
            "author": "MrRobot",
            "timestamp": 1585735800,
            "txt_content": "EmptyLava 发表于 2020-4-1 17:44\n应该是一次更新\n等下发代码的图给你\n可以给个最佳吗\n感谢你的耐心回答，我观望下有无其他大佬有更详细权威的信息owo"
        },
        {
            "author": "Salt_lovely",
            "timestamp": 1585741260,
            "txt_content": " 本帖最后由 Salt_lovely 于 2020-4-1 20:14 编辑 \n\n对没错是我，我来了XD\n\n我去拆了一份1.14.4的paper端（楼上拆的是1.15的），红石改变充能强度的代码如下：\n    public IBlockData calculateCurrentChanges(final World worldIn, final BlockPosition pos1, final BlockPosition pos2, IBlockData state) {\n        final IBlockData iblockstate = state;\n        final int i = state.get((IBlockState<Integer>)BlockRedstoneWire.POWER);\n        int j = 0;\n        j = this.getPower(j, worldIn.getType(pos2));\n        this.setCanProvidePower(false);\n        final int k = worldIn.isBlockIndirectlyGettingPowered(pos1);\n        this.setCanProvidePower(true);\n        if (!worldIn.paperConfig.useEigencraftRedstone && k > 0 && k > j - 1) {\n            j = k;\n        }\n        int l = 0;\n        if (!worldIn.paperConfig.useEigencraftRedstone || k < 15) {\n            for (final EnumDirection enumfacing : EnumDirection.EnumDirectionLimit.HORIZONTAL) {\n                final BlockPosition blockpos = pos1.shift(enumfacing);\n                final boolean flag = blockpos.getX() != pos2.getX() || blockpos.getZ() != pos2.getZ();\n                if (flag) {\n                    l = this.getPower(l, worldIn.getType(blockpos));\n                }\n                if (worldIn.getType(blockpos).isOccluding(worldIn, blockpos) && !worldIn.getType(pos1.up()).isOccluding(worldIn, pos1)) {\n                    if (!flag || pos1.getY() < pos2.getY()) {\n                        continue;\n                    }\n                    l = this.getPower(l, worldIn.getType(blockpos.up()));\n                }\n                else {\n                    if (worldIn.getType(blockpos).isOccluding(worldIn, blockpos) || !flag || pos1.getY() > pos2.getY()) {\n                        continue;\n                    }\n                    l = this.getPower(l, worldIn.getType(blockpos.down()));\n                }\n            }\n        }\n        if (!worldIn.paperConfig.useEigencraftRedstone) {\n            if (l > j) {\n                j = l - 1;\n            }\n            else if (j > 0) {\n                --j;\n            }\n            else {\n                j = 0;\n            }\n            if (k > j - 1) {\n                j = k;\n            }\n        }\n        else {\n            j = l - 1;\n            if (k > j) {\n                j = k;\n            }\n        }\n        if (i != j) {\n            state = ((BlockDataAbstract<O, IBlockData>)state).set((IBlockState<Comparable>)BlockRedstoneWire.POWER, j);\n            if (worldIn.getType(pos1) == iblockstate) {\n                worldIn.setTypeAndData(pos1, state, 2);\n            }\n            if (!worldIn.paperConfig.useEigencraftRedstone) {\n                this.getBlocksNeedingUpdate().add(pos1);\n                for (final EnumDirection enumfacing2 : EnumDirection.values()) {\n                    this.getBlocksNeedingUpdate().add(pos1.shift(enumfacing2));\n                }\n            }\n        }\n        return state;\n    }复制代码\n我们讨论的是原版，所以默认!worldIn.paperConfig.useEigencraftRedstone皆为true\n    public IBlockData calculateCurrentChanges(final World worldIn, final BlockPosition pos1, final BlockPosition pos2, IBlockData state) {\n        final IBlockData iblockstate = state;\n        final int i = state.get((IBlockState<Integer>)BlockRedstoneWire.POWER);\n        int j = 0;\n        j = this.getPower(j, worldIn.getType(pos2));\n        this.setCanProvidePower(false);\n        final int k = worldIn.isBlockIndirectlyGettingPowered(pos1);\n        this.setCanProvidePower(true);\n        if ( k > 0 && k > j - 1) {\n            j = k;\n        }\n        int l = 0;\n//================================\n        if (true) { //这一段难以阅读，只能根据下面一段猜测是从周围方块取得信号强度\n            for (final EnumDirection enumfacing : EnumDirection.EnumDirectionLimit.HORIZONTAL) {\n                final BlockPosition blockpos = pos1.shift(enumfacing);\n                final boolean flag = blockpos.getX() != pos2.getX() || blockpos.getZ() != pos2.getZ();\n                if (flag) {\n                    l = this.getPower(l, worldIn.getType(blockpos));\n                }\n                if (worldIn.getType(blockpos).isOccluding(worldIn, blockpos) && !worldIn.getType(pos1.up()).isOccluding(worldIn, pos1)) {\n                    if (!flag || pos1.getY() < pos2.getY()) {\n                        continue;\n                    }\n                    l = this.getPower(l, worldIn.getType(blockpos.up())); \n                    //从上面的方块获取信号强度 ？\n                }\n                else {\n                    if (worldIn.getType(blockpos).isOccluding(worldIn, blockpos) || !flag || pos1.getY() > pos2.getY()) {\n                        continue;\n                    }\n                    l = this.getPower(l, worldIn.getType(blockpos.down()));\n                    //从下面的方块获取信号强度 ？\n                }\n            }\n        }\n//================================\n        if (true) { // 这一段很明显是在计算自己的信号强度\n            if (l > j) { // l 猜测是前一段取得的信号强度记录（周围方块提供的信号强度）\n                j = l - 1;\n            }\n            else if (j > 0) {\n                --j;\n            }\n            else {\n                j = 0;\n            }\n            if (k > j - 1) {\n                j = k;\n            }\n        }\n        else {\n            j = l - 1;\n            if (k > j) {\n                j = k;\n            }\n        }\n//================================\n        if (i != j) { //当最终结果发现红石的信号强度变化了\n            state = ((BlockDataAbstract<O, IBlockData>)state).set((IBlockState<Comparable>)BlockRedstoneWire.POWER, j); \n            // 改变自身信号强度\n            if (worldIn.getType(pos1) == iblockstate) {\n                worldIn.setTypeAndData(pos1, state, 2);\n            }\n            if (true) {\n                this.getBlocksNeedingUpdate().add(pos1); //更新周围6个方块\n                for (final EnumDirection enumfacing2 : EnumDirection.values()) {\n                    this.getBlocksNeedingUpdate().add(pos1.shift(enumfacing2));\n                    //更新外面一圈方块\n                }\n            }\n        }\n        return state;\n    }复制代码\n源码虽然看不太懂（恕我直言能看懂不带注释的代码的都是大神），但是可以很清晰地看出，红石线更新自己的过程是这样的：\n开始方块更新-->获取自己的信号强度-->获取周围方块的信号强度-->计算自己的信号强度-->如果自己的信号强度改变，则设置新的信号强度，同时更新周围范围为2的方块如果不改变，则啥都不做，直接返回自己的状态\n\n所以不存在被激活时将自己的的信号强度从0递加到15这种情况，它是直接把自己的强度设置为15同时更新距离为2的所有方块。\n\n充能铁轨的代码还在找，不过理论上没那么花里胡哨（不像红石粉需要判断很多条件来确定自己有没有被周围方块充能），同时充能铁轨只更新周围6个方块而不是像红石粉那样：\nthis.getBlocksNeedingUpdate().add(pos1); //更新周围6个方块\nfor (final EnumDirection enumfacing2 : EnumDirection.values()) {\n    this.getBlocksNeedingUpdate().add(pos1.shift(enumfacing2));\n    //更新外面一圈方块\n}复制代码\n所以充能铁轨不那么卡服。\n\n至于我为啥最后做出来的结果是二者基本一样卡，估计是因为我是用客户端做的实验，虽然游戏里我的视角往上，但是充能铁轨被激活之后是换材质而不是红石那样换颜色（拆材质包可以拆到），所以渲染充能铁轨要花费的资源更多，二者抵消。（至于到底哪个多就不是我能计算的范畴了）"
        },
        {
            "author": "帝王坦克b",
            "timestamp": 1585787400,
            "txt_content": "他还得算强度运算起来应该会比较麻烦"
        },
        {
            "author": "MrRobot",
            "timestamp": 1585814580,
            "txt_content": "Salt_lovely 发表于 2020-4-1 19:41\n对没错是我，我来了XD\n\n我去拆了一份1.14.4的paper端（楼上拆的是1.15的），红石改变充能强度的代码如下：\n老哥你让我挺尴尬啊，我再看看有没有大佬回答。"
        }
    ]
}