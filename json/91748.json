{
    "title": "【FML】技术向，一些mod开发经验（坑）",
    "author": "LuiCat",
    "replyCount": 4,
    "timestamp": 1361374920,
    "txt_content": " 本帖最后由 LuiCat 于 2013-3-6 14:26 编辑 \n\n（首先，看帖前，先保证有一定的java和mod制作基础，本帖仅为技术向的经验分享）（本人使用Eclipse和mcp7.25，若有不同，还请见谅）\n\n做个mod真蛋疼。。遇到不会的问题就得翻fml的wiki，然后是forum，恨不得吃了英语书……\n最后就开始各种查找代码引用了（可真是麻烦）\n\n更新日志\n\n2013-2-20  开坑，前两篇\n         2-23  又写了一篇，开学头几周不一定有时间写\n\n\n\n\n先不废话了，直接开始写，就当做经验的整理。。\n\n使用新的伤害类型（DamageSource）\n\n\n（引用EntityArrow造成伤害段）\n\nmojang标准造成伤害的方法是这样，我们按这个继续研究下去\n\n我们打开DamageSource类的定义\n\n\n\n哇！钻出来一个。。。这么多的静态变量\n可以直接引用并且使用于Entity.attackEntityFrom()函数\n\n\n（不要介意那个tmp。。）\n这就是那一堆东西的用法，不过我们要研究新的伤害类型。\n\n我们找到DamageSource.causeArrowDamage()的定义，发现它也不过就是return了一个new DamageSource。。。\n\n\n那么我们如法炮制\n\n\n代码解释：\n使用了DamageSource的派生类EntityDamageSourceIndirect，对Entity造成间接伤害，有一些mojang预置好的控制策略（至于是什么就不知道了。。用就是）\n对entityHit调用attackEntityFrom(DamagSource, int)函数，参数为DamagSource对象，整型伤害值。\n可以猜得到，如果对EntityEnderman（小黑）使用EntityDamageSourceIndirect（间接伤害）或者对EntityWitch（巫婆）使用\n带有indirectMagic（间接魔法）参数的伤害都是无效的\nattackEntityFrom()函数返回boolean值，表示是否产生攻击效果（就是被攻击的对象是否变红= =），可以加上条件语句里面放上其他处理（代码中是弄了个岩浆变石头的音效）\n\n把代码放到任意道具里测试。。\n可怜你了，蜘蛛菌\n\n\n恋色「Master Spark」！！！\n\n\n当然还有你\n\n\n恋色「Master Spark」——\n。。。。\n不要向下看\n\n\n\n\n\n\n\n\n\n\n\n\n\n你妹妹的崩溃。。\n\n\nIterator居然报错了\n\n都是时臣的错。。\n这意思就是说，List遍历时有元素删除\n也就是说。。。\n小黑成功的躲（zao）过（cheng）攻（beng）击（kui）\n\n接着测试。。\n\n。。。\n\n\n恋色「Master Spark」\n\n\nPlayer553视角\n\n\n似乎没什么特别的。。\n\n另附一图\n\n\n出现了死亡宣告“death.masterspark”\n这就体现出意义所在了\n使用新的DamageSource可以用于定义新的死亡公告（后面会写）\n还有就是，对于新的生物啥的可以设置对应的伤害免疫什么的\n这也完全符合非常识中的常识啊（喂你够了）\n\n关于前面那个问（beng）题（kui），我再改改吧。。至少跟这些代码没关系，一定是我打开方式不对。。。\n\n以上。\n\n\n\n定义新的死亡公告（以及各种类似用途）\n\n再吐槽一下“death.masterspark”。。。\n\n就是为了解决这个问题，才引出来这一番折腾（继续）\n\n看到“death.masterspark”，第一反应就去查看了en_US.lang，果然\n\n好多和♂谐的东西\n死亡宣告什么的\n\n但是我们不能修改语言包，只能寄希望于FML了\n经过一番双向查找，找到了LanguageRegistry\n仔细检查了它的代码执行方式，发现只不过是在读取语言包时把mod里的东西加进去\n那就好了\n（表吐槽我。。你们什么都没看到）\n\n\n先用.instance()获取LR的唯一实例，然后.addStringLocalization()\n三参数的参数表分别为需转译的字符串，语言包，转译字符串\n二参数的就是默认en_US，用于全局（如果不定义en_US的转译的话，其他语言就只能看到“death.masterspark”）\n另：“%1$s”代表用于填充玩家名称的标识符，在发布死亡通告时会自动填充\n\n\n当然，LanguageRegistry还可以类推到很多地方，先在mod初始化时定义好，在GUI或者其他地方就可以直接调用了，不用自己判断语言（当然你基本上也办不到），还可以自定义填充字符串\n\n\n改天研究一下3p系统←你什么都没有看到\n就是哪三个基佬一块做出的宣告←你还是什么都没看到\n\n我什么都没说。。\n\n以上。\n\n\n\n解决实体创建时属性同步问题\n(实体创建时附加数据传输）\n\n先来讲实体创建的过程\n\n由于minecraft服务器机制等各项原因，要求只能在服务器端代码创建实体，而客户端会接收SpawnPacket，自动创建对应的实体（也就是客户端用来显示的实体）\n客服端默认调用entity(World par1World)创建新实体\n\n我还记得我做第一个mod时spawn出来的item有一半捡不起来，原因就在这里。。。\n\n既然说到packet，就不得不提EntityTracker\n用过modloader（1.3+）的就知道，注册实体时还要registerEntityTracker，目的就在于实时更新客户端entity的位移信息\n\n（拿了个Entry充数）\n\n于是关于一般Entity的服务器与客户端间的信息传输就只有两个：\n1.entity生成信息\n2.位移信息\n\n以上。\n\n\n\n等等。。讲哪里去了\n\n「Master Spark」！！\n\n\n\n崩溃异变解决\n\n我这魔炮光束可♂大♂可♂小\n看起来没什么是吧。。。\n根本不是\n有一个解决方案是用Entity里的dataWatcher，当然可以（参考EntitySlime.setSlimeSize(int)）\n但这里要介绍的是FML里的方法\n\n直接上代码\n\n\n\n\n就是这样。\n\n首先，Entity类需要使用IEntityAdditionalSpawnData接口（不会接口的自己去补）\n然后补全接口中的两个函数\n（图片里的两个@Override是自动补全整出来的注解，可以不用写）\n\nFML在entity构造完毕后调用服务器的writeSpawnData()写入数据，然后在客户端entity构造后调用readSpawnData()\n具体用法呢。。很像NBT操作，但是没有标签key值，总之就是各种writeInt()、readFloat()啥的了（注意按顺序读写）\n\n那么，以上代码也不难看出，就是在服务器写入beamOriginSize数据，然后在客户端setBeamSize()\n（我为什么不用beamSize呢~~~我不说~~答对了有奖——才怪）\n（提示：答案在上面的图里）\n\n真·以上\n\n\n\n先写到这里，以后再慢慢写\n要是有问题还请指出\n\n\n\n\n\n",
    "replies": [
        {
            "author": "Friendly",
            "timestamp": 1361377320,
            "txt_content": "围观技术党"
        },
        {
            "author": "2B国国主",
            "timestamp": 1364422920,
            "txt_content": "表示fml最近越来越坑了"
        },
        {
            "author": "苦力怕喵~",
            "timestamp": 1378558860,
            "txt_content": "楼主流弊{:10_495:}"
        },
        {
            "author": "人家叫我饼干",
            "timestamp": 1388734200,
            "txt_content": "LZ辛苦了，话说怎么更换MCP的MOD所适应的MC版本"
        }
    ]
}