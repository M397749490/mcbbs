{
    "title": "1.16 之前的 Inventory 没有getTitle方法了",
    "author": "酥宁最酥啦",
    "replyCount": 11,
    "timestamp": 1597142940,
    "txt_content": " 本帖最后由 苏宁y 于 2020-8-11 18:51 编辑 \n\n 请问如何重新有getTitle方法呢\n\n因为这个插件 是1.14支持到\n\n 1.16 用 没getTitle方法了\n\n\n\n\n\nimage.png (46.95 KB, 下载次数: 0)\n\n下载附件\n\n2020-8-11 18:48 上传\n\n\n\n\n\n\n具体应该怎么改呢  我是萌新 别喷\n\n可能语言组织的不好\n\n因为才学习java\n",
    "replies": [
        {
            "author": "William_Shi",
            "timestamp": 1597143420,
            "txt_content": "1.13开始就没有什么getTitle方法了，并不是1.16去掉的\n从1.13开始就不可以Inventory#getTitle了"
        },
        {
            "author": "酥宁最酥啦",
            "timestamp": 1597143540,
            "txt_content": "William_Shi 发表于 2020-8-11 18:57\n1.13开始就没有什么getTitle方法了，并不是1.16去掉的\n从1.13开始就不可以Inventory#getTitle了 ...\n 好吧   那 一个插件\n\n需要用到 getTitle方法 咋办\n\n因为这个是限制服务器 漏斗的插件"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597143600,
            "txt_content": "苏宁y 发表于 2020-8-11 18:59\n好吧   那 一个插件\n\n需要用到 getTitle方法 咋办\nhttps://bukkit.windit.net/javado ... iew.html#getTitle--"
        },
        {
            "author": "酥宁最酥啦",
            "timestamp": 1597143840,
            "txt_content": "William_Shi 发表于 2020-8-11 19:00\nhttps://bukkit.windit.net/javadoc/org/bukkit/inventory/InventoryView.html#getTitle--\n明白了  \n\n只能删除 插件的 标题界面了 也要改很多东西\n\n非常感谢您的回答！"
        },
        {
            "author": "隔壁老吕",
            "timestamp": 1597144560,
            "txt_content": "evt.getView().getTitle()"
        },
        {
            "author": "南柯郡守",
            "timestamp": 1597155780,
            "txt_content": "苏宁y 发表于 2020-8-11 19:04\n明白了  \n\n只能删除 插件的 标题界面了 也要改很多东西\n你楼下说的先.getView()就能.getTitle()\n\n不过之前看一个帖说可以用自定义的InventortHolder来做判断依据  可以参考\n怎么判定是否是指定容器啊\nhttps://www.mcbbs.net/thread-1080949-1-1.html\n(出处: Minecraft(我的世界)中文论坛)"
        },
        {
            "author": "13683096022",
            "timestamp": 1597156500,
            "txt_content": "20302433482030243348203024334820302433482030243348"
        },
        {
            "author": "结城希亚",
            "timestamp": 1597157820,
            "txt_content": "虽然我的插件写着支持到1.14，但我并不确定是否支持\n因为我手上就1.7、1.12、1.15的api来开发\n我看1.15已经没有getTitle了\n\n但我写1.14兼容，也没有人反馈不兼容，所以是可以用的（？）\n可以试试evt.getView().getTitle\n\n哦对了，gui那个类里的也要改，毕竟id扁平化"
        },
        {
            "author": "酥宁最酥啦",
            "timestamp": 1597158060,
            "txt_content": " 本帖最后由 苏宁y 于 2020-8-11 23:02 编辑 \n结城希亚 发表于 2020-8-11 22:57\n虽然我的插件写着支持到1.14，但我并不确定是否支持\n因为我手上就1.7、1.12、1.15的api来开发\n我看1.15已经 ...\n好的 知道了\n\n谢谢提醒！\n你写的变量啥的我可能会略调"
        },
        {
            "author": "William_Shi",
            "timestamp": 1597193100,
            "txt_content": "结城希亚 发表于 2020-8-11 22:57\n虽然我的插件写着支持到1.14，但我并不确定是否支持\n因为我手上就1.7、1.12、1.15的api来开发\n我看1.15已经 ...\npackage org.bukkit.craftbukkit.v1_14_R1.inventory;\n\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport net.minecraft.server.v1_14_R1.IInventory;\nimport net.minecraft.server.v1_14_R1.ItemStack;\nimport org.apache.commons.lang.Validate;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.craftbukkit.v1_14_R1.util.CraftLegacy;\nimport org.bukkit.entity.HumanEntity;\nimport org.bukkit.event.inventory.InventoryType;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.InventoryHolder;\nimport org.bukkit.inventory.ItemStack;\n\npublic class CraftInventory implements Inventory {\n  protected final IInventory inventory;\n  \n  public CraftInventory(IInventory inventory) {\n    this.inventory = inventory;\n  }\n  \n  public IInventory getInventory() {\n    return this.inventory;\n  }\n  \n  public int getSize() {\n    return getInventory().getSize();\n  }\n  \n  public ItemStack getItem(int index) {\n    ItemStack item = getInventory().getItem(index);\n    return item.isEmpty() ? null : CraftItemStack.asCraftMirror(item);\n  }\n  \n  protected ItemStack[] asCraftMirror(List<ItemStack> mcItems) {\n    int size = mcItems.size();\n    ItemStack[] items = new ItemStack[size];\n    for (int i = 0; i < size; i++) {\n      ItemStack mcItem = mcItems.get(i);\n      items = mcItem.isEmpty() ? null : CraftItemStack.asCraftMirror(mcItem);\n    } \n    return items;\n  }\n  \n  public ItemStack[] getStorageContents() {\n    return getContents();\n  }\n  \n  public void setStorageContents(ItemStack[] items) throws IllegalArgumentException {\n    setContents(items);\n  }\n  \n  public ItemStack[] getContents() {\n    List<ItemStack> mcItems = getInventory().getContents();\n    return asCraftMirror(mcItems);\n  }\n  \n  public void setContents(ItemStack[] items) {\n    if (getSize() < items.length)\n      throw new IllegalArgumentException(\"Invalid inventory size; expected \" + getSize() + \" or less\"); \n    for (int i = 0; i < getSize(); i++) {\n      if (i >= items.length) {\n        setItem(i, null);\n      } else {\n        setItem(i, items);\n      } \n    } \n  }\n  \n  public void setItem(int index, ItemStack item) {\n    getInventory().setItem(index, CraftItemStack.asNMSCopy(item));\n  }\n  \n  public boolean contains(Material material) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    for (ItemStack item : getStorageContents()) {\n      if (item != null && item.getType() == material)\n        return true; \n    } \n    return false;\n  }\n  \n  public boolean contains(ItemStack item) {\n    if (item == null)\n      return false; \n    for (ItemStack i : getStorageContents()) {\n      if (item.equals(i))\n        return true; \n    } \n    return false;\n  }\n  \n  public boolean contains(Material material, int amount) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    if (amount <= 0)\n      return true; \n    for (ItemStack item : getStorageContents()) {\n      if (item != null && item.getType() == material && (\n        amount -= item.getAmount()) <= 0)\n        return true; \n    } \n    return false;\n  }\n  \n  public boolean contains(ItemStack item, int amount) {\n    if (item == null)\n      return false; \n    if (amount <= 0)\n      return true; \n    for (ItemStack i : getStorageContents()) {\n      if (item.equals(i) && --amount <= 0)\n        return true; \n    } \n    return false;\n  }\n  \n  public boolean containsAtLeast(ItemStack item, int amount) {\n    if (item == null)\n      return false; \n    if (amount <= 0)\n      return true; \n    for (ItemStack i : getStorageContents()) {\n      if (item.isSimilar(i) && (amount -= i.getAmount()) <= 0)\n        return true; \n    } \n    return false;\n  }\n  \n  public HashMap<Integer, ItemStack> all(Material material) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    HashMap<Integer, ItemStack> slots = new HashMap<>();\n    ItemStack[] inventory = getStorageContents();\n    for (int i = 0; i < inventory.length; i++) {\n      ItemStack item = inventory;\n      if (item != null && item.getType() == material)\n        slots.put(Integer.valueOf(i), item); \n    } \n    return slots;\n  }\n  \n  public HashMap<Integer, ItemStack> all(ItemStack item) {\n    HashMap<Integer, ItemStack> slots = new HashMap<>();\n    if (item != null) {\n      ItemStack[] inventory = getStorageContents();\n      for (int i = 0; i < inventory.length; i++) {\n        if (item.equals(inventory))\n          slots.put(Integer.valueOf(i), inventory); \n      } \n    } \n    return slots;\n  }\n  \n  public int first(Material material) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    ItemStack[] inventory = getStorageContents();\n    for (int i = 0; i < inventory.length; i++) {\n      ItemStack item = inventory;\n      if (item != null && item.getType() == material)\n        return i; \n    } \n    return -1;\n  }\n  \n  public int first(ItemStack item) {\n    return first(item, true);\n  }\n  \n  private int first(ItemStack item, boolean withAmount) {\n    return first(item, withAmount, getStorageContents());\n  }\n  \n  private int first(ItemStack item, boolean withAmount, ItemStack[] inventory) {\n    if (item == null)\n      return -1; \n    for (int i = 0; i < inventory.length; i++) {\n      if (inventory != null)\n        if (withAmount ? item.equals(inventory) : item.isSimilar(inventory))\n          return i;  \n    } \n    return -1;\n  }\n  \n  public int firstEmpty() {\n    ItemStack[] inventory = getStorageContents();\n    for (int i = 0; i < inventory.length; i++) {\n      if (inventory == null)\n        return i; \n    } \n    return -1;\n  }\n  \n  public int firstPartial(Material material) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    ItemStack[] inventory = getStorageContents();\n    for (int i = 0; i < inventory.length; i++) {\n      ItemStack item = inventory;\n      if (item != null && item.getType() == material && item.getAmount() < item.getMaxStackSize())\n        return i; \n    } \n    return -1;\n  }\n  \n  private int firstPartial(ItemStack item) {\n    ItemStack[] inventory = getStorageContents();\n    ItemStack filteredItem = CraftItemStack.asCraftCopy(item);\n    if (item == null)\n      return -1; \n    for (int i = 0; i < inventory.length; i++) {\n      ItemStack cItem = inventory;\n      if (cItem != null && cItem.getAmount() < cItem.getMaxStackSize() && cItem.isSimilar(filteredItem))\n        return i; \n    } \n    return -1;\n  }\n  \n  public HashMap<Integer, ItemStack> addItem(ItemStack... items) {\n    Validate.noNullElements((Object[])items, \"Item cannot be null\");\n    HashMap<Integer, ItemStack> leftover = new HashMap<>();\n    for (int i = 0; i < items.length; i++) {\n      ItemStack item = items;\n      while (true) {\n        int firstPartial = firstPartial(item);\n        if (firstPartial == -1) {\n          int firstFree = firstEmpty();\n          if (firstFree == -1) {\n            leftover.put(Integer.valueOf(i), item);\n            break;\n          } \n          if (item.getAmount() > getMaxItemStack()) {\n            CraftItemStack stack = CraftItemStack.asCraftCopy(item);\n            stack.setAmount(getMaxItemStack());\n            setItem(firstFree, stack);\n            item.setAmount(item.getAmount() - getMaxItemStack());\n            continue;\n          } \n          setItem(firstFree, item);\n          break;\n        } \n        ItemStack partialItem = getItem(firstPartial);\n        int amount = item.getAmount();\n        int partialAmount = partialItem.getAmount();\n        int maxAmount = partialItem.getMaxStackSize();\n        if (amount + partialAmount <= maxAmount) {\n          partialItem.setAmount(amount + partialAmount);\n          setItem(firstPartial, partialItem);\n          break;\n        } \n        partialItem.setAmount(maxAmount);\n        setItem(firstPartial, partialItem);\n        item.setAmount(amount + partialAmount - maxAmount);\n      } \n    } \n    return leftover;\n  }\n  \n  public HashMap<Integer, ItemStack> removeItem(ItemStack... items) {\n    return removeItem(false, items);\n  }\n  \n  public HashMap<Integer, ItemStack> removeItemAnySlot(ItemStack... items) {\n    return removeItem(true, items);\n  }\n  \n  private HashMap<Integer, ItemStack> removeItem(boolean searchEntire, ItemStack... items) {\n    Validate.notNull(items, \"Items cannot be null\");\n    HashMap<Integer, ItemStack> leftover = new HashMap<>();\n    for (int i = 0; i < items.length; i++) {\n      ItemStack item = items;\n      int toDelete = item.getAmount();\n      do {\n        ItemStack[] toSearch = searchEntire ? getContents() : getStorageContents();\n        int first = first(item, false, toSearch);\n        if (first == -1) {\n          item.setAmount(toDelete);\n          leftover.put(Integer.valueOf(i), item);\n          break;\n        } \n        ItemStack itemStack = getItem(first);\n        int amount = itemStack.getAmount();\n        if (amount <= toDelete) {\n          toDelete -= amount;\n          clear(first);\n        } else {\n          itemStack.setAmount(amount - toDelete);\n          setItem(first, itemStack);\n          toDelete = 0;\n        } \n      } while (toDelete > 0);\n    } \n    return leftover;\n  }\n  \n  private int getMaxItemStack() {\n    return getInventory().getMaxStackSize();\n  }\n  \n  public void remove(Material material) {\n    Validate.notNull(material, \"Material cannot be null\");\n    material = CraftLegacy.fromLegacy(material);\n    ItemStack[] items = getStorageContents();\n    for (int i = 0; i < items.length; i++) {\n      if (items != null && items.getType() == material)\n        clear(i); \n    } \n  }\n  \n  public void remove(ItemStack item) {\n    ItemStack[] items = getStorageContents();\n    for (int i = 0; i < items.length; i++) {\n      if (items != null && items.equals(item))\n        clear(i); \n    } \n  }\n  \n  public void clear(int index) {\n    setItem(index, null);\n  }\n  \n  public void clear() {\n    for (int i = 0; i < getSize(); i++)\n      clear(i); \n  }\n  \n  public ListIterator<ItemStack> iterator() {\n    return new InventoryIterator(this);\n  }\n  \n  public ListIterator<ItemStack> iterator(int index) {\n    if (index < 0)\n      index += getSize() + 1; \n    return new InventoryIterator(this, index);\n  }\n  \n  public List<HumanEntity> getViewers() {\n    return this.inventory.getViewers();\n  }\n  \n  public InventoryType getType() {\n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.InventoryCrafting)\n      return (this.inventory.getSize() >= 9) ? InventoryType.WORKBENCH : InventoryType.CRAFTING; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.PlayerInventory)\n      return InventoryType.PLAYER; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityDropper)\n      return InventoryType.DROPPER; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityDispenser)\n      return InventoryType.DISPENSER; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityBlastFurnace)\n      return InventoryType.BLAST_FURNACE; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntitySmoker)\n      return InventoryType.SMOKER; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityFurnace)\n      return InventoryType.FURNACE; \n    if (this instanceof CraftInventoryEnchanting)\n      return InventoryType.ENCHANTING; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityBrewingStand)\n      return InventoryType.BREWING; \n    if (this.inventory instanceof CraftInventoryCustom.MinecraftInventory)\n      return ((CraftInventoryCustom.MinecraftInventory)this.inventory).getType(); \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.InventoryEnderChest)\n      return InventoryType.ENDER_CHEST; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.InventoryMerchant)\n      return InventoryType.MERCHANT; \n    if (this instanceof CraftInventoryBeacon)\n      return InventoryType.BEACON; \n    if (this instanceof CraftInventoryAnvil)\n      return InventoryType.ANVIL; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.IHopper)\n      return InventoryType.HOPPER; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityShulkerBox)\n      return InventoryType.SHULKER_BOX; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityBarrel)\n      return InventoryType.BARREL; \n    if (this.inventory instanceof net.minecraft.server.v1_14_R1.TileEntityLectern.LecternInventory)\n      return InventoryType.LECTERN; \n    if (this instanceof CraftInventoryLoom)\n      return InventoryType.LOOM; \n    if (this instanceof CraftInventoryCartography)\n      return InventoryType.CARTOGRAPHY; \n    if (this instanceof CraftInventoryGrindstone)\n      return InventoryType.GRINDSTONE; \n    if (this instanceof CraftInventoryStonecutter)\n      return InventoryType.STONECUTTER; \n    return InventoryType.CHEST;\n  }\n  \n  public InventoryHolder getHolder() {\n    return this.inventory.getOwner();\n  }\n  \n  public int getMaxStackSize() {\n    return this.inventory.getMaxStackSize();\n  }\n  \n  public void setMaxStackSize(int size) {\n    this.inventory.setMaxStackSize(size);\n  }\n  \n  public int hashCode() {\n    return this.inventory.hashCode();\n  }\n  \n  public boolean equals(Object obj) {\n    return (obj instanceof CraftInventory && ((CraftInventory)obj).inventory.equals(this.inventory));\n  }\n  \n  public Location getLocation() {\n    return this.inventory.getLocation();\n  }\n}\n\n\nPAPER 1.14 的CraftInventory类\n\n没看到getTitle\n\n我没记错，我想，1.13就已经无法使用这个方法了"
        },
        {
            "author": "酥宁最酥啦",
            "timestamp": 1597202820,
            "txt_content": "南柯郡守 发表于 2020-8-11 22:23\n你楼下说的先.getView()就能.getTitle()\n\n不过之前看一个帖说可以用自定义的InventortHolder来做判断依据 ...\n是的 我现在用的就是这个方法\n\n不过我现在在改读写  \n\n因为他获取的不是英文 Material"
        }
    ]
}