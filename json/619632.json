{
    "title": "Bukkit Conversation API 简单介绍 —— 处理玩家输入 So Easy！",
    "author": "桃渊林",
    "replyCount": 5,
    "timestamp": 1470984480,
    "txt_content": " 本帖最后由 hcrgm1 于 2020-2-15 18:36 编辑 \n\n最近梨子提起了一个叫“org.bukkit.conversations”的包是干啥用的，哇，这个包谁知道啊什么鬼？字面上的意思是对话，Bukkit的Javadoc说这个包是玩家与插件的信息交流用的，应该是获取玩家输入的消息然后由插件处理？那就探讨一下吧。\n目前大多数开发者都不知道这个包，所以蠢蠢地写了各种处理玩家输入的框架，比如：\n\n所以我决定编写这个教程\n了解下此包的结构->https://hub.spigotmc.org/javadoc ... ackage-summary.html\n1.Conversable接口\n这个接口代表可以与插件交流的对象，目前ConsoleCommandSender和Player类实现了这个接口.\n2.Prompt\n这个是对话的核心，你需要编写一个Prompt类，需要实现此接口。不过Bukkit已经提供了一些常用的抽象类，比如ValidatingPrompt（可以验证玩家输入的Prompt），你要用直接继承就好。你想偷懒就直接用Bukkit给你的，不过自己实现完全没有问题。\n更多的Prompt可以看看javadoc。\n对话开始后，getPromptText方法的返回值将会显示给玩家，当作提示，玩家输入信息后，会调用acceptInput方法，这个方法就是处理玩家输入的信息的，根据玩家的输入，返回Prompt，可以是新的Prompt，可以是用来结束对话的Prompt（Prompt.END_OF_CONVERSATION）。\n这里给一个ValidatingPrompt食用实例：\nprivate class MyPrompt extends ValidatingPrompt {\n    @Override\n    public String getPromptText(ConversationContext context) {\n        return \"Input something?\"; //给玩家的提示消息\n    }\n\n    @Override\n    protected boolean isInputValid(ConversationContext context, String input)\n    {\n        return true; //检查玩家的输入是否正确，这里直接返回true了，实际上就不是这样了\n    }\n\n    //处理玩家的输入\n    @Override\n    protected Prompt acceptValidatedInput(ConversationContext context, String input) {\n        context.getForWhom().sendRawMessage(\"Conversation end, your input is:\" + input); //输出玩家输入的信息(input)\n        return Prompt.END_OF_CONVERSATION; //结束对话\n    }\n}复制代码\n3.构建Conversation对象\nConversation是一个普通的类，但是一般不是直接new的，需要用ConversationFactory进行构建。\n创建ConversationFactory对象，然后对着javadoc里讲的方法附加些属性，最后就用buildConversation方法构建出Conversation对象。\n这里就贴一个非常基础的实例吧，要设置更多的属性还是看javadoc。\nConversation conversation = new ConversationFactory(this)\n                    .withFirstPrompt(new MyPrompt())\n                    .addConversationAbandonedListener(new ConversationAbandonedListener() {\n                        @Override\n                        public void conversationAbandoned(ConversationAbandonedEvent abandonedEvent) {\n                            if (abandonedEvent.gracefulExit()) {\n                                abandonedEvent.getContext().getForWhom().sendRawMessage(\"exit\");\n                            }\n                        }\n                    })\n                    .buildConversation(player);复制代码\nthis为插件对象，player为玩家对象。当然ConsoleCommandSender也可以。withFirstPrompt就是设置对话的第一个Prompt，addConversationAbandonedListener就是增加对话放弃监听器，这里的行为是放弃会话时给玩家发送“exit”消息。\n接着，开始对话。\nconversation.begin();复制代码\n你只需要做好你的对话，然后剩下的事是Bukkit的了。\n效果：http://dvideo.oss-us-west-1.aliyuncs.com/convdemo.flv\n最后贴上我测试时写的代码，可以自己改一改，快速上手Conversation API：http://git.oschina.net/hcrgm/codes/6vi4juo1h8ag93nrbekqy\n可惜GitHub Gist被墙...\n\n剩下的仔细咀嚼javadoc并动手吧，如果有哪些不懂的可以提问，我会解答",
    "replies": [
        {
            "author": "鸭蛋只吃黄",
            "timestamp": 1474624020,
            "txt_content": "这句最重要...ConsoleCommandSender和Player类实现了这个接口，一看就明白了。\n给楼主点个赞，这才是开发者应该干的事情。"
        },
        {
            "author": "Gaint",
            "timestamp": 1476005340,
            "txt_content": "            这个很好，"
        },
        {
            "author": "ByZYM",
            "timestamp": 1483957380,
            "txt_content": "有个没看懂的是，怎么开始下一个prompt"
        },
        {
            "author": "ByZYM",
            "timestamp": 1483957500,
            "txt_content": "意思是每一句对话都要写一个prompt来操作么"
        },
        {
            "author": "Jonjs_Dada",
            "timestamp": 1504071780,
            "txt_content": " 本帖最后由 Jonjs_Dada 于 2020-2-19 21:05 编辑 \n\ndalao的世界，萌新路过，没人看见我吧\n2020/2/19编辑一下，终于看懂了\n"
        }
    ]
}