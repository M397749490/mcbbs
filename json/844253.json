{
    "title": "插件完全意义上的重载",
    "author": "拉普达",
    "replyCount": 5,
    "timestamp": 1549917060,
    "txt_content": "在挺久以前，我想把自己的一个插件实现一个功能，就是完全卸载，然后再加载。但是有人跟我说得用两个插件配合，于是我就放弃了。\n今天，我意外地发现了，一个方法：\n先使用Bukkit.getPluginManager().disablePlugin(this)将插件卸载了，\n然后居然可以继续执行接下来的语句，\n于是使用Bukkit.getPluginManager().enablePlugin(this)就又加载了。\n\n不过该方法卸载以后，插件命令注册不会失效，并且help上也不会消失，但卸载加载会执行onEnable与onDisable方法。\n你对这个方法有什么看法呢，不知道这个方法是否能称为真正意义上的重载？",
    "replies": [
        {
            "author": "langyo",
            "timestamp": 1549935120,
            "txt_content": "顾名思义，disable 与 enable 分别有禁用和启用的意思\n\n这两个方法做到的并不是真正的卸载插件，而是将插件暂时禁用/启用\n\n照这样理解，这种禁用仅仅会造成插件的所有注册的事件暂时被冻结，也就是“外头无论发生啥事，插件捂着耳朵不听不听不听”，但 Bukkit 仍然会留着此插件一个位置，它注册的各种内容仍然在那不会消失（只不过是可能会暂时失效）"
        },
        {
            "author": "太帅是罪过",
            "timestamp": 1549943280,
            "txt_content": "楼上正解。"
        },
        {
            "author": "海螺螺",
            "timestamp": 1549947540,
            "txt_content": " 本帖最后由 754503921 于 2019-2-12 13:00 编辑 \n\n不要听二楼瞎说\n\n你调用的这个 disablePlugin(this) 东西，会调用一遍你的 onDisable，会取消掉你的所有定时任务，取消注册所有事件和服务，取消注册你的所有消息通道，并且尝试卸载加载的所有插件的类文件（除主类），这之后你就不能再调用其他类了。\n\n之所以会有需要两个插件配合才能「完全卸载一个插件」的说法，是因为 PluginManager 的 disablePlugin 方法不会删除他自身保存的插件主类实例，而由于jvm的规则，你的类不可能在这个时候被卸载回收，这也就是你可以继续执行 enablePlugin 的原因。你要控制插件就不能完全卸载插件，完全卸载插件必须在整个bukkit都没有保存你的插件实例才能，当然只能让其他插件来做。\n\n至于完全卸载再加载一个插件，你要是知道了所谓的完全卸载其实就是干的这些事，你完全可以自己做，也就是手动卸载.....再手动注册一遍。\n\n一般插件重载的逻辑是自己写的，不是给bukkit的。"
        },
        {
            "author": "juneve",
            "timestamp": 1550065200,
            "txt_content": "真的看不懂这些编程大佬做的东西"
        },
        {
            "author": "kevin2018",
            "timestamp": 1565082780,
            "txt_content": "754503921 发表于 2019-2-12 12:59\n不要听二楼瞎说\n\n你调用的这个 disablePlugin(this) 东西，会调用一遍你的 onDisable，会取消掉你的所有定 ...\n此乃正解。"
        }
    ]
}