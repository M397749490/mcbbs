{
    "title": "Recurrent Complex（循环遗迹）Wiki翻译（待更新）",
    "author": "森林蝙蝠",
    "replyCount": 2,
    "timestamp": 1528035420,
    "txt_content": " 本帖最后由 森林蝙蝠 于 2019-3-20 23:19 编辑 \n\n我发现很多人都不用Ruins，然后瞌睡了有人送枕头，就有了Recurrent Complex这个生成和定制遗迹的mod（以下简称RECC）。\n本文的目的是翻译RECC的wiki：http://minecraft-recurrent-complex.wikia.com/wiki/Minecraft_Recurrent_Complex_Wiki\nAPI（开发接口）：\n你可以将RECC用于开发中，有light dependency（联动）和hard dependency（依赖）这两个选项。\n如果你只是联动RECC的话，不需要安装它作为前置，但是安装了RECC之后你的mod就可以利用它。你可以用一些方法实现和RECC之间的通讯，在RCCommunicationAdapter类中找到这些方法，RECC已经给你预实现过。\nRECC会自动搜索任何你安装的mod中存在的多方块结构文件，并将它们注册到registry类中而不需要写一行代码，你只需要安装RECC，并将你的结构和其他相应的资源放在正确的文件夹下，例如：\nassets/modid/structures/activeassets/modid/structures/inactive\n这些资源将会被RECC自动加载，你可以在“文件管理”部分找到更多信息。\n如果你要用RECC作为前置，你应该注意这些类：\nStructureRegistry类用来注册和检索结构；GenericItemCollectionRegistry类用来注册和检索物品生成器；WorldGenStructures用来在世界中自动生成结构。\n\nAdding Structures And Disabling Structures（添加与禁用建筑结构）：\n\n你可以去http://complex.ivorius.de找到他人制作的结构，把它们放到.minecraft/structures/active文件夹下即可。你可以在游戏中运行/#files指令找到这些文件，也可以在“文件管理”部分中进一步了解。\n查看“结构建造”部分，建造自己的结构。\n\n如果你不喜欢某个结构，想要禁用它，有两种方式找出它的ID：\n 黑名单: 走进你不喜欢的结构当中，输入指令/#whatisthis得到它的ID； 白名单: 如果你想按你的意愿控制所有的结构，新建一个世界，输入 /#gen（生成）或者 #import（导入）以生成或者导入结构，使用 /#list命令可以看到所有可用的结构清单，或者#search命令以“更有指引性”的方式查看这些结构。\n然后按如下步骤：\n 找到配置界面 (主菜单 -> Mods -> Recurrent Complex -> Config，打开以编辑；如果在服务器上，你可以用/nano命令在线编辑，也可以本地改完后上传替换) 进入'Balancing' （平衡）分类下，找到structureGenerationMatcher 选项。 黑名单：以MeteorSite为例，将其设置为!MeteorSite，可以用&号同时指定多个结构，例如(!MeteorSite & !MeteorSite2 & !$reccomplex)。这是一个黑名单示例：!MeteorSite & !AbandonedTower & !id=SmallPyramid白名单：将这个结构设置为MeteorSite，可以用&号同时指定多个结构，例如(!MeteorSite & !MeteorSite2 & !$reccomplex)。这是一个白名单示例：MeteorSite | id=AbandonedTower | SmallPyramid\n如果你想禁用一个mod所有的结构，也可以用structureGenerationMatcher选项，不过你得知道modid，例如RecurrentComplex自己，它的id是reccomplex。如上所述，你可以设置类似于!$reccomplex（$modid）的表达式，并用&号将它们连接起来。\n如果你想禁用所有的结构，请将structureSpawnChanceModifier 和baseVillageSpawnWeight设置为 0。\n\nExpression（表达式，自定义结构时的重要操作）：\n\n布尔表达式又称逻辑表达式，用“真”和“假”这两个布尔值来进行运算。\n\n !a- 逻辑非，反转逻辑(真 -> 假, 假 -> 真) a & b - 逻辑与: 当a和b均为真时，才会返回真。 a | b - 逻辑或：a和b只要有一个为真就会返回真。 a ?? b :: c - 三目运算，如果a为真则返**，否则返回c。 (a) - 圆括号:将变量分组，括号内的运算优先级最高，就像你做小学数学题一样。\n特殊字符：引号 \"\"\n如果你想在变量中插入字符，请使用引号，例如: \"VariableWithAn&\" | \"VariableWithQuotes()\" 或者\"Variable with spaces\"。\n特殊字符：反斜线 \\ \n你可以用 \\ 使下一个字符实现转义，例如： VariableWithAn\\& | VariableWithQuotes\\(\\) | Variable\\ with\\ spaces会变成VariableWithAmpersand& | VariableWithQuotes() | Variable with spaces\n引号和反斜线都可以用在变量中，例如\" VariableWithQuotes\\\" 和 VariableWithBackslash\\\\.\n注意，空格不是必须的，它用来标记下一批字符的起始，例如：  Some\\ Variable & Some\\ Other\\ Variable 会变成 Some Variable & Some Other Variable.\n有一些全局变量会在所有的表达式中用到。\ntrue - 真，false - 假；\nglobal:a - 赋值全局变量a，可以在配置文件中声明。例如默认情况下表达式 global:decayTreeLeaves用在树的表达式中，以控制树叶可不可以在生成后消失。\n\n有很多不同种类的表达式，你不一定需要了解所有的表达式，看看下面的清单足以了。\n\n依赖表达式（Dependency Expression）：要素(例如结构和物品生成器)将被加载时使用该表达式。\n表达式类型：\n $a 或 mod:a - 如果modid为 'a'的mod已经安装或已经记载，返回真。 #a  structure:a 或 strc:a - 如果结构id为 'a'的结构已经加载，返回真。 registry:a.b 或reg:a.b - 查找id 'a'所注册的位置, 并在其中赋值一个变量b。\n以下是示例：\n$reccomplex & mod:yegamolchattels & $pandorasbox\n当RECC，ye gamol chattels和Pandora's Box这三个mod都被加载时，返回真。\n(registry:structure.has:BigHouse | registry:structure.has:SmallHouse) & !$yegamolchattels\n当ye gamol chattels这个mod不被加载，且“bighouse”或“smallhouse”至少有一个被加载时，返回真。\n$yegamolchattels & !(mod:pandorasbox | registry:inventory_generation_component.has:AbandonedChest)\n当ye gamol chanttels这个mod加载，但是Pandora‘s Box mod不加载，而且inventory_generation_component下的AbandonedChest也不加载时，表达式返回真。\n\n群系表达式（Biome Expression）：\n用来匹配生物群系的表达式。\n表达式类型:\n a id=a  - 如果生物群系的id是'a'的话，返回真. $a或type=a - 如果生物群系符合相应的群系辞典类型 'a'，则返回真。你可以用/#biome命令获取生物群系类型。 name=a - 如果生物群系名是 'a'的话，返回真。\nplains | id=desert | forest\n白名单：匹配“plains（平原）”，“desert（沙漠）”“forest（森林）”群系。\n!(type=WATER | id=forest)\n黑名单：匹配除了水类型（例如海洋，暮色湖泊）和森林群系之外所有的群系。注意，作为一个类型，WATER是大写的。\n($PLAINS | type=FOREST) & !id=plains\n匹配所有平原和森林类型的群系，除了'平原'本身之外。\ntype=WATER & !($OCEAN | $SNOWY)\n匹配所有水类型的群系，除了海洋和雪类型的群系。\n\n维度表达式（Dimension Expression）：\n用来匹配维度的表达式。\n\n表达式类型：\n $a或type=a - 如果当前维度符合维度辞典类型 'a'，返回真。 a  id=a- 如果当前维度的id是 'a'，返回真。\n0 | 1 | id=-1\n白名单：匹配dimensions 0 (主世界), 1 (末地) and -1 (地狱) 。\n!(type=FINITE | id=1)\n黑名单：匹配除了finite类型和1 (末地)之外所有的维度。\n($ENDER | type=REAL) & !id=0\n匹配所有“ender（末影）”和“real”类型的维度,除了0 (主世界)。\n$HELL & !(type=FINITE | $UNREAL)\n匹配所有“hell（地狱）”类型的维度，除了finite和unreal类型之外。\n\n方块表达式（Block Expression）：\n用来匹配某一特定方块。\n\n表达式类型:\n #a-b  metadata=a-b - 如果方块的元数据（metadata，也叫附加值）符合a-b这么一个区间，表达式返回真。 #a  metadata=a-如果方块元数据符合特定值a，表达式返回真。 property[a]=b - 如果方块id为a，元数据为b，返回真。 a  id=a - 如果方块id为a，返回真。\n如果是特定类型的表达式，可以用到如下的变量：\n is:a - 如果方块符合某一标准a，返回真。 'a' 可以是: leaves（树叶），air（空气），foliage（草和蕨类）, replaceable（可替换）, liquid（液体）, water（水）, lava（岩浆） sustains:a - 如果这个方块支撑了一个植物类型a，返回真。 'a' 可以是: trees（树木）, mushrooms（蘑菇）, cacti（紫颂果） blocks:a - 如果这个方块匹配一个给定要素a，返回真。 'a' 可以是: movement（移动）, light（光源，亮度）\nwool | id=reccomplex:generic_space | minecraft:stone\n匹配所有的羊毛，周围空间，和石头。\nsustains.trees & !id=grass\n匹配所有支撑树的方块，除了草方块。\nis.foliage | is.replaceable | is.air\n匹配所有空气，可替换的方块，和草蕨类。 (判定非地形方块时很有用)\nid=wool & !(property[color]=silver | property[color]=red)\n匹配所有的羊毛，除了那些银色和红色的。\n\n资源表达式（Resource Expression）用来匹配某些资源 (例如结构和物品生成器，这些资源应该被加载到游戏中) 。\n表达式类型：\n$a  domain=a - 如果资源符合某个域（domain）a，表达式返回真。 (a可以是一个modid). 如果该域不存在，可以不输入$ (例如structures文件夹下的资源)。a  id=a - 如果该资源符合某个特定id a，返回真。\nMeteorSite | id=AbandonedTower | SmallPyramid\n只匹配MeteorSite, AbandonedTower,和SmallPyramid结构 (这是白名单)。\n!MeteorSite & !AbandonedTower & !id=SmallPyramid\n匹配除MeteorSite, AbandonedTower, 和SmallPyramid之外所有的结构 (这是黑名单)。\n(domain=reccomplex | $) & !(MeteorSite | AbandonedTower)\n匹配所有由RECC添加，由用户制作的结构 - 除了MeteorSite和AbandonedTower之外.\n\n命令表达式（Command Expression）检测是否匹配一个命令。\n表达式类型：\n$a  name=a - 正在活动的玩家/方块有特定的名字a时，返回真。#a  canUseLevel:a - 正在活动的玩家/方块达到特定权限等级时，返回真。\nname=Ivorforce | canUseLevel:3\n只有Ivorforce和权限等级为3以上的玩家可以使用这个指令。\n!$Ivorforce & #3\n任何权限等级为3以上的玩家除了Ivorforce之外都可以使用这个指令。\n\n一个环境表达式（Environment Expression）用于匹配某一特定标准(例如生物群系，村庄类型等)。\n表达式类型：\n biome.a - a后面是一个生物群系表达式变量。 dimension.a或dim.a - a后面是一个维度表达式变量。 dependency.a或dep.a - a后面是一个依赖表达式变量。 villagetype=a或vtype=a - 如果环境是一个有特定类型的村庄，返回真，如果是=None，则匹配村庄之外的环境。 generation.a或gen.a  - a后面是一个结构生成信息表达式（生成信息表达式，Generation into expression）变量。\nbiome.name=Plains & dim.id=0 & villagetype=None\n只匹配主世界的平原群系，而且在村庄之外。\n(biome.type=Forest & dim.id=0) | (biome.type=Snowy & dim.id=-1)\n匹配主世界的森林类型群系，和地狱里的雪类型群系（**？）\n(vtype=0 | vtype=1) & dimension.id=0\n只匹配主世界的一般村庄和沙漠村庄。\n生成信息表达式可以检测生成信息是否合乎某些标准。\n表达式类型：\n id=a - 如果生成信息符合给定id a，返回真。 $a或 type=a - 如果生成信息的类型id符合给定id 'a'，返回真。\ntype=natural & !id=natural_4d36d9d1\n匹配所有'Natural'类型的生成信息，, 除了ID是natural_4d36d9d1的。\nIn Recurrent Complex, there are a bunch of registries that are referrable by the player - for example the structure registry or the item collection registry.  This expression determines if a registry matches the given criteria.\n在RECC当中，有些注册信息可供玩家参考——例如结构注册或者物品集合注册，这些表达式可以判定注册信息是否匹配给定的标准。\n\n表达式类型：\n has:a  #a - 如果该注册有入口 'a'的话，返回真。\nhas:MeteorSite 如果注册信息有入口MeteorSite，返回真。\n\nFiles Manage（文件管理，你需要在这里管理你的数据文件）：\n如果你有一组结构，想要它们生成在游戏中，将它们放在对应的文件夹中即可。基本的文件夹“structures”就在.minecraft主目录下，它包括着active、inactive、schematics这三个文件夹，启动游戏时会被加载，要重新加载，只需在游戏中输入/#reload指令。\nactive文件夹：结构，物品生成器和类似的资源放在这个文件夹，就会被加载，生成在世界中。\ninactive文件夹：结构，物品生成器和类似的资源放在这个文件夹，则不会被加载，也不能生成在世界中。\nschematics文件夹：示例文件可以使用/#exportschematic 指令导入，这些文件没有被注册，仅仅在输入指令时被读取。\n\nGuide：Building a Structure（建筑指导，你如何分享你的建筑作品）：\n如果你只是想建造并导出，备份，分享一个建筑结构，或者仅仅是为了测试，请看如下。\n注意，大小在32?以上的结构，需要一段时间来导入导出，如果你只想移动它们，考虑将它们分成小块。如果你不想使用RECC的其他功能，可以先阅读“将RECC作为辅助mod”部分。\n1.拿出一个方块选择器。\n2.右键选择结构的一个顶点，然后Ctrl+右键选择结构的另一顶点。\n3.使用/#export命令打开结构配置界面，你可能不想让它生成在世界中，这样你可以将保存地点设置在“Inactive”文件夹中。你也不需要调整这个结构，只需要输入一个文件名，点击保存就行了。\n\n你的结构现在已经出现在“active”或者“inactive”文件夹中任意一个，被RECC注册，你可以用“/#import+结构文件名”指令，将这个结构放在任何世界的任何地方。\n如果你想要建造一个更加复杂的结构，可以查看高级部分。\n\n\nGuide：Randomizing Chests（随机的箱子，在这里指定你的遗迹战利品）：\n当你生成一个结构时，任何箱子，或者说，任何有内部物品栏的实体数据（例如熔炉），都会保持它们当前所包含的物品，这不利于战利品的随机生成，RECC提供了一个简单的解决方式，可以查看“物品生成器”部分。\n一个完整的物品生成器包括了多个组成部分，这些部分用同一个“Group ID（组ID）”集合到一起。然后这些物品生成器在游戏中就将以“物品生成标签（Inventory Generation Tags）”的形式使用，当生成结构时，随机在里面的箱子里制定一些战利品。\n\n要新建一个物品生成器，请遵循如下步骤：\n1.拿到一个空的物品生成标签（名为“Create new Generator”），也可以编辑或复制已有的组件。\n2.将你想要生成在箱子里的物品放在你的物品栏里，你也可以使用其他的物品生成标签，随机生成或者修改它们的战利品。\n3.手持物品生成标签右击，将会打开一个界面。\n4.在最上面的输入框中输入ID（生成标签的名称），如果你只想修改原有的生成标签，保留原名就好了。\n5.在下面的输入框中输入组ID，如果你只对已经存在的生成标签修改，选择它的ID，而不是写个新的。\n6.点击“0 items”按钮，将物品放进弹出来的物品栏里，指定它们的权重（weight）和最小最大数量。\n7.点击保存，关闭界面，你现在可以将你的标签放进创造物品栏当中（不会消失），然后再拿出来。\n8.然后来到一个箱子或者其他任何有实体数据的容器前，将你希望使用的物品生成标签放进去。\n\n记住每一个物品生成标签都有自己的文件，如果你要分享自己的结构，你必须加上你的物品生成文件。\n\nStructure Configuration GUI（结构配置界面，在这里你可以了解如何在游戏中深度配置结构）：\n\n你可以在结构配置界面里编辑你的结构涉及到的参数——例如它生成在哪儿，生成的频率，以何种方式生成。注意，当你在界面里点击保存时，结构将会保存到相应的文件夹中（可参看“文件管理”部分），而且/#reload命令将会被调用。如果你想让这个结构自然生成在世界中，将其移动到“active”文件夹，然后运行/#reload命令即可。\n\n你会在界面中看到如下的要素，这里将一一解答： 名称（Name）: 唯一的标识符，不能有空格和特殊字符，建议使用简短且有辨识性的名称。 依赖（Dependencies）：在建造结构时用到的mod(也包括从物品生成标签中指定的)，如果该mod没有被加载，结构就不会生成。查看“表达式”下的“依赖表达式”部分可以了解。 标签，元数据（MetaData）: 结构本身的信息，例如作者信息和对结构的描述。 可旋转（Rotatable）: 决定结构是否可以旋转（前提是它足够简单）。你只有当确定这一选项不会把你的建筑物扭成一团麻花时才选择它。没有方向的方块，例如石头，草方块和栅栏，以及有朝向的简单方块，例如火把，箱子，楼梯之类方块都受支持，而另一些则可能不会——最简单的办法就是测试一下。\n 可镜像（Mirrorable）: 决定结构是否可以镜像，与“可旋转”相似，不过它的适用范围更窄，只能用于无方向的方块。 生成信息（Generation）: 该结构生成在世界中的方法清单，可以查看下面的部分（例如“自然生成”）。\n 变换器（Transformer）: 会影响到结构本身的生成。你一般不需要编辑这个，但还是应该检查一下里面的选项- 例如用柱子代替地板以支撑结构，你的设置应该尽可能符合这个建筑的风格。\nNatrual Generation（自然生成）\n使用这种生成方式，结构将在世界生成时“自然地”生成。\n 放置器（Placer）:决定结构生成的高度，可以查看高级部分中“放置器”部分。 生成类型（Generation Category）:点击这个按钮可以控制结构生成的频率（稀有度），一定程度上会影响结构的生成地区。 权重（Weight）: 在生成类型的影响下，生成结构的频率，权重越高，生成几率越大。 群系（Biomes）: 指定结构生成的群系，或者群系的类型。如何添加群系可以查看“群系表达式”部分，可以随意从你喜欢的模组中选择生物群系，你的结构将安全地生成在其中。\n使用命令/#biomedict 以获取你当前所有的群系类型。\n 维度（Dimensions）: 指定结构生成的维度，或者维度的类型。如何指定可以查看“维度表达式”部分。可以随意从你喜欢的模组中选择维度，你的结构将安全地生成在其中。\n使用命令/#dimensiondict 以获取你当前所有的群系类型。\n Maze Generation（迷宫生成）\n使用这种生成方式，你的结构将会成为一个迷宫的一部分，也可以查看高级部分的“迷宫建造指导”部分。\n迷宫名称（Maze ID）: 在这里指定迷宫的名称，必须匹配“迷宫生成器”的ID。 权重（Weight）: 在这里指定这一部分（你选择的结构）生成的几率，几率越高，你的结构在迷宫中生成的数量也就越多。出口（Exits）: 这一参数将决定你的结构有几条出口，可以通向迷宫的其他部分，这些出口坐标在房间中计数，作为迷宫的一部分信息而存在，“连通器”决定了这些出口将如何连接到其他部分的出口(例如， 'PathX' 只会连通到 'PathX', 'Male（雄房间）:PathY' 只会连通到 'Female（雌）:PathY').房间（Rooms）:你的迷宫当然不会只有你选择的结构体，而是会有房间分割与连通它们。举例：这个迷宫的房间基础大小是3*4*3，那么你所有的房间长宽高就只能是（3，4,3）这个基础的整数倍；如果你的结构体是9*4*12 ，那么你的房间大小将不能超过结构体的大小。如果你有尺寸特殊的房间，假设你的结构体不连通到那里，你可以用负数（subtractive）范围。\n Static Generation（静态生成）\n使用这种生成方式，在给定的坐标一定会生成指定的结构。\n\n Placer（放置器）: 决定结构生成的高度，可以查看高级部分中“生成器”部分。 At Spawn（在出生点）: 指定的坐标是否在出生点。如果你想要你的结构生成在出生点，将其设置为true，如果你只想生成在某个坐标例如[500, 300]，将其设置为false。 Dimensions（维度）:用维度表达式（详见“表达式”部分）决定生成结构的坐标在哪个世界。\n Structure List Generation（结构列表生成）： \n\n使用这种生成方法，结构将成为一系列结构中的一部分生成。\n List ID（列表名称）:你的结构从属的列表名字。必须匹配“结构生成器”的ID。 Weight（权重）:在生成时选中此结构的概率。权重越高，该列表中生成此结构的概率也越高。 Front（前面）: 指定结构的前面。 这一参数将决定结构的旋转方向，以配置结构方块生成的位置。(注意：你首先要将这个结构设置为可旋转（rotatable）的，否则这一项无法选择)\n 原版结构生成        使用这种生成方式，结构将作为原版MC结构的一部分生成，例如生成在村庄里。\n 权重: 你所指定的结构在原版结构中的生成概率。权重越高，该结构在原版结构的生成概率也就越高。 基础限制: 你所指定的结构在原版结构中尝试生成的次数，在两个值之间随机选择。比例限制: 你所指定的结构在原版结构中尝试生成的次数，在两个值之间随机选择，但会受原版结构的大小所影响。 前面: 指定结构的前面，这一参数将决定结构的旋转方向，以配置结构方块生成的位置。 (注意：你首先要将这个结构设置为可旋转（rotatable）的，否则这一项无法选择).偏移: 配置结构沿轴线（xyz）移动的距离，例如你可以配置此参数让结构生成在村庄的草径上。生物群系: 决定结构生成的群系或群系类型。你可以使用“生物群系表达式”来控制这一项。支持来自mod的生物群系类型，你可以更好地控制结构的生成。\n想查看群系有什么样的群系类型？使用/#biomedict指令吧。\n\n\nStructures File（结构文件，你可以在这里了解结构被保存在哪里）\n\n结构被保存在结构文件当中，文件扩展名是.rcst。\n.rcst其实是变种的zip，可以用压缩软件打开，里面的两个文件代表了结构数据的不同方面：\nstructure.json：包括了所有的结构生成标签（metadata），可以对应到“结构配置界面”里面你保存的设置。\nworlddata.nbt：包括了实际的结构数据。你可以将它和schematic文件进行比较，虽然它们的保存形式不同，但是有着相似的数据类型。\n你可以查看相应的源码以获得这个文件类型的更多数据，这个mod及其前置采用Apache 2.0许可证开源。\n\nUsing RECC as a utility（将RECC作为一个辅助mod）\n\n有的时候，你只想将RECC作为一个辅助性自定义的mod（例如将其作为游戏内的世界编辑器，或者将其作为mod前置，又或是分享建筑存档，等等），而不想让它对游戏本身产生什么影响（例如生成结构），这个时候你可以参考“添加与禁用建筑结构”部分，以移除RECC的结构。\n如果你想在只在服务端使用这个mod，而不需要在客户端安装它，可以启用“轻量模式（Lightweight Mode）”，这会阻止该mod向游戏内添加物品与方块，但其他的功能会被保留。\n按如下步骤启用轻量模式：\n运行一次游戏，使mod生成配置文件；\n删除世界，以重置物品和方块id（这一步其实是多余）；\n找到config/reccomplex.cfg文件，打开这个配置文件；\n将“lightweightMode=false”改成“lightweightMode=true”即可。\n\n\n现在进入高级部分。\n\n指导：如何平衡资源？如果你在做整合包，你可能需要调整结构里生成的宝藏，以符合你的整合包需求。这一部分将教你如何平衡RECC带来的资源。\n\n如果你发现结构中生成了一个你不想看到的方块，有几种方法将它从结构中移除：\n方法1：使用通用变换器。\n如果你设置一个通用变换器，就可以指定你不想要的方块类型不要生成在结构中，而不需要特意编辑结构本身：\n首先，在一个结构上输入/#edit命令，打开它的配置界面。你可能不想保存这个结构，所以你不需要关心结构是什么，只需要点击按钮（Transfomers），打开一个变换器界面就可以。\n\n在界面的顶部，点击带左右箭头的按钮，直到你找到预设的“none”变换器，点击旁边的按钮以应用它。然后点击旁边的按钮，自定义预设的变换器——你已经获得了一个空的待编辑的通用变换器。\n\n界面中还有一个带绿色加号和箭头的按钮，这就是“添加变换器”按钮了。点击箭头按钮，找到“取代变换器”，点击鼠标滚轮添加它。在新添加的“取代变换器”中，点击“编辑”按钮编辑它。\n取代变换器将会尝试匹配所有在“源（source）”表达式中的方块，并将其替换为“目标（destinations）”中的随机一个方块。在“源（source）”文本框里，输入一个方块表达式以匹配你想要替换的方块（例如“enchanting table/obsidian”），点击编辑目标，确定有预设的“空气（Air）”。（原理同上，但是你不需要点击后面的“Customize”）。\n然后就可以返回了。\n\n如果你想的话，你也可以编辑变换器的其他情况，这会限制例如特殊的建筑，群系或维度，可以查看“环境表达式”获得更多信息。\n\n点击preset（预设）旁边的+号按钮，将你当前的变换器保存成一个新的预设。你可以赋予它一个id，一个名字和一个你喜欢的描述，点击保存，如果你不想保存调整后的结构就点取消。预设会被保存在structures/active文件夹下，并添加rcmt扩展名，你现在可以在配置中的“通用变换器”选项中使用保存后的变换器了。\n\n Setting up the transformer as a universal transformer. EditEnter the game, click Mods -> Recurrent Complex -> Config and find the universalTransformer option. Add your new transformer to it using the ID.  You are now done setting up your universal transformer!\n Approach: Editing the structures EditA simpler, but less powerful approach is editing the structures specifically, overriding the version provided by the mod. This means that if Recurrent Complex makes changes to the structure afterwards, and you want to benefit from the changes, you need to edit the structure again using this method. In return, it's a lot simpler.\nUse /#whatisthis or /#containing to find the name of the structure you want to edit. Use /#import TheStructure to import the structure, make your changes (e.g. with /#replace air 0 enchanting_table | obsidian), select the structure again, and use /#export TheStructure to save it again. \nA quicker approach is using /#map (e.g. /#map TheStructure ACTIVE #replace air 0 enchanting_table | obsidian). With this command you don't need to import or export the structure at all. \n Approach: Disabling the structures EditProbably the simplest approach, you can just disable the structures you don't want. See Disabling Structures.\n Removing Items EditSometimes, chests (or other inventories) can contain items you don't like upon generation.\nWhenever you find one, you want to edit the inventory generator ('loot table') associated with it.\nUse /#whatisthis to find the name of the structure. Use Command:import TheStructure to import the structure, and open the chests to find the used inventory generator.\nIn the creative menu, find the corresponding inventory generation component (usually the same name), and right click to edit it. Here you can simply adjust the items as you need.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n[groupid=128]HAYO Studio[/groupid]",
    "replies": [
        {
            "author": "世界老骨灰",
            "timestamp": 1528873320,
            "txt_content": "我一直等"
        },
        {
            "author": "manson",
            "timestamp": 1534999020,
            "txt_content": "超赞的好贴，一直在研究这个mod！"
        }
    ]
}