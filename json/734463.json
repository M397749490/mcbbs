{
    "title": "[编程]CustomBattle —— 让开发者轻松制作属于自己的小游戏竞技场！[全版本]",
    "author": "12345559",
    "replyCount": 1,
    "timestamp": 1509281880,
    "txt_content": " 1.插件介绍 CustomBattle 是一个前置API插件，只能针对开发者使用。\n（下文简称CUSB）\n这个插件类似于给你提供了竞技场自带的内容，\n你在开发的时候只需要直接调用监听器和API内，\n对你的开发进展速度有显著帮助。\n\n注意！如果你的服务器安装了CUSB，\n但是没有安装任何其他的附属插件，\n那么插件是不会有任何作用的。\n\n（至少我再也不用担心为开发的时候为那些大厅和房间而担心了） 2.插件指令和权限 /cusb help 查看指令说明\n/cusb create <竞技场名字-必须是一个世界名字> <竞技场类型> <...> 这个插件和其他竞技场插件有很大差别。你的竞技场名字必须是世界名字，并且竞技场建造后你不能选择区域，而是直接将整个世界划分为一个竞技场。\n/cusb delete <竞技场名字> 删除一个竞技场\n/cusb list 查阅竞技场列表\n/cusb join <竞技场名字> 加入某个竞技场进行游戏。\n/cusb leave 离开你当前所在的竞技场。\n\nCustomBattle.use 用户玩家使用权利\nCustomBattle.admin 管理员创建和管理竞技场的权利 3.插件API使用方法 插件自身带有JavaDoc，\n只需要下载整个压缩包，即可找到JavaDoc。\n我自己也是刚刚摸索，也不太熟悉。\n但是看了一下示范代码，的确做起来很简单。\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage com.mcml.space;\n\nimport com.mcml.space.EventAPI.*;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.entity.PlayerDeathEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\n/**\n *\n * 本插件仅做示范，如何使用CUSB!插件来开发你自己的小游戏竞技场或其他游戏\n * 实际上本插件玩法和使用方法需要使用者自己规划来使用，游戏模式也是自己制定。\n * 如果你对本插件有任何建议或者BUG反馈，随时找乐乐：QQ1207223090.\n */\npublic class OwnDeathMatch extends JavaPlugin implements Listener {\n\n    private HashMap<Player, Integer> KillCount = new HashMap();\n\n    @Override\n    public void onEnable() {\n        Bukkit.getPluginManager().registerEvents(this, this);\n        this.getLogger().info(\"[CUSB-CustomBattle]个人死斗模式——示范插件\");\n        this.getLogger().info(\"本插件为 CustonBattle 插件的使用示范附属插件。\");\n    }\n\n    @EventHandler\n    public void Creater(CusBArenaCreateEvent event) { //为了演示简洁，只演示一个竞技场的时候的情况，因此只采用了一个杀人计数器，禁止多个竞技场创建的示范\n        List<Arena> arenas = CUSB.getLoadedArenas();\n        CommandSender sender = event.getSender();\n        for (int i = 0; i < arenas.size(); i++) {\n            Arena arena = arenas.get(i);\n            if (arena.getArenaType().equalsIgnoreCase(\"owndeathmatch\")) {\n                sender.sendMessage(\"真对不起！为了演示插件的简洁，个人死斗模式竞技场只能创建一个！\");\n                event.setCancelled(true);\n                return;\n            }\n        }\n        event.setAutoReset(true); //是否当游戏结束的时候还原整个世界场地？\n        sender.sendMessage(\"§a个人死斗竞技场创建成功！\");\n    }\n\n    @EventHandler\n    public void Joiner(CusBPlayerJoinArenaEvent event) { //当玩家加入一个竞技场的时候\n        Player player = event.getPlayer();\n        Arena arena = event.getArena();\n        if (arena.getArenaType().equalsIgnoreCase(\"owndeathmatch\")) { //如果这个竞技场是个人死斗类型的\n            if (arena.getArenaState() != ArenaState.InLobby) {\n                player.sendMessage(\"真对不起，游戏不能进去玩！\");\n                return;\n            }\n            Location sl = arena.getWorld().getSpawnLocation(); //假设这里是玩家等待大厅的坐标\n            player.teleport(sl);\n            List<Player> players = arena.getPlayers();\n            Iterator<Player> it = players.iterator();\n            if (players.size() >= 3) { //实际上这个监听器会触发在玩家进入大厅之前，所以实际上真正的在大厅玩家会少一个人，所以当人数到达3个的时候视为4个看待\n                while (it.hasNext()) {\n                    Player thisplayer = it.next();\n                    thisplayer.sendMessage(\"游戏人数到达4人！游戏开始！\");\n                    arena.setArenaState(ArenaState.InGame); //设置游戏开始状态\n                    Location spawnLocation2 = arena.getWorld().getSpawnLocation(); //假设这里是出生点（你可以自己写将玩家随机传送到地点）\n                    thisplayer.teleport(spawnLocation2);\n                }\n            } else {\n                while (it.hasNext()) {\n                    Player thisplayer = it.next();\n                    thisplayer.sendMessage(\"游戏人数 §a\" + players.size() + \"/4\");\n                }\n            }\n        }\n    }\n\n    @EventHandler\n    public void onKill(PlayerDeathEvent event) { //当玩家死的时候进行计数，记录杀敌数\n        Player killer = event.getEntity().getKiller();\n        if (killer == null && CUSB.getPlayerWhichArenaIn(killer) == null) {\n            return;\n        }\n        Arena arena = CUSB.getPlayerWhichArenaIn(killer);\n        if (arena.getArenaType().equalsIgnoreCase(\"owndeathmatch\") == false) {\n            return;\n        }\n        if (KillCount.get(killer) == null) {\n            KillCount.put(killer, 0);\n        }\n        KillCount.put(killer, KillCount.get(killer) + 1);\n        List<Player> players = arena.getPlayers();\n        Iterator<Player> it = players.iterator();\n        if (KillCount.get(killer) >= 10) {\n            arena.setArenaState(ArenaState.InLobby);\n            while (it.hasNext()) {\n                Player thisplayer = it.next();\n                thisplayer.sendMessage(\"游戏结束！\" + killer.getName() + \"击杀10个人，他赢了！\");\n                thisplayer.teleport(Bukkit.getWorld(\"world_the_end\").getSpawnLocation()); //假设回到了主城\n            }\n            arena.removeAllPlayers();\n        } else {\n            while (it.hasNext()) {\n                Player thisplayer = it.next();\n                thisplayer.sendMessage(\"击杀消息：\" + killer.getName() + \"杀了\" + event.getEntity().getName() + \",该玩家剩余杀敌数\" + (10-KillCount.get(killer)));\n            }\n        }\n    }\n}\n复制代码这是原帖带的（下载内也有）的示范代码，的确很简单。 4.下载地址下载地址为站外 后记：\n尽管乐乐的抄袭行为对圈内造成了负面影响，但是这份作品的品质的确是很不错的。\n因此对本插件进行了转载，并且根据原帖说明：无需申请转载授权和复制转载。\n\n\n\n\n授权.png (7.84 KB, 下载次数: 0)\n\n下载附件\n\n2017-10-29 20:53 上传\n\n\n\n\n\n",
    "replies": [
        {
            "author": "1850343382",
            "timestamp": 1509284040,
            "txt_content": "前排支持"
        }
    ]
}