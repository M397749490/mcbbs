{
    "title": "java 新手问题",
    "author": "spad",
    "replyCount": 4,
    "timestamp": 1588489620,
    "txt_content": " 本帖最后由 spad 于 2020-5-3 15:40 编辑 \n\n这帖子编辑器太难用了 等我编辑一下...\n\nbukkit官方API 有下面这段代码\npublic interface CommandSender extends Permissible {\n  void sendMessage(@NotNull String paramString);\n  \n  void sendMessage(@NotNull String[] paramArrayOfString);\n  \n  @NotNull\n  Server getServer();\n  \n  @NotNull\n  String getName();\n  \n  @NotNull\n  Spigot spigot();\n  \n  public static class Spigot {\n    public void sendMessage(@NotNull BaseComponent component) {\n      throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n    \n    public void sendMessage(@NotNull BaseComponent... components) {\n      throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n  }\n}复制代码这个接口里面有 getServer() 这个方法\n然后Spigot官方javadoc 里面说这个方法 会返回一个Server 对象\n请问一下具体是怎麽调用的?\n我在想 是不是某一个类实现了这个方法    public Server getServer() {\n        this.server = server\n        return server\n    }复制代码所以可以这样玩 因为 getServer 会返回一个server 对象然后再从这个对象里面调用 getPlayer 这个方法\nPlayer target = sender.getServer().getPlayer(args[0]);复制代码\n具体为什磨要这样子调用 应该是因为玩家对象只有一个\n所以当我们要对玩家进行操作时 也必须针对这个对象进行操作\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "南柯郡守",
            "timestamp": 1588491480,
            "txt_content": " 本帖最后由 南柯郡守 于 2020-5-3 15:45 编辑 \n\n不是很明白你想表达什么 \n用法比如说   \nCommandSender sender;\nServer server = sender.getServer();\nPlayer player = server.getPlayer(\"playername\");\nplayer.sendMessage(\"message send success\");复制代码\n这三行连起来就是\nsender.getServer().getPlayer(\"playername\").sendMessage(\"message send success\");复制代码\n\n看完你最新编辑结果之后我更懵了"
        },
        {
            "author": "spad",
            "timestamp": 1588492500,
            "txt_content": "南柯郡守 发表于 2020-5-3 15:38\n不是很明白你想表达什么 \n用法比如说   \n就是不明白为什麽 能这麽调\n\nCommandSender 应该是一个接口\n为什麽不是 实现类 sender 而是 CommandSender sender\n\n然后 CommandSender 的 方法我在api里看 里面并没有方法体\n\n抱歉 我真的很菜\n\npublic interface CommandSender extends Permissible {\n  void sendMessage(@NotNull String paramString);\n  \n  void sendMessage(@NotNull String[] paramArrayOfString);\n  \n  @NotNull\n  Server getServer();\n  \n  @NotNull\n  String getName();\n  \n  @NotNull\n  Spigot spigot();\n  \n  public static class Spigot {\n    public void sendMessage(@NotNull BaseComponent component) {\n      throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n    \n    public void sendMessage(@NotNull BaseComponent... components) {\n      throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n  }\n}复制代码\n"
        },
        {
            "author": "南柯郡守",
            "timestamp": 1588494480,
            "txt_content": "spad 发表于 2020-5-3 15:55\n就是不明白为什麽 能这麽调\n\nCommandSender 应该是一个接口\n因为有类实现了这个接口\n\n然后我们可以通过这个接口使用那个实现了这个接口的类的方法\n\n比如网络\n\n我连接到了一个叫做Sender的服务器(所谓的接口)\n那么你可以通过这个叫做Sender的服务器  来查看、使用我电脑上的文件、应用等\n大概是这一意思 可能我的理解也有偏差 \n\n更详细的内容需要百度  java 接口"
        },
        {
            "author": "William_Shi",
            "timestamp": 1588500420,
            "txt_content": " 本帖最后由 William_Shi 于 2020-5-3 18:11 编辑 \nspad 发表于 2020-5-3 15:55\n就是不明白为什麽 能这麽调\n\nCommandSender 应该是一个接口\n你可以看看org.bukkit.plugin.PluginManager类\npublic interface PluginManager {\n  void registerInterface(@NotNull Class<? extends PluginLoader> paramClass) throws IllegalArgumentException;\n  \n  @Nullable\n  Plugin getPlugin(@NotNull String paramString);\n  \n  @NotNull\n  Plugin[ getPlugins();\n  \n  boolean isPluginEnabled(@NotNull String paramString);\n  \n  @Contract(\"null -> false\")\n  boolean isPluginEnabled(@Nullable Plugin paramPlugin);\n  \n  @Nullable\n  Plugin loadPlugin(@NotNull File paramFile) throws InvalidPluginException, InvalidDescriptionException, UnknownDependencyException;\n  \n  @NotNull\n  Plugin[ loadPlugins(@NotNull File paramFile);\n  \n  void disablePlugins();\n  \n  void clearPlugins();\n  \n  void callEvent(@NotNull Event paramEvent) throws IllegalStateException;\n  \n  void registerEvents(@NotNull Listener paramListener, @NotNull Plugin paramPlugin);\n  \n  void registerEvent(@NotNull Class<? extends Event> paramClass, @NotNull Listener paramListener, @NotNull EventPriority paramEventPriority, @NotNull EventExecutor paramEventExecutor, @NotNull Plugin paramPlugin);\n  \n  void registerEvent(@NotNull Class<? extends Event> paramClass, @NotNull Listener paramListener, @NotNull EventPriority paramEventPriority, @NotNull EventExecutor paramEventExecutor, @NotNull Plugin paramPlugin, boolean paramBoolean);\n  \n  void enablePlugin(@NotNull Plugin paramPlugin);\n  \n  void disablePlugin(@NotNull Plugin paramPlugin);\n  \n  @Nullable\n  Permission getPermission(@NotNull String paramString);\n  \n  void addPermission(@NotNull Permission paramPermission);\n  \n  void removePermission(@NotNull Permission paramPermission);\n  \n  void removePermission(@NotNull String paramString);\n  \n  @NotNull\n  Set<Permission> getDefaultPermissions(boolean paramBoolean);\n  \n  void recalculatePermissionDefaults(@NotNull Permission paramPermission);\n  \n  void subscribeToPermission(@NotNull String paramString, @NotNull Permissible paramPermissible);\n  \n  void unsubscribeFromPermission(@NotNull String paramString, @NotNull Permissible paramPermissible);\n  \n  @NotNull\n  Set<Permissible> getPermissionSubscriptions(@NotNull String paramString);\n  \n  void subscribeToDefaultPerms(boolean paramBoolean, @NotNull Permissible paramPermissible);\n  \n  void unsubscribeFromDefaultPerms(boolean paramBoolean, @NotNull Permissible paramPermissible);\n  \n  @NotNull\n  Set<Permissible> getDefaultPermSubscriptions(boolean paramBoolean);\n  \n  @NotNull\n  Set<Permission> getPermissions();\n  \n  boolean useTimings();\n}\n\n是不是和你现在看到的类似？没有任何方法体？\n原因很简单，这玩意是一个super接口，其功能有待SimplePluginManager类实现\n\nSimplePluginManager具体代码可以自行反编译查看\n换句话说，SimplePluginManager该实现什么，在这里预先规定了一部分\n（具体请看java多态相关教程）\n然后再使用JavaRTTI来调用有关方法\n（RTTI是什么自行百度）\n这就是为什么可以直接使用PluginManager的方法来注册事件监听\n你的这个也是同理\nCommandSender一定是被某个接口/类实现了的\n比如说玩家（当然肯定不止是玩家）\n\n\npublic interface Player extends HumanEntity, Conversable, OfflinePlayer, PluginMessageRecipient\n\n\n玩家继承HumanEntity\n\n接口 HumanEntity所有超级接口:AnimalTamer, Attributable, CommandSender, Damageable, Entity, InventoryHolder, LivingEntity, Metadatable, Nameable, Permissible, PersistentDataHolder, ProjectileSource, ServerOperator\n\n\nHumanEntity的super接口又包括了CommandSender\n\n继承关系就是这么来的\n\n\n"
        }
    ]
}