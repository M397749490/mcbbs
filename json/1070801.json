{
    "title": "真正的从零基础学Bukkit开发！——四.Java的数据集合，forEach",
    "author": "贺兰兰",
    "replyCount": 7,
    "timestamp": 1593612000,
    "txt_content": " 本帖最后由 贺兰星辰 于 2020-7-8 00:23 编辑 \n\n真正的从零基础学Bukkit开发！——四.Java的数据集合，forEach\n\n\n上一章: https://www.mcbbs.net/thread-1015705-1-1.html\n\n\n首先祝土球生日快乐!(是不是晚了咳咳)\n其次，Markdown是个好东西\n上节作业:\n1.懒得写了2333\n\n\n2.静态获取主类实例\npublic class MyClass extends JavaPlugin{\n\n\n  //声明静态插件主类实例变量(此时instance为null，不能使用)\n  private static MyClass instance;\n\n\n  @Override\n  public void onEnable(){\n    //插件启用时将主类实例赋值到instance上(此时instance才真正是MyClass的实例)\n    instance = this;\n  }\n\n\n  //声明getInstance方法以获取私有的实例对象变量\n  public static MyClass getInstance(){\n    //返回instance变量\n    return instance;\n  }\n}\n之后，你便可以在任意地方使用MyClass.getInstance()获取主类实例\n\n\nTips:\nQ:为什么要把instance声明为private，然后使用getInstance方法获取instance变量?\nA:你当然可以把instance声明为public然后调用MyClass.instance获取主类实例，但是这样会有一个安全性问题:变量instance可以被在任意位置随意被重新赋值(你也不可以把变量instance设置为final，因为如果那样的话instance必须在主类对象被初始化时就被赋值，而不是在执行onEnable时)\n\n\n数组\n那么我们接下来来认识一下Java的数据存储\n众所周知，我们可以通过如下方式声明一个整形变量int来存储一个整数\nint a = 1;\n但是，当我们需要存储一堆这样的整数时，难道我们需要声明一堆这样的int变量吗?\n答案是当然不需要，我们可以创建一个数组来解决这个问题\n要想创建数组，你应该使用如下的格式:\nint[] array = new int[number];\n由于数组是大小不可变的，因此，在初始化数组时，你必须指定数组大小，即填写number值。\n如\nint[] array = new int[3];\n创建了一个大小为3的int数组\n此后，我们便可为此数组赋值，如\narray[0] = 1;\narray[1] = 2;\narray[2] = 3;\n将会将数组array({0,0,0})填充为array({1,2,3})\nTips:在Java中，基本数据类型及其未初始化值不能为null，因此，此处未定义数值的int[]数组内的三个int值初始值均为0，而不是null\n反过来，我们也可以直接通过array[number]访问数组内存储的数据，如\nint a = array[2];\n将a赋值为3\n*Tips:在Java中，数组(也包括List)的索引值(index)是从0开始计算而不是从1开始的，即array[0]指的是array数组中的第一个值(如果指定的索引值过大(即超出数组大小)或过小(如-1)则会抛出ArrayIndexOutOfBoundsException(数组下标越界异常)*-\n如果你希望在声明数组的时候就填充数组内值，那么你可以用一种简单的方法声明数组:\nint[] array = {1,2,3};\nTips:因为创建数组时数组的大小已经确定了，所以你不需要在[]内填写数组大小，编译器会自动判断\n上例中，我们使用\nint[] array;\n以声明数组\n但其实Java支持C语言风格的数组创建方式，即\nint array[];\nTips:虽然叫做数组，但是任何对象和基本数据类型都可以成为数组，如\nboolean[] boolArray = {true,false};\nItemStack[] itemStackArray = new ItemStack[3];\n\n\n多维数组\nHey，也许你已经想到了，既然我们能创建数组，那是不是意味着我们可以为数组创建数组?\n答案是可以，你可以通过这样的方式得到一个二维数组\nint[][] array = {{1,2},{2,3}};\n(使用new操作符创建这个数组的方式是\nint[][] array = new int[][];\n)\n然后\nint a = int[0][1];\n将a赋值为2\nTips:在Java中不存在所谓二维数组，其实是数组里套了一个数组，这点要谨记)(因为这意味着当你使用for,forEach,迭代器遍历这个数组时，你遍历一遍外层的数组，得到了一堆内层的数组(而不是直接得到所有数组)，通常情况下，你需要嵌套遍历才能达到目标)\n\n\nJava的数据集合\nJava有多种数据存储方式，他们大致分为List,Map,Set等，此处我们仅介绍ArrayList和LinkedHashMap，更多有关Java数据集合的内容请见:\n菜鸟教程\n\n\nArrayList\n\nArrayList 继承于 List 继承于 Collection 实现了 Iterator\nArratList 是 长度可变的\nArrayList 是 有序的\nArrayList 支持 迭代器\nArrayList 支持 增强式For循环(Foreach)\nArrayList 支持 使用Lambda表达式 遍历\nArrayList 使用 泛型 创建对象实例\nArrayList 使用 索引值(Index)获取内容\n\n\nHey，还记得我们刚刚学的数组吗，数组有一个缺点，那就是长度不可变，这为我们存储未知数量的一堆对象造成了困难。因此，我们可以使用ArrayList存储数组并读取内容\n使用以下方式创建一个存储布尔值(boolean)的ArrayList:\nArrayList<Boolean> boolArray = new ArrayList<>();\n因为ArrayList继承于List，因此这样的写法也是允许的:\nList<Boolean> boolArray = new ArrayList<>();\n注意，List是一个接口，这意味着你不能直接初始化一个List对象，如\nList<Boolean> boolArray = new List<>();\nTips:\n1.那个尖括号是怎么回事\nArrayList是一个泛型对象，泛型允许我们向对象指定需要传入的自定义对象类型，通过在尖括号内填写对象名称来创建一个指定的泛型对象。此处ArrayList<Boolean>声明了一个能够存储布尔值的ArrayList\n2.Boolean是怎么回事\nBoolean和boolean有本质的区别，boolean是一个Java基本数据类型，而Boolean是boolean的装箱对象，属于对象，而不是基本数据类型(还记得吗，泛型只能传入一个对象，而不是一个基本数据类型)，我们把某个基本数据类型转为对象的方式叫作装箱，反过来叫做拆箱。不过不用担心，在大部分情况下，Java都支持自动拆箱装箱而不需要你手动这么做(你完全可以把Boolean当boolean用)。\n对于其他基本数据类型，他们的装箱对象大都是其关键字的首字母大写，如long->Long，double->Double；int有些特殊，他的装箱对象名是其全称，Integer。\n3.泛型的钻石型写法\n事实上，上面的ArrayList声明是一个简写版的，其完整版应当是\nArrayList<Boolean> boolArray = new ArrayList<Boolean>();\n但是，自JDK1.7开始，Java引入了钻石型写法，这允许你省略后面那个尖括号里的对象，编译器会自动帮你判断。\n\n\n你可以通过执行如下方法向ArrayList中放入Boolean对象:\nboolArray.add(true);\n\n\n然后可以通过索引值获取\nboolean a = boolArray.get(0);\na将被赋值为true\n\n\n你可以使用如下方法判断指定List内是否含有指定对象(返回一个布尔值)\nboolArray.contains(true);\n很显然boolMap里有true，因此将返回true;\n\n\n是不是很方便?\nTips:当然，除了ArrayList，还有LinkedList等其他List，在这里就不多赘述了\n\n\nLinkedHashMap\nLinkedHashMap 继承于 Map 继承于 Collection\nLinkedHashMap 是 有序的\nLinkedHashMap 支持 增强式For循环(Foreach)\nLinkedHashMap 支持 使用Lambda表达式 遍历\nLinkedHashMap 使用 泛型 创建对象实例\nLinkedHashMap 使用 Key 获取 Value\n如果你开MC服务器，那么你一定见过各种各样的YAML格式文件，他们一般都由.yml文件后缀结尾(当然也有特殊的，比如Dynmap的Configuration.txt)\n那么来看如下一个YAML数据\nEnablePlugin: true\nEnableDebugMode: false\n很显然我们能够看到，EnablePlugin对应的值是true，而EnableDebugMode对应的值是false。而这种以键(Key)-值(Value)对的对应关系存储数据的形式在Java中便称为Map\n你可以使用如下方式创建一个使用String读取存储的布尔值的LinkedHashMap:\nLinkedHashMap<String,Boolean> boolMap = new LinkedHashMap<>();\n因为LinkedHashMap继承于Map，因此这样的写法也是允许的:\nMap<String,Boolean> boolMap = new LinkedHashMap<>();\n同样，Map也是一个接口，你也不能尝试直接初始化一个Map\n\n\n你可以通过如下方法向该Map写入一个键值对:\nboolMap.put(\"EnablePlugin\",true);\n\n\n然后，使用键来获取值\nboolean a = boolMap.get(\"EnablePlugin\");\na将被赋值为true\n\n\n你可以使用如下方法判断指定Map内是否含有一个键(返回一个布尔值)\nboolMap.containsKey(\"hello?\");\n很显然boolMap里没有\"hello?\"键，因此将返回false;\n\n\n你可以使用如下方法判断指定Map内是否含有一个值(返回...一个布尔值)\nboolMap.containsValue(true);\n很显然，值true存在于boolMap中，因此将返回true\n\n\n特殊的，你可以通过使用\nSet<String> set = boolMap.keySet();\n来获取一个包含所有key的Set(简单来说，Set其实就是一个内容不可重复的List)\n你可以通过如下方法生成一个包含keySet内容的ArrayList\nArrayList<String> list = new ArrayList<>(set);\n\n\nTips:Key是不可重复的，尝试put一个相同的Key会覆盖掉原来的Key对应的Value;而不同Key对应的Value是可重的\n\n\nTips:当然，除了LinkedHashMap，还有HashMap等其他Map，在这里就不多赘述了\n\n\n增强式For循环(Foreach)\n我们已经知道了For循环，这意味着，你可以通过如下方式遍历整个ArrayList中存储的所有值:\n//boolArray.length将返回一个int值，表明当前ArrayList的长度(就是存储了几个数字)\nfor(int i = 0; i<boolArray.length; i++){\n//这里即每一次遍历到的数据\nboolean a = boolArray.get(i);\n}\n这样是不是有一些麻烦?\n于是，我们可以使用一种更简单的语法创建这样的遍历\nfor(boolean a : boolArray){\n//使用a处理每一次遍历到的数据\n}\n是不是简单太多了?\n同样，对于Map，我们可以这么写\nfor(String k : boolMap.keySet){\n//使用k处理每一次遍历到的key\n//通过key获取对应的value进行处理\nboolean v = boolean.get(a);\n}\n特殊的基于Lambda表达式的forEach\n我们可以通过函数式表达式Lambda(JDK1.8特性，即在一个函数(Java叫方法)内使用代码处理数据)极其方便的遍历数据\n在List使用Lambda表达式进行forEach的方法如下\nboolArray.forEach((a) -> {\n//a即为每一次遍历到的数据\n});\n在Map使用Lambda表达式进行forEach的方法如下\nboolMap.forEach((k,v) -> {\n//k即为每一次遍历到的键，v即为键对应的值\n});\n注意，基于Lambda表达式的forEach仅能在对象提供了类似forEach的方法时才能使用，且Foreach均不支持break和continue关键字。\n\n\n\n\n使用迭代器:\n什么是迭代器?\n迭代器是一个对象，他可以将实现了Iterator接口的存储器(如ArrayList)的全部数据通过next()方法一个一个遍历出来，直到获取到末尾\nIterator<Boolean> iterator = boolArray.iterator();\n//如果迭代器内数据集合有下一个值(即未到末尾)\nwhile(iterator.hasNext()){\n//获取这个值\nboolean a = iterator.next();\n}\nTips:如果当迭代器已经遍历完成所有值(hasNext方法会返回false），那么当你再次使用next方法时，Java会抛出一个异常）\nHey，你可能已经发现了，和ForEach不同的是，迭代器的使用可以是不连续的，你可以在需要使用下一个数据的时候调用一下next，然后进行相对的处理，因此:\n谨防迭代器失效: 当你使用迭代器时，你不能修改迭代器所绑定的那个集合，或者容器的状态（比如添加和删除元素），这会导致迭代器失效，无法正常使用。如果你需要在迭代器使用过程中删除元素，那么也许你可以使用Iterator#remove()移除当前next()所获取到的那一个元素\n非线程安全:因为上述原因，千万不要多线程的使用迭代器，这同样会导致迭代器失效（例外的是，在多线程情况下只读迭代器是安全的）\n\n\n实战:写一个基于1.16的随机颜色聊天字符插件\n成品:MCBBS | Github | Open Source Under MIT License\n众所周知，自1.16起，Minecraft聊天栏支持RGB色彩而不是仅仅只有以前那16种颜色\n因此，我们或许可以做一个插件，当玩家输入指令启用该功能时，发送的消息将会是随机上色的!\n\n\n如何生成彩色字?\n首先，MC使用RGB Hex格式定义颜色，如#000000为黑色，#FFFFFF为白色\n,在MC中输入彩色字的格式是\n§x§R§R§G§G§B§B\n如天依蓝#66ccff在MC中表示为§x§6§6§c§c§f§f\n其中\"§\"为分节符，其Unicode代码为\\u00A7\n\n\n原理\nBukkit有一个AsyncPlayerChatEvent(异步玩家聊天事件)，当玩家发送聊天时，你可以获取玩家发送的聊天文本并处理修改玩家想要发送的文本。\n\n\n开始编写\nColorUtils.java\n首先，我们编写随机彩色字符，这时，我们得知道Bukkit用什么处理颜色\n于是我们找到了org.bukkit.Color\n通过BukkitAPI的Javadoc，我们能够看到获得一个Color对象的方式是\nColor color = Color.fromRGB(int r,int g ,int b)\n其中，r,g,b分别为大小不超过255整数\n将Color对象转为RGB Hex值的方法是\nint rgbInt color.asRGB();\n将返回表示RGB Hex值的6位整数\n但是我们不需要6位整数，我们需要的是6个单独的数字，因此，我们需要把rgbInt转为包含六个Char的Char[]处理\nChar[] chars = String.valueOf(rgbInt).toCharArray();\n其中，静态方法String.valueOf()可以将任意基本数据类型或者对象转为String(如果是对象那么会自动调用其toString方法)，而String#toCharArray()可以将一个字符串转为Char数组\n接下来我们先制作一个能够生成随机颜色Color对象的方法:\nprivate static Color generatorRandomColor(){\n\n\nRandom random = new Random();\n\n\nreturn Color.fromRGB(random.nextInt(255),random.nextInt(255),random.nextInt(255));\n\n\n}\n以上代码中，通过Java的Random对象，我们可以随机生成各种类型的数据的随机值，因为获取Color对象需要传入三个int值，所以我们也随机三个int值\n通过Random#nextInt(int bound)方法，我们可以生成一个不超过bound的随机数\n最后我们返回这个Color对象，generatorRandomColor方法就制作完成了\n接下来我们为字符串\"上色\"，即传入一个原始的String，返回一个带有颜色代码的String:\npublic static String getColoredString(String original){\n    StringBuilder builder = new StringBuilder();\n    for (char c : original.toCharArray()) {\n        StringBuilder rgbBuilder = new StringBuilder();\n        rgbBuilder.append(\"§x\");\n        for (char rgb : String.valueOf(generatorRandomColor().asRGB()).toCharArray()) {\n            rgbBuilder.append(\"§\");\n            rgbBuilder.append(rgb);\n        }\n        builder.append(rgbBuilder.toString());\n        builder.append(c);\n    }\n    return builder.toString();\n}\n其中，还记得吗，String是不可更改的，因此我们不能对一个字符串添加字符，因此我们需要引入StringBuilder对象，StringBuilder对象允许通过调用StringBuilder#append()方法，向这个构建器的末尾追加字符，最后使用StringBuilder#toString即可获得编辑好的String字符串\n本例中还使用了\nfor (char c : original.toCharArray()) {}\n即上面提到的forEach方法来遍历原字符串的每一个字符(因为我们需要为每一个单独字符上色，而不是整个字符串)\n而\nfor (char rgb : String.valueOf(generatorRandomColor().asRGB()).toCharArray()) {}\n则将随机生成的RGB Hex数据分割成6个Char单独进行遍历，添加到单个字符前。\n\n\nCommandHandler.java\n众所周知，我们只希望需要彩色字功能的玩家发送彩色字，所以我们必须存储哪些玩家希望开启，哪些玩家不希望\n很显然我们需要创建一个指令让玩家选择是否开启\n一般来说，在Bukkit创建一个指令的标准流程是:\n1.在plugin.yml中注册指令\n2.定义一个实现了org.bukkit.command.CommandExecutor接口的对象以接受和处理指令\n3.使用Bukkit.getPluginCommand(String command)获取指定指令头的PluginCommand对象\n4.使用PluginCommand#setExecutor(CommandHandler)为指定指令绑定CommandExecutor处理器\n接下来我们需要明确一个格式，即在指令/tp shaokeyibb others中，tp是指令头，而后面的shaokeyibb是第一个参数，others是第二个参数，以此类推......\n\n\n\n\nListener.java\n接下来我们编写监听器，监听AsyncPlayerChatEvent\npublic class Listener implements org.bukkit.event.Listener {\n\n\n@EventHandler\npublic void onPlayerChat(AsyncPlayerChatEvent e){\nif (ColorfulChat.getEnable().getOrDefault(e.getPlayer(),false)){\ne.setMessage(ColorUtils.getColoredString(e.getMessage()));\n}\n}\n}\n本例中，AsyncPlayerChatEvent#getPlayer()可以获取发送聊天消息的Player对象，而AsyncPlayerChatEvent#getMessage()和AsyncPlayerChatEvent#setMessage()则分别可以获取和设置玩家发送的聊天消息\n\n\n这其中的ColorfulChat.getEnable()指向一个定义在插件主类的Map<Player,Boolean>，用来存储一个玩家是否开启了随机彩色字模式\n@Getter\nprivate static final HashMap<Player, Boolean> enable = new HashMap<>();\nTips:上述代码中的@Getter注解来自于Lombok，可以为变量快速生成Getter(即getEnable()方法。有关Lombok的更多使用方法以后可能会讲)\n本例中的Map#getOrDefault(Object key,Object def)是Map类的一个方法，它的逻辑是:根据key获取此Map中key对应的value，如果没有(本应返回null)则返回def，此处这样写是当有玩家没有使用过随机彩色字模式时返回false跳过这个玩家\n",
    "replies": [
        {
            "author": "IceCC",
            "timestamp": 1593662940,
            "txt_content": "终于更了，还以为真要等到明年呢"
        },
        {
            "author": "二逼青年歡樂多",
            "timestamp": 1593763740,
            "txt_content": "mcbbs有你更精彩"
        },
        {
            "author": "二逼青年歡樂多",
            "timestamp": 1593763800,
            "txt_content": "mcbbs有你更精彩"
        },
        {
            "author": "上杉夏相",
            "timestamp": 1594080960,
            "txt_content": "感谢楼主  排版已瞎\n越看越费劲\n要不你把原文件发一下？"
        },
        {
            "author": "IceCC",
            "timestamp": 1594098000,
            "txt_content": " 本帖最后由 IceCC 于 2020-7-7 13:01 编辑 \n\n这样操作是不是有问题啊\nint[number] array = new int[];\n\n我试了下,这样才可以\nint[] array = new int[number];\n\n"
        },
        {
            "author": "贺兰兰",
            "timestamp": 1594138860,
            "txt_content": "IceCC 发表于 2020-7-7 13:00\n这样操作是不是有问题啊\nint[number] array = new int[];\n\n\n真的不好意思，确实是我写错了，发帖当天本来已经纠正了但是新版本的稿子在我手机里存着还没来得及发出去然后就把这事忘了...."
        },
        {
            "author": "小帅120",
            "timestamp": 1596007560,
            "txt_content": "看了看还是吧不怎么懂脑子有点疼"
        }
    ]
}