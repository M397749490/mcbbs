{
    "title": "[Bukkit]详解发包机制|实现发送Title|反射 NMS",
    "author": "天启-麒麟",
    "replyCount": 15,
    "timestamp": 1596418800,
    "txt_content": " 本帖最后由 天启-麒麟 于 2020-8-4 22:11 编辑 \n\n详解NMS发包机制写在前面：一、本文适合：    1.有Java基础  (基础语法|面向对象|继承|接口|封装-非必须)    2.有Bukkit开发基础    3.想要深入了解NMS中的发包，通过反射技术实现大多数版本通用发包代码二、IDE(集成开发环境)：IntelliJ IDEA   不推荐使用Ec或其他IDE(不过你用了又有谁知道呢)三、Spigot版本：Spigot-1.12.2      Bukkit API：https://bukkit.windit.net/javadoc/      好吧发包技术和API没有半毛钱关系四、本文发包代码不借助任何工具API(ProtocolLib)，如果有需要可以查看ProtocolLib怎么玩|使用ProtocolLib收发包五、本文会把每一行用到的代码都做解析六、本文不是一个bbs不赞成的纯Java教程附：西方有个人说：A picture is worth thousand words(一图值千言) 所以我会在这个教程里面能用上图片的，绝对不废话如果本文有地方有错误，请您及时指出！谢谢！ps.本文虽然排版简陋，难以入目，但是内容上还是比较有深度和技术含量的。我会尽量以内容上的精致instead of外观上的满足。难以理解的抽象的东西，会尽量贴近生活去讲解，使抽象的东西变得不抽象，使难以理解的东西变得好理解\n本文将要向你介绍：    Java基础--面向对象之多态|Reflect反射技术    发包机制--介绍|使用NMS的优点    发包机制--思路分析|问题解决    发包机制--代码实现\n为什么在NMS发包教程上讲解Java基础：因为某些读者可能Java基础并不是特别的好，没有学到反射之类的技术。为了让这类开发者更快的不借助API实现反射全版本发包，提供了Java基础---多态|Reflect反射的快速入门 深入理解。为那些会的读者也可以加深一下印象，不会到了后面出现看不懂代码的情况。\n如果已经有这些基础且能灵活运用的开发者，可以直接跳过Java基础，直接看NMS发包\n本文涉及到的Java基础都是实现发包需要用到的Java基础强化一、多态深入讲解面向对象三大特征：封装性、继承性、多态性其中：继承(extends OR implements)是多态性的前提我想各位肯定都学过前两个特征。没学过？那还不赶紧去学多态在面向对象中是一个非常重要的技术特征，如果没有了多态，面向对象就失去了他的典征(典型特征)其重要性好比如：服务器与服务器的核心  如果一个服务器没有了核心，那你还开什么服务器\n什么是多态？\n他并不是有多种状态多态，字面上的意思就是多种形态   简单来说，多态是具有多种表现形态的特征我们首先来画一个图\n\n\n\n\nimage.png (27.78 KB, 下载次数: 9)\n\n下载附件\n\n2020-8-2 15:41 上传\n\n\n\n\n\n图中有三个类(我们把圆当成一个类)，学生类 员工类 和人类学生类继承了人类，员工类继承了人类我们先只来看学生和人类来举个栗子：小明是一个学生，他肯定也是一个人类。  你不能说他不是人吧      同理 员工肯定也是人(当然有老板不把员工当人的 拖欠工资 要求加班) 咳 扯远了           学生形态                      人类形态小明是一个对象，他既有学生形态，也有人类形态。一个对象拥有多种形态我们称为：对象的多态\n那么...多态怎么使用呢？\n在Java代码当中，我们体现多态就是一句话:父类引用指向子类对象父类引用：父类的引用数据类型的变量(指针)子类对象：new子类new出来的对象(也叫实例)格式：父类名称 对象名 = new 子类名称();接口名称 对象名 = new 实现类名称();\n用刚刚的例子体现： Human XiaoMing = new Student(); 复制代码\nHuman：父类引用new Student()：子类对象其实也可以把它理解为： 用Human类型的变量存储Student对象用父类类型的变量存储子类对象\n\n多态中成员变量及方法使用特征用一段代码来讲解：public class Human{\n    public String name = \"Human\";\n\n    public void show(){\n        System.out.println(\"我是父类\");\n    }\n}\n复制代码public class Student extends Human {\n    public String name = \"Student\";\n\n    @Override\n    public void show(){\n        System.out.println(\"我是子类\");\n    }\n}复制代码public class Test {\n    public static void main(String[] args) {\n        Human human = new Student();\n        System.out.println(human.name);\n        human.show();\n    }\n}复制代码\n这一段代码，我写了三个类，一个Human 一个Student 一个Test测试类其中Student extends Human\n我在测试类中使用多态：父类引用指向子类对象然后通过对象名.变量名获取子类父类共有的成员变量，并打印输出通过对象名.方法名调用子类父类共有的成员方法\n(你们猜猜结果是啥)\n结果：Human\n我是子类\n复制代码\n多态中，成员变量的访问特点没有任何变化，看结果 返回的是Human，是Human类中的name的值，所以多态中成员变量的访问特点和普通的成员变量访问没什么区别\n我们来看方法，我们是不是通过多态的父类引用指向子类对象的对象名来调用的子类父类共有的成员方法。如果我们不使用多态就这么写Human human = new Human();human.show();是不是肯定是调用的Human类的show方法\n我们来看使用多态的结果，哎？他怎么返回的是\"我是子类\"，调用的是子类的show方法呢？这个，其实就是多态的作用多态中，对于成员方法来说，子类父类共有的成员方法，通过多态的对象名调用这个方法，就会调用子类的方法记住一句话：等号右边new的是谁，调用的就是谁的方法，如果没有，就向上找。啥意思呢？就是看Human human = new Student();等号左边是不是new的是一个Student类的对象，那么我们使用 human.show(); 的时候，优先调用的就是Student类中的show方法如果Student也就是子类没有这个方法的时候，他就会向上找(找到他的父类Human)，调用父类的show方法\n思考题：\n那么问题来了：如果我子类有一个特有的方法，而父类没有这个方法，通过多态对象名调用这个方法，他会执行子类那个特有的方法么。\n(思考...)\n我们自己手写代码来试验试验，如果可以，那就证明可以这么干，如果不可以，那肯定有原因。那我们还是用刚才的代码，往子类(Student)中添加一个study方法，里面打印输出\"我爱学习！   study...\"public class Human{\n    public String name = \"Human\";\n\n    public void show(){\n        System.out.println(\"我是父类\");\n    }\n}\n复制代码public class Student extends Human {\npublic String name = \"Student\";\n\n@Override\npublic void show(){\nSystem.out.println(\"我是子类\");\n}\n\npublic void study(){\nSystem.out.println(\"我爱学习！ study...\");\n}\n}复制代码public class Test {\npublic static void main(String[] args) {\nHuman human = new Student();\nhuman.study();\n}\n}复制代码然而，你会发现，哎？他咋报错了？这不是有方法么？？难道我的名字写错了？？？!%$^@*#X$x？？？？？不不不，这个东西，其实涉及到了一点JVM的东西。\n我们都知道，Java程序在运行的时候，JVM虚拟机会先在内存中申请一块供Java程序运行的内存，然后他又把这个内存分成了五个区域，分别是：\n1.栈 Stack\n2.堆 Heap\n3.方法区 Method Area\n4.本地方法栈 Native Method Stack\n5.寄存器 pc Register\n\n\n\n\nfile_1596357387000.jpg (64.35 KB, 下载次数: 9)\n\n下载附件\n\n2020-8-2 16:36 上传\n\n\n\n\n\n在这里，我们只研究栈，堆和方法区，因为只有这三个是我们现在用到了的\n后面两个在JVM和JVM调优那块才会有大用(不过那是JavaEE的很深入的内容了，如果不是搞开发，肯定不用学)\n\n我们来看一张图\n\n\n\n\nimage.png (111.44 KB, 下载次数: 6)\n\n下载附件\n\n2020-8-2 16:37 上传\n\n\n\n\n\n不要吐槽为什么这个帖子里面的图片画的都这么难看，没错，都是我画的，都是我的锅左侧是代码，右侧是内存图解。内存我只画了栈，堆，方法区\n\n当我们在编译(就是javac)这个.java结尾的文件的时候，JVM编译到了\nhuman.study(); 的时候，他会上这个对象的引用数据类型也就是Human类中查找有没有这个study方法，如果有 编译成功 如果没有 编译失败\n那么我们Human类中有没有study方法呢？答案肯定是没有，所以你写的这个代码，他编译都不可能通过，谈何运行时运行new出来的子类的study方法呢？\n这个其实是属于动态版定的一个知识\n动态绑定语句的编译、运行原理：我们假设 Father ft=new Son();  ft.say();  Son继承自Father，重写了say()。\n        1：编译：我们知道，向上转型时，用父类引用执行子类对象，并可以用父类引用调用子类中重写了的同名方法。但是不能调用子类中新增的方法，为什么呢？\n                     因为在代码的编译阶段，编译器通过 声明对象的类型（即引用本身的类型） 在方法区中该类型的方法表中查找匹配的方法（最佳匹配法：参数类型最接近的被调用），如果有则编译通过。（这里是根据声明的对象类型来查找的，所以此处是查找 Father类的方法表，而Father类方法表中是没有子类新增的方法的，所以不能调用。）\n                     编译阶段是确保方法的存在性，保证程序能顺利、安全运行。\n        2：运行：我们又知道，ft.say()调用的是Son中的say()，这不就与上面说的，查找Father类的方法表的匹配方法矛盾了吗？不，这里就是动态绑定机制的真正体现。\n摘自http://www.cnblogs.com/ygj0930/p/6554103.html    感谢大佬！\n\n\n多态的向上转型，向下转型\n\n1.向上转型：\n向上转型，其实就是我们说多态的一句话：父类引用指向子类对象\nHuman human = new Student();\n2.向下转型：自动转换是向上转型了，那么向下转型肯定就是强制类型转换喽！\n\n具体写法：\n来一个多态先// 向上转型\nHuman human = new Student();\n// 我们如果想要把human重新转换成Student怎么办？ 很简单\nStudent student = (Student) human;\n// 因为是强制类型转换，不加写括号会报错，如果你要把一个不是学生的对象，转换成学生，这怎么可能成功？\n// 例：  错误写法！！！\nHuman human = new Employee();\nStudent student = (Student) Employee;复制代码一开始举得栗子\n员工和学生都继承人类\n那我如果想把员工的对象转换成学生对象，他不报错他干啥？(人家员工都有老板虐待了 别再让员工遭受老师的折磨了=-=)\n\n这个地方我们可以判断一下，如果是学生对象，那就转换，如果不是，那就不转换\n怎么实现呢？\nJava为我们提供了一个关键字，叫做instanceof，这其实可以拆成两个词，第一个instance实例(对象)，第二个of，是、关于(反正就那意思)\n这个关键字可以判断这个对象是不是这个引用数据类型的\n格式：\n对象名 instanceof 类名\n他可以看做一个逻辑运算符，这个东西返回的是一个boolean值，(不会吧不会吧？你连布尔值都没学过？赶紧去学吧。)\n我们写一个代码来用一下这个instanceof关键字Human human = new Student();\n// 运用instanceof关键字判断这个human是不是Student类型的\nif (human instanceof Student){\n    // 是就执行这里面的代码\n    Student student = (Student) human;\n}\n// 不是就不执行\n\n//再来一个代码：\nHuman human2 = new Employee();\nif (human2 instanceof Student){\n    Student stu = (Student) human;\n}复制代码第一段代码肯定是可以转换成功的\n第二段代码肯定是转换不成功的，因为human2不是Student类型的还是那句话 你不能把不是学生的人把他强制弄成学生吧。\n\n补充：\n这段代码显得有点冗余，因为我们看啊，这两段代码里面都有一个公共部分就是if判断语句\n那我们是不是可以把这个if从这两段代码中抽取出来，封装到一个方法中去呢？   你要连这个都不知道 你封装没学吧\n这个就是一个更面向对象的一个方式写\n抽取重复代码抽取出来的一个方法：public Student ifInstanceof(Object instance){\n    if (instance instanceof Student) {\n        return (Student) instance;\n    }\n}复制代码然后再调用就好了\n其实这个还是有一个复用性很强的一种写法public E ifInstance(Object instance, Class<E> cls){\n    if(instance != null && instance.getClass().getName().equalsIgnoreCase(cls.getName())){\n        return (E) instance;\n    }\n}复制代码这种写法是以后写框架的时候常用的一种写法，框架要求代码的耦合性要非常的低。\n了解了解装个*就行，这个用到了反射技术，一会就讲到。\n\n那么我们的多态就讲完了。接下来开始非常致命有趣且好玩的Reflect反射。\n\n二、反射技术(机制)\n1.在程序运行时，对于任意一个类，都可以知道他的属性和方法，对于任意一个对象，都能调用任意一个方法或属性。\n这种动态的获取信息和动态调用对象的方法，我们称为Java的反射机制\n简单来说，将类中的各种信息封装为各个对象，我们叫做反射 反射：强调的是运行时，也就是说我们在运行之前，并不知道要干什么\n反射的好处：\n     1.可以在程序运行中，操作这些对象\n     2.可以降低程序的耦合性，提高程序的可扩展性\n\n在学习之前，希望你们先自己看一看Class类的介绍和成员方法\n2.通过反射获取类信息\n(1)如何获取Class对象\n在Java中，代码一共有三个阶段\n    1.Source源代码阶段\n    2.Class字节码文件阶段\n    3.Runtime运行时阶段\n继续不多说，上图\n\n\n\n\nfile_1596361075000.jpg (79.06 KB, 下载次数: 15)\n\n下载附件\n\n2020-8-2 17:37 上传\n\n\n\n\n\n\nSource源代码阶段他是在硬盘上的\n而Class类文件阶段和Runtime运行时阶段是在内存中的\n这三个阶段，我们有三种分别对应的获取Class类对象的方式\nFirst：Source源代码阶段：\nClass中的静态方法\nstatic Class forName(\"全类名\")    (在JavaDoc中Class是有泛型的，而且是一个特别不大正常的泛型<?> 或者是<? extends Xxxx> 还有<? super Xxx>)\n这个地方我们不带泛型就好\n参数：\n字符串，全类名：包名.类名    (你别告诉我你不知道包是啥)\n如：Class cls = Class.forName(\"cn.kylin.main\");复制代码cn.kylin 就是包名  main就是类名\n通过这个方法可以返回一个Class对象，注意：名字不要起class，因为class是一个关键字\n\nSecond：Class类文件阶段\n直接通过\n类名.class获取就行\n例：\nClass clazz = main.class;\n\nThird：Runtime运行时阶段\nObject类中有一个方法是getClass()，返回一个Class对象，我们都知道，Object是所有类的父类，也就是说 Object类中有的方法所有的类都有，我们可以直接通过\n对象.getClass(); 来获取Class类对象\n如：\nStudent stu = new Student();\nClass cls = stu.getClass();\n\nEASY！\n\n\n(2)如何通过Class对象操作类中的变量，方法，构造方法\n变量，英文名称叫Field\n方法，英文名叫Method\n构造方法，英文名叫Constructor\n一图值千言，再放个图(懒得排版了，这个md排版还好看一点)\n\n\n\n\nfile_1596372734000.jpg (74.54 KB, 下载次数: 0)\n\n下载附件\n\n2020-8-2 20:52 上传\n\n\n\n\n\n\n补充：Class中有一个方法cast(Object obj) 把这个obj对象强转为这个Class对象的类型\n\n我们获取到了封装变量的类Field  封装方法的类Method 封装构造方法的类Constructor\n需要知道这几个对象怎么用啊\nField：\nget(Object obj)  传进去一个对象，返回这个变量在对象中的值\nset(Object obj, Objec value)  传进去一个对象还有一个值，设置这个变量在对象中的value\n\nMethod：\ninvoke(Object obj, Object... args)  传进去一个对象，和这个方法的参数列表  后面的Object... args 是可变参数，传几个都可以，不传都行\n\nConstructor：\nnewInstance(Object... args)  传进去这个构造方法的参数列表\n\n具体的学完了 我们通过一个案例来学习怎么使用\n案例：// Person类\npublic class Person {\n    public String name;\n    public int age;\n    private String gender;\n    public int a;\n    protected int b;\n    int c;\n    private int d;\n\n    public Person(String name, int age, String gender, int a, int b, int c, int d) {\n        this.name = name;\n        this.age = age;\n        this.gender = gender;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n\n    public Person() {\n    }\n\n    public void eat(){\n        System.out.println(\"eat...\");\n    }\n\n    public void eat(String food){\n        System.out.println(\"eat...\" + food);\n    }\n\n    @Override\n    public String toString() {\n        return \"Person{\" +\n                \"name='\" + name + '\\'' +\n                \", age=\" + age +\n                \", gender='\" + gender + '\\'' +\n                \", a=\" + a +\n                \", b=\" + b +\n                \", c=\" + c +\n                \", d=\" + d +\n                '}';\n    }\n}\n\n\n// 测试类\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        // 获取Person的Class对象\n        Class personClass = Person.class;\n        // 调用getField获取方法\n        Field a = personClass.getField(\"a\");\n        Person p = new Person();\n        // 调用Field中的get方法，传进去一个Person对象，我们并没有给a赋值，所以返回的是默认值：0\n        System.out.println(a.get(p));\n        System.out.println(\"=======我是一条华丽的分割线======\");\n\n        // 调用getFields方法\n        Field[] fields = personClass.getFields();\n        // 遍历fields\n        for (Field field : fields) {\n            System.out.println(field);\n            // 可以发现，只获取到了public修饰的变量\n        }\n        // 调用Declared的两个方法\n        System.out.println(\"=======我是一条华丽的分割线======\");\n\n        Field privateGender = personClass.getDeclaredField(\"gender\");\n        // 打印一下这个变量\n        System.out.println(privateGender);\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for (Field privateField : declaredFields) {\n            System.out.println(privateField);\n        }\n        System.out.println(\"=======我是一条华丽的分割线======\");\n\n        // 既然我们能获取私有变量，那我们是不是能设置私有变量的值呢？如果能，那肯定要逆天啊！\n        // 当然是可以的，不然set方法是吃素的？\n        // 我们把p对象的private String gender设置成\"女\"\n        Field gender = personClass.getDeclaredField(\"gender\");\n        // 但是我们会发现，他报错了！！！报了一个IllegalAccessException 这个其实就是权限不通过的错误\n        // 反射更为逆天的就是，你设置一下，他就可以忽视权限的检查  反射大法好！！！\n        gender.setAccessible(true);  // 设置为true，就是忽略权限的检查，就不会报错了\n        gender.set(p,\"女\");\n        System.out.println(\"修改后gender：\" + gender.get(p));\n        System.out.println(\"=======我是一条华丽的分割线======\");\n\n        // 接下来是一系列的方法\n        // 获取指定名称指定参数列表的方法 这里我们Person中的eat有两个重载的方法 分别调用一下\n        // 无参eat\n        Method eat1 = personClass.getMethod(\"eat\");\n        // 获取带参eat\n        Method eat2 = personClass.getMethod(\"eat\", String.class);\n        // 分别执行一下\n        eat1.invoke(p);\n        eat2.invoke(p,\"Meat\");\n        // 没问题，都执行成功了，Declared也差不多\n        System.out.println(\"=======我是一条华丽的分割线======\");\n\n        // 下面是构造方法\n        // 分别获取空参构造和全参构造\n        Constructor con1 = personClass.getConstructor();\n        Constructor con2 = personClass.getConstructor(String.class, int.class, String.class, int.class, int.class, int.class, int.class);\n        // 分别创建实例对象\n        Person p1 = (Person) con1.newInstance();\n        Person p2 = (Person) con2.newInstance(\"狗皮张\",21,\"人妖\",1,2,3,4);\n        System.out.println(p1);\n        System.out.println(p2);\n    }\n}复制代码代码里面注释写的很清楚了已经，没有啥要解释的了\n\n好的，那么我们的Java基础铺垫好了之后，开始进入我们今天的正题------NMS发包机制\n\nNMS发包机制--介绍|使用NMS的优点\nNMS是什么？包又是什么？\n我们先来聊聊包\nMinecraft中 客户端Client和服务器Server之间的通信，全部以数据包来往的方式进行，但是呢Bukkit他又没有给收发包的API，原因？我也不知道\nNMS就是net.minecraft.server 包 简称NMS(别问我为啥去这个怪异的名字听着像是骂人都取首字母不就粗来了么=-=)\n每一种数据包都被封装为一个Packet的实现类放在net.minecraft.server.版本 包下，他的命名为：Packet+类型+(Out/In)+内容\n类型主要分为四种\n\nLogin - 加入服务器时.(与登录插件无关)\nStatus - Ping与MOTD等\nPlay - 游戏内容\nHandshake - 握手包\n\n\n其中我们最常用的就是Play了\nOut就是输出，传出数据包(发包)In就是输入，传入数据包(收包)\n我们今天要讲的就是不通过任何API(点名ProtocolLib)来实现各个版本都能使用的发包代码\n\n首先我们来讲一下为什么不使用API，也就是不使用API进行收发包的好处：\n你用手指头想想都知道\n1. 对外依赖减弱     (为啥？  你这如果用了API你这插件肯定会有前置，他不就对外依赖了么)\n2. 代码减小耦合性   你想想，你自己写的代码是不是可以随意更改，可以自己修改代码依赖的模块，而你如果使用给定的API的话，你是不是不能修改API的代码，他是不是代码依赖性就更高了？\n3. 提高自己的技术\n你说不使用API收发包有这么多好处，最主要的还能提高自己的技术，何乐而不为呢？\n弊端：\n较为麻烦。\n发包机制--思路分析|问题解决\nBukkit API中，我们也不知道为什么，他居心险恶的并没有给收发包的API\n所以就使我们的收发包变得特别的麻烦\n既然没有给我们直接能用的，那我们是不是要自己去找呢？\n首先我们想，给玩家收发包，是不是肯定和玩家有关系，那么我们去Player类中寻找，但是你看，Player他是一个抽象类，所以我们要找他的子类。CraftPlayer，然后我们继续找，CraftPlayer有一个方法getHandle他返回的是一个EntityPlayer，想必和这个类应该有点关系，然后我们再去EntityPlayer类中找，然后我们会发现有一个成员变量的类型的是PlayerConnection，翻译过来就是 玩家连接 哎？这个东西里面肯定有点啥可以发包的东西，我们再去PlayerConnection类中寻找，最后发现一个方法的名字就是sendPacket(Packet packet) 里面传入一个Packet(是一个接口)的实现类对象，大功告成！\n\n\n\n\nimage.png (73.19 KB, 下载次数: 15)\n\n下载附件\n\n2020-8-3 07:33 上传\n\n\n\n\n\n\n真是得来全不费工夫\n然后我们就可以调用里面的这东西进行发包了。真的吗？\n\n我们在查看Spigot核心里面的一些东西的时候，有一个net包，下面有minecraft包，下面还有server包，再下一个？啥东西？V1_12_R1\n这个包名其实就是版本号，我们再查看 org.bukkit.craftbukkit包下，也有一个V1_12_R1包(版本不同可能不一样)\n我们是不是可以明白，两个包下的东西，每一个版本的包名都是不一样的\n包名不一样又怎么了？\n包名不一样 比如说你在这里写了一个V1_12_R1  \n结果服务器使用的时候，他的版本不大一样，是V1_12_R2 了，这服务器不就找不到这个包下的class文件了么，他就会抛出ClassNotFoundException类找不到异常。\n\n而我们目前知道的需要用到的类(接口) CraftPlayer在cb(craftbukkit).版本 包下EntityPlayer PlayerConnection Pocket 在NMS.版本 包下，我们会发现如果我们导入(import)这些类 是不是如果版本变了，他会找不到这些类了呢？\n\n怎么办呢？  这个时候使用反射是明智的选择(当然你也可以判断版本)\n使用反射问题就迎刃而解了！\n\n首先我们分析一下该从哪里写起，我们要发包 就要调用PlayerConnection中的sendPocket方法，但是里面需要传入一个Pocket实现类对象，Pocket那些实现类我们刚才说了，全部在NMS.版本包下，比如我们想要给玩家发一个Title(虽然高版本Bukkit在Player类中提供了sendTitle方法)，然后我们判断，他是什么类型的啊？Play游戏内容类型的，然后他是发包还是收包呢？发包Out 内容是啥呢？Title\n所以这个包类的名称就是PacketPlayerOutTitle\n然后我们进去看一眼，他里面有四个构造方法\n\n\n\n\nimage.png (28.6 KB, 下载次数: 6)\n\n下载附件\n\n2020-8-3 07:42 上传\n\n\n\n\n\n我们要看肯定要用最多参数的那一个\nPacketPlayOutTitle() - 无参\nPacketPlayOutTitle(EnumTitleAction, IChatBaseComponent) - 类型枚举、基础交流类\nPacketPlayOutTitle(EnumTitleAction, IChatBaseComponent,int,int,int) - 类型枚举、基础交流类、淡入时间、停留时间、淡出时间PacketPlayOutTitle(int,int,int) - 淡入时间、停留时间、淡出时间\n然后我们发现这里面要传进去一个EnumTitleAction(他在高版本的时候已经是PacketPlayOutTitle的内部枚举了)那我们是不是要获取一下这东西，怎么获取呢？我们看看源码\n\n\n\n\nimage.png (26.21 KB, 下载次数: 6)\n\n下载附件\n\n2020-8-3 07:45 上传\n\n\n\n\n\n哦！我们需要通过反射获取他的a方法，然后再通过反射创建一个这个的对象，执行这个方法，传进去我们要的类型TITLE，简单！\n我们再来看IChatBaseComponent：这个是bc包下的，他有子类为ChatBaseComponent，这个类还有一个子类ChatComponentText，那肯定是使用这个无疑了(多态)，为什么？因为这个ChatComponentText他有一个构造方法的参数为String\n\n\n\n\nimage.png (2.83 KB, 下载次数: 14)\n\n下载附件\n\n2020-8-3 07:48 上传\n\n\n\n\n\n这个传入一个TITLE要显示的内容，这不就好了么？\n分析完毕，然后我们代码实现一下\n发包机制--代码实现\n首先明确两个小点：\n我们getPlayer的虽然获取的是Player，但是其实所有的Player都是CraftPlayer对象(多态) Server也是 getServer得到的是CraftServer对象\n首先我们想：这里面有好多类呢，我们一个个获取他们的Class是不是太麻烦了点，他们的获取的代码其实都是差不多的，比如我想获取一个CraftPlayer的Class对象\n //首先获取版本号，怎么获取呢\nString version = Bukkit.getServer().getClass().getPackage().subString(Bukkit.getServer().getClass().getPackage().lastIndexOf(\".\") + 1);\n// 或者是\nString version = Bukkit.getServer().getClass().getPackage().split(\".\")[3];\nClass craftPlayer = Class.forName(\"org.bukkit.craftbukkit.\" + version + \".CraftBukkit\");\n复制代码\n对吧，你会发现，如果我获取需要的所有的Class对象，其中冗余(重复)的代码非常的多，那么我们是不是可以把重复的代码共性抽取，封装为一个方法?\n注意：建议在开服的时候就把所有的Class对象都获取出来然后在有需要的时候我们就用，这样可以在使用的时候 大大提升插件的性能\n\n那么我们写两个方法\n我为了偷懒直接把主类注册监听器了\npublic class SendTitle extends JavaPlugin implements Listener {\n    @Override\n    public void onEnable() {\n        Bukkit.getPluginManager().registerEvents(this,this);\n    }\n\n    public Class getNmsClass(String name) throws ClassNotFoundException {\n        String version = Bukkit.getServer().getClass().getPackage().getName().split(\".\")[3];\n        return Class.forName(\"net.minecraft.server.\" + version + \".\" + name);\n    }\n\n    public Class getCbClass(String name) throws ClassNotFoundException {\n        String version = Bukkit.getServer().getClass().getPackage().getName().split(\".\")[3];\n        return Class.forName(\"org.bukkit.craftbukkit.\" + version + \".\" + name);\n    }\n}复制代码为什么要抛出异常而不是直接在方法内try-catch了：我们要告诉调用者这个方法他有异常，要小心(虽然调用者是我们自己)\n但是我们会发现，这段代码还不是那么的完美，为什么？因为他也有冗余的代码啊，而且很浪费性能，为什么？因为他在每次调用这个获取Class对象的方法的时候，他都会获取一次version，获取version的步骤是不是非常的繁琐？是不是浪费性能？ 那么我们改一下\npublic class SendTitle extends JavaPlugin implements Listener {\n    @Override\n    public void onEnable() {\n        Bukkit.getPluginManager().registerEvents(this,this);\n        version = Bukkit.getServer().getClass().getPackage().getName().split(\".\")[3];\n    }\n    // 在外面声明一个String变量，用来存储version，然后在onEnable类中只获取一次\n    String version;\n\n    public Class getNmsClass(String name) throws ClassNotFoundException {\n        return Class.forName(\"net.minecraft.server.\" + version + \".\" + name);\n    }\n\n    public Class getCbClass(String name) throws ClassNotFoundException {\n        return Class.forName(\"org.bukkit.craftbukkit.\" + version + \".\" + name);\n    }\n}复制代码是不是变得比较的简洁，而且这个代码还美。\n然后我们开始写获取Class的，我们想，获取Class是不是只用获取一次就够了？(你不会傻乎乎的每次发送Title都获取一次Class吧)那怎么获取呢?\n我们写一个方法，开服的时候调用他(我为了偷懒，所有的代码都在主类里面写了，建议开发插件的时候分开写，然后把方法修饰上static就行，修饰了static他就是静态方法，静态方法可以直接通过类名.静态方法名调用)\n// 我们目前只需要获取这几个Class对象就好，放在外面他的作用域更大了，整个类都能调用了\n    Class iChatBaseComponent;\n    Class chatComponentText;\n    Class packet;\n    Class packetPlayOutTitle;\n    Class enumTitleAction;\n\n    public void getAllClass(){\n        try {\n            iChatBaseComponent = getNmsClass(\"IChatBaseComponent\");\n            chatComponentText = getNmsClass(\"ChatComponentText\");\n            packet = getNmsClass(\"Packet\");\n            packetPlayOutTitle = getNmsClass(\"PacketPlayOutTitle\");\n            // 因为EnumTitleAction这个枚举是PacketPlayOutTitle中的内部枚举，如果你看过内部类编译出来的class文件的名字的话，应该会知道\n            enumTitleAction = getNmsClass(\"PacketPlayOutTitle$EnumTitleAction\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n复制代码\n然后在onEnable方法中调用他\n@Override\n    public void onEnable() {\n        Bukkit.getPluginManager().registerEvents(this,this);\n        version = Bukkit.getServer().getClass().getPackage().getName().split(\".\")[3];\n        getAllClass();\n    }复制代码没毛病，然后就开始写我们最关键的，也就是最重要的一部分，实现发包，我们写一个方法吧，需要传入Player p对象，然后在有需要的时候直接调用这个方法传入一个Player对象就好了\n// var3为渐入时间/s  var4是停留时间/s  var5是渐出时间/s\n    public void sendTitle(Player p, String title,int var3, int var4, int var5){\n        try {\n            // 1. 获取ChatComponentText对象\n            Object chatComponentTextInstance = chatComponentText.getConstructor(String.class).newInstance(title);\n            // 2. 获取EnumTitleAction枚举TITLE\n            Object enumTITLE = enumTitleAction.getMethod(\"a\", String.class).invoke(enumTitleAction.getConstructor().newInstance(), \"TITLE\");\n            // 3. 创建PacketPlayOutTitle对象\n            Object packetPlayOutTitleInstance = packetPlayOutTitle.getConstructor(enumTitleAction, iChatBaseComponent, int.class, int.class, int.class).newInstance(enumTITLE, chatComponentTextInstance, var3, var4, var5);\n            // 4. 使用CraftPlayer.class.cast(p) 把p对象强转一下\n            Object craftPlayer = getCbClass(\"CraftPlayer\").cast(p);\n            // 5. 调用CraftPlayer中的getHandle方法获取EntityPlayer\n            Object entityPlayer = craftPlayer.getClass().getMethod(\"getHandle\").invoke(craftPlayer);\n            // 6. 获取EntityPlayer中的成员变量PlayerConnection对象\n            Object playerConnection = entityPlayer.getClass().getField(\"playerConnection\").get(entityPlayer);\n            // 7. 调用sendPacket方法，传进去PacketPlayOutTitle对象\n            playerConnection.getClass().getMethod(\"sendPacket\",packet).invoke(playerConnection,packetPlayOutTitleInstance);\n        } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException | ClassNotFoundException | NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }复制代码由于页面的原因，代码可能有点变形，你们可以粘贴到自己的IDE上查看代码\n\n反射学好了，这代码绝对能看懂，其实翻来覆去就是那几个东西，我这里举了一个发送Title的例子，其他的包都在NMS下面，举一反三就好。\n不过在高版本，Bukkit API在Player类中整了一个sendTitle的方法，所以高版本如果要发送Title就不需要发包这么麻烦了\n\n我们监听一个玩家进入服务器的事件 PlayerJoinEvent，然后调用sendTitle给他发送一个Title\n@EventHandler\n    public void onPlayerJoin(PlayerJoinEvent e){\n        sendTitle(e.getPlayer(), ChatColor.GREEN + \"欢迎欢迎！\",1,3,1);\n    }\n复制代码\n最后的最后，整个类的代码：import org.bukkit.Bukkit;\nimport org.bukkit.ChatColor;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.PlayerJoinEvent;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.lang.reflect.InvocationTargetException;\n\npublic class SendTitle extends JavaPlugin implements Listener {\n    @Override\n    public void onEnable() {\n        Bukkit.getPluginManager().registerEvents(this,this);\n        version = Bukkit.getServer().getClass().getPackage().getName().split(\".\")[3];\n        getAllClass();\n    }\n    // 在外面声明一个String变量，用来存储version，然后在onEnable类中只获取一次\n    String version;\n\n    public Class getNmsClass(String name) throws ClassNotFoundException {\n        return Class.forName(\"net.minecraft.server.\" + version + \".\" + name);\n    }\n\n    public Class getCbClass(String name) throws ClassNotFoundException {\n        return Class.forName(\"org.bukkit.craftbukkit.\" + version + \".\" + name);\n    }\n\n    // 我们目前只需要获取这几个Class对象就好，放在外面他的作用域更大了，整个类都能调用了\n    Class iChatBaseComponent;\n    Class chatComponentText;\n    Class packet;\n    Class packetPlayOutTitle;\n    Class enumTitleAction;\n\n    public void getAllClass(){\n        try {\n            iChatBaseComponent = getNmsClass(\"IChatBaseComponent\");\n            chatComponentText = getNmsClass(\"ChatComponentText\");\n            packet = getNmsClass(\"Packet\");\n            packetPlayOutTitle = getNmsClass(\"PacketPlayOutTitle\");\n            // 因为EnumTitleAction这个枚举是PacketPlayOutTitle中的内部枚举，如果你看过内部类编译出来的class文件的名字的话，应该会知道\n            enumTitleAction = getNmsClass(\"PacketPlayOutTitle$EnumTitleAction\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // var3为渐入时间/s  var4是停留时间/s  var5是渐出时间/s\n    public void sendTitle(Player p, String title,int var3, int var4, int var5){\n        try {\n            // 1. 获取ChatComponentText对象\n            Object chatComponentTextInstance = chatComponentText.getConstructor(String.class).newInstance(title);\n            // 2. 获取EnumTitleAction枚举TITLE\n            Object enumTITLE = enumTitleAction.getMethod(\"a\", String.class).invoke(enumTitleAction.getConstructor().newInstance(), \"TITLE\");\n            // 3. 创建PacketPlayOutTitle对象\n            Object packetPlayOutTitleInstance = packetPlayOutTitle.getConstructor(enumTitleAction, iChatBaseComponent, int.class, int.class, int.class).newInstance(enumTITLE, chatComponentTextInstance, var3, var4, var5);\n            // 4. 使用CraftPlayer.class.cast(p) 把p对象强转一下\n            Object craftPlayer = getCbClass(\"CraftPlayer\").cast(p);\n            // 5. 调用CraftPlayer中的getHandle方法获取EntityPlayer\n            Object entityPlayer = craftPlayer.getClass().getMethod(\"getHandle\").invoke(craftPlayer);\n            // 6. 获取EntityPlayer中的成员变量PlayerConnection对象\n            Object playerConnection = entityPlayer.getClass().getField(\"playerConnection\").get(entityPlayer);\n            // 7. 调用sendPacket方法，传进去PacketPlayOutTitle对象\n            playerConnection.getClass().getMethod(\"sendPacket\",packet).invoke(playerConnection,packetPlayOutTitleInstance);\n        } catch (InstantiationException | InvocationTargetException | NoSuchMethodException | IllegalAccessException | ClassNotFoundException | NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    @EventHandler\n    public void onPlayerJoin(PlayerJoinEvent e){\n        sendTitle(e.getPlayer(), ChatColor.GREEN + \"欢迎欢迎！\",1,3,1);\n    }\n}复制代码\n我们会发现，没有一个import是导入的带版本号的包，这就使得我们的发包在几乎全版本(不确定1.13+能否使用，因为1.13的时候Bukkit API大改)\n\n如果觉得好，请不要吝啬你的人气和金粒，你们的支持是我最大的动力。\n明目张胆的要人气\n\n\n\n\nimage.png (8.38 KB, 下载次数: 3)\n\n下载附件\n\n2020-8-3 09:36 上传\n\n\n\n\n\n\n\n\n\n\n\n[groupid=1427][IRCN]红墨青城[/groupid]\n\n\n\n\n\n\nimage.png\n(111.44 KB, 下载次数: 6)\n\n\n\n\n下载附件\n\n\n2020-8-2 16:32 上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "replies": [
        {
            "author": "HotPe_e",
            "timestamp": 1596420360,
            "txt_content": "看了一半 突然看到了一个问题\n\n这里没有变量名 2333\npublic class Human{\n    public String = \"Human\";\n\n    public void show(){\n        System.out.println(\"我是父类\");\n    }\n}"
        },
        {
            "author": "天启-麒麟",
            "timestamp": 1596420420,
            "txt_content": "HotPe_e 发表于 2020-8-3 10:06\n看了一半 突然看到了一个问题\n\n这里没有变量名 2333\n感谢感谢我是直接在帖子上敲得，我也没发现"
        },
        {
            "author": "CyanBillows",
            "timestamp": 1596447540,
            "txt_content": "对初学者很友好，受教了XD"
        },
        {
            "author": "RE_OVO",
            "timestamp": 1596454200,
            "txt_content": "为什么要花这么多时间去反射发包呢，直接ProtocolLib不香吗"
        },
        {
            "author": "天启-麒麟",
            "timestamp": 1596456420,
            "txt_content": "RE_OVO 发表于 2020-8-3 19:30\n为什么要花这么多时间去反射发包呢，直接ProtocolLib不香吗\n不使用API的好处肯定是有的啊，使用别的API使你的插件对外依赖十分严重，如果不使用API还可以提高自己的技术，多香"
        },
        {
            "author": "William_Shi",
            "timestamp": 1596457200,
            "txt_content": "RE_OVO 发表于 2020-8-3 19:30\n为什么要花这么多时间去反射发包呢，直接ProtocolLib不香吗\n不使用plib研究截包、改包的确没意思，但是playerConnetion发包是很实用的"
        },
        {
            "author": "RE_OVO",
            "timestamp": 1596513660,
            "txt_content": " 本帖最后由 RE_OVO 于 2020-8-4 12:03 编辑 \n天启-麒麟 发表于 2020-8-3 20:07\n不使用API的好处肯定是有的啊，使用别的API使你的插件对外依赖十分严重，如果不使用API还可以提高自己的 ...\n当大量需要数据包操作的时候，再反射，你就知道酸爽了。这玩意会写就行了，实际操作还是上ProtocolLib优雅，代码可读性高，况且ProtocolLib和Vault这种类似，已经是MC服务器不可或缺的插件了。\n\n* 真要研究还得看TinyProtocol(ProtocolLib的简化版): https://github.com/dmulloy2/ProtocolLib/tree/master/TinyProtocol"
        },
        {
            "author": "天启-麒麟",
            "timestamp": 1596514800,
            "txt_content": "RE_OVO 发表于 2020-8-4 12:01\n当大量需要数据包操作的时候，再反射，你就知道酸爽了。这玩意会写就行了，实际操作还是上Protocol ...\n他大量数据包操作你只要多获取几个Class对象，然后再通过各种稀奇古怪的反射硬倒腾，就好了，虽然没有那么优雅=-=但是他也不算太麻烦啊"
        },
        {
            "author": "RE_OVO",
            "timestamp": 1596527040,
            "txt_content": " 本帖最后由 RE_OVO 于 2020-8-4 15:56 编辑 \n天启-麒麟 发表于 2020-8-4 12:20\n他大量数据包操作你只要多获取几个Class对象，然后再通过各种稀奇古怪的反射硬倒腾，就好了，虽然没有那 ...\n大佬的世界果然不一样！\n反射操作！高端！彳亍！用别人类库！不行！\n\n1. 浪费时间，你反射花半天时间慢慢获取那几个对象绕来绕去，我几行代码就能搞定，能够更加专注实现需要的功能\n2. 代码全是try catch throws，频繁检查反射抛出错误(这里就假定大神您能够写个反射工具类简化吧，毕竟是大神，不麻烦！)\n3. 非基础数据类型读取。有些数据包的成员是非基础数据类型，属于NMS类，好家伙，你得把这个也反射，这还没完，有些是一个类套一个类，你就慢慢反射去吧，嘻嘻。而ProtocolLib全包装好了，我直接调用包装类写入就行，会自动转换。特别是1.13/1.14 NMS大改之后，一堆数据包都是这样。不过毕竟是大神你，反射就完事了！\n\n*咱也别争了，等会版主来了\n"
        },
        {
            "author": "南柯郡守",
            "timestamp": 1596527760,
            "txt_content": "教程很详细 但是也太过于详细\n\n不必从Java底层开始讲\n也不必过多赘述开发基础\n洋洋洒洒大半篇 还没有做目录引导\n\n但是内容详实值得肯定"
        },
        {
            "author": "秋韵",
            "timestamp": 1601641440,
            "txt_content": "楼主您好，我是一名Java新手，非常感谢你带来的教程\n\n不过在你帖子里直接复制下来的代码在我这里运行不了（可能是我的问题）\n我改成了这样才能运行↓ （其实我也不知道为什么）\nsendTitle方法\n\n\npublic void sendTitle(Player p, String title,int var3, int var4, int var5){\n        try {\n                Enum[] enumConstants = enumTitleAction.getEnumConstants();\n                      Object enumTITLE =  null;\n                      for (Enum enum1 : enumConstants) {\n                              String name = enum1.name();\n                              if (name.equals(\"TITLE\")) {\n                                  enumTITLE = enum1;\n                              }\n                      }\n                Object chatComponentTextInstance = chatComponentText.getConstructor(String.class).newInstance(title);\n                Object packetPlayOutTitleInstance = packetPlayOutTitle.getConstructor(enumTitleAction, iChatBaseComponent, int.class, int.class, int.class).newInstance(enumTITLE, chatComponentTextInstance, var3, var4, var5);\n                Object craftPlayer = getCbClass(\"entity.CraftPlayer\").cast(p);\n            Object entityPlayer = craftPlayer.getClass().getMethod(\"getHandle\").invoke(craftPlayer);\n            Object playerConnection = entityPlayer.getClass().getField(\"playerConnection\").get(entityPlayer);\n            playerConnection.getClass().getMethod(\"sendPacket\",packet).invoke(playerConnection,packetPlayOutTitleInstance);\n          } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }复制代码\n\n我还只是个新手，不太懂反射这块，所以也不能完全肯定您的代码一定存在问题\n不过有一点错误可以肯定的是，CraftPlayer应该在\norg.bukkit.craftbukkit.版本.entity 里面\n而非\norg.bukkit.craftbukkit.版本\n\n最后，还是非常感谢你的教程，已评分了"
        },
        {
            "author": "秋韵",
            "timestamp": 1601641920,
            "txt_content": "刚才又看了一下感觉可能是这一段代码出了问题\nObject enumTITLE = enumTitleAction.getMethod(\"a\", String.class).invoke(enumTitleAction.getConstructor().newInstance(), \"TITLE\");\n我在运行的时候后台会NoSuchMethodException报错\n"
        },
        {
            "author": "天启-麒麟",
            "timestamp": 1602067260,
            "txt_content": "秋韵 发表于 2020-10-2 20:32\n刚才又看了一下感觉可能是这一段代码出了问题\nObject enumTITLE = enumTitleAction.getMethod(\"a\", String. ...\n试试getDeclaredMethod()？不知道你用的啥版本的Spigot呢，但是这个异常大致有两个原因\n1. 这个名叫a传进去一个String类型的方法，不存在\n2.这个方法他修饰了private\n如果是第二个可以用getDeclaredMethod()解决，别忘写一下忽略检查\n第一个....去看看源码是啥方法改一下"
        },
        {
            "author": "qse",
            "timestamp": 1606015680,
            "txt_content": " 本帖最后由 qse 于 2020-11-22 11:55 编辑 \nObject enumTITLE = enumTitleAction.getMethod(\"a\", String.class).invoke(enumTitleAction.getConstructor().newInstance(), \"TITLE\");复制代码高版本的NMS中EnumTitleAction枚举里是没有a方法的，都2020年了，还拿1.12的NMS做演示，有点坑了……Object chatComponentTextInstance = chatComponentTextClass.getConstructor(String.class).newInstance(title);\n\n            //enumTITLE = \"TITLE\"\n            Object enumTITLE = null;\n            for (Enum currentEnum : (Enum[]) enumTitleActionClass.getEnumConstants()) {\n                String name = currentEnum.name();\n                if (name.equals(\"TITLE\")) {\n                    enumTITLE = currentEnum;\n                }\n            }\n\n            Object packetPlayOutTitleInstance = packetPlayOutTitleClass.getConstructor(enumTitleActionClass, iChatBaseComponentClass, int.class, int.class, int.class).newInstance(enumTITLE, chatComponentTextInstance, fadeInTime, stayTime, fadeOutTime);\n\n            //Player -> CraftPlayer -> EntityPlayer -> PlayerConnection\n            Object craftPlayer = getCBClass(\"entity.CraftPlayer\").cast(p);\n            Object entityPlayer = craftPlayer.getClass().getMethod(\"getHandle\").invoke(craftPlayer);\n            Object playerConnection = entityPlayer.getClass().getField(\"playerConnection\").get(entityPlayer);\n\n            playerConnection.getClass().getMethod(\"sendPacket\", packetClass).invoke(playerConnection,packetPlayOutTitleInstance);复制代码\n这段代码可以在1.16的Spigot上正常运行\n\n"
        },
        {
            "author": "1347473112",
            "timestamp": 1607956860,
            "txt_content": "努力学习\n。。。。。。。。。。。。。"
        }
    ]
}