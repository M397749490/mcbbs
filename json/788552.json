{
    "title": "[SC]如何玩♂多线程——(4)关于一些多线程中常犯的错误",
    "author": "弱鸡绿毛怪",
    "replyCount": 1,
    "timestamp": 1522139820,
    "txt_content": " 前言 本排版来自PCD小组\n仅有小部分资料来源于其他网站\n\n\n 第一种情况: 把锁加在Integer对象上 举一个很简单的例子\nstatic Integer count = 0;\n@Override\npublic void run() {\n    for (int i = 0;i < 1000;i++) {\n    synchorid(count) { count++; }\n }\n}\n\n当有多个线程同时访问这一段代码的时候，这个count对象会被写出问题，这表明我们并没有加锁成功，为什么呢？\n这便要回到第二章我们所说的IntegerCache了\nhttp://www.mcbbs.net/thread-730539-1-1.html\ncount++的在实际运行时会变成Integer.valueOf(count+1); \nvalueOf(int i)这个方法，若i并不在-128~127之间，就会new一个Integer对象，并返回。所以，我们的锁加在了不同的对象上，即导致了锁的故障。\n\n\n 第二种情况:最好用锁来代替volatile\n volidate关键词确实在平时用的比较少，但是这个关键词是确实存在的。它可以修饰一个变量。修饰这个变量有什么用呢？当你用volatile修饰一个变量时，就等于告诉了jvm，让jvm小心地处理这个变量。精确地说，就是优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。看到这里，你会不会就认为这不是很爽了？变量加个关键词就变成原子性了的吗？我们这里将会举出一个反例，证明使用volatile的代码往往比使用锁的代码更加容易出错。\npublic class Test {\n    private volatile static long value = 0;\n    public static void main(String args[]) {\n        Thread[] threads = new Thread[30];\n        for (int i = 0;i < 30;i++) {\n            Thread target = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0;i < 1000;i++)\n                    value++;                    \n                }                \n            });\n            threads = target;\n            threads.start();\n        }\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        System.err.println(value);\n        System.err.print(\"应该得到的值: \"+30*1000);\n    }\n}\n运行这段代码，你会发现，很有可能得到一个小于30000的值，这就说明了，我们的volatile并没有保证对象的原子性!如何修改呢？很容易:\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Test {\n    private static ReentrantLock lock = new ReentrantLock();\n    private static long value = 0;\n    public static void main(String args[]) {\n        Thread[] threads = new Thread[30];\n        for (int i = 0;i < 30;i++) {\n            Thread target = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0;i < 1000;i++) {\n                        lock.lock();\n                        value++;    \n                        lock.unlock();\n                    }\n                }                \n            });\n            threads = target;\n            threads.start();\n        }\n        for (Thread thread : threads) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        System.err.println(value);\n        System.err.print(\"应该得到的值: \"+30*1000);\n    }\n}\n\n目前就想到这些，以后再补充吧。。。\n[groupid=1533]SpicyChicken[/groupid]",
    "replies": [
        {
            "author": "lovexyn0827",
            "timestamp": 1613479860,
            "txt_content": "最薄弱的就是多线程了"
        }
    ]
}