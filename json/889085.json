{
    "title": "【第二章】Scala从入门到入土 - 使用Option、Either进行错误处理",
    "author": "yuxuanchiadm",
    "replyCount": 0,
    "timestamp": 1563641580,
    "txt_content": " 本帖最后由 yuxuanchiadm 于 2019-7-21 01:25 编辑 \n\n【索引贴】https://www.mcbbs.net/thread-887515-1-1.html\n\n错误的本质\n\n在编程的过程中，程序不可避免的会出现各种各样的错误，例如：\n引用为Null文件不存在IO出错数组访问越界引用为Null\n很多高级编程语言处理这类问题的方式叫做异常。当错误发生时，会抛出一个异常，并进行捕获并处理。在简单的情况下，这种叫做结构化异常处理的方式简便快捷且符合直觉。但是，这种处理异常的方式很大程度上不具有可组合性。Java的[ruby=Checked Exception]检查异常[/ruby]试图解决这个问题，但是由于各种各样的原因以及标准库都不按照规则来，导致实际上并不怎么好用，所以大家都开始乱来了。间接导致检查异常本身被当作Misfeature被批判，甚至还被后来的语言用于跟Java本身比较，别拦着我擦盘子，草（中日双语）。总之，一旦任何的异常没有被程序正确的处理，程序就会崩溃、进入错误的状态、甚至引发未定义行为。所以按照这个思路，实际上是想要有一种能对所有错误情况进行处理、高可组合性、且能够由编译器进行检查的函数式错误处理机制。\n\n使用Option\n\n对于很多简单的异常来说，除了函数计算出的值外，还需要判断函数是否执行成功。典型的例子就是从一个数组中查找一个元素，找到则返回，没找到则出现错误。大多数现代编程语言对这种情况的处理方式是让所有的值在其值本身之外，再加入一个null值，这样在出现这类错误的时候返回null就好了。但是谁都知道null已经被批判成Billion Dollar Mistake了，其原因在于一旦你往所有值内加入null，并且拿来进行错误处理，那么也就相当于默认了所有的函数都可能会出现错误。实际上只有一些函数会返回null值，但是你并不知道哪些函数会返回null值，所有要么你去读每个函数的定义，要么你靠合理猜测，要么你在每个函数返回后都判断一次是否是null。但是人不是完美的，总有猜错忘记处理的情况，甚至是更新、重构代码之后本来不会返回null的函数返回了null。回过头来看看代数数据类型，正好就有一个代数数据类型是往原来的类型里面加一个值的，也就是Option，那么是否可以拿Option替代掉null解决错误处理问题呢？当然可以，但是有一个问题，如果使用Option来处理错误，那么会出现可组合性问题，例如：\ndef gibPrimeNumber(x: Int): Option[Int]\ndef gibEvenNumber(x: Int): Option[Int]\n\ndef gibPrimeEvenNumber(x: Int): Option[Int] = {\n  val primeNumberResult: Option[Int] = gibPrimeNumber(x)\n  if (primeNumberResult.isEmpty)\n    return Option.empty\n  val primeNumber: Int = primeNumberResult.get\n  gibEvenNumber(primeNumber)\n}复制代码首先这种解决方法一点也不函数式，其次这种写法组合性很差，基本上只能处理一些简单的情况，对于复杂的问题只是累赘而已。另一种方法是使用模式匹配：\ndef gibPrimeNumber(x: Int): Option[Int]\ndef gibEvenNumber(x: Int): Option[Int]\n\ndef gibPrimeEvenNumber(x: Int): Option[Int] = gibPrimeNumber(x) match {\n  case None => None\n  case Some(primeNumber) => gibEvenNumber(primeNumber)\n}复制代码这样就使用了函数式的方法解决了问题，但是可组合性问题还是没有解决，可以想到面对很多的函数调用，而且整个程序会一层一层的堆叠起来，形成一种另类的艺术。实际上，这种可组合性问题是可以被解决的！只需要使用M...，咳咳，我指的是列表解析，就能解决问题：\ndef gibPrimeNumber(x: Int): Option[Int]\ndef gibEvenNumber(x: Int): Option[Int]\n\ndef gibPrimeEvenNumber(x: Int): Option[Int] = for {\n  primeNumber <- gibPrimeNumber(x)\n  evenNumber <- gibEvenNumber(primeNumber)\n} yield evenNumber复制代码这样就成功解决了可组合性问题，但是上面的代码到底干了啥？我们需要对列表解析解糖分析一波。上面的函数等价于：def gibPrimeEvenNumber(x: Int): Option[Int] = gibPrimeNumber(x).flatMap(primeNumber =>\n  gibEvenNumber(primeNumber).map(evenNumber => evenNumber)\n)复制代码其中flatMap和map的定义分别为：def map[B](f: A => B): Option[B] = this match {\n  case None => None\n  case Some(a) => Some(f(a))\n}\ndef flatMap[B](f: A => Option[B]): Option[B] = this match {\n  case None => None\n  case Some(a) => f(a)\n}复制代码可以发现上例中的map实际上是啥都没做，可以将其去掉：def gibPrimeEvenNumber(x: Int): Option[Int] = gibPrimeNumber(x).flatMap(primeNumber =>\n  gibEvenNumber(primeNumber)\n)复制代码然后将flatMap代换进去：def gibPrimeEvenNumber(x: Int): Option[Int] = gibPrimeNumber(x) match {\n  case None => None\n  case Some(x) => gibEvenNumber(x)\n}复制代码可以发现其完全等价于上面的有可组合性问题的解决方案，实际上是将有可组合性问题的部分进行了抽象，进而直接解决了组合性问题，而且可以编写优雅的函数式代码。\n\n使用Either\n\n很遗憾并不是所有的错误都能用上面的方式来处理，有些时候我们需要知道错误的详细信息，例如是什么类型的错误、具体的错误信息等。在这种情况下，我们就需要使用Option的加强版，Either了，如果说Option是用于替换null的1 + a，那么Either就是n + a了，此处的n可以随便填我们想要的类型。假如我们想从磁盘读取文件，可能会出现找不到文件和IO错误两种类型的错误，然后我们想从磁盘上读取2个配置文件，并生成Config对象，示例代码如下：sealed abstract class FileError\ncase object FileIOError extends FileError\ncase object FileNotFoundError extends FileError\ndef readFile(path: String): Either[FileError, String]\n\nsealed case class Config(configA: String, configB: String)\ndef readConfig: Either[FileError, Config] = for {\n  configA <- readFile(\"./configA.cfg\")\n  configB <- readFile(\"./configB.cfg\")\n  config = Config(configA, configB)\n} yield config复制代码你可能会发现，不对好像Java的检查异常也能实现同样的功能啊？顺带一提其实Scala也有结构化异常，但并不是检查异常，所以我并不会去用233，另外别拦着我擦盘子，草（中日双语）。哦对了，你可能想问如何像Java一样抛出异常，很简单，可以将其包装为一个函数：def throwError[A](e: FileError): Either[FileError, A] = Left(e)\n\ndef alwaysFail: Either[FileError, String] = for {\n  result <- throwError(FileNotFoundError)\n} yield result复制代码\n",
    "replies": []
}